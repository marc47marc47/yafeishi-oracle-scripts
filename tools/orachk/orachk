#!/bin/env bash
{
# Copyright (c) 2002, 2015, Oracle and/or its affiliates. All rights reserved.
# Name raccheck.sh - checks Oracle best practices and patches on all nodes in clustered environment
#Caution This script is provided for educational purposes only and not supported by Oracle Support Services. It has been tested internally, however, and works as documented. We do not guarantee that it will work for you, so be sure to test it in your environment before relying on it.Proofread this script before using it! Due to the differences in the way text editors, e-mail packages and operating systems handle text formatting (spaces, tabs and carriage returns), this script may not be in an executable state when you first receive it. Check over the script to ensure that errors of this type are corrected. 


##############################################################################
# Authors        : Bob Caldwell, Girdhari Ghantiyala and Girish Adiga
# Creation Date : 18-Apr-2008
# Purpose       : Tool for checking best practices
#
##############################################################################


# MODIFIED (MM/DD/YY)
#    apriyada 02/19/15 - cygwin warning
#    apriyada 02/11/15 - new report format for orachk/exachk
#    apriyada 02/03/15 - BUG 20441625
#    rojuyal  01/21/15 - Exalogic Spin Switch and Storage Changes
#    apriyada 01/21/15 - set EMAGENT_INST
#    rojuyal  12/19/14 - Fixed Script Injection Vulnerabilities
#    apriyada 12/18/14 - corroborate profile
#    rojuyal  12/12/14 - Added Infrastructure Software and Configuration Summary Section
#    rojuyal  12/10/14 - BUG 18022854(PART 1)
#    apriyada 12/10/14 - Platinum in report
#    rojuyal  11/27/14 - BUG 18393291
#    rojuyal  11/27/14 - BUG 19897409,20089352, RAT_ZFS_ROOT_TIMEOUT for ZFS, instead of RAT_ROOT_TIMEOUT
#    apriyada 11/26/14 - Em header
#    rojuyal  11/20/14 - BUG 19881738
#    rojuyal  11/20/14 - Change in discovery code for uneven oracle homes.
#    rojuyal  11/19/14 - Bug 19385724 , Moved Main debug log inside log directory
#    apriyada 11/18/14 - BUG 19869334
#    apriyada 11/11/14 - Bug 19304345
#    apriyada 11/09/14 - EBS SPECIFIC MESSAGE ABOUT TIMEOUT IN EBS SECTION OF
#                        ORACHK REPORT
#    rojuyal  11/05/14 - silent and force option
#    rojuyal  11/13/14 - Bug 17308279
#    rojuyal  11/04/14 - Mos URL changes
#    cgirdhar 10/24/14 - X5 support
#    apriyada 10/23/14 - Fix noupgrade issue
#    apriyada 10/22/14 - EM Agent
#    cgirdhar 10/22/14 - zLinux support
#    rojuyal  10/16/14 - Changes related to ORACLE_BASE and RAT_OUTPUT
#    apriyada 10/16/14 - Reduce score only for logic info checks
#    cgirdhar 10/16/14 - OL 7 support
#    rojuyal  10/15/14 - Custom Alert level
#    cgirdhar 10/15/14 - Oracle Linux 6 support for Exadta
#    apriyada 09/30/14 - Fix read only issue in auto upgrade
#    gadiga   09/30/14 - fix RAT_IBSWITCH_USER
#    apriyada 09/15/14 - Fix Issues in profile only
#    apriyada 09/11/14 - Auto upgrade changes
#    gadiga   09/11/14 - exalytics
#    gadiga   09/10/14 - fix 19483326.. remove passwords in debug
#    gadiga   09/10/14 - fix 19514154 - wrong asm patch file name
#    rojuyal  09/09/14 - Bug:18861189
#    gadiga   09/08/14 - sudo root
#    rojuyal  09/04/14 - Bug:14008679
#    gadiga   09/05/14 - SC checks
#    gadiga   09/05/14 - dblra issues
#    gadiga   09/04/14 - add EM section in report
#    gadiga   09/04/14 - dblra discovery issue
#    rojuyal  09/01/14 - Running script as ROOT user(psqlplus changes)
#    cgirdhar 08/12/14 - Changes to support DBLRA appliance
#    rojuyal  08/08/14 - Bug 19386798
#    apriyada 08/05/14 - Diff the collections between two runs
#    apriyada 07/22/14 - Switch IP Verification at Prompt
#    rojuyal  07/21/14 - BUG:18993064
#    apriyada 07/20/14 - Merge checks for report
#    apriyada 07/17/14 - Add Hardware Version Information
#    rojuyal  07/15/14 - EM Changes - BUG:17818263
#    apriyada 07/10/14 - Score Mechanism when components are skipped
#    apriyada 06/19/14 - Merging same check with different exit value
#    rojuyal  07/03/14 - BUG: 18382908 , 19135947
#    apriyada 06/18/14 - Sudo support for guest domU
#    apriyada 06/19/14 - Exachk support "no Ping" (SSH is enabled)
#    apriyada 06/19/14 - New profile module - EXALOGIC_PROFILEONLY
#    rojuyal  06/10/14 - Running script as ROOT user
#    rojuyal  06/10/14 - EM Changes - BUG:17818221
#    apriyada 06/17/14 - ZFSSA fix
#    gadiga   06/10/14 - support cygwin
#    apriyada 05/21/14 - Fix ^M issue
#    apriyada 05/13/14 - Auto upgrade
#    rojuyal  05/13/14 - Platform related changes
#    gadiga   05/09/14 - system patch reco
#    rojuyal  05/09/14 - Mulitple Autorun schedules
#    gadiga   05/08/14 - exalogic dns issue
#    rojuyal  05/07/14 - BUG 18690575 18719926
#    rojuyal  05/07/14 - Parsing top time consuming checks
#    gadiga   05/07/14 - exalogic dns issue
#    rojuyal  05/02/14 - Fixed Single Instance discovry Issue
#    rojuyal  05/02/14 - Fixed BUG 18382908
#    apriyada 05/05/14 - Add Duration
#    rojuyal  04/30/14 - Fixed BUG 18665313,18665217,18665077,18664811,18675977,18350335
#    cgirdhar 04/28/14 - PDB to CDB mapping
#    apriyada 04/28/14 - Context Sensitive Help
#    cgirdhar 04/24/14 - X4-8 support
#    rojuyal  04/23/14 - Fixed BUG 18514932,18515349,18515449,18515507,18515463,18361278
#    rojuyal  04/23/14 - Fixed BUG 18456411
#    rojuyal  04/22/14 - Store localcmd.sh files for debugging, Modifications for merge functionality
#    rojuyal  04/22/14 - hostname corresponding to hostname in equivalency message
#    rojuyal  04/21/14 - Fixed BUG 18442011, 18530656, 18530680, 18541816, 18358758(/usr/bin/expect -> $EXPECT)
#    rojuyal  03/27/14 - support for DB parallaization 
#    cgirdhar 03/19/14 - Report command support for clusterwide checks
#    cgirdhar 03/17/14 - pre/post upgrade suport for single instance
#    cgirdhar 03/14/14 - logging to pdb without password
#    rojuyal  03/14/14 - Fixed BUGS:18392717,18392778,18398256
#    cgirdhar 02/28/14 - 2.2.4 proudction
#    rojuyal  01/24/14 - expect changes, script debugging
#    cgirdhar 01/14/14 - uploaded installed patches to database
#    cgirdhar 12/10/13 - support for multipleline checks and report commands
#    rojuyal  11/26/13 - BUG Fix: 17882201,17896809,17620698,17849308
#    rojuyal  11/26/13 - Exalogic GuestVM and Hybrid changes
#    rojuyal  11/22/13 - Merge collections(for different profiles, nodes and users)
#    cgirdhar 11/19/13 - GoldenGate application support
#    gadiga   11/05/13 - inittab changes
#    cgirdhar 11/01/13 - count storage server checks in healthscore
#    cgirdhar 10/30/13 - Move root script from /tmp
#    cgirdhar 10/28/13 - Added support for location file
#    rojuyal  10/18/13 - new option : -excludeprofile <profile> 
#    rojuyal  10/17/13 - EBS support
#    cgirdha  10/16/13 - Fixed patch upload issue for ASM_HOME
#    cgirdha  09/17/13 - zip file upload support
#    gadiga   09/10/13 - bug 17061012
#    gadiga   09/06/13 - password prompts
#    gadiga   09/06/13 - fix exalogic issue with parallel
#    rojuyal  08/21/13 - Fix for BUG 16702324
#    gadiga   08/20/13 - daemon run at specific time and day
#    gadiga   08/20/13 - store all answers in daemon
#    gadiga   08/20/13 - fix second db home expand (er 4888)
#    cgirdhar 08/12/13 - X4-2 support
#    cgirdhar 08/08/13 - disable software/firmware reprot for Exadata
#    rojuyal  08/02/13 - Fix for 16979212,17226854,17220748
#    cgirdhar 07/24/13 - Fix for 17209210
#    rojuyal  07/24/13 - Changes for root collections on compute, cells and switches 
#    cgirdhar 07/18/13 - skip checks based on name and list them in final report
#    rojuyal  07/18/13 - Support for BDA(Big Data Appliance)
#    cgirdhar 07/16/13 - X3-2 support for supercluster
#    gadiga   07/15/13 - echo exallogic
#    gadiga   07/15/13 - run exachk at specific time and day using Daemon
#    rojuyal  07/11/13 - Fixed Running DB discovery
#    gadiga   07/11/13 - fix remote ASM
#    rojuyal  07/08/13 - Fix for 17081319 and various other modifications
#    rojuyal  07/08/13 - Changes for consolidated Echo VM(Exalogic)
#    cgirdhar 07/05/13 - Fix for 17061977
#    cgirdhar 07/03/13 - Fix for odachk bug 16832171
#    rojuyal  07/03/13 - Integrate auto downloader
#    rojuyal  06/24/13 - TimesTen support in exalytics
#    gadiga   06/14/13 - dont run exalogic discovery if exalytics
#    rojuyal  06/03/13 - Fix for BUG:16894500
#    cgirdhar 05/24/13 - Making beta for 2.2.2
#    gadiga   05/22/13 - source /etc/profile
#    rojuyal  05/21/13 - create_version.pl Integration
#    gadiga   05/20/13 - remove extra - in links
#    rojuyal  05/20/13 - Integrate create_version.pl
#    rojuyal  05/17/13 - add create_version.pl .
#    gadiga   05/15/13 - root password using expect
#    rojuyal  05/15/13 - Changes For BUG 16520619
#    gadiga   05/06/13 - root issue in parallel and handle missing md5sum
#    gadiga   05/03/13 - flags in auto mode
#    cgirdhar 05/02/13 - regular health check with post ugprade
#    cgirdhar 05/01/13 - fix for 16687669
#    gadiga   04/29/13 - adding -set option
#    gadiga   04/25/13 - check for password changes in daemon mode
#    gadiga   04/25/13 - ssh password prompt
#    gadiga   04/24/13 - exalytics minor fixes
#    gadiga   04/24/13 - database prompts
#    gadiga   04/24/13 - different root passwords
#    gadiga   04/23/13 - daemon with commands
#    gadiga   04/23/13 - bug 16519731
#    gadiga   04/23/13 - upgrade issue in parallel
#    gadiga   04/22/13 - silent on cell and switch
#    gadiga   04/22/13 - bug 16680382
#    gadiga   04/22/13 - exalytics changes
#    cgirdhar 04/18/13 - multiple version support for upgrade
#    cgirdhar 04/11/13 - OBIEE support in exalytics
#    gadiga   04/09/13 - OPSTAT issue on switch
#    cgirdhar 04/08/13 - fix for 14534296
#    cgirdhar 04/04/13 - distinguish between spine and leaf switch
#    cgirdhar 04/02/13 - Fix for mixed hardware types storage servers bug
#                        16243437
#    gadiga   04/01/13 - fix 16561752
#    gadiga   04/01/13 - fix solaris exalogic issue and multiple db with
#                        similar names
#    cgirdhar 03/28/13 - handling IS_SYSDBA for multiple databases
#    gadiga   03/27/13 - daemon mode support
#    cgirdhar 03/27/13 - output directory re-oraganization
#    cgirdhar 03/25/13 - avm support
#    cgirdhar 03/22/13 - check for higher version of PSU,fixed -m and -r for
#                        SIDB
#    cgirdhar 03/20/13 - finished zfs support for super cluster
#    cgirdhar 03/15/13 - same code zfs on exalogic and SuperCluster
#    cgirdhar 03/14/13 - zfs best practice checking for super cluster
#    cgirdhar 03/12/13 - started changes for exalytics support
#    cgirdhar 03/11/13 - fix for 16441191
#    cgirdhar 02/21/13 - remove HAchecks for exadata
#    gadiga   02/19/13 - raw data browser integration
#    gadiga   02/13/13 - exalogic system identifier
#    cgirdhar 02/07/13 - making 2.2.1 beta
#    gadiga   01/31/13 - cells and switches on command line
#    gadiga   01/29/13 - profiles
#    gadiga   01/27/13 - profiles
#    gadiga   01/25/13 - skipped nodes in report
#    gadiga   01/23/13 - move cp errors to /dev/null
#    cgirdhar 01/22/13 - making hacheck default. same as maa scorecard
#    gadiga   01/20/13 - remove strict host check
#    gadiga   01/14/13 - WRKDIR should have write permission
#    gadiga   01/14/13 - rpm issue
#    cgirdhar 01/11/13 - fix for 16050940
#    gadiga   01/10/13 - fix 16096009
#    cgirdhar 01/09/13 - fix for 15992146
#    gadiga   01/07/13 - stop watchdog after run finishes
#    cgirdhar 01/07/13 - Fix for bug 16081291
#    gadiga   12/27/12 - compute node parallel run
#    cgirdhar 12/21/12 - VM support on ODA
#    cgirdhar 12/12/12 - executing sql collections on pdbs
#    cgirdhar 12/11/12 - executing checks on pdbs
#    cgirdhar 11/29/12 - cross component check support
#    cgirdhar 11/28/12 - spine switch support
#    cgirdhar 11/27/12 - pdb discovery for 12c support
#    cgirdhar 11/26/12 - enhancement in ssh setup to restore system in original
#                        state
#    gadiga   11/20/12 - cleanup cell and ib before new run
#    gadiga   11/15/12 - copy exalogic conf file to outputdir
#    gadiga   11/13/12 - issue when first db down
#    gadiga   11/06/12 - add maa note
#    cgirdhar 11/02/12 - Exadata 1/8 rack support
#    cgirdhar 10/29/12 - changes for 2.2.0 beat
#    cgirdhar 10/26/12 - maa scorecard, profile trap and version change
#    cgirdhar 10/25/12 - X3-8 support
#    gadiga   10/25/12 - SI patch rec
#    gadiga   10/23/12 - new MAA entry
#    gadiga   10/23/12 - exalogic changes
#    gadiga   10/22/12 - cleanup to redirect errors to /dev/null
#    cgirdhar 10/18/12 - clusterwide checks for Exalogic control VMs
#    gadiga   10/12/12 - assign all dbs for locanode
#    gadiga   10/12/12 - separate report for control servers
#    gadiga   10/11/12 - OVS node is not EC
#    cgirdhar 10/11/12 - Fix to handle upper case hostname in v-instance view
#    gadiga   10/11/12 - html report bugs
#    gadiga   10/10/12 - separate ssh prompt for exalogic
#    cgirdhar 10/09/12 - Support for mixed hardware in Exadata
#    gadiga   10/04/12 - exalogic VM support
#    cgirdhar 10/03/12 - Support for hacheck
#    cgirdhar 10/02/12 - Fix for bug 14383945 and ways to pass component from
#                        command line
#    cgirdhar 10/01/12 - Changed RC-00* error messages
#    gadiga   09/24/12 - SI support
#    cgirdhar 09/21/12 - MAA scorecard for supercluster
#    cgirdhar 09/19/12 - Fix for 14559998-delete inputdir on nfs
#    cgirdhar 09/17/12 - changes for supercluster
#    cgirdhar 09/12/12 - ASR healthcheck integration
#    cgirdhar 09/06/12 - component re-organization
#    cgirdhar 09/04/12 - component re-org
#    cgirdhar 08/22/12 - Enhancement to add more columns in upload result table
#                        bug # 14521204
#    cgirdhar 08/15/12 - Added validation to check prompt in profile
#    gadiga   08/13/12 - BUG 13992787: ADA Compliance
#    cgirdhar 08/12/12 - Assign module on each node to support hybrid rack
#    cgirdhar 08/10/12 - Fix for bug 14175874
#    cgirdhar 08/09/12 - bug fixes for 14262805 14227779 and 14319077
#    gadiga   08/09/12 - maa scorecard changes
#    cgirdhar 08/08/12 - Fix for bug 14148335
#    gadiga   08/03/12 - print na for asm home post 112
#    cgirdhar 08/02/12 - Solaris Express support for Exalogic
#    cgirdhar 08/01/12 - fix for bug 14336802
#    gadiga   08/01/12 - hp-ux support
#    cgirdhar 07/31/12 - Added message in log file before removing node from
#                        list in ssh setup function
#    gadiga   07/11/12 - run parallel on cells and swicthes
#    gadiga   06/21/12 - fix dir issue
#    gadiga   05/30/12 - oda single instance bug
#    cgirdhar 05/24/12 - made 2.1.5 prod
#    gadiga   05/22/12 - xml for rac and oda
#    cgirdhar 05/10/12 - final changes before going beta
#    cgirdhar 05/09/12 - change for root password check login delay on linux
#                        database and storage servers
#    cgirdhar 05/02/12 - new way to execute checks on remote nodes
#    gadiga   04/23/12 - skip zfs cell
#    gadiga   04/23/12 - handle case in hostname
#    cgirdhar 04/19/12 - upgrade support in ODA
#    gadiga   04/19/12 - skip merging for -p
#    cgirdhar 04/18/12 - Support for virtual compute nodes in Exalogic
#    gadiga   04/16/12 - cellscript name, disable merge for post
#    gadiga   04/16/12 - arg cnt
#    gadiga   04/15/12 - Fix: opstat in multi db takes last value
#    gadiga   04/13/12 - reset arrays in port & pre
#    gadiga   04/12/12 - RackIdentifier
#    gadiga   04/10/12 - modelversion in xml
#    gadiga   04/08/12 - systemwide in exalogic
#    gadiga   04/02/12 - check name as heading instead of first message
#    gadiga   04/01/12 - fix zfs cell report issue
#    cgirdhar 03/30/12 - Changes to execute storage server collection and
#                        checks
#    gadiga   03/30/12 - exalogic xml updates
#    gadiga   03/29/12 - exalogic zfs cell support
#    gadiga   03/29/12 - link jumps when same check is in pass/fail
#    cgirdhar 03/27/12 - Added validation for Exalogic rack type
#    cgirdhar 03/20/12 - change to run in slient mode for Exalogic
#    cgirdhar 03/19/12 - Changes for Exalogic node discovery and added EXALOGIC
#                        module
#    gadiga   03/06/12 - remove toplevel MAA checks
#    gadiga   03/05/12 - fix -s & -u issue
#    gadiga   03/02/12 - dont run checks on cell in silent
#    cgirdhar 02/14/12 - Solaris 11 Express not supported
#    gadiga   02/14/12 - multiple version support in os_collect
#    gadiga   02/07/12 - consider HOME_PATH for multiple version
#    gadiga   02/05/12 - merge giri's changed
#    gadiga   01/31/12 - multiple db version support
#    gadiga   01/27/12 - comp summary, remote db fixes, bug 13608775
#    gadiga   01/20/12 - merge exalogic support
#    cgirdhar 01/19/12 - Fixed environment checking on remote nodes
#    cgirdhar 01/18/12 - support to copy utility files and skip database if its
#                        upgraded
#    gadiga   01/04/12 - add Installed components summary report
#    gadiga   01/03/12 - add option -t
#    cgirdhar 12/28/11 - reporting improvements in oracle patch checking
#    gadiga   12/27/11 - report patch checks
#    cgirdhar 12/27/11 - enhanced framwork for checking Oracle patches
#    cgirdhar 12/23/11 - support for pre and post upgrade checks
#    gadiga   12/20/11 - bug 13516696
#    gadiga   12/19/11 - handle input parameters
#    gadiga   12/12/11 - remote database
#    gadiga   12/08/11 - 2.1.3 exachk bug fixes
#    gadiga   12/08/11 - version 2.1.4
#    cgirdhar 11/29/11 - Added NEEDS_RUNNING for CLUSTERWIDE_CHECKS for EM
#    cgirdhar 11/22/11 - added support to copy xmls on localnode also for ER
#                        13018831
#    cgirdhar 11/21/11 - improved offline run for MAA scorecard
#    cgirdhar 11/18/11 - ER 13039130 for EM to add two new tags in result and
#                        exception xml
#    gadiga   11/18/11 - add dbname
#    cgirdhar 11/11/11 - detail data for passed clusterwide checks
#    cgirdhar 11/09/11 - fixed RAT_PASSWORDCHECK_TIMEOUT env variable
#    gadiga   11/09/11 - system health score
#    cgirdhar 11/08/11 - changed -m flag functionality for exachk
#    cgirdhar 11/07/11 - fixed bug 13325647 and enhanced root collection
#                        logging
#    cgirdhar 11/04/11 - maa score card testing on standby database
#    gadiga   11/01/11 - maa report
#    cgirdhar 11/01/11 - new argument for maa scroe card
#    cgirdhar 10/27/11 - changes to support multiple components
#    cgirdhar 10/25/11 - imroved to handle standby databases for MAA score card
#    gadiga   10/23/11 - fix typo
#    gadiga   10/21/11 - passed cell checks
#    gadiga   10/18/11 - system wide check
#    cgirdhar 10/18/11 - ER 12977998 for systemwide checks testing
#    cgirdhar 10/17/11 - ER 12977998 for systemwide checks
#    cgirdhar 10/13/11 - fix for bug 12820321
#    cgirdhar 10/11/11 - fixed bug 12815752
#    cgirdhar 10/10/11 - no patch recommendation for odachk
#    cgirdhar 10/05/11 - change for oracle database appliances
#    cgirdhar 10/04/11 - changes for oracle database appliance
#    gadiga   09/27/11 - edit link and program name
#    cgirdhar 09/27/11 - fixed actual value for kumar to match html report to
#                        RAT report
#    gadiga   09/26/11 - missing outfile
#    cgirdhar 09/26/11 - change for rat reprot to match html report
#    cgirdhar 09/23/11 - ER 13017633 and no cell checks in silent mode
#    cgirdhar 09/19/11 - bug fix 12993594
#    cgirdhar 09/17/11 - made it beta for 2.1.3
#    gadiga   09/13/11 - edit html
#    gadiga   09/08/11 - html file name to have date time
#    cgirdhar 09/01/11 - exachk 2.1.2 production version
#    cgirdhar 08/18/11 - copying cells.out to $TMPDIR/.$program_name} for checkDiskFGMapping.sh
#    gadiga 08/18/11 - napply missing patches
#    gadiga 08/17/11 - param without instance name
#    gadiga 08/17/11 - remove .program dir on cells
#    cgirdh 08/16/11 - testing html report
#    gadiga 08/16/11 - format versions html
#    gadiga 08/16/11 - null pass message
#    cgirdh 08/11/11 - changes after x2-2 testing
#    cgirdh 08/10/11 - testing tmp dir changes
#    gadiga 08/10/11 - include versions.html when available
#    gadiga 08/10/11 - show only parameter from instance
#    gadiga 08/09/11 - append versions.html into program.html
#    gadiga 08/09/11 - use /tmp/.program instead of /tmp to create tmp files
#    gadiga 08/09/11 - changes from giri to support x2-x8
#    gadiga 08/01/11 - improve check_id_number perf
#    gadiga 07/28/11 - Show o/p from failed storage server only
#    gadiga 07/28/11 - show zero CRS patch message
#    gadiga 07/28/11 - ORACLE_HOME type
#    cgirdh 07/27/11 - changes on July 27,2011
#    gadiga 07/26/11 - Format changes for patch report
#    cgirdh 07/26/11 - checking out to fix bug 12800318
#    gadiga 07/26/11 - Show patch summary only for raccheck
#    gadiga 07/26/11 - update tool names
#    gadiga 07/25/11 - add patch summary report
#    gadiga 07/25/11 - Fix check-type for exceptions
#    gadiga 07/25/11 - storage server fix
#    gadiga 07/24/11 - fix cwc issue & incorporate review
#    gadiga 07/19/11 - add PASS messages
#    cgirdh 07/18/11 - testing it on exadata cluster
# cgirdhar 01/22/09 Added clusterwide checks functionality 
# Define a function to printut usage of this command
#one line if command if [ $expected = $actual ]; then echo "1"; else echo "0";fi;
#export PS4='$0.$LINENO+ '

GREEN="\033[1;32;40m"
#ORANGE="\033[33;40m"
ORANGE="\033[33;44m"
#RED="\033[1;31;40m"
RED="\033[1;37;41m"
#BLUE="\033[1;34;40m"
BLUE="\033[1;30;46m"
CYAN="\033[1;36;40m"
NORM="\033[0m"
BOLD="\033[1m"
#BLINK="\033[5m"
GREEN="\033[1;32;40m"
ORANGE="\033[33;40m"
RED="\033[1;31;40m"
BLUE="\033[1;34;40m"

PROBE_QUES_CNT=1
G_CELL=0
G_SWITCH=0
G_COMPUTE=0
G_EC=0
G_PC=0
G_DB=0
G_OVMM=0

EMHOMEVERSIONFIL="/etc/oragchomelist"
EMHOMEVERSIONFIL2="/var/opt/oragchomelist"
mb_emagent_home=""

is_windows=0
no_upgrade=0
BAT=""
BIN="bin"
if [ `/bin/uname |grep -c CYGWIN` -gt "0" ] ; then
  export PATH=/usr/bin:/bin:$PATH
  export SHELLOPTS 
  set -o igncr 
  is_windows=1
  BAT=".bat"
  BIN="exe"
  #RAT_COMPUTE_RUNMODE="serial"
  #RAT_LOCALONLY=1
  perl_exe=$(which perl|sed 's/\r//')
  if [ -z "$perl_exe" ] ; then
    echo "";
    echo "Failed to find perl exectable in PATH. Perl is needed to discover Oracle stack components automatically. Please set PATH and run again.";
    echo "";
    exit;
  fi
fi

RAT_UPGRADE_LOC=`env | grep RAT_UPGRADE_LOC`


if [[ -z "$RAT_UPGRADE_LOC" ]]
then
 if [[ -n "$RAT_ORATAB_LOC" ]]
 then
  ORATAB=$RAT_ORATAB_LOC;
 else
  case `/bin/uname` in
    Linux)
      ORATAB=/etc/oratab
      ;;
    SunOS)
      ORATAB="/var/opt/oracle/oratab"
      ;;
    HP-UX)
      ORATAB=/etc/oratab
      ;;
    AIX)
      ORATAB=/etc/oratab
      ;;
    CYGWIN_NT-[0-9].[0-9])
      ORATAB="win_oratab.out"
      ;;
    *)
      /bin/echo "ERROR: Unknown Operating System"
      ;;
  esac
 fi
  #ora_home=$(cat $ORATAB |grep ":/" |grep -v "+"|grep -v "^#"|cut -d: -f2|tr '\n' "/suptools,")
  if [ -f "$ORATAB" ]
  then
    #for var in `cat $ORATAB |grep ":/" |grep -v "+"|grep -v "^#"|cut -d: -f2`
    for var in `grep ":/" $ORATAB |grep -v "+"|grep -v "^#"|cut -d: -f2`
    do
      ora_home="$ora_home,$var/suptools"
    done

    RAT_UPGRADE_LOC=$(echo $ora_home| sed 's/^,//') 
  fi
fi

cur_dir=`pwd`

RAT_UPGRADE_LOC="$RAT_UPGRADE_LOC,$cur_dir"

check_upgrade_ret_val="";

more_cmd=$(which more 2>/dev/null);
if [ -z "$more_cmd" ]; then
  display_mode=1
else
  display_mode=2
fi

usage_AR()
{
  if [ $is_windows -eq "1" ] ; then return; fi
echo -e "	
	Auto Restart Options:
		-auto_restart -h: Prints help for this option
		-<initsetup|initrmsetup|initcheck|initpresetup>
                initsetup       : Setup auto restart. Auto restart functionality automatically brings up ${program_name} daemon when node starts
                initrmsetup     : Remove auto restart functionality
                initcheck       : Check if auto restart functionality is setup or not
                initpresetup    : Sets root user equivalency for COMPUTE, STORAGE and IBSWITCHES.(root equivalency for COMPUTE nodes is mandatory for setting up auto restart functionality)

"
}

usage_report()
{
echo -e "	
	Report Options:
	-nopass
                Skip PASS'ed check to print in ${program_name} report and upload to database.

        -noscore
                Do not print healthscore in HTML report.

        -diff <Old Report> <New Report> [-outfile <Output HTML>]
                Diff two ${program_name} reports. Pass directory name or zip file or html report file as <Old Report> & <New Report> 
 
        -exadiff <Exalogic collection1> <Exalogic collection2>
                Compare two different Exalogic rack and see if both are from the same release.Pass directory name or zip file as <Exalogic collection1> & <Exalogic collection2>(applicable for Exalogic only)

	-merge [-force]
                Pass comma separated collection names(directory or zip files) to merge collections and prepare single report.
                eg:- ./${program_name} -merge ${program_name}_hostname1_db1_120213_163405.zip,${program_name}_hostname2_db2_120213_164826.zip

                -force
	                Merge collections from dom0 and domu or global and local zones.
			eg:- ./${program_name} -merge ${program_name}_hostname1_db1_120213_163405.zip,${program_name}_hostname2_db2_120213_164826.zip -force

        -tag <tagname>
                Appends <tagname> to Report Name. <Tagname> must contain only alphanumeric characters.
		for eg: ./${program_name} -tag newtag123 will append 'newtag123' to report name like '${program_name}_hostname1_db1_100914_123456_newtag123.html'
"
}

usage_dopt()
{
echo -e "        
        -d <start|start_debug|stop|status|info|stop_client|nextautorun|-h>
                start           	: Start the ${program_name} daemon
                start_debug		: Start the ${program_name} daemon in debug mode
                stop            	: Stop the ${program_name} daemon
                status          	: Check if the ${program_name} daemon is running
                info            	: Print information about running ${program_name} daemon
                stop_client     	: Stop the ${program_name} daemon client

                nextautorun [-id <ID>]  : print the next auto run time
		                          if '-id <ID>' is specified, it will print the next auto run time for specified autorun schedule ID

		-h              	: Prints help for this option
"
}

usage_daemon()
{
echo -e "	
        Daemon Options:
"
	usage_dopt;
echo -e "

        -daemon
                run ${program_name} only if daemon is running
        -nodaemon
                Do not use daemon to run ${program_name} 
        [-id <ID>] -set
                configure ${program_name} daemon parameter like 'param1=value1;param2=value2... '
 	 	if '-id <ID>' is specified, it will configure ${program_name} daemon parameter(s) for specified autorun schedule ID	
               
                 Supported parameters are:-
 
                 (Deprecated) - AUTORUN_INTERVAL <n[d|h]> :- Automatic rerun interval in daemon mode.Set it zero to disable automatic rerun which is zero.
                                                                  
 
                 AUTORUN_SCHEDULE * * * *       :- Automatic run at specific time in daemon mode. AUTORUN_INTERVAL will be ignored when AUTORUN_SCHEDULE is used.
                                  - - - -
                                  ? ? ? ?
                                  ? ? ? +----- day of week (0 - 6) (0 to 6 are Sunday to Saturday)
                                  ? ? +---------- month (1 - 12)
                                  ? +--------------- day of month (1 - 31)
                                  +-------------------- hour (0 - 23)
 
                     example: ${program_name} -set 'AUTORUN_SCHEDULE=8,20 * * 2,5' will schedule runs on Tuesday and Friday at 8 and 20 hour.
                  
                 AUTORUN_FLAGS <flags> : ${program_name} flags to use for auto runs.
         
                     example: ${program_name} -set 'AUTORUN_INTERVAL=12h;AUTORUN_FLAGS=-profile sysadmin' to run sysadmin profile every 12 hours
 
                              ${program_name} -set 'AUTORUN_INTERVAL=2d;AUTORUN_FLAGS=-profile dba' to run dba profile once every 2 days.
 
                 NOTIFICATION_EMAIL : Comma separated list of email addresses used for notifications by daemon if mail server is configured.

                 PASSWORD_CHECK_INTERVAL <number of hours> : Interval to verify passwords in daemon mode

                 COLLECTION_RETENTION <number of days> : Purge ${program_name} collection directories and zip files older than specified days. 

        [-id <ID>] -unset <parameter | all>
                unset the parameter
 	        if '-id <ID>' is specified, it will unset the parameter for specified autorun schedule ID
                  example: ${program_name} -unset "AUTORUN_SCHEDULE"

        [-id <ID>] -get <parameter | all>
                Print the value of parameter. 
	        if '-id <ID>' is specified,  it will print the value of parameter for specified autorun schedule ID

"
}

usage_profilesw()
{
echo -e " 
        Profile Run Options:
        -profile
	        Pass specific profile. 
                With -h prints help.
                List of supported profiles:
"

if [ -e $SCRIPTPATH/.cgrep/profiles.dat ]
then
    if [[ ${program_name} = "raccheck" || ${program_name} = "odachk" ]] ; then
      #cat $SCRIPTPATH/.cgrep/profiles.dat| grep -v "^.-"| sort |grep -ivw "ControlVM" | grep -ivw "Switch" | grep -v "storage"|grep -v "debug_check" | grep -v "virtual_infra" |grep -v "el_" |grep -v "timesten" |grep -v "obiee"|awk -F"|" '{printf "                 %-15s %-20s\n",$1,$NF}'
      grep -v "^.-" $SCRIPTPATH/.cgrep/profiles.dat| sort |grep -ivw "ControlVM" | grep -ivw "Switch" | grep -v "storage"|grep -v "debug_check" | grep -v "virtual_infra" |grep -v "el_" |grep -v "timesten" |grep -v "obiee"|awk -F"|" '{printf "                 %-15s %-20s\n",$1,$NF}'
    else # Show all
      #cat $SCRIPTPATH/.cgrep/profiles.dat| grep -v "^.-"|grep -v "debug_check"|sort | awk -F"|" '{printf "                 %-15s %-20s\n",$1,$NF}'
      grep -v "^.-" $SCRIPTPATH/.cgrep/profiles.dat|grep -v "debug_check"|sort | awk -F"|" '{printf "                 %-15s %-20s\n",$1,$NF}'
    fi
fi

}

usage_profiles()
{
   usage_profilesw;
echo -e "
        -excludeprofile
                Pass specific profile.
                List of supported profiles is same as for -profile.
"

}

usage_granular()
{
  if [[ $1 == "-a" ]] ; then
    echo -e "	
        -a      All (Perform best practice check and recommended patch check)
    "
  elif [[ $1 == "-b" ]] ; then
    echo -e "	
	-b      Best Practice check only. No recommended patch check
    "
  elif [[ $1 == "-v" ]] ; then
    echo -e "	
        -v      Show version
    "
  elif [[ $1 == "-p" ]] ; then
    echo -e "	
        -p      Patch check only
    "
  elif [[ $1 == "-m" ]] ; then
    echo -e "	
        -m      exclude checks for Maximum Availability Architecture (MAA) scorecards(see user guide for more details)
    "
  elif [[ $1 == "-u" ]] ; then
    echo -e "	
        -u      Run ${program_name} to check pre-upgrade or post-upgrade best practices for 11.2.0.3 and above
                -o pre or -o post is mandatory with -u option like ./${program_name} -u -o pre
    "
  elif [[ $1 == "-f" ]] ; then
    echo -e "	
        -f      Run Offline.Checks will be performed on data already collected from the system
    "
  elif [[ $1 == "-o" ]] ; then
    echo -e "	
        -o      Argument to an option. if -o is followed by v,V,Verbose,VERBOSE or Verbose, it will print checks which passs on the screen
                if -o option is not specified,it will print only failures on screen. for eg: ${program_name} -a -o v
    "
  elif [[ $1 == "-clusternodes" ]] ; then
    echo -e "	
        -clusternodes      Pass comma separated node names to run ${program_name} only on subset of nodes.
    "
  elif [[ $1 == "-output" ]] ; then
    echo -e "	
        -output       
    "
  elif [[ $1 == "-dbnames" ]] ; then
    echo -e "
        -dbnames      Pass comma separated database names to run ${program_name} only on subset of databases
    "
  elif [[ $1 == "-localonly" ]] ; then
    echo -e "	
        -localonly      Run ${program_name} only on local node.
    "
  elif [[ $1 == "-dbnone" ]] ; then
    echo -e "	
        -dbnone      Do not prompt database selection and skip all database related checks.
    "
  elif [[ $1 == "-dball" ]] ; then
    echo -e "	
        -dball      Do not prompt database selection and run database related checks on all databases discovered on system.
    "
  elif [[ $1 == "-c" ]] ; then
    echo -e "	
        -c     Used only under the guidance of Oracle support or development to override default components
    "
  elif [[ $1 == "-merge" ]] ; then
    echo -e "   
        -merge [-force] 
                Pass comma separated collection names(directory or zip files) to merge collections and prepare single report.
                eg:- ./${program_name} -merge ${program_name}_hostname1_db1_120213_163405.zip,${program_name}_hostname2_db2_120213_164826.zip

		-force	
			Merge collections from dom0 and domu or global and local zones.
			eg:- ./${program_name} -merge ${program_name}_hostname1_db1_120213_163405.zip,${program_name}_hostname2_db2_120213_164826.zip -force
		
  "
  elif [[ $1 == "-diff" ]] ; then
    echo -e "   
        -diff <Old Report> <New Report> [-outfile <Output HTML>]
                Diff two ${program_name} reports. Pass directory name or zip file or html report file as <Old Report> & <New Report>
  "
  elif [[ $1 == "-upgrade" ]] ; then
    echo -e "   
        -upgrade 
                Used to force upgrade the version of ${program_name} being run if a newer version is available under the location specified by RAT_UPGRADE_LOC.
  "
  elif [[ $1 == "-noupgrade" ]] ; then
    echo -e "   
        -noupgrade 
                User can specify this option if he does not want to be prompted for an upgrade even if a later version is available under the location specified by RAT_UPGRADE_LOC.
 "
  elif [[ $1 == "-dbserial" ]] ; then
    echo -e "   
        -dbserial 
                Run SQL, SQL_COLLECT and OS Checks in serial.
  "
  elif [[ $1 == "-dbparallel" ]] ; then
    echo -e "   
        -dbparallel 
		Run SQL, SQL_COLLECT and OS Checks in parallel.
                n       : Specified number of Child processes. Default is 25% of CPUs.
  "
  elif [[ $1 == "-daemon" ]] ; then
    echo -e "   
        -daemon 
                run ${program_name} only if daemon is running.
  "
  elif [[ $1 == "-nodaemon" ]] ; then
    echo -e "   
        -nodaemon 
                Dont use daemon to run ${program_name}.
  "
  elif [[ $1 == "-cells" ]] ; then
    echo -e "   
        -cells 
                Pass comma separated storage server names to run ${program_name} only on selected storage servers.\n
  "
  elif [[ $1 == "-ibswitches" ]] ; then
    echo -e "   
        -ibswitches 
                Pass comma separated infiniband switch names to run ${program_name} only on selected infiniband switches.\n
  "
  elif [[ $1 == "-tag" ]] ; then
    echo -e "   
        -tag <tagname>
                Appends <tagname> to Report Name. <Tagname> must contain only alphanumeric characters.
		for eg: ./${program_name} -tag newtag123 will append 'newtag123' to report name like '${program_name}_hostname1_db1_100914_123456_newtag123.html'
  "
  else
    display_usage; 
  fi	
}

usage()
{
#if [ $# -lt 1 ]
#then
#  TYP="-a"
#else
if [ "$program_name" = "odachk" ]
then
 echo "Usage : oakcli ${program_name} [-abvhpfmsuSo:c:t:]"
else
 echo "Usage : ./${program_name} [-abvhpfmsuSo:c:t:] "
fi
echo -e "
	-h      Prints this page.
        -a      All (Perform best practice check and recommended patch check)
        -b      Best Practice check only. No recommended patch check
        -v      Show version 
        -p      Patch check only
        -m      exclude checks for Maximum Availability Architecture (MAA) scorecards(see user guide for more details)
        -u      Run ${program_name} to check pre-upgrade or post-upgrade best practices for 11.2.0.3 and above
                -o pre or -o post is mandatory with -u option like ./${program_name} -u -o pre
        -f      Run Offline.Checks will be performed on data already collected from the system
        -o      Argument to an option. if -o is followed by v,V,Verbose,VERBOSE or Verbose, it will print checks which passs on the screen
                if -o option is not specified,it will print only failures on screen. for eg: ${program_name} -a -o v 

        -clusternodes
                Pass comma separated node names to run ${program_name} only on subset of nodes.
	-output
               Create ${program_name} collection zip file and ouptut directory to non-default(current) location.
        -dbnames
               	Pass comma separated database names to run ${program_name} only on subset of databases
        -localonly
               	Run ${program_name} only on local node.
	-debug
	     	Run ${program_name} in debug mode. Debug log will be generated. 
	       	eg:- ./${program_name} -debug
        -dbnone
                Do not prompt database selection and skip all database related checks.   
        -dball
                Do not prompt database selection and run database related checks on all databases discovered on system.

        -c     	Used only under the guidance of Oracle support or development to override default components 

	-upgrade 
		Used to force upgrade the version of ${program_name} being run.
	-noupgrade
		Do not prompt for an upgrade even if a later version is available under the location specified by RAT_UPGRADE_LOC.
"
	usage_report;
	usage_AR;
        usage_daemon;
echo -e "
	-vmguest
		Pass comma separated filenames containing exalogic guest VM list(applicable for Exalogic only)

	-hybrid [-phy]
		phy	:Pass comma separated physical compute nodes(applicable for Exalogic only)
			 eg:- ./${program_name} -hybrid -phy phy_node1,phy_node2	
"
	usage_profiles;	


echo -e "        
        -cells
                Pass comma separated storage server names to run ${program_name} only on selected storage servers.\n
        -ibswitches
                Pass comma separated infiniband switch names to run ${program_name} only on selected infiniband switches.\n
        -zfsnodes
                Pass comma separated ZFS storage appliance names to run ${program_name} only on selected storage appliances.

        -dbserial
                Run SQL, SQL_COLLECT and OS Checks in serial

        -dbparallel [n]
                Run SQL, SQL_COLLECT and OS Checks in parallel.
                n       : Specified number of Child processes. Default is 25% of CPUs."


#        -systemtype 
#               Pass <single | RAC>
#               single : if system is for single instance database
#               RAC    : if system is a part of cluster to run RAC database.
#
#        -orainst
#               Pass <no|yes>
#               no  : if Oracle software is not installed 
#               yes : if Oracle software is installed 

#	echo -e "
#	-update 
#		Used to auto update ${program_name}.
#		Dont use this with offline or silent mode"
	usage_winonly;
exit 1
#fi 
}

function usage_winonly ()
{
  if [ $is_windows -eq "0" ] ; then return; fi
echo -e "        
        -oracle_restart
                Oracle Restart environment.\n
"
}

function display_usage ()
{
  if [[ -n $RAT_DISPLAY_HELP && $RAT_DISPLAY_HELP -eq "1" ]]; then display_mode=1; usage; return; fi
  if [[ $display_mode -eq "2" ]]; then
    usage|more
  else 
    usage;
  fi
}

set_alvl ()
{
  if [ $i != $localnode ] ; then 
    SCPDIR=$RTEMPDIR
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then SCPDIR=$TMP_OUTPUT; fi

    $SCOPY ${i}:${localcmdval} ${SCPDIR} >/dev/null 2>&1; 
    $SSHELL $i "rm -f ${localcmdval} >/dev/null 2>&1"
  fi

  if [ -e ${localcmdval} ]; then
    ALVL=$(grep 'ALVL=' "${localcmdval}" | cut -d"=" -f2)
    ALVL_CHECK=$ALVL
    rm -f ${localcmdval} >/dev/null 2>&1;
  else
    if [[ -n "$1" && $1 -eq "10" ]]
    then
      ALVL="INFO";returncode=0;
    elif [[ -n "$1" && $1 -eq "11" ]]
    then
      ALVL="WARN";returncode=0;
    elif [[ -n "$1" && $1 -eq "12" ]]
    then
      ALVL="ERROR";returncode=0;
    elif [[ -n "$1" && $1 -eq "13" ]]
    then
      ALVL="FAIL";returncode=0;
    fi
  fi
}

score_per_component ()
{
  if [ $1 = "compute_node" ]
  then
    G_COMPUTE=$(expr $G_COMPUTE + 1);
  elif [ $1 = "switch" ]
  then
    G_SWITCH=$(expr $G_SWITCH + 1);
  elif [ $1 = "cell" ]
  then
    G_CELL=$(expr $G_CELL + 1);
  elif [ $1 = "ec" ]
  then
    G_EC=$(expr $G_EC + 1);
  elif [ $1 = "pc" ]
  then
    G_PC=$(expr $G_PC + 1);
  elif [ $1 = "db" ]
  then
    G_DB=$(expr $G_DB + 1);
  elif [ $1 = "ovmm" ]
  then
    G_OVMM=$(expr $G_OVMM + 1);
  fi
}

validate_needs_running ()
{
  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
  then
    if [[ "$NEEDS_RUNNING" = "STORAGE_CELL" ]]
    then
      score_per_component "cell";
    elif [[ "$NEEDS_RUNNING" = "SWITCH" || $NEEDS_RUNNING = "SPINE_SWITCH" ]]
    then
      score_per_component "switch";
    else
      score_per_component "compute_node";
      if [[ `echo $check_components|grep -wc "EXALOGIC_DB"` -ge 1 ]]
      then
        score_per_component "db";
      fi
      if [[ `echo $check_components|grep -wc "EXALOGIC_EC"` -ge 1 ]]
      then
        score_per_component "ec";
      fi
      if [[ `echo $check_components|grep -wc "EXALOGIC_OVMM"` -ge 1 ]]
      then
        score_per_component "ovmm";
      fi
      if [[ `echo $check_components|grep -wc "EXALOGIC_PC"` -ge 1 ]]
      then
        score_per_component "pc";
      fi
    fi
  fi

}

get_dbserverscnt ()
{

  if [ -e "$OUTPUTDIR/check_env.out" ]
  then
    MASTERFIL1=$OUTPUTDIR/check_env.out
  else
    MASTERFIL1=$OUTPUTDIR/raccheck_env.out
  fi
  if [ -n "$MERGEFILES" ]
  then
    MASTERFIL1=$NEW_MASTERFIL1;
    rm $HOSTLIST
    HOSTLIST=$WRKDIR/.MERGED_COLLECTIONS/o_host_list.out.merge
  fi

  el_db_node=""
  el_ec1_node=""
  el_ovmm_node=""
  el_pc_nodes=""
  el_pc1_node=""
  el_pc2_node=""
  el_exclude=""
  if [[ -n "$in_ec_exalogic" &&  $in_ec_exalogic -eq "1" ]] ;then
    el_db_node=$(grep '\.COMPONENT = .*EXALOGIC_DB' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u| sed 's/ //g')
    el_ec1_node=$(grep '\.COMPONENT = .*EXALOGIC_EC' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u| sed 's/ //g')
    el_ovmm_node=$(grep '\.COMPONENT = .*EXALOGIC_OVMM' $MASTERFIL1 |sed 's/\.COMPONENT.*//' | sort -u| sed 's/ //g')
    el_pc_nodes=$(grep '\.COMPONENT = .*EXALOGIC_PC' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u| sed 's/ //g')
    el_pc1_node=$(grep '\.COMPONENT = .*EXALOGIC_PC' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u | head -1| sed 's/ //g')
    el_pc2_node=$(grep '\.COMPONENT = .*EXALOGIC_PC' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u | tail -1| sed 's/ //g')
  fi

  if [ -e "$HOSTLIST" ]
  then
    dbserverscnt=0
    p_dbservers_cnt=0
    v_dbservers_cnt=0
    elsnodecnt=0
    exa_vcomp_list=""
    for hostname in `grep "[a-zA-Z0-9]" $HOSTLIST`
    do
      if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "1" ]]
      then
        skipnode=`grep LOCALNODE $MASTERFIL1 |awk '{print $3}'`
        if [ $hostname = $skipnode ]
        then
          continue
        fi
      fi

      if [[  -n "$in_ec_exalogic" &&  $in_ec_exalogic -eq "1" ]] ; then
        if [[ $hostname != $el_db_node && $hostname != $el_ec1_node && $hostname != $el_ovmm_node && `grep -ic "$hostname\.COMPONENT.*EXALOGIC_PC" $MASTERFIL1` -eq "0" ]] ; then
          dbserverscnt=$(expr $dbserverscnt + 1);
        else
          elsnodecnt=$(expr $elsnodecnt + 1)
        fi
      else
        dbserverscnt=$(expr $dbserverscnt + 1);
      fi
    done
  fi
}

#-s  Run silent mode, does not ask if environment is set correctly, assumes it is.  Also runs with sudo for oracle assumed.
#set up for changing colors of output lines
#site for examples of colors http://oinkzwurgl.org/bashrc

#Added validation to make sure supported bash version is there
bash_version=$(bash -version|grep version|head -1|sed 's/[^0-9]//g'|cut -c1-2)
bash_version_msg=$(bash -version|head -1|awk '{print $4}'|cut -d. -f1-2)
program_name=$(echo $(basename $0)|sed 's/[\.\/]//g')
if [[ -n "$bash_version" && $bash_version -lt 30 ]]
then
  echo -e "\n${RED}${program_name} is not supported on bash version ${bash_version_msg}. It requires bash version 3.2 and above. Use bash -version command to verify ${NORM}\n"
  exit 1
fi
AWK=$(command -v gawk)
if [ ! -f "$AWK" ];then  AWK=awk;fi

copy_cgrep()
{
#Following section to copy right executable at working directory
data_file_type=$(grep -ic FILE_ID $REFFIL)
DECRYPT_VDAT=0
if [ ! -e $EXADATA_CELL_COLLECTIONS ]; then touch $EXADATA_CELL_COLLECTIONS >/dev/null 2>&1;fi
if [[ -n "$data_file_type" && $data_file_type -le 0 ]]
then
  if [ -e $SCRIPTPATH/.cgrep/cgrep ]
  then
    cp $SCRIPTPATH/.cgrep/cgrep $WRKDIR/cgrep >/dev/null 2>&1
    chmod 744 $WRKDIR/cgrep
  elif [ $cgrep_platform = "Linux" ]
  then
    if [ -e /etc/redhat-release ]
    then
      #os_version=$(cat /etc/redhat-release|grep -v ^#|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      os_version=$(grep -v ^# /etc/redhat-release|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      if [ $os_version -eq 3 ]
      then
        cp $SCRIPTPATH/.cgrep/lcgrep3 $WRKDIR/cgrep >/dev/null 2>&1
      elif [ $os_version -eq 4 ]
      then
        cp $SCRIPTPATH/.cgrep/lcgrep4 $WRKDIR/cgrep >/dev/null 2>&1
      elif [ $os_version -eq 5 ]
      then
        cp $SCRIPTPATH/.cgrep/lcgrep5 $WRKDIR/cgrep >/dev/null 2>&1
      elif [ $os_version -ge 6 ]
      then
         if [ $(uname -p) = "s390x" ]
         then
             cp $SCRIPTPATH/.cgrep/zlcgrep6 $WRKDIR/cgrep >/dev/null 2>&1
         else
             cp $SCRIPTPATH/.cgrep/lcgrep6 $WRKDIR/cgrep >/dev/null 2>&1
         fi
      fi
      #$READ -p "what_os=$what_os is_exalogic_machine=$is_exalogic_machine and os_version=$os_version"
    elif [ -e /etc/SuSE-release ]
    then
      #os_version=$(cat /etc/SuSE-release|grep -v ^#|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      #if [ -z "$os_version" ]; then os_version=$(cat /etc/SuSE-release|grep -i version|awk '{print $3}');fi
      os_version=$(grep -v ^# /etc/SuSE-release|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      if [ -z "$os_version" ]; then os_version=$(grep -i version /etc/SuSE-release|awk '{print $3}');fi
      if [ $os_version -eq 9 ]
      then
        cp $SCRIPTPATH/.cgrep/lcgreps9 $WRKDIR/cgrep >/dev/null 2>&1
      elif [ $os_version -eq 10 ]
      then
        cp $SCRIPTPATH/.cgrep/lcgreps10 $WRKDIR/cgrep >/dev/null 2>&1
      elif [ $os_version -ge 11 ]
      then
          if [ $(uname -p) = "s390x" ]
          then
              cp $SCRIPTPATH/.cgrep/zlcgreps11 $WRKDIR/cgrep >/dev/null 2>&1
          else
              cp $SCRIPTPATH/.cgrep/lcgreps11 $WRKDIR/cgrep >/dev/null 2>&1
          fi
      fi
    fi
    chmod 744 $WRKDIR/cgrep >/dev/null 2>&1
  elif [ $cgrep_platform = "SunOS" ]
  then
    if [ `uname -p` = "sparc" ]
    then
      cp $SCRIPTPATH/.cgrep/scgrep $WRKDIR/cgrep >/dev/null 2>&1
    elif [ `uname -p|grep -ic 86` -ge 1 ]
    then
      cp $SCRIPTPATH/.cgrep/scgrepx86 $WRKDIR/cgrep >/dev/null 2>&1
    fi
    chmod 744 $WRKDIR/cgrep
  elif [ $cgrep_platform = "AIX" ]
  then
    cp $SCRIPTPATH/.cgrep/acgrep $WRKDIR/cgrep >/dev/null 2>&1
    chmod 744 $WRKDIR/cgrep
  elif [ $cgrep_platform = "HP-UX" ]
  then
    cp $SCRIPTPATH/.cgrep/hiacgrep $WRKDIR/cgrep >/dev/null 2>&1
    chmod 744 $WRKDIR/cgrep
  #elif [[ $cgrep_platform = "CYGWIN_NT-6.3" || $cgrep_platform = "CYGWIN_NT-6.1" ]]
  elif [[ $cgrep_platform = "CYGWIN_NT-6.3" || $cgrep_platform = "CYGWIN_NT-6.2" || $cgrep_platform = "CYGWIN_NT-6.1" || $cgrep_platform = "CYGWIN_NT-5.2" ]]
  then
    win_v=$(echo $cgrep_platform | sed 's/CYGWIN_NT-//' | sed 's/\.//');
    if [[ "$win_v" = "62" || "$win_v" = "52" ]]; then win_v=61; fi
    cp $SCRIPTPATH/.cgrep/cgrepwin$win_v $WRKDIR/cgrep >/dev/null 2>&1
    chmod 744 $WRKDIR/cgrep
  #else
  #    echo -e "\n${RED}Error RC-001- Unable to read driver files. Please report this error to your Oracle representative for action.\n\nExiting .....\n${NORM}"
  #    exit 1;
  fi
  #cgrep_perm=$(ls -l cgrep |awk '{ print $1}'|grep -ic x)
  #if [ $cgrep_perm -le 0 ];then echo -e "\n${RED}Error RC-002 - cgrep is not executable. Please change permission to 755 for cgrep and run agian.\n\nExiting .....\n${NORM}";exit 1;fi;
  if [ ! -e $WRKDIR/cgrep ]
  then
    echo -e "\n${RED}RC-001- Unable to read driver files.  Please refer to the section for this error code in "Appendix A - Troubleshooting Scenarios" of the "${program_name} User Guide".\n\n ${program_name} exiting .....\n${NORM}"
    exit 1;
  fi
  export PATH=$PATH:.
  cgrep_test=$($WRKDIR/cgrep FILE_ID $REFFIL>/dev/null 2>&1)
  if [ $? -ne 0 ]
  then
    #$READ -p "grep =$GREP cgrep_test=$cgrep_test"
    echo -e "\n${RED}RC-002- Unable to read driver files.  Please refer to the section for this error code in "Appendix A - Troubleshooting Scenarios" of the "${program_name} User Guide".\n\n ${program_name} exiting .....\n${NORM}"
    exit 1;
  fi
  GREP=$WRKDIR/cgrep
  DECRYPT_VDAT=1
else
  GREP=/bin/grep
fi

}


upgrade_orachk()
{
	PRERDIR=`pwd`;
	if [ `touch $PRERDIR/testfile 2> /dev/null; echo "$?"` -eq 0 ]; then
		perl_exe=$(which perl|tr -d '\r');
		$perl_exe $SCRIPTPATH/.cgrep/auto_upgrade.pl $program_version ${program_name} "-upgrade" $RAT_UPGRADE_LOC $WRKDIR $check_upgrade_ret_val;
		rm $PRERDIR/testfile;
		readonlyval=0;
	else
		readonlyval=1;
		echo "
Cannot upgrade. The current directory is read-only.
";
	fi 
#  PRERDIR=`pwd`;
#  perl_exe=$(which perl|tr -d '\r');
#  $perl_exe $SCRIPTPATH/.cgrep/auto_upgrade.pl ${program_name} "-upgrade" $RAT_UPGRADE_LOC $WRKDIR $check_upgrade_ret_val;
}

check_upgrade()
{
  func_what_platform
  copy_cgrep
  PRERDIR=`pwd`;
  perl_exe=$(which perl|tr -d '\r');
  check_upgrade_ret_val=`$perl_exe $SCRIPTPATH/.cgrep/auto_upgrade.pl $program_version ${program_name} "-check" $RAT_UPGRADE_LOC $WRKDIR $check_upgrade_ret_val`;

  #check_upgrade_ret_val=`$perl_exe $PRERDIR/auto_upgrade.pl ${program_name} "-check" $RAT_UPGRADE_LOC $check_upgrade_ret_val`;
    
  #if [[ $ret_val -eq "1" ]]; then
  #  if [[ $daemon_running -ne "1" ]]
  #  then 	
  #    echo "Upgrade done! Running the latest version.";
  #    $PRERDIR/${program_name} ${argsaved};
  #    exit;
  #  else
  #    echo "Daemon is running. Sending email!!";
  #    upgrade_email_subj="New version of ${program_name} is available";
  #    matter="A new version of ${program_name} is available at $location. Please restart the ${program_name} daemon to upgrade to latest version";
      
  #    send_email "$upgrade_email_subj" "$matter" "0" "all";
  #  fi
  #fi

}

#Function to Fix root password
fixRootPassword ()
{
  inputPassword=$1
  #fixedRootPassword=$(echo "$inputPassword" | sed 's/\\/\\\\/g')
  #fixedRootPassword=$(echo "$fixedRootPassword" | sed 's/\[/\\[/g')
  #fixedRootPassword=$(echo "$fixedRootPassword" | sed 's/"/\\"/g')
  fixedRootPassword=$(echo "$inputPassword" | sed  -e 's/\\/\\\\/g' -e 's/\[/\\[/g' -e 's/"/\\"/g')

  hasDollar=$(echo "$fixedRootPassword"|grep -c "$");
  if [[ -n "$hasDollar" && $hasDollar -ge "1" ]]; then 
    fixedRootPassword=$(echo "$fixedRootPassword"|sed 's/\$/\\$/g');
  fi
}

get_check_env_file ()
{
  #Cluster, platform details are read from end file in offline mode
  if [ -e "$OUTPUTDIR/check_env.out" ]
  then
    check_env_file=$OUTPUTDIR/check_env.out
  else
    check_env_file=$OUTPUTDIR/raccheck_env.out
  fi
}

read_env_file_for_cs_nodes ()
{
  get_check_env_file;

  el_db_node=""
  el_ec1_node=""
  el_ovmm_node=""
  el_pc_nodes=""
  el_pc1_node=""
  el_pc2_node=""

  if [[ -n "$in_ec_exalogic" &&  $in_ec_exalogic -eq "1" ]] ;then
    el_db_node=$(grep '\.COMPONENT = .*EXALOGIC_DB' $check_env_file |sed 's/\.COMPONENT.*//'| sort -u | sed 's/ //g')
    el_ec1_node=$(grep '\.COMPONENT = .*EXALOGIC_EC' $check_env_file |sed 's/\.COMPONENT.*//'| sort -u | sed 's/ //g')
    el_ovmm_node=$(grep '\.COMPONENT = .*EXALOGIC_OVMM' $check_env_file |sed 's/\.COMPONENT.*//' | sort -u| sed 's/ //g')
    el_pc_nodes=$(grep '\.COMPONENT = .*EXALOGIC_PC' $check_env_file |sed 's/\.COMPONENT.*//'| sort -u| sed 's/ //g')
    el_pc1_node=$(grep '\.COMPONENT = .*EXALOGIC_PC' $check_env_file |sed 's/\.COMPONENT.*//'| sort -u | head -1| sed 's/ //g')
    el_pc2_node=$(grep '\.COMPONENT = .*EXALOGIC_PC' $check_env_file |sed 's/\.COMPONENT.*//'| sort -u | tail -1| sed 's/ //g')
  fi
}

get_el_prefix()
{
  if [[ -z "$el_db_node" ]] ; then
    read_env_file_for_cs_nodes
  fi

  el_hname=$(echo $1 | sed 's/ //g')
  case $el_hname in
    $el_db_node)
      el_prefix="DB";;
    $el_ec1_node)
      el_prefix="EC";;
    $el_ovmm_node)
      el_prefix="OVMM";;
    "$el_pc1_node"|"$el_pc2_node")
      el_prefix="PC";;
    *)
      el_prefix="CN";;
  esac
}

prompt_for_pass()
{
  #$usern $hname
  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
  then
    if [[ -n $in_ec_exalogic && $in_ec_exalogic -eq "1" ]]
    then #Get type of node
      case $hname in 
        $ea_db_node)
          el_prefix="DB";;
        $ea_ec1_node)
          el_prefix="EC";;
        $ea_ovmm_node)
          el_prefix="OVMM";;
        "$ea_pc1_node"|"$ea_pc2_node")
          el_prefix="PC";;
        *)
          el_prefix="CN";;
      esac
    fi

    ask_pass=0
    go_back=0
    if [[ -n $in_ec_exalogic && $in_ec_exalogic -eq "1" && $el_prefix = "CN" && -n "$use_expect_for_ssh_cn" && $use_expect_for_ssh_cn -eq "1" ]]
    then # Already prompted for compute node password in new exalogic..
      go_back=1
      if [[ -n "$node_samerootpassword_cn" && $node_samerootpassword_cn -eq "0" ]] ; then ask_pass=1 ; fi
    elif [[ -n $in_ec_exalogic && $in_ec_exalogic -eq "1" && $el_prefix != "CN" && -n "$use_expect_for_ssh_vm" && $use_expect_for_ssh_vm -eq "1" ]]
    then # Already prompted for control server password in new exalogic..
      go_back=1
      if [[ -n "$node_samerootpassword_vm" && $node_samerootpassword_vm -eq "0" ]] ; then ask_pass=1 ; fi
    elif [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" && $in_ec_exalogic -eq "0" ]]
    then # Already prompted for password, so we have details
      go_back=1
      if [[ -n "$node_samerootpassword" && $node_samerootpassword -eq "0" ]] ; then ask_pass=1 ; fi
    fi

    if [[ $go_back -eq "1" ]] ; then
      if [[ $ask_pass -eq "1" ]]
      then # Get nodepassword
        echo -e "\n"
	if [[ -n "$prepare_init" && $prepare_init -eq "1" ]] && [[ -z "$compute_samerootpassword_YesNo" || `echo "$compute_samerootpassword_YesNo" |grep -ic "n"` -eq 0 ]]
        then
          printf  "Enter ${usern} password ${NORM} :- "
        else
          printf  "Enter ${usern} password on $hname ${NORM} :- "
        fi

	if [[ $EM_XMLD_MODE -eq 1 ]]
	then
	  read_probe_xml "<text>$hname</text>"
	  node_rootpassword=$xml_rvalue
	else
          tty -s && stty -echo
          $READ -r node_rootpassword
          tty -s && stty echo
	fi
        printf "\n\nVerifying ${usern} password.\n\n. . ";
        checkUserPassword "$hname" "$usern" "$node_rootpassword" "3"
	node_rootpassword=$passwordToCheck
      fi
      return 0;
    fi

    use_expect_for_ssh=1

    node_type="nodes"
    node_type2=""
    if [[ -n $in_ec_exalogic && $in_ec_exalogic -eq "1" ]] ; then
      if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "1" ]] ;  then
	use_expect_for_ssh_cn=1
	node_type="Guest Virtual Machines"
      elif [[ $el_prefix = "CN" ]] ; then 
        use_expect_for_ssh_cn=1
        node_type="Compute Nodes"
      else
        node_type="Control VM's"
        node_type2="(EC,OVMM,DB,PC)"
        use_expect_for_ssh_vm=1
      fi
    fi

    echo -e  "We can configure ssh on all $node_type $node_type2 without prompting for password on each host if password is same on all $node_type."

    if [[ $EM_XMLD_MODE -eq 1 ]]
    then
      echo -e "Is ${usern} password same on all $node_type?[y/n][y]"

      read_probe_xml "Is {1} user password same on all nodes"
      node_samerootpassword_yes=$xml_rvalue
    else
      exec 3<&2; exec 2<&0
      $READ -p  "Is ${usern} password same on all $node_type?[y/n][y]" node_samerootpassword_yes
      read_code=`echo $?`;
      exec 2<&3
      process_prompt "$read_code" "node_samerootpassword_yes" "y"
    fi
    case $node_samerootpassword_yes in
      n|N|No|NO|no)
        node_samerootpassword=0
        echo "Enter password for each host when prompted."
        echo -e "\n"
        printf  "Enter ${usern} password on $hname ${NORM} :- "

	if [[ $EM_XMLD_MODE -eq 1 ]]
	then
	  read_probe_xml "<text>$hname</text>"
	  node_rootpassword=$xml_rvalue
	else
          tty -s && stty -echo
          $READ -r node_rootpassword
          tty -s && stty echo
	fi
        printf "\n\nVerifying ${usern} password.\n\n. . ";
        checkUserPassword "$hname" "$usern" "$node_rootpassword" "3"
	node_rootpassword=$passwordToCheck
        ;;
      *)
        echo -e "\n"
        printf  "Enter ${usern} password ${NORM} :- "
	
	if [[ $EM_XMLD_MODE -eq 1 ]]
	then
	  read_probe_xml "Common {1} user password on nodes"
	  node_rootpassword=$xml_rvalue	
	else
          tty -s && stty -echo
          $READ -r node_rootpassword
          tty -s && stty echo
	fi
        printf "\n\nVerifying ${usern} password.\n\n. . ";
        checkUserPassword "$hname" "$usern" "$node_rootpassword" "3"
	node_rootpassword=$passwordToCheck
        if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
        then
          node_samerootpassword=1
        else
          node_samerootpassword=0
        fi
        ;;
    esac

    if [[ -n $in_ec_exalogic && $in_ec_exalogic -eq "1" ]] ; then
      if [[ $el_prefix = "CN" ]] ; then
        node_samerootpassword_cn=$node_samerootpassword
        node_rootpassword_cn=$node_rootpassword
      else
        node_samerootpassword_vm=$node_samerootpassword
        node_rootpassword_vm=$node_rootpassword
      fi
    fi
  fi

  if [ -e "$EXPECT" ] ; then
    node_rootpassword=$passwordToCheck;
    if [[ -z "$node_rootpassword" || $passwordCheckStatus -ne 0 ]]
    then  
      if [[ -n "$prepare_init" && $prepare_init -eq "1" ]] && [[ -z "$compute_samerootpassword_YesNo" || `echo "$compute_samerootpassword_YesNo" |grep -ic "n"` -eq 0 ]]
      then
        printf  "Enter ${usern} password ${NORM} :- "
      else
        printf  "Enter ${usern} password on $hname ${NORM} :- "
      fi

      if [[ $EM_XMLD_MODE -eq 1 ]]
      then
    	read_probe_xml "<text>$hname</text>"
	node_rootpassword=$xml_rvalue
      else
        tty -s && stty -echo
        $READ -r node_rootpassword
        tty -s && stty echo
      fi
      printf "\n\nVerifying ${usern} password.\n\n. . ";
    fi
    checkUserPassword "$hname" "$usern" "$node_rootpassword" "3"
    node_rootpassword=$passwordToCheck
    if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
    then
      if [ -z "$node_index" ] ; then node_index=0; fi
      a_node_names[$node_index]=$hname;
      a_node_passwords[$node_index]="$node_rootpassword";
      node_index=$(expr $node_index + 1)
      use_expect_for_ssh=1
    fi
  fi
}

#follwoing fuction is to setup ssh at given node
func_setup_ssh ()
{ 
  if [ -z $READ ]; then
    READ="read"
    if [[ $prompt_timeout -eq 1 ]]
    then
      if [[ -z $RAT_PROMPT_TIMEOUT ]]; then export RAT_PROMPT_TIMEOUT=0; fi
      READ="read -t $RAT_PROMPT_TIMEOUT"
    fi
  fi

  SSH_PASS_STATUS=0
  passwordCheckStatus=0
  
  prompt_for_pass  # Ask user if we need to setup automatically.
  
  if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -ne 0 ]]
  then 
    SSH_PASS_STATUS=1
    return 1
  fi
  
  local numargs=$#
  local ADVANCED=false
  local HOSTNAME=`hostname`
  local CONFIRM=no
  local SHARED=false
  local i=1
  local USR=$USER
  if  test -z "$TEMP"
  then
    local TEMP=$TMPDIR
  fi
  local IDENTITY=id_dsa
  #local LOGFILE=$TEMP/sshUserSetup_`date +%F-%H-%M-%S`.log
  local LOGFILE=/dev/null
  local VERIFY=false
  local EXHAUSTIVE_VERIFY=false
  local HELP=false
  local PASSPHRASE=no
  local RERUN_SSHKEYGEN=no
  local NO_PROMPT_PASSPHRASE=yes
  local j=""
  local HOSTS=""
  local USR=""
  while [ $i -le $numargs ]
  do
    j=$1 
    if [ $j = "-hosts" ] 
    then
      HOSTS=$2
      shift 1
      i=`expr $i + 1`
    fi
    if [ $j = "-user" ] 
    then
      USR=$2
      shift 1
      i=`expr $i + 1`
    fi
    if [ $j = "-logfile" ] 
    then
      LOGFILE=$2
      shift 1
      i=`expr $i + 1`
    fi
    if [ $j = "-confirm" ] 
    then
      CONFIRM=yes
    fi
    if [ $j = "-hostfile" ] 
    then
      CLUSTER_CONFIGURATION_FILE=$2
      shift 1
      i=`expr $i + 1`
    fi
    if [ $j = "-usePassphrase" ] 
    then
      PASSPHRASE=yes
    fi
    if [ $j = "-noPromptPassphrase" ] 
    then
      NO_PROMPT_PASSPHRASE=yes
    fi
    if [ $j = "-shared" ] 
    then
      SHARED=true
    fi
    if [ $j = "-exverify" ] 
    then
      EXHAUSTIVE_VERIFY=true
    fi
    if [ $j = "-verify" ] 
    then
      VERIFY=true
    fi
    if [ $j = "-advanced" ] 
    then
      ADVANCED=true
    fi
    if [ $j = "-help" ] 
    then
      HELP=true
    fi
    i=`expr $i + 1`
    shift 1
  done
  

  if [ $HELP = "true" ]
  then
    echo "Usage $0 -user <user name> [ -hosts \"<space separated hostlist>\" | -hostfile <absolute path of cluster configuration file> ] [ -advanced ]  [ -verify] [ -exverify ] [ -logfile <desired absolute path of logfile> ] [-confirm] [-shared] [-help] [-usePassphrase] [-noPromptPassphrase]"
  exit 1
  fi
  
  if test -z "$HOSTS"
  then
    if test -n "$CLUSTER_CONFIGURATION_FILE" && test -f "$CLUSTER_CONFIGURATION_FILE"
    then
       HOSTS=`awk '$1 !~ /^#/ { str = str " " $1 } END { print str }' $CLUSTER_CONFIGURATION_FILE` 
    elif ! test -f "$CLUSTER_CONFIGURATION_FILE"
    then
      echo "Please specify a valid and existing cluster configuration file."
    fi
  fi
  
  if  test -z "$HOSTS" || test -z $USR
  then
    echo "Either user name or host information is missing"
    echo "Usage $0 -user <user name> [ -hosts \"<space separated hostlist>\" | -hostfile <absolute path of cluster configuration file> ] [ -advanced ]  [ -verify] [ -exverify ] [ -logfile <desired absolute path of logfile> ] [-confirm] [-shared] [-help] [-usePassphrase] [-noPromptPassphrase]" 
    return 1
  fi

  #echo Hosts are $HOSTS | tee -a $LOGFILE
  #echo user is  $USR | tee -a $LOGFILE
  SSH="/usr/bin/ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"
  SSH_KEYGEN="/usr/bin/ssh-keygen"
  calculateOS()
  {
    platform=`uname -s`
    case "$platform"
    in
       "SunOS")  SSH="/usr/bin/ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"
                 SSH_KEYGEN="/usr/bin/ssh-keygen"
                 os=solaris;;
       "Linux")  os=linux;;
       "HP-UX")  os=hpunix;;
         "AIX")  os=aix;;
        CYGWIN_NT-[0-9].[0-9])
                 os=windows;;
             *)  echo "Sorry, $platform is not currently supported." | tee -a $LOGFILE
                 return 1;;
    esac
  
    #echo "Platform:- $platform " | tee -a $LOGFILE
  }
  calculateOS
  BITS=1024
  ENCR="dsa"
  
  deadhosts=""
  alivehosts=""
  PING_W_FLAG=""
  echo Checking if the remote hosts are reachable >> $LOGFILE
  #if [ $platform = "Linux" ]
  #then
  #  PING="/bin/ping"
  #  PING_W_FLAG="-w 5"
  #else
  #  PING="/usr/sbin/ping"
  #fi

  for host in $HOSTS
  do
    test_node_reachability "$host";
    #if [ $platform = "SunOS" ]; then
    #  $PING -s $host 5 5 >/dev/null 2>&1
    #elif [ $platform = "HP-UX" ]; then
    #  $PING $host -n 5 -m 5 >/dev/null 2>&1
    #else
    #  $PING -c 1 $PING_W_FLAG $host >/dev/null 2>&1
    #fi
    #exitcode=`echo $?`
    if [ $el_node_ping -eq "1" ]
    then
      alivehosts="$alivehosts $host"
    else
      deadhosts="$deadhosts $host"
    fi
  done
  
  if test -z "$deadhosts"
  then
    echo Remote host reachability check succeeded >> $LOGFILE
    #echo The following hosts are reachable: $alivehosts.  | tee -a $LOGFILE
    #echo The following hosts are not reachable: $deadhosts.  | tee -a $LOGFILE
    #echo All hosts are reachable. Proceeding further...  | tee -a $LOGFILE
  else
    echo Remote host reachability check failed.  >>$LOGFILE
    #echo The following hosts are reachable: $alivehosts.  | tee -a $LOGFILE
    #echo The following hosts are not reachable: $deadhosts.  | tee -a $LOGFILE
    #echo Please ensure that all the hosts are up and re-run the script.  | tee -a $LOGFILE
    #echo Exiting now...  | tee -a $LOGFILE
    return 1
  fi

  if [ $platform = "HP-UX" ]
  then
    firsthost=`echo $HOSTS | awk '{print $1}; END { }'`
    echo firsthost $firsthost
    numhosts=`echo $HOSTS | awk '{ }; END {print NF}'`
    echo numhosts $numhosts
  else
    declare -a HOSTSARR="( $HOSTS )"
    firsthost=${HOSTSARR[0]}
    typeset -i numhosts=${#HOSTSARR[@]} 
  fi
  
  if [ $VERIFY = "true" ]
  then
    echo Since user has specified -verify option, SSH setup will not be performed. Existing SSH setup will be verified instead. >>$LOGFILE
    continue
  else
    #echo The script will setup SSH connectivity from the host ''`hostname`'' to all  | tee -a $LOGFILE 
    #echo the remote hosts. After the script is executed, the user can use SSH to run  | tee -a $LOGFILE 
    #echo commands on the remote hosts or copy files between this host ''`hostname`'' | tee -a $LOGFILE 
    #echo and the remote hosts without being prompted for passwords or confirmations. | tee -a $LOGFILE 
    #echo  | tee -a $LOGFILE 
    #echo NOTE 1: | tee -a $LOGFILE 
    #echo As part of the setup procedure, this script will use 'ssh' and 'scp' to copy | tee -a $LOGFILE 
    #echo files between the local host and the remote hosts. Since the script does not  | tee -a $LOGFILE 
    #echo store passwords, you may be prompted for the passwords during the execution of  | tee -a $LOGFILE 
    #echo the script whenever 'ssh' or 'scp' is invoked. | tee -a $LOGFILE 
    #echo  | tee -a $LOGFILE 
    #echo NOTE 2: | tee -a $LOGFILE 
    #echo "AS PER SSH REQUIREMENTS, THIS SCRIPT WILL SECURE THE USER HOME DIRECTORY" | tee -a $LOGFILE 
    #echo AND THE .ssh DIRECTORY BY REVOKING GROUP AND WORLD WRITE PRIVILEDGES TO THESE  | tee -a $LOGFILE 
    #echo "directories." | tee -a $LOGFILE 
    #echo  | tee -a $LOGFILE 
    #echo "Do you want to continue and let the script make the above mentioned changes (yes/no)?" | tee -a $LOGFILE 
    
    #Added by to overwrite variable
    CONFIRM=yes
    if [ "$CONFIRM" = "no" ] 
    then 
      $READ CONFIRM 
      read_code=`echo $?`;
      process_prompt "$read_code" "CONFIRM" "yes"
    else
      echo "Confirmation provided on the command line" >>$LOGFILE
    fi 
       
    #echo  | tee -a $LOGFILE 
    #echo The user chose ''$CONFIRM'' | tee -a $LOGFILE 
 
    if [ "$CONFIRM" = "no" ] 
    then 
      echo "SSH setup has not been performed." >> $LOGFILE 
      return 1 
    else 
      NO_PROMPT_PASSPHRASE=yes
      if [ $NO_PROMPT_PASSPHRASE = "yes" ]
      then
        echo "User chose to skip passphrase related questions."  >>$LOGFILE
      else
        typeset -i PASSPHRASE_PROMPT
        if [ $SHARED = "true" ]
        then
              PASSPHRASE_PROMPT=2*${numhosts}+1
        else
              PASSPHRASE_PROMPT=2*${numhosts} 
        fi
        echo "Please indicate whether you want to specify a passphrase for the private key this script will create for the local host. The passphrase is used to encrypt the private key and makes SSH much more secure. Type 'yes' or 'no' and then press enter. If you press 'yes', you will need to enter the passphrase whenever the script executes ssh or scp. " >>$LOGFILE
        echo "The estimated number of times the user will be prompted for a passphrase is $PASSPHRASE_PROMPT. In addition, if the private-public files are also newly created, the user would have to specify the passphrase on one additional occasion. " | tee -a $LOGFILE
        echo "Enter 'yes' or 'no'." >>$LOGFILE

	if [ $PASSPHRASE = "no" ]
        then
          $READ PASSPHRASE
	  read_code=`echo $?`;
	  process_prompt "$read_code" "PASSPHRASE" "no"
        else
          echo "Confirmation provided on the command line" >>$LOGFILE
        fi 

        echo  | tee -a $LOGFILE 
        echo The user chose ''$PASSPHRASE'' >> $LOGFILE 

        if [ "$PASSPHRASE" = "yes" ] 
        then 
          RERUN_SSHKEYGEN="yes"
	  #Checking for existence of ${IDENTITY} file
          if test -f  $HOME/.ssh/${IDENTITY}.pub && test -f  $HOME/.ssh/${IDENTITY} 
          then
            echo "The files containing the client public and private keys already exist on the local host. The current private key may or may not have a passphrase associated with it. In case you remember the passphrase and do not want to re-run ssh-keygen, press 'no' and enter. If you press 'no', the script will not attempt to create any new public/private key pairs. If you press 'yes', the script will remove the old private/public key files existing and create new ones prompting the user to enter the passphrase. If you enter 'yes', any previous SSH user setups would be reset. If you press 'change', the script will associate a new passphrase with the old keys." | tee -a $LOGFILE
            echo "Press 'yes', 'no' or 'change'" >> $LOGFILE
            $READ RERUN_SSHKEYGEN 
	    read_code=`echo $?`;
	    process_prompt "$read_code" "RERUN_SSHKEYGEN" "no"
            echo The user chose ''$RERUN_SSHKEYGEN'' >> $LOGFILE 
          fi 
        else
          if test -f  $HOME/.ssh/${IDENTITY}.pub && test -f  $HOME/.ssh/${IDENTITY} 
          then
            echo "The files containing the client public and private keys already exist on the local host. The current private key may have a passphrase associated with it. In case you find using passphrase inconvenient(although it is more secure), you can change to it empty through this script. Press 'change' if you want the script to change the passphrase for you. Press 'no' if you want to use your old passphrase, if you had one."
            $READ RERUN_SSHKEYGEN 
	    read_code=`echo $?`;
	    process_prompt "$read_code" "RERUN_SSHKEYGEN" "no"
            echo The user chose ''$RERUN_SSHKEYGEN'' >> $LOGFILE 
          fi
        fi
      fi

      #echo Creating .ssh directory on local host, if not present already | tee -a $LOGFILE
      mkdir -p $HOME/.ssh | tee -a $LOGFILE
      #echo Creating authorized_keys file on local host  | tee -a $LOGFILE
      touch $HOME/.ssh/authorized_keys  | tee -a $LOGFILE
      #echo Changing permissions on authorized_keys to 644 on local host  | tee -a $LOGFILE
      chmod 644 $HOME/.ssh/authorized_keys  | tee -a $LOGFILE
      mv -f $HOME/.ssh/authorized_keys  $HOME/.ssh/authorized_keys.tmp | tee -a $LOGFILE
      #echo Creating known_hosts file on local host  | tee -a $LOGFILE
      touch $HOME/.ssh/known_hosts  | tee -a $LOGFILE
      #echo Changing permissions on known_hosts to 644 on local host  | tee -a $LOGFILE
      chmod 644 $HOME/.ssh/known_hosts  | tee -a $LOGFILE
      mv -f $HOME/.ssh/known_hosts $HOME/.ssh/known_hosts.tmp | tee -a $LOGFILE
      
      #echo Creating config file on local host | tee -a $LOGFILE
      #echo If a config file exists already at $HOME/.ssh/config, it would be backed up to $HOME/.ssh/config.backup.
      echo "Host *" > $HOME/.ssh/config.tmp | tee -a $LOGFILE
      echo "ForwardX11 no" >> $HOME/.ssh/config.tmp | tee -a $LOGFILE
      
      if test -f $HOME/.ssh/config 
      then
        cp -f $HOME/.ssh/config $HOME/.ssh/config.backup
      fi
      
      mv -f $HOME/.ssh/config.tmp $HOME/.ssh/config  | tee -a $LOGFILE
      #Fix for BUG NO 5157782
      chmod 644 $HOME/.ssh/config
      if [ $RERUN_SSHKEYGEN = "yes" ]
      then
        #echo Removing old private/public keys on local host | tee -a $LOGFILE
        rm -f $HOME/.ssh/${IDENTITY} | tee -a $LOGFILE
        rm -f $HOME/.ssh/${IDENTITY}.pub | tee -a $LOGFILE
        #echo Running SSH keygen on local host | tee -a $LOGFILE
        $SSH_KEYGEN -t $ENCR -b $BITS -f $HOME/.ssh/${IDENTITY}   | tee -a $LOGFILE
      elif [ $RERUN_SSHKEYGEN = "change" ]
      then
        echo Running SSH Keygen on local host to change the passphrase associated with the existing private key | tee -a $LOGFILE
        $SSH_KEYGEN -p -t $ENCR -b $BITS -f $HOME/.ssh/${IDENTITY} | tee -a $LOGFILE
      elif test -f  $HOME/.ssh/${IDENTITY}.pub && test -f  $HOME/.ssh/${IDENTITY} 
      then
        echo "">>$LOGFILE
        #continue
      else
        #echo Removing old private/public keys on local host | tee -a $LOGFILE
        rm -f $HOME/.ssh/${IDENTITY} | tee -a $LOGFILE
        rm -f $HOME/.ssh/${IDENTITY}.pub | tee -a $LOGFILE
        #echo Running SSH keygen on local host with empty passphrase | tee -a $LOGFILE
        $SSH_KEYGEN -t $ENCR -b $BITS -f $HOME/.ssh/${IDENTITY} -N ''  | tee -a $LOGFILE
      fi
      if [ $SHARED = "true" ]
      then
        if [ $USER = $USR ]
        then
          #No remote operations required
          echo Remote user is same as local user >> $LOGFILE
          REMOTEHOSTS=""
          chmod og-w $HOME $HOME/.ssh >> $LOGFILE
        else    
          REMOTEHOSTS="${firsthost}"
        fi
      else
        REMOTEHOSTS="$HOSTS"
      fi
      
      fixRootPassword "$node_rootpassword"

      for host in $REMOTEHOSTS
      do
        #echo Creating .ssh directory and setting permissions on remote host $host | tee -a $LOGFILE
        #echo "THE SCRIPT WOULD ALSO BE REVOKING WRITE PERMISSIONS FOR "group" AND "others" ON THE HOME DIRECTORY FOR $USR. THIS IS AN SSH REQUIREMENT." | tee -a $LOGFILE
        #echo The script would create ~$USR/.ssh/config file on remote host $host. If a config file exists already at ~$USR/.ssh/config, it would be backed up to ~$USR/.ssh/config.backup. | tee -a $LOGFILE
        #echo The user may be prompted for a password here since the script would be running SSH on host $host. | tee -a $LOGFILE
        if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
        then
          $EXPECT -f - << IBEOF
                              set timeout 10
                              set le_node_rootpassword "$fixedRootPassword"
                              log_user 0
                              if { "$RAT_EXPECT_DEBUG" == "-d" } {   
                                exp_internal 1
                              } 
                              spawn -noecho $SSH -x -l $USR $host "/bin/sh -c \"  mkdir -p .ssh ; chmod og-w . .ssh;   touch .ssh/authorized_keys .ssh/known_hosts .ssh/config;  chmod 644 .ssh/authorized_keys  .ssh/known_hosts .ssh/config; mv  .ssh/authorized_keys .ssh/authorized_keys.tmp ;  mv .ssh/known_hosts .ssh/known_hosts.tmp; echo \\"Host *\\" > .ssh/config.tmp; echo \\"ForwardX11 no\\" >> .ssh/config.tmp; if test -f  .ssh/config ; then cp -f .ssh/config .ssh/config.backup; fi ; mv -f .ssh/config.tmp .ssh/config\";chmod 644 .ssh/config"
                              match_max 100000
                              expect {
      	     	                -nocase "permission denied *" {
	      	     		  exit 4;
      	     		 	}
                                -nocase "no)?" {
                                  send -- "yes\n"
                                }
                                -nocase "*?assword:*" {
                                  send -- "\$le_node_rootpassword\n" 
                                }
                                -nocase eof {
                                  exit 0
                                }
                              }
                              expect {
                                -nocase "*?assword:*" {
         	     		  send -- "\$le_node_rootpassword\n"
                                }
                                -nocase eof {
                                  exit 0
                                }
                              }
IBEOF
        else
          $SSH -x -l $USR $host "/bin/sh -c \"  mkdir -p .ssh ; chmod og-w . .ssh;   touch .ssh/authorized_keys .ssh/known_hosts .ssh/config;  chmod 644 .ssh/authorized_keys  .ssh/known_hosts .ssh/config; mv  .ssh/authorized_keys .ssh/authorized_keys.tmp ;  mv .ssh/known_hosts .ssh/known_hosts.tmp; echo \\"Host *\\" > .ssh/config.tmp; echo \\"ForwardX11 no\\" >> .ssh/config.tmp; if test -f  .ssh/config ; then cp -f .ssh/config .ssh/config.backup; fi ; mv -f .ssh/config.tmp .ssh/config\";chmod 644 .ssh/config" | tee -a $LOGFILE
        fi
        echo Done with creating .ssh directory and setting permissions on remote host $host.>> $LOGFILE
      done

      for host in $REMOTEHOSTS
      do
        #echo Copying local host public key to the remote host $host | tee -a $LOGFILE
        #echo The user may be prompted for a password or passphrase here since the script would be using SCP for host $host. | tee -a $LOGFILE
        if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
        then
          $EXPECT -f - << IBEOF
                              set timeout 100
      			      set le_node_rootpassword "$fixedRootPassword"
                              log_user 0
                              if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                exp_internal 1
                              }
                              spawn $SCOPY $HOME/.ssh/${IDENTITY}.pub  $USR@$host:.ssh/authorized_keys
                              match_max 100000
                              expect {
      			        -nocase "permission denied *" {
      				  exit 4;
      				}
                                -nocase "no)?" {
                                  send -- "yes\n"
                                }
                                -nocase "*?assword:*" {
      				  send -- "\$le_node_rootpassword\n"
                                }
                                -nocase eof {
                                  exit 0
                                }
                              }
                              expect {
                                -nocase "*?assword:*" {
      				  send -- "\$le_node_rootpassword\n"
                                }
                                -nocase eof {
                                  exit 0
                                }
                              }
IBEOF
        else
          scp $HOME/.ssh/${IDENTITY}.pub  $USR@$host:.ssh/authorized_keys | tee -a $LOGFILE
        fi
        echo Done copying local host public key to the remote host $host >> $LOGFILE
      done

      PUBLIC_KEY=$(cat $HOME/.ssh/${IDENTITY}.pub)
      if [[ `grep -ic "$PUBLIC_KEY" $HOME/.ssh/authorized_keys.tmp` -eq 0 ]]; then cat $HOME/.ssh/${IDENTITY}.pub >> $HOME/.ssh/authorized_keys | tee -a $LOGFILE; fi
      
      for host in $HOSTS
      do
        if [ $ADVANCED = "true" ] 
        then
          echo Creating keys on remote host $host if they do not exist already. This is required to setup SSH on host $host. >> $LOGFILE
          if [ $SHARED = "true" ]
          then
            IDENTITY_FILE_NAME=${IDENTITY}_$host
            COALESCE_IDENTITY_FILES_COMMAND="cat .ssh/${IDENTITY_FILE_NAME}.pub >> .ssh/authorized_keys"
          else
            IDENTITY_FILE_NAME=${IDENTITY}
          fi
      
          if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
          then
            $EXPECT -f - << IBEOF
                                 set timeout 10
      			         set le_node_rootpassword "$fixedRootPassword"
                                 log_user 0
                                 if { "$RAT_EXPECT_DEBUG" == "-d" } {   
                                   exp_internal 1
                                 }
                                 spawn -noecho $SSH  -x -l $USR $host " /bin/sh -c \"if test -f  .ssh/${IDENTITY_FILE_NAME}.pub && test -f  .ssh/${IDENTITY_FILE_NAME}; then echo; else rm -f .ssh/${IDENTITY_FILE_NAME} ;  rm -f .ssh/${IDENTITY_FILE_NAME}.pub ;  $SSH_KEYGEN -t $ENCR -b $BITS -f .ssh/${IDENTITY_FILE_NAME} -N '' ; fi; ${COALESCE_IDENTITY_FILES_COMMAND} \"" | tee -a $LOGFILE
                                 match_max 100000
                                 expect {
      			           -nocase "permission denied *" {
      				      exit 4;
      				    }
                                    -nocase "no)?" {
                                      send -- "yes\n"
                                    }
                                    -nocase "*?assword:*" {
      				      send -- "\$le_node_rootpassword\n"	
                                    }
                                    -nocase eof {
                                      exit 0
                                    }
                                 }
                                 expect {
                                    -nocase "*?assword:*" {
      				      send -- "\$le_node_rootpassword\n"
                                    }
                                    -nocase eof {
                                      exit 0
                                    }
                                 }
IBEOF
          else
            $SSH  -x -l $USR $host " /bin/sh -c \"if test -f  .ssh/${IDENTITY_FILE_NAME}.pub && test -f  .ssh/${IDENTITY_FILE_NAME}; then echo; else rm -f .ssh/${IDENTITY_FILE_NAME} ;  rm -f .ssh/${IDENTITY_FILE_NAME}.pub ;  $SSH_KEYGEN -t $ENCR -b $BITS -f .ssh/${IDENTITY_FILE_NAME} -N '' ; fi; ${COALESCE_IDENTITY_FILES_COMMAND} \"" | tee -a $LOGFILE
          fi
        else 
          #At least get the host keys from all hosts for shared case - advanced option not set
          if test  $SHARED = "true" && test $ADVANCED = "false"
          then
            if [ $PASSPHRASE = "yes" ]
            then
               echo "The script will fetch the host keys from all hosts. The user may be prompted for a passphrase here in case the private key has been encrypted with a passphrase." >>$LOGFILE
            fi

            if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
            then
              $EXPECT -f - << IBEOF
                                 set timeout 10
              		   	 set le_node_rootpassword "$fixedRootPassword"
                                 log_user 0
                                 if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                   exp_internal 1
                                 }
                                 spawn -noecho $SSH  -x -l $USR $host "/bin/sh -c true"
                                 match_max 100000
                                 expect {
              		     	   -nocase "permission denied *" {
              			      exit 4;
              			   }
                                   -nocase "no)?" {
                                      send -- "yes\n"
                                   }
                                   -nocase "*?assword:*" {
              			      send -- "\$le_node_rootpassword\n"
                                   }
                                   -nocase eof {
                                      exit 0
                                   }
                                 }
                                 expect {
                                   -nocase "*?assword:*" {
              			      send -- "\$le_node_rootpassword\n"
                                   }
                                   -nocase eof {
                                      exit 0
                                   }
                                }
IBEOF
            else
               $SSH  -x -l $USR $host "/bin/sh -c true"
            fi
          fi
        fi
      done

      for host in $REMOTEHOSTS
      do
        if test $ADVANCED = "true" && test $SHARED = "false"  
        then
          if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
          then
            $EXPECT -f - << IBEOF
                                set timeout 10
      	 			set le_node_rootpassword "$fixedRootPassword"
                                log_user 0
                                if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                  exp_internal 1
                                }   
                                spawn -noecho scp $USR@$host:.ssh/${IDENTITY}.pub $HOME/.ssh/${IDENTITY}.pub.$host | tee -a $LOGFILE
                                match_max 100000
                                expect {
				  -nocase "permission denied *" {
      	       		 	    exit 4;
      	       		 	  }
                                  -nocase "no)?" {
                                    send -- "yes\n"
                                  }
                                  -nocase "*?assword:*" {
				    send -- "\$le_node_rootpassword\n"
                                  }
                                  -nocase eof {
                                    exit 0
                                  }
                                expect {
                                  -nocase "*?assword:*" {
	       			    send -- "\$le_node_rootpassword\n"
                                  }
                                  -nocase eof {
                                    exit 0
                                  }
                                }
IBEOF
          else
            scp $USR@$host:.ssh/${IDENTITY}.pub $HOME/.ssh/${IDENTITY}.pub.$host | tee -a $LOGFILE
          fi
          cat $HOME/.ssh/${IDENTITY}.pub.$host >> $HOME/.ssh/authorized_keys | tee -a $LOGFILE
          rm -f $HOME/.ssh/${IDENTITY}.pub.$host | tee -a $LOGFILE
        fi
      done

      for host in $REMOTEHOSTS
      do
        if [ $ADVANCED = "true" ]
        then
          if [ $SHARED != "true" ]
          then
            echo Updating authorized_keys file on remote host $host >>$LOGFILE
            if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
            then
              $EXPECT -f - << IBEOF
                              set timeout 10
      	     	   	      set le_node_rootpassword "$fixedRootPassword"
                              log_user 0
                              if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                exp_internal 1
                              }
                              spawn -noecho scp $HOME/.ssh/authorized_keys  $USR@$host:.ssh/authorized_keys | tee -a $LOGFILE
                              match_max 100000
                              expect {
			       -nocase "permission denied *" {
      	     		         exit 4;
      	     		       }
                               -nocase "no)?" {
                                 send -- "yes\n"
                               }
                               -nocase "*?assword:*" {
      	     		 	 send -- "\$le_node_rootpassword\n"
                               }
                               -nocase eof {
                                 exit 0
                               }
                             }
                             expect {
                               -nocase "*?assword:*" {
      	     		 	 send -- "\$le_node_rootpassword\n"
                               }
                               -nocase eof {
                                 exit 0
                               }
                             }
IBEOF
            else
              scp $HOME/.ssh/authorized_keys  $USR@$host:.ssh/authorized_keys | tee -a $LOGFILE
            fi
          fi 

          echo Updating known_hosts file on remote host $host >>$LOGFILE
          if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
          then
            $EXPECT -f - << IBEOF
                                set timeout 10
             		        set le_node_rootpassword "$fixedRootPassword"
                                log_user 0
                                if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                  exp_internal 1	
                                }
                                spawn -noecho scp $HOME/.ssh/known_hosts $USR@$host:.ssh/known_hosts | tee -a $LOGFILE
                                match_max 100000
                                  expect {
             		            -nocase "permission denied *" {
             			      exit 4;
             			    }
                                    -nocase "no)?" {
                                      send -- "yes\n"
                                    }
                                    -nocase "*?assword:*" {
             			      send -- "\$le_node_rootpassword\n"
                                    }
                                    -nocase eof {
                                      exit 0
                                    }
                                  }
                                  expect {
                                    -nocase "*?assword:*" {
             			      send -- "\$le_node_rootpassword\n"
                                    }
                                    -nocase eof {
                                      exit 0
                                    }
                                  }
IBEOF
          else
            scp $HOME/.ssh/known_hosts $USR@$host:.ssh/known_hosts | tee -a $LOGFILE
          fi
        fi
        if [ $PASSPHRASE = "yes" ]
        then
          echo "The script will run SSH on the remote machine $host. The user may be prompted for a passphrase here in case the private key has been encrypted with a passphrase." >> $LOGFILE
        fi
        if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
        then
          $EXPECT -f - << IBEOF
                                set timeout 10
             		        set le_node_rootpassword "$fixedRootPassword"
                                log_user 0
                                if { "$RAT_EXPECT_DEBUG" == "-d" } {   
                                  exp_internal 1
                                }		
                                if { "$AutoLoginCheckYes" == "1" } {
                                  spawn -noecho $SSH -x -l $USR $host "/bin/sh -c \"cat .ssh/authorized_keys.tmp >> .ssh/authorized_keys; cat .ssh/known_hosts.tmp >> .ssh/known_hosts; rm -f  .ssh/known_hosts.tmp  .ssh/authorized_keys.tmp\"" | tee -a $LOGFILE
                                } else { 
                                  spawn -noecho $SSH -x -l $USR $host "/bin/sh -c \"cat .ssh/authorized_keys.tmp >> .ssh/authorized_keys; cat .ssh/known_hosts.tmp >> .ssh/known_hosts\"" | tee -a $LOGFILE
                                }
                                match_max 100000
                                expect {
             		          -nocase "permission denied *" {
             			    exit 4;
             			  }
                                  -nocase "no)?" {
                                    send -- "yes\n"
                                  }
                                  -nocase "*?assword:*" {
             			    send -- "\$le_node_rootpassword\n"
                                  }
                                  -nocase eof {
                                    exit 0
                                  }
                                }
                                expect {
                                  -nocase "*?assword:*" {
             			    send -- "\$le_node_rootpassword\n"
                                  }
                                  -nocase eof {
                                    exit 0
                                  }
                               }
IBEOF
        else
          if [[ -n "$AutoLoginCheckYes" && $AutoLoginCheckYes -eq 1 ]]            
          then  
              $SSH -x -l $USR $host "/bin/sh -c \"cat .ssh/authorized_keys.tmp >> .ssh/authorized_keys; cat .ssh/known_hosts.tmp >> .ssh/known_hosts; rm -f  .ssh/known_hosts.tmp  .ssh/authorized_keys.tmp\"" | tee -a $LOGFILE
          else   
              $SSH -x -l $USR $host "/bin/sh -c \"cat .ssh/authorized_keys.tmp >> .ssh/authorized_keys; cat .ssh/known_hosts.tmp >> .ssh/known_hosts\"" | tee -a $LOGFILE
          fi
        fi
      done

      if [ -f $HOME/.ssh/known_hosts.tmp ]
      then
          cat  $HOME/.ssh/known_hosts.tmp >> $HOME/.ssh/known_hosts | tee -a $LOGFILE
      fi
      if [ $HOME/.ssh/authorized_keys.tmp ]
      then
          cat  $HOME/.ssh/authorized_keys.tmp >> $HOME/.ssh/authorized_keys | tee -a $LOGFILE
      fi
      #Added chmod to fix BUG NO 5238814
      chmod 644 $HOME/.ssh/authorized_keys
      chmod 644 $HOME/.ssh/config
      rm -f  $HOME/.ssh/known_hosts.tmp $HOME/.ssh/authorized_keys.tmp | tee -a $LOGFILE
      echo SSH setup is complete. >> $LOGFILE
    fi
  fi
  #echo                                                                          | tee -a $LOGFILE
  #echo ------------------------------------------------------------------------ | tee -a $LOGFILE
  #echo Verifying SSH setup | tee -a $LOGFILE
  #echo =================== | tee -a $LOGFILE
  #echo The script will now run the 'date' command on the remote nodes using ssh | tee -a $LOGFILE
  #echo to verify if ssh is setup correctly. IF THE SETUP IS CORRECTLY SETUP,  | tee -a $LOGFILE
  #echo THERE SHOULD BE NO OUTPUT OTHER THAN THE DATE AND SSH SHOULD NOT ASK FOR | tee -a $LOGFILE
  #echo PASSWORDS. If you see any output other than date or are prompted for the | tee -a $LOGFILE
  #echo password, ssh is not setup correctly and you will need to resolve the  | tee -a $LOGFILE
  #echo issue and set up ssh again. | tee -a $LOGFILE
  #echo The possible causes for failure could be:  | tee -a $LOGFILE
  #echo   1. The server settings in /etc/ssh/sshd_config file do not allow ssh | tee -a $LOGFILE
  #echo      for user $USR. | tee -a $LOGFILE
  #echo   2. The server may have disabled public key based authentication.
  #echo   3. The client public key on the server may be outdated.
  #echo   4. ~$USR or  ~$USR/.ssh on the remote host may not be owned by $USR.  | tee -a $LOGFILE
  #echo   5. User may not have passed -shared option for shared remote users or | tee -a $LOGFILE
  #echo     may be passing the -shared option for non-shared remote users.  | tee -a $LOGFILE
  #echo   6. If there is output in addition to the date, but no password is asked, | tee -a $LOGFILE
  #echo   it may be a security alert shown as part of company policy. Append the | tee -a $LOGFILE
  #echo   "additional text to the <OMS HOME>/sysman/prov/resources/ignoreMessages.txt file." | tee -a $LOGFILE
  #echo ------------------------------------------------------------------------ | tee -a $LOGFILE
  #$READ -t 30 dummy
  for host in $HOSTS
  do
    #echo --$host:-- | tee -a $LOGFILE
    #echo Running $SSH -x -l $USR $host date to verify SSH connectivity has been setup from local host to $host.  | tee -a $LOGFILE
    #echo "IF YOU SEE ANY OTHER OUTPUT BESIDES THE OUTPUT OF THE DATE COMMAND OR IF YOU ARE PROMPTED FOR A PASSWORD HERE, IT MEANS SSH SETUP HAS NOT BEEN SUCCESSFUL. Please note that being prompted for a passphrase may be OK but being prompted for a password is ERROR." | tee -a $LOGFILE
    if [ $PASSPHRASE = "yes" ]
    then
      echo "The script will run SSH on the remote machine $host. The user may be prompted for a passphrase here in case the private key has been encrypted with a passphrase." | tee -a $LOGFILE
    fi
    #$SSH -l $USR $host "/bin/sh -c date"  | tee -a $LOGFILE
    echo ------------------------------------------------------------------------ >> $LOGFILE
  done

  if [ $EXHAUSTIVE_VERIFY = "true" ]
  then
    for clienthost in $HOSTS
    do
      if [ $SHARED = "true" ]
      then
        REMOTESSH="$SSH -i .ssh/${IDENTITY}_${clienthost}"
      else
        REMOTESSH=$SSH
      fi
  
      for serverhost in  $HOSTS
      do
        echo ------------------------------------------------------------------------ >> $LOGFILE
        echo Verifying SSH connectivity has been setup from $clienthost to $serverhost  | tee -a $LOGFILE
        echo ------------------------------------------------------------------------ | tee -a $LOGFILE
        $SSH -l $USR $clienthost "$REMOTESSH $serverhost \"/bin/sh -c date\""  | tee -a $LOGFILE
        echo ------------------------------------------------------------------------ >> $LOGFILE
      done  
      echo -Verification from $clienthost complete- | tee -a $LOGFILE
    done
  else
    if [ $ADVANCED = "true" ]
    then
      if [ $SHARED = "true" ]
      then
        REMOTESSH="$SSH -i .ssh/${IDENTITY}_${firsthost}"
      else
        REMOTESSH=$SSH
      fi
      for host in $HOSTS
      do
        echo ------------------------------------------------------------------------ >>$LOGFILE
        echo Verifying SSH connectivity has been setup from $firsthost to $host  | tee -a $LOGFILE
        $SSH -l $USR $firsthost "$REMOTESSH $host /bin/sh -c date" | tee -a $LOGFILE
        echo ------------------------------------------------------------------------ >> $LOGFILE
      done
      echo -Verification from $clienthost complete- | tee -a $LOGFILE
    fi
  fi
  echo "SSH verification complete." >>$LOGFILE
  printf ". "
}
#End - fun_setup_ssh

generate_result_xml ()
{
  insert_stmt_printed=0
  target="$i"
  ACT_TARGET="$i"
  P_TARGET_TYPE=$TARGET_TYPE

  #code to write xml for em plug-in starts here
  status_on_target="";
  check_execution_time=$(date '+%Y-%m-%d %H:%M:%S %Z')

  echo "   <${xml_prefix1}Result executionTimestamp=\"$check_execution_time\">" >> $XMLREPFIL
  if [ $COMTYPE = "CLUSTERWIDE_CHECK" ]
  then
    echo "     <CheckID>${crs_check_id[$crs_check_file_counter]}</CheckID>" >>$XMLREPFIL
  else
    echo "     <CheckID>$CHECK_ID</CheckID>" >>$XMLREPFIL
  fi

  if [[ -n $COL_COMTYPE && $COL_COMTYPE = 'CROSS_NODE_CHECK' ]]; then OLD_COMTYPE=$COMTYPE; COMTYPE='CROSS_NODE_CHECK'; fi

  echo "     <CheckType>$COMTYPE</CheckType>" >>$XMLREPFIL 
  echo "     <AlertType>$ALVL_CHECK</AlertType>" >>$XMLREPFIL 

  #if [[ "$COMTYPE" = "SQL_PARAM" || "$COMTYPE" = "SQL" ]]
  #then
  #  echo "     <TargetType>RDBMS</TargetType>" >>$XMLREPFIL 
  ##elif [[ "$COMTYPE" = "CLUSTERWIDE_CHECK" || "$COMTYPE" = "SYSTEMWIDE_CHECK" ]]
  ##then
  ##  echo "     <TargetType>CLUSTER</TargetType>" >>$XMLREPFIL
  #elif [[ "$COMTYPE" = "OS_PACKAGE" || "$COMTYPE" = "OS_PATCH" || "$COMTYPE" = "OS_PARAM" ]]
  #then
  #  echo "     <TargetType>UNSPECIFIED</TargetType>" >>$XMLREPFIL 
  #elif [[ "$COMTYPE" = "ORACLE_PATCH" ]]
  #then
  #  echo "     <TargetType>ORACLE_HOME</TargetType>" >>$XMLREPFIL
  #else
  #  echo "     <TargetType>$NEEDS_RUNNING</TargetType>" >>$XMLREPFIL 
  #fi
  echo "     <TargetType>$TARGET_TYPE</TargetType>" >>$XMLREPFIL

  echo "     <Status>$1</Status>" >>$XMLREPFIL 

  if [[ -n "$SOURCEFIL" && -e $SOURCEFIL ]] && [[ $COMTYPE != "OS" && $COMTYPE != "SQL" && $COMTYPE != "CLUSTERWIDE_CHECK" ]]
  then
    SOURCEFIL4XML=$(basename $SOURCEFIL)               
    echo "     <OutfilePath>$SOURCEFIL4XML</OutfilePath>" >>$XMLREPFIL               
  fi

  echo "     <ColumnValues>" >>$XMLREPFIL               

  #if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
  #then 
  #  cellname_counter=0
  #  for cellname in ${a_cellname[@]}
  #  do
  #    echo "       <ColumnValue Name=\"NodeName\" value=\"$cellname\" status=\"${a_cellCheckStatus[$cellname_counter]}\"/>" >>$XMLREPFIL
  #    #echo "       <ColumnValue Name=\"CellCheckStatus\" value=\"${a_cellCheckStatus[$cellname_counter]}\"/>" >>$XMLREPFIL
  #    cellname_counter=$(expr $cellname_counter + 1 )
  #  done
  #  #for cellCheckStatus in ${a_cellCheckStatus[@]}
  #  #do
  #  #   echo "       <ColumnValue Name=\"CellCheckStatus\" value=\"$cellCheckStatus\">" >>$XMLREPFIL
  #  #done
  #elif [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH" ]]
  #then
  #  echo "       <ColumnValue Name=\"NodeName\" value=\"$switchname\"/>" >>$XMLREPFIL
  #elif [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS_PACKAGE" || $COMTYPE = "OS_PATCH" ]]
  #then
  #  echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
  #elif [[ $COMTYPE = "OS_PARAM" ]]
  #then
  #  echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
  #  if [ -n "$PARAM_NAME" ] ; then p_name=$PARAM_NAME; else p_name=$PARAM_PATH; fi
  #  echo "       <ColumnValue Name=\"ParamName\" value=\"$p_name\"/>" >>$XMLREPFIL
  #elif [ $COMTYPE = "OS" ]
  #then
  #  if [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "RDBMS" ]]
  #  then
  #    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
  #    echo "       <ColumnValue Name=\"DBName\" value=\"$db_name_to_check\"/>" >>$XMLREPFIL
  #  elif [[ -n "$multiple_oracle_homes" && $multiple_oracle_homes -gt 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && -n "$ulimit_cmd" && $ulimit_cmd -eq 0 ]]
  #  then
  #    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
  #    echo "       <ColumnValue Name=\"DBHome\" value=\"${mb_db_homes_without_slash}\"/>" >>$XMLREPFIL
  #  else
  #    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
  #  fi 
  #elif [[ $COMTYPE = "SQL" || $COMTYPE = "SQL_OUT_CHECK" ]]
  #then
  #  echo "       <ColumnValue Name=\"DBName\" value=\"$db_name_to_check\"/>" >>$XMLREPFIL
  #elif [[ $COMTYPE = "SQL_PARAM" ]]
  #then
  #  echo "       <ColumnValue Name=\"DBName\" value=\"$db_name_to_check\"/>" >>$XMLREPFIL
  #  echo "       <ColumnValue Name=\"InstanceName\" value=\"$inst_name\"/>" >>$XMLREPFIL
  #  echo "       <ColumnValue Name=\"InitORAParameterName\" value=\"$PARAM_PATH\"/>" >>$XMLREPFIL
  #  status_on_target="$inst_name";
  #elif [ $COMTYPE = "CLUSTERWIDE_CHECK" ]
  #then
  #  echo "       <ColumnValue Name=\"NodeName\" value=\"CLUSTERWIDE_CHECK\"/>" >>$XMLREPFIL
  #elif [ $COMTYPE = "ORACLE_PATCH" ]
  #then
  #  echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
  #  if [[ $HOME_PATH = "RDBMS" ]]
  #  then
  #    echo "       <ColumnValue Name=\"DBHome\" value=\"${mb_db_homes}\"/>" >>$XMLREPFIL
  #  else
  #    echo "       <ColumnValue Name=\"DBHome\" value=\"$message4Home\"/>" >>$XMLREPFIL
  #  fi
  #else
  #  echo "       <ColumnValue Name=\"NodeName\" value=\"what_to_write\"/>" >>$XMLREPFIL
  #fi
  if [[ $TARGET_TYPE = 'RDBMS' || $TARGET_TYPE = 'ASM' ]] && [[ $COMTYPE = 'SQL_PARAM' ]] ; then
    echo "       <ColumnValue Name=\"DBName\" value=\"$db_name_to_check\"/>" >>$XMLREPFIL
    echo "       <ColumnValue Name=\"InstanceName\" value=\"$inst_name\"/>" >>$XMLREPFIL
    echo "       <ColumnValue Name=\"InitORAParameterName\" value=\"$PARAM_PATH\"/>" >>$XMLREPFIL
  
  elif [[ $TARGET_TYPE = 'RDBMS' && $COMTYPE = 'OS' ]] ; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
    echo "       <ColumnValue Name=\"InstanceName\" value=\"$inst_name\"/>" >>$XMLREPFIL
       
  elif [[ $TARGET_TYPE = 'ASM' && $COMTYPE = 'OS' ]] ; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
    echo "       <ColumnValue Name=\"InstanceName\" value=\"$inst_name\"/>" >>$XMLREPFIL

  elif [[ $TARGET_TYPE = 'RDBMS' && $COMTYPE = 'CROSS_NODE_CHECK' ]] ; then
    echo "       <ColumnValue Name=\"DBName\" value=\"$db_name_to_check\"/>" >>$XMLREPFIL
   
  elif [[ $TARGET_TYPE = 'ASM' && $COMTYPE = 'CROSS_NODE_CHECK' ]] ; then
    echo "       <ColumnValue Name=\"ASMName\" value=\"$db_name_to_check\"/>" >>$XMLREPFIL       

  elif [[ $TARGET_TYPE = 'RDBMS' ]] && [[ $COMTYPE = 'SQL' || $COMTYPE = 'SQL_OUT_CHECK' ]] ; then
    echo "       <ColumnValue Name=\"DBName\" value=\"$db_name_to_check\"/>" >>$XMLREPFIL
       
  elif [[ $TARGET_TYPE = 'RDBMS_HOME' && $COMTYPE = 'OS' ]] ; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
    echo "       <ColumnValue Name=\"HomePath\" value=\"${mb_db_homes}\"/>" >>$XMLREPFIL
       
  elif [[ $TARGET_TYPE = 'TIMESTEN_HOME' && $COMTYPE = 'OS' ]] ; then
    ACT_TARGET=${mb_db_homes}
    target="${mb_db_homes}"
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
    echo "       <ColumnValue Name=\"HomePath\" value=\"${mb_db_homes}\"/>" >>$XMLREPFIL
       
  elif [[ $TARGET_TYPE = 'GOLDENGATE_HOME' && $COMTYPE = 'OS' ]] ; then
    ACT_TARGET=${mb_ogg_home}
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
    echo "       <ColumnValue Name=\"HomePath\" value=\"${mb_ogg_home}\"/>" >>$XMLREPFIL

  elif [[ $TARGET_TYPE = 'CLUSTER' && $COMTYPE = 'CLUSTERWIDE_CHECK' ]] ; then
    result_xml_entry=0 

  elif [[ $TARGET_TYPE = 'CRS' || $TARGET_TYPE = 'CRS_HOME' ]] && [[ $COMTYPE = 'OS' ]] ; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
     
  elif [[ $TARGET_TYPE = 'STORAGE_CELL' && $COMTYPE = 'OS' ]] && [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] ; then
    cellname_counter=0
    insert_stmt_printed=1
    for cellname in ${a_cellname[@]}
    do
      echo "       <ColumnValue Name=\"NodeName\" value=\"$cellname\" status=\"${a_cellCheckStatus[$cellname_counter]}\"/>" >>$XMLREPFIL
      cellname_counter=$(expr $cellname_counter + 1 )
    done
  elif [[ $TARGET_TYPE = 'STORAGE_CELL' && $COMTYPE = 'OS_OUT_CHECK' ]] && [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] ; then
    cellname_counter=0
    insert_stmt_printed=1
    for cellname in ${a_cellname[@]}
    do
      echo "       <ColumnValue Name=\"NodeName\" value=\"$cellname\" status=\"${a_cellCheckStatus[$cellname_counter]}\"/>" >>$XMLREPFIL
      cellname_counter=$(expr $cellname_counter + 1 )
    done
  elif [[ $TARGET_TYPE = 'SPINE_SWITCH' || $TARGET_TYPE = 'SWITCH' ]] && [[ $COMTYPE = 'OS_OUT_CHECK' || $COMTYPE = 'CROSS_NODE_CHECK' ]] ; then
    target="$switchname"
    ACT_TARGET="$switchname"
    echo "       <ColumnValue Name=\"NodeName\" value=\"$switchname\"/>" >>$XMLREPFIL
  elif [[ $TARGET_TYPE = 'BI_INSTANCE' && $COMTYPE = 'OS' ]] ; then
    target="$bi_instance"
    ACT_TARGET="$bi_instance"
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
    echo "       <ColumnValue Name=\"WeblogicDomainName\" value=\"${mb_db_homes}\"/>" >>$XMLREPFIL
    echo "       <ColumnValue Name=\"InstanceName\" value=\"$bi_instance\"/>" >>$XMLREPFIL
   
  else
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL

  fi;

  echo "     </ColumnValues>" >>$XMLREPFIL               
  echo "   </${xml_prefix1}Result>" >> $XMLREPFIL

  if [[ -n $COL_COMTYPE && $COL_COMTYPE = 'CROSS_NODE_CHECK' ]]; then COMTYPE=$OLD_COMTYPE; fi

  #Merge Changes..
  #if [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]] ; then
    echo "$CHECK_ID|$cch_status|$COMTYPE|$status_on_target|$db_name_to_check|$inst_name|$mb_db_homes|$message4Home|$cch_cname|$g_hosts" >> $OUTPUTDIR/slave_results_${localnode}.out
  #fi
  #code to write xml for em plug-in ends here

  if [[ $TARGET_TYPE = 'RDBMS_HOME' ]];
  then
    ACT_TARGET=${mb_db_homes}
  elif [[ $TARGET_TYPE = 'CRS' || $TARGET_TYPE = 'CRS_HOME' || $TARGET_TYPE = 'ASM_HOME' ]];
  then
    if [[ $TARGET_TYPE = 'CRS' ]]; then P_TARGET_TYPE='CRS_HOME'; fi
    ACT_TARGET="$CRS"
  elif [[ $TARGET_TYPE = 'ASM' ]];
  then
    ACT_TARGET=$inst_name
  elif [[ $TARGET_TYPE = 'RDBMS' ]]; 
  then
    if [[ $COMTYPE = 'OS' || $COMTYPE = 'SQL_PARAM' ]]; 
    then
      P_TARGET_TYPE='RDBMS_INSTANCE'
      ACT_TARGET=$inst_name
    else
      ACT_TARGET=$db_name_to_check
    fi
  fi

  print_audit_check_name=$audit_check_name;
  if [[ -z "$audit_check_name" || "$audit_check_name" = "" ]]; then 
    print_audit_check_name=$PARAM_PATH 
  fi
}

generate_exceptions_xml ()
{
  echo "   <${xml_prefix1}Exclusion>" >> $XMLSKIPFIL
  if [ $COMTYPE = "CLUSTERWIDE_CHECK" ]
  then
    echo "     <CheckID>${crs_check_id[$crs_check_file_counter]}</CheckID>" >>$XMLSKIPFIL
  else
    echo "     <CheckID>$CHECK_ID</CheckID>" >>$XMLSKIPFIL
  fi

  if [[ -n $COL_COMTYPE && $COL_COMTYPE = 'CROSS_NODE_CHECK' ]]; then OLD_COMTYPE=$COMTYPE; COMTYPE='CROSS_NODE_CHECK'; fi

  echo "     <CheckType>$COMTYPE</CheckType>" >>$XMLSKIPFIL
  echo "     <AlertType>$ALVL_CHECK</AlertType>" >>$XMLSKIPFIL

  #if [[ "$COMTYPE" = "SQL_PARAM" || "$COMTYPE" = "SQL" ]]
  #then
  #  echo "     <TargetType>RDBMS</TargetType>" >>$XMLSKIPFIL
  ##elif [[ "$COMTYPE" = "CLUSTERWIDE_CHECK" || "$COMTYPE" = "SYSTEMWIDE_CHECK" ]]
  ##then
  ##  echo "     <TargetType>CLUSTER</TargetType>" >>$XMLSKIPFIL
  #elif [[ "$COMTYPE" = "OS_PACKAGE" || "$COMTYPE" = "OS_PATCH" || "$COMTYPE" = "OS_PARAM" ]]
  #then
  #  echo "     <TargetType>UNSPECIFIED</TargetType>" >>$XMLSKIPFIL
  #elif [[ "$COMTYPE" = "ORACLE_PATCH" ]]
  #then
  #  echo "     <TargetType>ORACLE_HOME</TargetType>" >>$XMLREPFIL
  #else
  #  echo "     <TargetType>$NEEDS_RUNNING</TargetType>" >>$XMLSKIPFIL
  #fi
  echo "     <TargetType>$TARGET_TYPE</TargetType>" >>$XMLSKIPFIL

  if [[ $COMTYPE = "OS_PARAM" || $COMTYPE = "OS_PACKAGE" || $COMTYPE = "OS_PATCH" || $COMTYPE = "SQL_PARAM" ]]
  then
    echo "     <CheckName><![CDATA[$PARAM_NAME]]></CheckName>" >>$XMLSKIPFIL
  else
    echo "     <CheckName><![CDATA[$(echo $audit_check_name|sed 's/\[DBMV2]//g' |sed 's/</less than/g' | sed 's/>/greater than/g')]]></CheckName>" >>$XMLSKIPFIL
  fi

  if [[ $COMTYPE != "OS" && $COMTYPE != "SQL" && $COMTYPE != "CLUSTERWIDE_CHECK" ]]
  then
    if [ -e $SOURCEFIL ]; then SOURCEFIL4XML=$(basename $SOURCEFIL 2>/dev/null);fi               
    echo "     <OutfilePath>$SOURCEFIL4XML</OutfilePath>" >>$XMLSKIPFIL               
  fi    

  echo "     <ColumnValues>" >>$XMLSKIPFIL 
  #if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
  #then 
  #  echo "       <ColumnValue Name=\"NodeName\" value=\"$cellname\"/>" >>$XMLSKIPFIL       
  #elif [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH" ]]
  #then
  #  echo "       <ColumnValue Name=\"NodeName\" value=\"$switchname\"/>" >>$XMLSKIPFIL
  #elif [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" || $COMTYPE = "OS_PARAM" || $COMTYPE = "OS_PACKAGE" || $COMTYPE = "OS_PATCH" ]]
  #then
  #  echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLSKIPFIL
  #elif [[ $COMTYPE = "OS_PARAM" ]]
  #then
  #  echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLSKIPFIL
  #  if [ -n "$PARAM_NAME" ] ; then p_name=$PARAM_NAME; else p_name=$PARAM_PATH; fi
  #  echo "       <ColumnValue Name=\"ParamName\" value=\"$p_name\"/>" >>$XMLSKIPFIL
  #elif [[ $COMTYPE = "SQL" || $COMTYPE = "SQL_OUT_CHECK" ]]
  #then
  #  echo "       <ColumnValue Name=\"DBName\" value=\"$db_name_to_check\"/>" >>$XMLSKIPFIL
  #elif [[ $COMTYPE = "SQL_PARAM" ]]
  #then
  #  echo "       <ColumnValue Name=\"DBName\" value=\"$db_name_to_check\"/>" >>$XMLSKIPFIL
  #  echo "       <ColumnValue Name=\"InstanceName\" value=\"$inst_name\"/>" >>$XMLSKIPFIL
  #  echo "       <ColumnValue Name=\"InitORAParameterName\" value=\"$PARAM_PATH\"/>" >>$XMLSKIPFIL
  #elif [ $COMTYPE = "CLUSTERWIDE_CHECK" ]
  #then
  #  echo "       <ColumnValue Name=\"NodeName\" value=\"CLUSTERWIDE_CHECK\"/>" >>$XMLSKIPFIL
  #elif [ $COMTYPE = "ORACLE_PATCH" ]
  #then
  #  echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
  #  if [[ $HOME_PATH = "RDBMS" ]]
  #  then
  #    echo "       <ColumnValue Name=\"DBHome\" value=\"${mb_db_homes}\"/>" >>$XMLREPFIL
  #  else
  #    echo "       <ColumnValue Name=\"DBHome\" value=\"$message4Home\"/>" >>$XMLREPFIL
  #  fi
  #else
  #  echo "       <ColumnValue Name=\"NodeName\" value=\"what_to_write\"/>" >>$XMLSKIPFIL
  #fi    
  if [[ $TARGET_TYPE = 'RDBMS' || $TARGET_TYPE = 'ASM' ]] && [[ $COMTYPE = 'SQL_PARAM' ]] ; then
    echo "       <ColumnValue Name=\"DBName\" value=\"$db_name_to_check\"/>" >>$XMLSKIPFIL
    echo "       <ColumnValue Name=\"InstanceName\" value=\"$inst_name\"/>" >>$XMLSKIPFIL
    echo "       <ColumnValue Name=\"InitORAParameterName\" value=\"$PARAM_PATH\"/>" >>$XMLSKIPFIL

  elif [[ $TARGET_TYPE = 'RDBMS' && $COMTYPE = 'OS' ]] ; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLSKIPFIL
    echo "       <ColumnValue Name=\"InstanceName\" value=\"$inst_name\"/>" >>$XMLSKIPFIL

  elif [[ $TARGET_TYPE = 'ASM' && $COMTYPE = 'OS' ]] ; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLSKIPFIL
    echo "       <ColumnValue Name=\"InstanceName\" value=\"$inst_name\"/>" >>$XMLSKIPFIL

  elif [[ $TARGET_TYPE = 'RDBMS' && $COMTYPE = 'CROSS_NODE_CHECK' ]] ; then
    echo "       <ColumnValue Name=\"DBName\" value=\"$db_name_to_check\"/>" >>$XMLSKIPFIL
   
  elif [[ $TARGET_TYPE = 'ASM' && $COMTYPE = 'CROSS_NODE_CHECK' ]] ; then
    echo "       <ColumnValue Name=\"ASMName\" value=\"$db_name_to_check\"/>" >>$XMLSKIPFIL
       
  elif [[ $TARGET_TYPE = 'RDBMS' ]] && [[ $COMTYPE = 'SQL' || $COMTYPE = 'SQL_OUT_CHECK' ]] ; then
    echo "       <ColumnValue Name=\"DBName\" value=\"$db_name_to_check\"/>" >>$XMLSKIPFIL
       
  elif [[ $TARGET_TYPE = 'RDBMS_HOME' && $COMTYPE = 'OS' ]] ; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLSKIPFIL
    echo "       <ColumnValue Name=\"HomePath\" value=\"${mb_db_homes}\"/>" >>$XMLSKIPFIL
       
  elif [[ $TARGET_TYPE = 'TIMESTEN_HOME' && $COMTYPE = 'OS' ]] ; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLSKIPFIL
    echo "       <ColumnValue Name=\"HomePath\" value=\"${mb_db_homes}\"/>" >>$XMLSKIPFIL
       
  elif [[ $TARGET_TYPE = 'GOLDENGATE_HOME' && $COMTYPE = 'OS' ]] ; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLSKIPFIL
    echo "       <ColumnValue Name=\"HomePath\" value=\"${mb_ogg_home}\"/>" >>$XMLSKIPFIL
       
  elif [[ $TARGET_TYPE = 'CLUSTER' && $COMTYPE = 'CLUSTERWIDE_CHECK' ]] ; then
    exception_xml_entry=0 

  elif [[ $TARGET_TYPE = 'CRS' || $TARGET_TYPE = 'CRS_HOME' ]] && [[ $COMTYPE = 'OS' ]] ; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLSKIPFIL
       
  elif [[ $TARGET_TYPE = 'STORAGE_CELL' && $COMTYPE = 'OS' ]] && [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] ; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLSKIPFIL
       
  elif [[ $TARGET_TYPE = 'STORAGE_CELL' && $COMTYPE = 'OS_OUT_CHECK' ]] && [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] ; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$cellname\"/>" >>$XMLSKIPFIL
       
  elif [[ $TARGET_TYPE = 'SPINE_SWITCH' || $TARGET_TYPE = 'SWITCH' ]] && [[ $COMTYPE = 'OS_OUT_CHECK' || $COMTYPE = 'CROSS_NODE_CHECK' ]] ; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$switchname\"/>" >>$XMLSKIPFIL
       
  elif [[ $TARGET_TYPE = 'BI_INSTANCE' && $COMTYPE = 'OS' ]] ; then
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLSKIPFIL
    echo "       <ColumnValue Name=\"WeblogicDomainName\" value=\"${mb_db_homes}\"/>" >>$XMLSKIPFIL
    echo "       <ColumnValue Name=\"InstanceName\" value=\"$bi_instance\"/>" >>$XMLSKIPFIL
       
  else
    echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLSKIPFIL

  fi;

  echo "     </ColumnValues>" >>$XMLSKIPFIL               
  echo "     <Message><![CDATA[$1]]></Message>" >>$XMLSKIPFIL               
  echo "   </${xml_prefix1}Exclusion>" >> $XMLSKIPFIL

  if [[ -n $COL_COMTYPE && $COL_COMTYPE = 'CROSS_NODE_CHECK' ]]; then COMTYPE=$OLD_COMTYPE; fi

}

log_pass ()
{
  if [ $OFFLINE -eq "0" ]; then 
    get_current_epoch 
    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $pval] Check:log_pass Start Time: $epoch_time" >> $CHK_TIMINGS
  fi

  #if we're in SILENT mode then all we want to suppress some of this logging
  #BUT not all of the logging which we may need for debugging purposes
  #pass/fail is not a concept fo rSILENT mode
  #$READ -p "calling log pass"
  #echo "row=$ROW COMTYPE=$COMTYPE command=$COM PARAM_PATH=$PARAM_PATH ISBRANCH=$ISBRANCH REQUIRES_ROOT_OS=$REQUIRES_ROOT_OS NEEDS_RUNNING=$NEEDS_RUNNING execute once=$execute_once"	
  case $COMTYPE in

  OS_COLLECT)
    echo "------------------------------" >>$LOGFIL 
    #echo "------------------------------" >>$REPFIL
    echo "  SEE OS OUTPUT FILE $OUTFIL" >>$LOGFIL
    #echo "  SEE OS OUTPUT FILE $OUTFIL" >>$REPFIL
    echo "------------------------------" >>$LOGFIL
    #echo "------------------------------" >>$REPFIL
    echo "" >>$LOGFIL
    #echo "" >>$REPFIL
    ;;
  SQL_COLLECT)
    echo "------------------------------" >>$LOGFIL
    #echo "------------------------------" >>$REPFIL
    echo "  SEE SQL OUTPUT FILE $OUTFIL" >>$LOGFIL
    #echo "  SEE SQL OUTPUT FILE $OUTFIL" >>$REPFIL
    echo "------------------------------" >>$LOGFIL
    #echo "------------------------------" >>$REPFIL
    echo "" >>$LOGFIL
    #echo "" >>$REPFIL
    ;;
  #CLUSTERWIDE_CHECK)
  #   echo "it called the right fuction"
  #  ;;
  *)
    if [[ $ISBRANCH -eq "1" && $SILENT -eq "0" ]]
    then
      echo "BRANCH CONDITION TRUE" >>$LOGFIL
      echo "---------------------------------------------" >>$LOGFIL
    else
      #gadiga.. added for SHS
      if [[ $OFFLINE -eq 0 ]]; 
      then
        cell_ib_fail_count=$(grep 'FAIL' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
        cell_ib_warn_count=$(grep 'WARN' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
        cell_ib_info_count=$(grep 'INFO' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
        cell_ib_total_count=$(grep 'TOTAL' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
      fi

      if [[ "$COMTYPE" = "OS_OUT_CHECK" && "$NEEDS_RUNNING" = "STORAGE_CELL" ]]
      then
        let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+$outcheck_cell_counter;
        validate_needs_running;
        cell_ib_total_count=$(expr $cell_ib_total_count + $outcheck_cell_counter);
         
        if [[ $OFFLINE -eq 0 ]];
      	then
          echo "FAIL = $cell_ib_fail_count" >> $CELLIBNTFILE.new
          echo "WARN = $cell_ib_warn_count" >> $CELLIBNTFILE.new
          echo "INFO = $cell_ib_info_count" >> $CELLIBNTFILE.new
          echo "TOTAL = $cell_ib_total_count" >> $CELLIBNTFILE.new

          rm -f $CELLIBNTFILE 2>/dev/null
          mv -f $CELLIBNTFILE.new $CELLIBNTFILE 2>/dev/null         
        fi
      else
        let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1;
        validate_needs_running
      fi
      outcheck_cell_counter=0   
      if [ $SILENT -eq "0" ]
      then     
        echo "" >>$LOGFIL 
        #if [ "$ALVL" != "INFO" ]
        #then
        #    ACREPCOUNT=`expr $ACREPCOUNT + 1`
        #fi
        #echo "------------------------------" >>$LOGFIL
        echo  "PASS =>  $PMSG" >>$LOGFIL
        #echo "------------------------------" >>$LOGFIL
        echo "" >>$LOGFIL
        #Commented this if condition on Oct 02 to print info pass messages in all reports
        #if [[ -n $ALVL && $ALVL != "INFO" ]]
        #then 
        if [  $COMTYPE = "CLUSTERWIDE_CHECK" ]
        then
          echo "" >>$CWCREPFIL_PASS
          echo  "Check:- PASS => $PMSG" >>$CWCREPFIL_PASS
          echo  "Check:- PASS => $PMSG" >>$SCWCREPFIL_PASS
        else
          if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
          then
            echo "" >>$CELLREPFIL_PASS
            echo "Check:- PASS => $PMSG" >>$CELLREPFIL_PASS
            echo "Check:- PASS => $PMSG" >>$CELLSREPFIL_PASS
          elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
          then
            echo "" >>$IBREPFIL_PASS
            echo "Check:- PASS => $PMSG" >>$IBREPFIL_PASS
            echo "Check:- PASS => $PMSG" >>$IBSREPFIL_PASS
          else
            echo "" >>$REPFIL_PASS
            echo "Check:- PASS => $PMSG" >>$REPFIL_PASS
            echo "Check:- PASS => $PMSG" >>$SREPFIL_PASS
          fi
        fi
        if [[ $COMTYPE != "OS_PACKAGE" && -n "$db_machine_compute" && $db_machine_compute -eq 0 ]]
        then
          if [[  $COMTYPE = "CLUSTERWIDE_CHECK"  ]]
          then
            echo -e "Success factor name = $SF \n">>$CWCREPFIL_PASS
          else
            if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
            then
              echo -e "Success factor name = $SF \n">>$CELLREPFIL_PASS
            elif [[ $COMTYPE = "OS_OUT_CHECK"  ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
            then
              echo -e "Success factor name = $SF \n">>$IBREPFIL_PASS
            else
              echo -e "Success factor name = $SF \n">>$REPFIL_PASS
            fi
          fi
        fi
        if [ $COMTYPE = "OS_PACKAGE" ]
        then
          echo  "Audit check # $ACREPCOUNT@RPM Version Check@$actual@$PARAM_PATH@PASS =>   $PMSG@$rpm_status@$rpm_arch">>$OSCHECKRESULT
        else
          if [ -z "$audit_check_name" ]
          then
            audit_check_name=$COM
          fi
          echo  "Audit check # $ACREPCOUNT@$audit_check_name@$VAL@$COMP@PASS =>   $PMSG">>$OSCHECKRESULT
          #audit_check_name=""
        fi 
        #echo "------------------------------" >>$REPFIL
        if [  $COMTYPE = "CLUSTERWIDE_CHECK" ]
        then 
          echo "" >>$CWCREPFIL_PASS
        else
          if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
          then
            echo "" >>$CELLREPFIL_PASS
          elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
          then
            echo "" >>$IBREPFIL_PASS
          else 
            echo "" >>$REPFIL_PASS
          fi 
        fi
        if [[ $CREATE_HTML_REPORT -eq 1 ]]
        then # gadiga - for html reporting
          init_arrays_html "PASS"
          write_additional_info;
        fi

        generate_result_xml "PASS"     

        #fi 
        BPMSG=0  
        BPMSG=`echo $PMSG|grep -c "BRANCH CONDITION TRUE"`
        if [[ $BPMSG -lt 1 && $ALVL != "INFO" && -n $ALVL && $print_pass_on_screen -eq 1 ]]
        then
          echo -e "$GREEN PASS =>   $NORM $PMSG"
        else
	  #to stop printing info in pass, just redirect follwing line to devnull 
          if [[ -n "$RAT_INFOPASS" && $RAT_INFOPASS -eq 1 && $print_pass_on_screen -eq 1 ]]
          then
            echo -e "$CYAN $ALVL =>   $NORM $PMSG" 
          else
            echo -e "$CYAN $ALVL =>   $NORM $PMSG" > /dev/null
            #echo -e "$CYAN $ALVL =>   $NORM $PMSG"
          fi
        fi
        echo -e "CHECK ID = $CHECK_ID \nAUDIT CHECK NAME = $audit_check_name\n">>$LOGFIL
        echo "---------------------------------------------" >>$LOGFIL
      fi
    fi
  ;;
  esac

  if [ $OFFLINE -eq "0" ]; then 
    get_current_epoch 
    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $pval] Check:log_pass End Time: $epoch_time" >> $CHK_TIMINGS
  fi
}

function assign_usern ()
{
  case `/bin/uname` in
    Linux)
    usern=`whoami`
    ;;
    SunOS)
    usern=`id|awk '{print $1}'|cut -d'(' -f2|cut -d')' -f1`
    ;;
    HP-UX)
    usern=`whoami`
    ;;
    AIX)
    usern=`whoami`
    ;;     
    *)
    usern=`whoami`
    ;;     
  esac
}

P_CONF_NAMES[0]="AUTORUN_INTERVAL"
P_CONF_NAMES[1]="AUTORUN_SCHEDULE"
P_CONF_NAMES[2]="AUTORUN_FLAGS"
P_CONF_NAMES[3]="NOTIFICATION_EMAIL"
P_CONF_NAMES[4]="PASSWORD_CHECK_INTERVAL"
P_CONF_NAMES[5]="COLLECTION_RETENTION"

function check_p_conf_validity ()
{
  p_name=$1
  p_conf_valid=0
  for v_n in "${P_CONF_NAMES[@]}"
  do
    #if [[ `echo $v_n | grep -cw "$p_name"` -gt "0" ]] ; then
    if [[ `echo $v_n | grep -icw "$p_name"` -gt "0" ]] ; then
      p_conf_valid=1
      return
    fi
  done
}

#    FILE			FORMAT
#=============================================
#1. last_autorun_report 	@ID:<ID> - REPORT
#2. autorun_list		@ID:<ID> - COLLECTION_NAME
#3. last_autorun_time		@ID=><ID> - TIME
#4. autorun_conf		@<ID>_START...@<ID>_END

function modify_conf_file ()
{
  if [ -e "$p_conf_file" ]
  then
    #numids=$(cat "$p_conf_file" | grep -c "^\s*@.*_START\s*$" | sed 's/ //g')  
    numids=$(grep -c "^\s*@.*_START\s*$" $p_conf_file | sed 's/ //g')  
    if [[ $numids -eq "0" ]]
    then
      echo "@${autorun_id}_START"	> "$p_conf_file.tmp"
      cat "$p_conf_file" 	 	>>"$p_conf_file.tmp"
      echo "@${autorun_id}_END"		>>"$p_conf_file.tmp"
      mv "$p_conf_file.tmp" "$p_conf_file"
    fi
  fi

  if [ -e $autorun_list ]; then
    if [[ `grep -c "^@ID:" $autorun_list` -eq 0 ]]; then
	sed -i -e "s/^/@ID:${program_name}.default - /" $autorun_list 
    fi
  fi

  if [ -e $RTEMPDIR_D/last_autorun_report ]; then
    if [[ `grep -c "^@ID:" $RTEMPDIR_D/last_autorun_report` -eq 0 ]]; then
	sed -i -e "s/^/@ID:${program_name}.default - /" $RTEMPDIR_D/last_autorun_report
    fi
  fi
}

function show_conf_file ()
{
  i_name=$1
  if [ -z "$i_name" ] ; then i_name="all"; fi
  #if [ "$i_name" != "all" ] ; then
  #  check_p_conf_validity $i_name
  #  if [ $p_conf_valid -eq "0" ] ; then
  #    echo
  #    echo -e "${RED}Invalid parameter name : $i_name${NORM}"
  #    echo
  #    return
  #  fi
  #fi

  matched_conf=0
  if [ ! -f "$p_conf_file" ] ; then
    echo
    echo "None of parameters are set"
    echo
    return
  fi

  if [[ -n "$setting_autorun_id" && $setting_autorun_id -eq "0" ]]
  then
    look_p_conf=`cat $p_conf_file`
  else
    #is_id_exist=$(cat "$p_conf_file" | grep -c "^\s*@${autorun_id}_START\s*$" | sed 's/ //g')
    is_id_exist=$(grep -c "^\s*@${autorun_id}_START\s*$" "$p_conf_file" | sed 's/ //g')
    if [[ $is_id_exist -eq "0" ]]; then
      echo
      echo -e "${RED}Specified ID[${autorun_id}] doesn't exist.${NORM}"
      echo
      exit 1
    fi
    look_p_conf=`sed -n "/^@${autorun_id}_START$/,/^@${autorun_id}_END$/p" $p_conf_file`
  fi

  OIFS="${IFS}";
  NIFS=$'\n';
  IFS="${NIFS}";

  #while read l_option
  for l_option in $look_p_conf
  do
    if [[ `echo "$l_option" | grep -c "^\s*$"` -gt "0" ]]; then continue; fi

    if [[ `echo "$l_option" | grep -c "^\s*@.*_START\s*$"` -gt "0" ]]
    then
      echo
      l_option=$(echo "$l_option" | sed 's/_START$//g' | sed 's/^@//g')
      echo "ID: $l_option"
      echo "----------------------------------"
    elif [[ `echo "$l_option" | grep -c "^\s*@.*_END\s*$"` -gt "0" ]]
    then
      continue
    else
      if [[ `echo "$l_option" |grep -c "^\s*$"` -gt "0" ]]
      then
        continue
      fi
      o_name=$(echo "$l_option" | cut -d"=" -f1 | sed 's/ //g')
      o_val=$(echo "$l_option" | cut -d"=" -f2 | sed 's/^ *//g' | sed 's/ *$//')
      if [[ -n "$i_name" &&  `echo $o_name | grep -iwc $i_name` -gt "0" ]] ; then
        echo "$o_name = $o_val";
        matched_conf=1
      elif [[ "$i_name" = "all" ]] ; then
        echo "$o_name = $o_val";
        matched_conf=1
      fi
    fi
  #done < $p_conf_file
  done
  IFS="${OIFS}";

  if [[ $matched_conf -eq "0" ]] ; then
    echo
    echo -e "${RED}Invalid parameter name : $i_name${NORM}"
  fi
  echo
}

function validate_autorun_id ()
{
  if [ -f "$p_conf_file" ]; then
    #numids=$(cat "$p_conf_file" | grep -c "^\s*@.*_START\s*$" | sed 's/ //g')  
    #is_id_exist=$(cat "$p_conf_file" | grep -c "^\s*@${autorun_id}_START\s*$" | sed 's/ //g')
    numids=$(grep -c "^\s*@.*_START\s*$" "$p_conf_file" | sed 's/ //g')  
    is_id_exist=$(grep -c "^\s*@${autorun_id}_START\s*$" "$p_conf_file" | sed 's/ //g')

    if [[ -n "$setting_autorun_id" && $setting_autorun_id -eq "0" ]]; then
      if [[ $numids -gt "1" ]]; then
        echo
        echo -e "${RED}Multiple autorun schedules exists. Please specify ID with -id option${NORM}"
        usage_daemon;
        echo
        exit 1
      else
        if [[ $is_id_exist -eq "0" ]]; then
          echo
          echo -e "${RED}Please specify ID with -id option${NORM}"
          usage_daemon;
          echo
          exit 1
        fi
      fi
    else
      if [[ $is_id_exist -eq "0" ]]; then
        if [[ -n $setting_conf && $setting_conf -ne "1" ]]; then
          echo
          echo -e "${RED}Autorun schedule does not exist for specified ID[$autorun_id].${NORM}"
          echo
          exit 1
        fi
      fi
    fi
  fi
}

function update_conf_file ()
{
  old_ifs=$IFS
  IFS=";"

  if [[ -n "$setting_conf" && $setting_conf -eq "1" ]]; then
    validate_autorun_id
    for l_option in $options2set
    do
      o_name=$(echo "$l_option" | cut -d"=" -f1 | sed 's/ //g')
      o_val=$(echo "$l_option" | cut -d"=" -f2 | sed 's/^ *//g' | sed 's/ *$//')
      if [[ -n "$o_name" && -n "$o_val" ]] ; then
        check_p_conf_validity "$o_name"
        if [[ $p_conf_valid -eq "1" ]] ; then
          do_update_conf
        else
          echo
          echo -e "${RED}Invalid parameter name $p_name${NORM}";
          echo
        fi
      else
        echo
        echo -e "${RED}Invalid parameter name${NORM}";
        echo
      fi
    done
  elif [[ -n "$unset_conf" && $unset_conf -eq "1" ]]; then
    if [ ! -f "$p_conf_file" ] ; then
      echo
      echo "None of parameters are set"
      echo
      return
    fi
	
    if [[ "$options2unset" = "all" ]]; then
      if [[ -n "$setting_autorun_id" && $setting_autorun_id -eq "0" ]]; then
        rm -f $p_conf_file >/dev/null 2>&1;
        rm -f $RTEMPDIR_D/last_autorun_time >/dev/null 2>&1;
        echo
        echo "Removed all autorun schedules"
        echo
      else
        #is_id_exist=$(cat "$p_conf_file" | grep -c "^\s*@${autorun_id}_START\s*$" | sed 's/ //g')
        is_id_exist=$(grep -c "^\s*@${autorun_id}_START\s*$" "$p_conf_file" | sed 's/ //g')
        if [[ $is_id_exist -eq "0" ]]; then
          echo
          echo -e "${RED}Autorun schedule does not exist for specified ID[$autorun_id].${NORM}"
          echo
          return
        else
          if [[ $numids -eq "1" ]]; then
            rm -f $p_conf_file >/dev/null 2>&1;
            rm -f $RTEMPDIR_D/last_autorun_time >/dev/null 2>&1;
          else
            sed "/^@${autorun_id}_START$/,/^@${autorun_id}_END$/d" $p_conf_file > $p_conf_file.tmp
            mv $p_conf_file.tmp $p_conf_file

	    sed "/^ID=>${autorun_id} - /d" $RTEMPDIR_D/last_autorun_time > $RTEMPDIR_D/last_autorun_time.tmp
            mv $RTEMPDIR_D/last_autorun_time.tmp $RTEMPDIR_D/last_autorun_time 
          fi
        fi
        echo
        echo "Removed autorun schedule for ID[${autorun_id}]"
        echo
      fi
    else
      validate_autorun_id
      for l_option in $options2unset
      do
        o_name=$(echo "$l_option"|sed 's/ //g')
        if [[ -n "$o_name" ]] ; then
          check_p_conf_validity "$o_name"
          if [[ $p_conf_valid -eq "1" ]] ; then
            do_update_conf
          else
            echo
            echo -e "${RED}Invalid parameter name $p_name${NORM}";
            echo
          fi
        else
          echo
          echo -e "${RED}Invalid parameter name${NORM}";
          echo
        fi
      done
    fi
  fi
  IFS="$old_ifs"
}

function do_update_conf ()
{
  if [[ -n "$setting_conf" && $setting_conf -eq "1" ]]
  then
    if [[ -f "$p_conf_file" ]]; then
      #is_id_exist=$(cat "$p_conf_file" | grep -c "^\s*@${autorun_id}_START\s*$" | sed 's/ //g')
      is_id_exist=$(grep -c "^\s*@${autorun_id}_START\s*$" "$p_conf_file" | sed 's/ //g')
      if [[ $is_id_exist -eq "0" ]]; then
        echo "@${autorun_id}_START" >> "$p_conf_file"
        echo "$o_name=$o_val"       >> "$p_conf_file"  
        echo "@${autorun_id}_END"   >> "$p_conf_file"
        #echo ""		    >> "$p_conf_file"

        echo
        echo "Created $o_name for ID[${autorun_id}]"
        echo
      else
        is_update=0
        sed -n "/^@${autorun_id}_START$/,/^@${autorun_id}_END$/p" "$p_conf_file" 	> "$p_conf_file.tmp"
	sed "/^@${autorun_id}_END$/d" "$p_conf_file.tmp" 				> "$p_conf_file.tmp.3"

        if [[ `grep -ic "$o_name" $p_conf_file.tmp` -gt "0" ]] ; then
          is_update=1
	  sed "/^$o_name/d" "$p_conf_file.tmp.3" > "$p_conf_file.tmp.4" 
	  mv "$p_conf_file.tmp.4" "$p_conf_file.tmp.3"
	fi

	echo "$o_name=$o_val"       >> "$p_conf_file.tmp.3"
        echo "@${autorun_id}_END"   >> "$p_conf_file.tmp.3"
        sed "/^@${autorun_id}_START$/,/^@${autorun_id}_END$/d" $p_conf_file > "$p_conf_file.tmp.2"

	cat "$p_conf_file.tmp.2"     > "$p_conf_file"
	#echo ""  		    >> "$p_conf_file"
        cat "$p_conf_file.tmp.3"    >> "$p_conf_file"

        rm -f "$p_conf_file.tmp" "$p_conf_file.tmp.2" "$p_conf_file.tmp.3"

        echo
        if [[ $is_update -eq 0 ]]; then
	  echo "Created $o_name for ID[${autorun_id}]"
        else
	  echo "Updated $o_name for ID[${autorun_id}]"
        fi
        echo
      fi
    else
      #echo ""			     > "$p_conf_file"
      echo "@${autorun_id}_START"   >> "$p_conf_file"
      echo "$o_name=$o_val"         >> "$p_conf_file"  
      echo "@${autorun_id}_END"     >> "$p_conf_file"
      #echo ""			    >> "$p_conf_file"

      echo
      echo "Created $o_name for ID[${autorun_id}]"
      echo
    fi

    log_daemon "Updating config - set $o_name for ID[${autorun_id}]"
  elif [[ -n "$unset_conf" && $unset_conf -eq "1" ]]
  then
    sed -n "/^@${autorun_id}_START$/,/^@${autorun_id}_END$/p" "$p_conf_file" > "$p_conf_file.tmp" 
    if [[ -f "$p_conf_file.tmp" && `grep -ic "$o_name" $p_conf_file.tmp` -gt "0" ]] ; then
      perl -i -p -e 's/'$o_name'=.*//gi' "$p_conf_file.tmp"
      perl -i -n -e "print if /\S/" "$p_conf_file.tmp"

      sed "/^@${autorun_id}_START$/,/^@${autorun_id}_END$/d" $p_conf_file > "$p_conf_file.tmp.2"
      cat "$p_conf_file.tmp.2"	>  $p_conf_file
      #echo "" 			>> $p_conf_file
      cat "$p_conf_file.tmp" 	>> $p_conf_file
      rm -f "$p_conf_file.tmp" "$p_conf_file.tmp.2"

      echo
      echo "Removed $o_name for ID[${autorun_id}]"
      echo

      log_daemon "Updating config - unset $o_name for ID[${autorun_id}]"
    else
      echo
      echo -e "${RED}$o_name was not set for ID[${autorun_id}].${NORM}";
      echo
    fi
  fi
}

function read_conf ()
{
  if [ ! -f "$p_conf_file" ] ; then
    p_conf_value=""
    return
  fi
  #p_conf_value=$(grep "$1=" $p_conf_file | cut -d"=" -f2)
  p_conf_value=$(grep -i "$1=" $p_conf_file | cut -d"=" -f2)
	
  # default AUTORUN_INTERVAL will be in days
  #if [[ `echo "$p_conf_value"| grep -c '^[0-9]*$'` -gt "0" && $1 = "AUTORUN_INTERVAL" ]] ; then
  if [[ `echo "$p_conf_value"| grep -c '^[0-9]*$'` -gt "0" && `echo "$1"|grep -icw "AUTORUN_INTERVAL"` -gt "0" ]] ; then
    p_conf_value=$(expr $p_conf_value \* 24)
  fi

  #if [[ `echo "$p_conf_value"| grep -c '^[0-9]*d$'` -gt "0" ]] ; then
  if [[ `echo "$p_conf_value"| grep -ic '^[0-9]*d$'` -gt "0" ]] ; then
    p_conf_num=$(echo "$p_conf_value"| sed 's/d$//');
    p_conf_num=$(echo "$p_conf_num"| sed 's/D$//');
    p_conf_value=$(expr $p_conf_num \* 24)
  #elif [[ `echo "$p_conf_value"| grep -c '^[0-9]*h$'` -gt "0" ]] ; then
  elif [[ `echo "$p_conf_value"| grep -ic '^[0-9]*h$'` -gt "0" ]] ; then
    p_conf_value=$(echo "$p_conf_value"| sed 's/h$//');
    p_conf_value=$(echo "$p_conf_value"| sed 's/H$//');
  fi
}

mail_server_running=0
function check_if_mail_exists ()
{
  t_attachment=$1
  mail_cmd=$(which mail)
  if [ -z "$mail_cmd" ] ; then mail_cmd=$(which mailx); fi
  if [ -n "$mail_cmd" ] ; then mail_server_running=1; fi

  if [[ -n "$t_attachment" && $t_attachment -eq "1" ]]; then mail_server_running=1; fi
}


function send_email_with_attachment ()
{
  which uuencode >/dev/null 2>&1 
  if [ `echo $?` -eq 0 ] 
  then
    if [[ `echo "$subject"|grep -ic "No differences"` -gt 0 || `echo "$subject"|grep -iwc "First"` -gt 0 ]]
    then
      uuencode $html_report $html_report >> $TMPDIR/mail.out
    else
      uuencode $prev_report $prev_report > $TMPDIR/mail.out
      uuencode $html_report $html_report >> $TMPDIR/mail.out
      uuencode $diff_report $diff_report >> $TMPDIR/mail.out
    fi
    echo "$matter" >> $TMPDIR/mail.out
  
    log_daemon "Sending Email with attachment to [ $remail ] using [ $mail_cmd ]."

    $mail_cmd -s "$subject" $remail < $TMPDIR/mail.out >/dev/null 2>&1;	
    mail_status=`echo $?`

    rm -rf $TMPDIR/mail.out >/dev/null 2>&1;
  else
    which mutt >/dev/null 2>&1
    if [ `echo $?` -eq 0 ]
    then
      echo "$matter" > $TMPDIR/mail.out

      log_daemon "Sending Email with attachment to [ $remail ] using [ mutt ]."

      if [[ `echo "$subject"|grep -ic "No differences"` -gt 0 || `echo "$subject"|grep -iwc "First"` -gt 0 ]]
      then
        mutt -s "$subject" -a "$html_report" -- $remail < $TMPDIR/mail.out >/dev/null 2>&1;
	mail_status=`echo $?`
      else
        mutt -s "$subject" -a "$prev_report" -a "$html_report" -a "$diff_report" -- $remail < $TMPDIR/mail.out >/dev/null 2>&1;
	mail_status=`echo $?`
      fi
       
      rm -rf $TMPDIR/mail.out >/dev/null 2>&1;
    else
      which sendmail >/dev/null 2>&1
      if [ `echo $?` -eq 0 ]
      then
        log_daemon "Sending Email with attachment to [ $remail ] using [ sendmail ]."

	from=""
	to="$remail"
	subject="$subject"
	boundary="ZZ_/afg6432dfgkl.94531q"
	body="$matter"
	declare -a attachments
 
        if [[ `echo "$subject"|grep -ic "No differences"` -gt 0 || `echo "$subject"|grep -iwc "First"` -gt 0 ]]
        then
	  attachments=( "$html_report" )
        else
	  attachments=( "$prev_report" "$html_report" "$diff_report" )
        fi
{
	printf '%s\n' "From: $from
To: $to
Subject: $subject
Mime-Version: 1.0
Content-Type: multipart/mixed; boundary=\"$boundary\"

--${boundary}

$body
"
	for file in "${attachments[@]}"; do
          if [ -z "$file" ]; then continue; fi

	  [ ! -f "$file" ] && echo "Warning: attachment $file not found, skipping" >&2 && continue
  	  mimetype=$(file --mime "$file"|cut -d: -f2|cut -d\; -f2|sed 's/ //g') 

	  printf '%s\n' "--${boundary}
Content-Type: $mimetype
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename=\"$file\"
"
	  base64 "$file"
	  echo
	done
	printf '%s\n' "--${boundary}--"
} | sendmail -t -oi
	mail_status=`echo $?`
      else
        log_daemon "Sending Email without attachment to [ $remail ] using [ $mail_cmd ]. Configure email client for sending attachments."

        echo "$matter" | $mail_cmd -s "$subject" $remail
	mail_status=`echo $?`
      fi
    fi
  fi

  if [[ -n $mail_status && $mail_status -eq 0 ]]; then
    log_daemon "Email successfully sent."
  else
    log_daemon "Email sending failed."
  fi

}

#Use: send_email "subject" "body" "attachment(0|1)" "recipients(all| value for current_run)"
function send_email ()
{
  subject="$1"
  matter="$2"
  attachment="$3"
  recipients="$4"

  check_if_mail_exists "$attachment"

  if [[ ! -z $recipients && $recipients = "all" ]]; then
    if [[ -f "$p_conf_file" && `grep -ic "NOTIFICATION_EMAIL" $p_conf_file` -gt "0" ]] ; then
      for emails in `grep -i "NOTIFICATION_EMAIL" "$p_conf_file"`
      do
        all_emails=$all_emails","$(echo "$emails" | cut -d"=" -f2);
      done 

      #all_emails=$(echo "$all_emails" | sed 's/^,//g' | sed 's/,$//g');
      all_emails=$(echo "$all_emails"|awk 'BEGIN{RS=","}{print $0}'|sort|uniq|awk 'BEGIN{ORS=","}{print $0}'|sed 's/^,//g'|sed 's/,$//g')  
      remail="$all_email"
    else
      echo 
      echo -e "${RED}Email address is not configured. Please use ${program_name} -set \"NOTIFICATION_EMAIL=admin@company.com\" command to set email address for notifications.${NORM}"
      echo
      return
    fi
  else
    swap_p_conf_file "$cur_p_conf_file"

    #if [[ -f "$p_conf_file" && `grep -c "NOTIFICATION_EMAIL" $p_conf_file` -gt "0" ]] ; then
    if [[ -f "$p_conf_file" && `grep -ic "NOTIFICATION_EMAIL" $p_conf_file` -gt "0" ]] ; then
      echo >/dev/null
    else
      echo 
      echo -e "${RED}Email address is not configured. Please use ${program_name} -set \"NOTIFICATION_EMAIL=admin@company.com\" command to set email address for notifications.${NORM}"
      log_daemon "Failed to send email as email address is not configured. Please use ${program_name} -set \"NOTIFICATION_EMAIL=admin@company.com\" command to set email address for notifications."
      echo
      return
    fi
    read_conf "NOTIFICATION_EMAIL"
    remail=$p_conf_value
  fi

  if [[ -n "$mail_server_running" && $mail_server_running -eq "1" ]] ; then
    if [[ -e "$RTEMPDIR_D/.cells.txt" ]] ; then
      send_mail_using_cell 
    else
      if [[ -n "$attachment" && "$attachment" -eq "1" ]]
      then
	send_email_with_attachment
      else
	log_daemon "Sending Email without attachment to [ $remail ] using [ $mail_cmd ]."
        echo "$matter" | $mail_cmd -s "$subject" $remail
	
 	if [ `echo $?` -eq 0 ]; then
	  log_daemon "Email successfully sent."
	else
	  log_daemon "Email sending failed."
	fi	
      fi
    fi
  fi
}

function add_to_skipped_nodes ()
{
  skipped_host=$1
  skipped_reason=$2
  if [[ -e "$OUTPUTDIR/${program_name}_skipped_nodes.log" && `grep -iwc "$skipped_host" $OUTPUTDIR/${program_name}_skipped_nodes.log` -gt "0" ]] ; then
    return; # The node is already in skipped host list
  fi

  if [ ! -e "$OUTPUTDIR/${program_name}_skipped_nodes.log" ] ; then
    echo "<table summary=\"Summary of skipped nodes\"><tr><th scope=\"col\">Host Name</th><th>Reason</th></tr>" > $OUTPUTDIR/${program_name}_skipped_nodes.log
  fi
  echo "<tr><td scope=\"row\">$skipped_host</td><td scope=\"row\">$skipped_reason</td></tr>" >> $OUTPUTDIR/${program_name}_skipped_nodes.log
  echo "$skipped_host" >> $OUTPUTDIR/${program_name}_skipped_nodes_txt.log
}

# Global variables for System Health Score for a cluster
# System Health Score will be a number b/w 0 - 100
# At the top of report print the score
# The logic used is (From Giri)
# Every check has 10 points
# If check status = FAIL reduce 10 points
#                   WARN reduce 5 points
#                   INFO reduce 3 points
# The total checks = checks in log_pass + checks in log_fail
# Also total check is count of all checks executed on all nodes, means,
# if same check is executed on two nodes, add 2 to total
G_TOTAL_CHECKS=0
G_FAIL_CHECKS=0
G_WARN_CHECKS=0
G_INFO_CHECKS=0
G_INFO_CHECKS_SCORE=0
G_SKIP_CHECKS=0
# Heath score is
# ((G_TOTAL_CHECKS*10)-(G_FAIL_CHECKS*10+G_WARN_CHECKS*5+G_INFO_CHECKS*3+G_SKIP_CHECKS*3))/(G_TOTAL_CHECKS*10)

# Added by gadiga for creating html reports
# After writing failed message to corresponding .rep file, 
# write the message to <checkid>.html. If the file exists already, just 
# concatinate the .out file contents. Create <a name=<checkid>_details> anchor.
# Also create "Top" link, which will jump back to the message in summary table with 
# name <checkid>_summary. All <checkid>.html files are concatinated later to 
# create raccheck.html file

g_cch_cnt=0                 # check id count
g_cid=0                     # index for a check id
g_type=""                   # Type of check
g_hosts=""                  # Host names where check failed
declare -a G_CHECKIDS       # All failed check ids
declare -a G_CHECKID_INFO   # Collection name
declare -a G_CHECKID_TYPE   # Check Type
declare -a G_CHECKID_STATUS   # Status Pass failed etc
declare -a G_CHECKID_MAA_SF
declare -a G_CHECKID_HOSTS    # Host names
declare -a G_CHECKID_HOSTS_PASSED    # Host names
declare -a G_CHECKID_ALLHOSTS # Host names
CID_HTML_REPFILE=""         # checkid file
G_SOURCEFIL_REPORT=""       # Saved SOURCEFIL_REPORT
G_SOURCEFIL_REPORT_NEW=""   # Saved SOURCEFIL_REPORT_NEW
G_LINKS=""                  # Saved links finormation
CREATE_HTML_REPORT=1        # Set to zero to disable html reporting
TOOL_NAME="raccheck"        # Tool name to display. Changed later based on program name.
G_OUT_LINES=20               # Number of lines to display from .out file. default 20
G_HOST_CNT=5                # Number of host/db names to display in summary table. Default 5
                            # To change G_HOST_CNT, update the number in function get_host_string_html (In cut command)
# Below variables track the summary counts
G_TOTAL_CHECKS=0           
G_PASS_CNT=0           
G_WARNING_CNT=0           
G_ERROR_CNT=0           
G_FAIL_CNT=0           
G_INFO_CNT=0           

g_tr_index=0 # Index for deletebutton

G_SFS_TO_IGNORE[0]='GENERIC OS DATA COLLECTIONS';
G_SFS_TO_IGNORE[1]='OVM GUEST AUDIT CHECKS';
G_SFS_TO_IGNORE[2]='ARCHIVED AUDIT CHECKS';
G_SFS_TO_IGNORE[3]='DBMACHINE X2-2, X2-8 GENERIC AUDIT CHECKS'
G_SFS_TO_IGNORE[4]='DBMACHINE X2-2 AND X2-8 AUDIT CHECKS'
G_SFS_TO_IGNORE[5]='SQL DATA COLLECTIONS AND CHECKS'
G_SFS_TO_IGNORE[6]='GENERIC ORACLE PRE-UPGRADE AND POST-UPGRADE COLLECTIONS AND AUDIT CHECKS'
G_SFS_TO_IGNORE[7]='SFRAC'
G_SFS_TO_IGNORE[8]='OVM SERVER AUDIT CHECKS'
G_SFS_TO_IGNORE[9]='HA CHECKS'
G_SFS_TO_IGNORE[10]='SOLARIS DATA COLLECTIONS'
G_SFS_TO_IGNORE[11]='EXALOGIC AUDIT CHECKS'
G_SFS_TO_IGNORE[12]='LINUX RPM AUDIT CHECKS'
G_SFS_TO_IGNORE[13]='ACFS- OS COLLECTIONS AND OS CHECKS'
G_SFS_TO_IGNORE[14]='ORACLE DATABASE APPLIANCE (ODA)'
G_SFS_TO_IGNORE[15]='LINUX DATA COLLECTIONS AND AUDIT CHECKS'
G_SFS_TO_IGNORE[16]='HP-UX DATA COLLECTIONS'
G_SFS_TO_IGNORE[17]='AIX DATA COLLECTIONS'
G_SFS_TO_IGNORE[18]='AIX OS PACKAGES AND PATCHES'
G_SFS_TO_IGNORE[19]='SOLARIS OS PACKAGES AND PATCHES'
G_SFS_TO_IGNORE[20]='EXALYTICS AUDIT CHECKS'
G_SFS2INGORE=21
#--

ignore_sf_name=0
set_ignore_sf_name ()
{
  l_sf_counter=0
  while [[ $l_sf_counter -lt $G_SFS2INGORE ]] ; do
    l_sfname=${G_SFS_TO_IGNORE[$l_sf_counter]}
    if [[ $SF = $l_sfname ]] ; then
      ignore_sf_name=1
      return;
    else
      ignore_sf_name=0
    fi
    l_sf_counter=$(expr $l_sf_counter + 1)
  done
}

# Identifies the check type. Logic copied from generate_result_xml
# Output
#     $g_type : Check type
#     $g_hosts: machine/db/switch names
get_check_type ()
{
  g_type=""
  g_hosts=""
  g_hosts_passed="" # On cell no new message for passed checked

  if [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
  then
    cwc_failed=0
    if [[ "$cell_outcheck_type" = "cwc" ]]
    then # failed on one node = failed on all nodes
      cellname_counter=0
      for cellname in ${a_cellname[@]}
      do
        if [[ ${a_cellCheckStatus[$cellname_counter]} != "PASS" ]]
        then
          cwc_failed=1
        fi
        cellname_counter=$(expr $cellname_counter + 1 )
      done
    fi

    g_type="Storage Server Check"
    cellname_counter=0
    for cellname in ${a_cellname[@]}
    do
      cell_status=${a_cellCheckStatus[$cellname_counter]}
      if [[ "$cell_outcheck_type" = "cwc" && $cwc_failed = "1" ]]
      then
        cell_status="FAIL"
      fi

      if [[ $cell_status != "PASS" ]]
      then
        if [[ `echo $g_hosts | grep -ic $cellname` -eq 0 ]] ; then
          g_hosts="$cellname, $g_hosts"
        fi
        # Storage server check status is stored in a array. 
        # For PASS, a new message is not created
      else
        if [[ `echo $g_hosts_passed | grep -ic $cellname` -eq 0 ]] ; then
          g_hosts_passed="$cellname, $g_hosts_passed"
        fi
      fi
      update_check_status "$cell_status" $cch_check_id
      cellname_counter=$(expr $cellname_counter + 1 )
    done
    g_hosts_saved=$g_hosts
    g_hosts=$(echo $g_hosts_saved | sed 's/,$//')
    g_hosts_saved=$g_hosts_passed
    g_hosts_passed=$(echo $g_hosts_saved | sed 's/,$//')
  elif [[ $NEEDS_RUNNING = "RDBMS" && -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]]
  then
    g_type="TimesTen Database Check"
    g_hosts="$i:$db_name_to_check"	
  elif [[ $PARAM = "TIMESTEN" && -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]]
  then
    g_type="TimesTen Installation Check"
    g_hosts="$i:$mb_db_homes"	
  elif [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH" ]]
  then
    g_type="Switch Check"
    g_hosts="$switchname"
  elif [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS_PARAM" || $COMTYPE = "OS_PACKAGE" || $COMTYPE = "OS_PATCH" ]]
  then
    g_type="OS Check"
    g_hosts="$i"
  elif [ $COMTYPE = "OS" ]
  then
    if [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "RDBMS" ]]
    then
      g_type="Database Check"
      g_hosts="$i:$db_name_to_check"
    elif [[ -n "$multiple_oracle_homes" && $multiple_oracle_homes -gt 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && -n "$ulimit_cmd" && $ulimit_cmd -eq 0 ]]
    then
      g_type="ORACLE_HOME Check"
      if [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]]
      then
      	g_type="OBIEE_HOME Check"
	if [[ `echo $audit_check_name|grep -iEc "^OBIEE configuration"` -ge 1 ]]
        then
                g_type="OBIEE configuration for TimesTen"
        fi
      fi
      g_hosts=" $i:$mb_db_homes"
    elif [[ -n "$multiple_oracle_homes" && $multiple_oracle_homes -gt 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "BI_INSTANCE" && -n "$ulimit_cmd" && $ulimit_cmd -eq 0 ]]
    then
      g_type="BI_INSTANCE Check"
      g_hosts=" $i:$mb_db_homes:$bi_instance"
    elif [[ "$NEEDS_RUNNING" = "ASM" ]]
    then
      g_type="ASM Check"
      g_hosts="$i"
    elif [[ "$NEEDS_RUNNING" = "STORAGE_CELL" ]]
    then
      g_type="Storage Server Check"
      g_hosts="$cellname"
    elif [[ "$NEEDS_RUNNING" = "ZFS" ]]
    then
      g_type="ZFS Storage Appliance Check"
      g_hosts="$cellname"
    else
      g_type="OS Check"
      g_hosts="$i"
      if [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 && "$PARAM" = "RDBMS" ]]
      then
	g_type="OBIEE_HOME Check"	
	if [[ `echo $audit_check_name|grep -iEc "^OBIEE configuration"` -ge 1 ]]
        then
          g_type="OBIEE configuration for TimesTen"
        fi
        g_hosts="$i:$mb_db_homes"
      fi
    fi
  elif [[ $COMTYPE = "SQL" || $COMTYPE = "SQL_OUT_CHECK" ]]
  then
    g_type="SQL Check"
    g_hosts="$db_name_to_check"
  elif [[ $COMTYPE = "SQL_PARAM" ]]
  then
    g_type="SQL Parameter Check"
    g_hosts="$inst_name"
  elif [[ $COMTYPE = "CLUSTERWIDE_CHECK" || $COMTYPE = "CROSS_NODE_CHECK" ]]
  then
    g_type="$html_rack_type Wide Check"
    g_hosts="$html_rack_type Wide"
  elif [ $COMTYPE = "SYSTEMWIDE_CHECK" ]
  then
    g_type="System Wide Check"
    g_hosts="System Wide"
  elif [ $COMTYPE = "ORACLE_PATCH" ] && [[ $HOME_PATH = "CRS" || $HOME_PATH = "ASM" || $HOME_PATH = "RDBMS" ]]
  then
    g_type="Patch Check"
    if [[ $HOME_PATH = "CRS" || $HOME_PATH = "ASM" ]]
    then
      g_hosts="$i:$message4Home"
    elif [ $HOME_PATH = "RDBMS" ]
    then
      g_hosts="$i:$mb_db_homes"
    fi
  elif [ $COMTYPE = "ORACLE_PATCH" ] 
  then
    g_type="Patch Check"
    g_hosts="$i"
  else
    echo "Could not find the check type/target"
    g_type="Unknown"
    g_hosts="Unknown"
  fi
}

# Array G_CHECKIDS holds all check id's, one entry for each status
# Key is check_id and status
# This function will insert a check id into the array if does not exists
# Input:
#   Status
#   Check id
# Output:
#   $g_cid : Index number in array for the i/p check id
get_check_id_number ()
{
  gci_index=0;
  g_cid=-1;
  gci_cid="A${2}_$1"
  if [ -z $(eval echo \${$gci_cid}) ]
  then # First time
  #while [ $gci_index -lt $g_cch_cnt ]
  #do
  #  chk_status=$(echo ${G_CHECKID_STATUS[$gci_index]} | awk -F":" '{print $1}')
  #  if [[ "${G_CHECKIDS[$gci_index]}" = "$2" && $chk_status = "$1" ]]
  #  then # Already there
  #    g_cid=$gci_index;
  #    break;
  #  fi
  #  let gci_index=$gci_index+1
  #done

  #if [ $g_cid -eq -1 ] 
  #then # Assign a new id
    eval $gci_cid=$g_cch_cnt
    g_cid=$g_cch_cnt
    G_CHECKIDS[$g_cid]=$2
    let g_cch_cnt=$g_cch_cnt+1
  else
    g_cid=$(eval echo \${$gci_cid});
  fi
}

# Find the right check_id and initialize variable $cch_check_id
# Output:
#   $cch_check_id
get_check_id ()
{
  if [ $COMTYPE = "CLUSTERWIDE_CHECK" ]
  then 
    cch_check_id=${crs_check_id[$crs_check_file_counter]}
  else
    cch_check_id=$CHECK_ID
  fi
}

# This function will create a variable by name <checkid> using eval and assigns below values
# = 1 if the status is PASS
# = -1 if the status is FAIL
# = 2 if the status has both pass and fail
update_check_status ()
{
  ucs_status=$1
  ucs_cid="A$2" # Variable names can't start with number. So append dummy letter A

  if [ -z $(eval echo \${$ucs_cid}) ]
  then # First time
    #let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1 # unique check count
    if [ $ucs_status = "PASS" ] 
    then
      eval $ucs_cid=1
    else
      eval $ucs_cid=-1
    fi
  else # We have results for the check from another host/db
    ucs_current=$(eval echo \${$ucs_cid}) # Status from previous host/db
    if [[ $ucs_current -eq "1" && $ucs_status != "PASS" ]]
    then # Passed in earlier hosts, failed in the new host
      eval $ucs_cid=2
    elif [[ $ucs_current -eq "-1" && $ucs_status = "PASS" ]]
    then # Failed in earlier hosts, passed in the new host
      eval $ucs_cid=2
    fi
  fi
  
}

# for PASS messages log_pass does not initialize ONFAIL and LINK variable
# This function does that
write_additional_info ()
{
  #ALVL="PASS"
  if [[ -n "$NO_WRITE_PASS" && $NO_WRITE_PASS -eq 1 ]]; then return; fi;
  alvl_value="PASS"
  if [ -n "$1" ] ; then alvl_value="$1"; fi
  if [ $COMTYPE != "OS_PACKAGE-DISABLED" ]
  then
    #grab the details from the appendix
    LINKNUM=0
    LINK=
    if [ $op_mode -eq 0 ]
    then
      LINKNUM=`grep -c _$ROW-LINK $REFFIL1`
      BEGPAT="_$ROW-BEGIN_COMMENTS"
      ENDPAT="_$ROW-END_COMMENTS"
    else
      if [ $COMTYPE = "CLUSTERWIDE_CHECK" ]
      then 
        CHECK_ID=${crs_check_id[$crs_check_file_counter]}
      fi 
      LINKNUM=`grep -c _$CHECK_ID-LINK $REFFIL1`
      BEGPAT="_$CHECK_ID-BEGIN_COMMENTS"
      ENDPAT="_$CHECK_ID-END_COMMENTS"
    fi
    ONFAIL=`sed -n /$BEGPAT/,/$ENDPAT/p $REFFIL1 |sed s/$BEGPAT//g | sed s/$ENDPAT//g |sed 's/ / /g'`
    PLA_LINE=`grep "_"$CHECK_ID"-PLA_LINE"" " $REFFIL1 | sed -n 's/.*-PLA_LINE//p' | sed 's/^\s*//g' | sed 's/\s*$//g'`

    #Added this line to add pass/fail message as rational if its ORACLE_PATH and ratinoal is empty
    if [[ "$COMTYPE" = "ORACLE_PATCH" && `echo $ONFAIL|sed '/^$/d'|wc -l` -eq 0 ]];then ONFAIL=$PMSG;fi
    if [ $LINKNUM -gt 0 ]
    then
      #echo "$ROW LINKNUM = $LINKNUM" >>$REPFIL
      for ((j=1;j<=$LINKNUM;j+=1));
      do
        #echo "j=$j, ROW=$ROW" >>$REPFIL
        if [ $op_mode -eq 0 ]
        then
          LINK=`grep "_"$ROW"-LINK"$j" " $REFFIL1 |sed  -n 's/.*-LINK//p'`
        else
          LINK=`grep "_"$CHECK_ID"-LINK"$j" " $REFFIL1 |sed  -n 's/.*-LINK//p'`
        fi
        if [ $CREATE_HTML_REPORT -eq 1 ]
        then
          append_links_html "$alvl_value"
        fi
      done
    fi

    if [ $CREATE_HTML_REPORT -eq 1 ]
    then # gadiga - for html reports
      create_checkid_html "$alvl_value"
      write_output_to_html "$alvl_value"
    fi
  else
    if [ $CREATE_HTML_REPORT -eq 1 ]
    then  # gadiga - for html reports
      write_output_to_html "$alvl_value"
    fi
  fi # end if not to print in report file for OS_PACAKGE
}

# Info related to a check are stored in different arrays using the same index
# which is used in checkid array G_CHECKIDS
# Output:
#   Global arrays which hold the info on each check
init_arrays_html ()
{
  NO_WRITE_PASS=0
  cch_check_id=""
  get_check_id
  if [ $1 = "PASS" ]
  then
    if [[ -n "$print_pass_in_report" && $print_pass_in_report -eq "0" ]] ; then return; fi
    if [[ -n "$ORIG_PMSG" && `echo "$PMSG" | grep -ic "$ORIG_PMSG"` -ge 1 ]]
    then # ORIG_PMSG has message without db names
      cch_cname="$ORIG_PMSG"
    else
      cch_cname="$PMSG"
    fi

    if [[ -n "$skip_maa_scorecard" && $skip_maa_scorecard -eq 0  ]]; then
      if [[ `echo $cch_cname|grep -ic "System is not exposed"` -ge 1 ]]; then
	NO_WRITE_PASS=1;
	cch_status="PASS"
	return;
      fi
    fi
	  
    get_check_id_number "PASS" $cch_check_id
    update_check_status "PASS" $cch_check_id
    cch_status="PASS"
  else # FAIL 
    get_check_id_number "$ALVL" $cch_check_id
    update_check_status "FAIL" $cch_check_id
    if [[ -n "$ORIG_FMSG" && `echo "$FMSG" | grep -ic "$ORIG_FMSG"` -ge 1 ]]
    then # ORIG_FMSG has message without db names
      cch_cname="$ORIG_FMSG"
    else
      cch_cname="$FMSG"
    fi
    cch_status="$ALVL"
  fi
  get_check_type

  if [ -n "$MERGEFILES" ];
  then
    components=$(grep -i "COMPONENTS" $NEW_MASTERFIL1|head -1|cut -d"=" -f2|sed 's/ //g');	
    if [[ `grep -i "COMPONENTS" $NEW_MASTERFIL1|grep -ic ':MAA'` -gt 0 ]]; then components=$components:MAA; fi
  fi

  if [[ -n "$skip_maa_scorecard" && $skip_maa_scorecard -eq 0  ]]; then
    if [[ `echo $check_components|grep -ic "MAA"` -ge 1 && `echo $components|grep -ic "MAA"` -ge 1 ]]
    then
      G_CHECKID_MAA_SF[$g_cid]=$SF
      if [[ $is_exadata_dom0_machine -eq "1" || $is_ssc_globalzone_machine -eq 1 ]] && [ "$SF" != "SOFTWARE MAINTENANCE BEST PRACTICES" ]; then G_CHECKID_MAA_SF[$g_cid]=""; fi
    elif [[ `echo $check_components|grep -ic "MAA"` -ge 1 ]] && [[ $is_exadata_dom0_machine -eq "1" || $is_ssc_globalzone_machine -eq 1 ]]
    then
       G_CHECKID_MAA_SF[$g_cid]=$SF
       if [ "$SF" != "SOFTWARE MAINTENANCE BEST PRACTICES" ]; then G_CHECKID_MAA_SF[$g_cid]=""; fi
    elif [[ `echo $cch_cname|grep -ic "System is not exposed"` -ge 1  || `echo $cch_cname|grep -ic "System is exposed"` -ge 1 || `echo $cch_cname|grep -ic "DB01-DB04"` -ge 1 || `echo $cch_cname|grep -ic "System may be exposed"` -ge 1 ]]
    then
      if [[ -n "$maa_scorecard" && $maa_scorecard -eq 0 ]] ; then
        G_CHECKID_MAA_SF[$g_cid]=""
      else
        if [ $cch_status = "PASS" ]
	then
	  NO_WRITE_PASS=1;
	  G_CHECKID_MAA_SF[$g_cid]=""
	else 
	  G_CHECKID_MAA_SF[$g_cid]='SOFTWARE MAINTENANCE BEST PRACTICES'
	fi
      fi
    else
      G_CHECKID_MAA_SF[$g_cid]=""
    fi
  else
    G_CHECKID_MAA_SF[$g_cid]=""
  fi

  CID_HTML_REPFILE="$OUTPUTDIR/$cch_check_id.html"
  #G_CHECKIDS[$g_cch_cnt]=$cch_check_id
  G_CHECKID_INFO[$g_cid]="${cch_cname}"
  G_CHECKID_TYPE[$g_cid]="$g_type"
  G_CHECKID_STATUS[$g_cid]="$cch_status:$1" # Some INFO can be PASS.. So we store INFO:PASS

  # Append host names for each each
  if [ -z "${G_CHECKID_HOSTS[$g_cid]}" ]
  then
    G_CHECKID_HOSTS[$g_cid]="$g_hosts"
  else
    G_CHECKID_HOSTS[$g_cid]="${G_CHECKID_HOSTS[$g_cid]}, $g_hosts";
  fi

  # Append host names for each each
  if [ -z "${G_CHECKID_HOSTS_PASSED[$g_cid]}" ]
  then
    G_CHECKID_HOSTS_PASSED[$g_cid]="$g_hosts_passed"
  else
    G_CHECKID_HOSTS_PASSED[$g_cid]="${G_CHECKID_HOSTS_PASSED[$g_cid]}, $g_hosts_passed";
  fi

  # Save for use in write_output_to_html. These varibales are unset before we call function
  G_SOURCEFIL_REPORT="$SOURCEFIL_REPORT"
  G_SOURCEFIL_REPORT_NEW="$SOURCEFIL_REPORT_NEW"
}

# Additional details on a check are stored in a <checkid>.html as discussed before.
# The information needs to be written only once for each check.
# Output:
#   <checkid>.html  - temporary files.. deleted after creating raccheck.html
create_checkid_html ()
{
  if [[ $1 = "PASS" && -n "$print_pass_in_report" && $print_pass_in_report -eq "0" ]] ; then return; fi
  if [ ! -e "$CID_HTML_REPFILE" ]
  then
    set_ignore_sf_name;
    if [[ $COMTYPE = "OS_PARAM" || $COMTYPE = "OS_PACKAGE" || $COMTYPE = "OS_PATCH" || $COMTYPE = "SQL_PARAM" ]]
    then
      if [ -n "$PARAM_NAME" ] ; then p_name=$PARAM_NAME; else p_name=$PARAM_PATH; fi
      cch_check_name="Check for parameter $p_name"
    elif [[ $COMTYPE = "ORACLE_PATCH" ]]
    then
      if [ -n "$PARAM_NAME" ] ; then p_name=$PARAM_NAME; else p_name=$PARAM_PATH; fi
      cch_check_name="Check ORACLE_PATCH $p_name for $HOME_PATH home"
    else
      cch_check_name=$(echo $audit_check_name|sed 's/\[DBMV2]//g')
    fi

    echo "<hr>" >> $CID_HTML_REPFILE
    echo "<a name=\"${cch_check_id}_details\"></a>" >> $CID_HTML_REPFILE
    echo "<a href=\"#${cch_check_id}_summary\" class=\"a_bgw\">Top</a><br>" >> $CID_HTML_REPFILE
    echo "<h3>${cch_check_name}</h3>" >> $CID_HTML_REPFILE
    echo "<table width=800 summary="Summary of audit check and SF" role="presentation">" >> $CID_HTML_REPFILE
    if [[ $ignore_sf_name -eq "0" ]] ; then
      echo "<tr><td>Success Factor</td><td>${SF}</td></tr>" >> $CID_HTML_REPFILE
    fi
    #cch_onfail=$(echo $ONFAIL | sed 's/</&lt;/g' | sed 's/>/&gt;/g' | sed 's/ /&nbsp;/g' | sed 's/\n/<br>/g')
    cch_onfail=$(echo "$ONFAIL" | sed 's/</\&lt;/g' | sed 's/>/\&gt;/g' | sed 's/\n/<br>/g' )
    cch_onfail="<pre>$cch_onfail</pre>";
    echo "<tr><td scope=\"row\">Recommendation</td><td scope=\"row\">$cch_onfail</td></tr>" >> $CID_HTML_REPFILE
    # Write links and close table.
    if [ ! -z "$G_LINKS" ] ; then
      echo "<tr><td scope=\"row\">Links</td><td scope=\"row\"><ul>$G_LINKS</ul></td></tr>" >> $CID_HTML_REPFILE
    fi;
    # At this point we don't know all hosts where check was run. So just create a placeholder
    # which is replaced with actual host names before writing rachcheck.html
    echo "<tr><td scope=\"row\"><a name=\"${cch_check_id}_machines\"></a>Needs attention on</td><td scope=\"row\">PLACEHOLDER_TO_REPLACE_FAIL</td></tr>" >> $CID_HTML_REPFILE
    echo "<tr><td scope=\"row\"></a>Passed on</td><td>PLACEHOLDER_TO_REPLACE_PASS</td></tr>" >> $CID_HTML_REPFILE
    echo "</table>" >> $CID_HTML_REPFILE

    generate_recommendations_xml "${cch_check_id}" "$cch_onfail" "$G_LINKS"
  fi
  unset G_LINKS
}

show_file ()
{
  sfh_id=$(echo $G_SOURCEFIL_REPORT | awk -F"/" '{print $NF}' | sed 's/\./_/g')
  sfh_hosts="$g_hosts"
  sfh_suffix="$cch_check_id"

  if [[ -n "$parse_passed_list" && $parse_passed_list -eq "1" ]]
  then
    sfh_hosts="$g_hosts_passed"
    sfh_suffix=$cch_check_id"_passed"
  fi

  sfh_suffix=$RANDOM
  echo "<a name=\"${sfh_id}_more_text${sfh_suffix}_a\"></a>" >> $CID_HTML_REPFILE

  echo "<div id=\"${sfh_id}_more_text${sfh_suffix}\" class='scrollc'>" >> $CID_HTML_REPFILE
  old_IFS=$IFS
  IFS=$'\n'

  sed 's/<!-- HTML OUTPUT -->//' ${G_SOURCEFIL_REPORT} >> $CID_HTML_REPFILE

  IFS=$old_IFS
  echo "</div>" >> $CID_HTML_REPFILE
  echo "</div><a id=\"${sfh_id}_more_text${sfh_suffix}_mh\" class=more_less_style onclick=\"javascript:ExpandContract('${sfh_id}_more_text$sfh_suffix')\" href=\"javascript:;\" >Click for more data</a>" >> $CID_HTML_REPFILE
}

# Show the contents of .out file.
# If the file has more than $G_OUT_LINES (default 20) lines (excluding blank lines), 
#  show a more link and truncate rest of contents
# div id for hidden region will be <filename>_more_text
# id for more/hide link is <filename>_more_text_mh
# In file name replace "." with "_"

show_file_in_html_perl ()
{
    perl_exe=$(which perl| tr -d '\r');
    $perl_exe - -f "$G_SOURCEFIL_REPORT" -o "$CID_HTML_REPFILE" -c "$sfh_rcnt" -i "$sfh_id" -x "$sfh_suffix" -h "$sfh_hosts" -w "$wh_hosts" -l "$G_OUT_LINES" -n "$woh_line_cnt" <<PERLEOF
	use strict;
	use warnings;
	
	use Getopt::Long;
	
	my (\$SOURCEFILE);
	my (\$SFH_RCNT);
	my (\$SFH_HOSTS);
	my (\$WH_HOSTS);
	my (\$CID_HTML_REPFILE);
	my (\$SFH_ID);
	my (\$SFH_SUFFIX);
	my (\$G_OUT_LINES)       = 20;
	my (\$WOH_LINE_CNT);
	
	sub usage {
	    print "Usage: \$0 -f SOURCEFILE -o CID_HTML_REPFILE -c SFH_CNT -i SFH_ID -x SFH_SUFFIX -h SFH_HOSTS -w WH_HOSTS -l G_OUT_LINES -n WOH_LINE_CNT\n";
	    exit;
	}
	
	GetOptions(
	    "f=s" => \\\$SOURCEFILE,
	    "o=s" => \\\$CID_HTML_REPFILE,
	    "c=n" => \\\$SFH_RCNT,
	    "i=s" => \\\$SFH_ID,
	    "x=s" => \\\$SFH_SUFFIX,
	    "h=s" => \\\$SFH_HOSTS,
	    "w=s" => \\\$WH_HOSTS,
	    "l=n" => \\\$G_OUT_LINES,
	    "n=n" => \\\$WOH_LINE_CNT,
	) or usage();
	
	my (\$SFH_DINDEX)        = 0;
	my (\$SFH_INDEX)         = 0;
	my (\$SFH_SHOW_LINE)     = 1;
	my (\$SFH_DISPLAY_MORE)  = 0;
	
	open( my \$FH, "<", "\$SOURCEFILE" ) or die "Cannot open \$SOURCEFILE: \$!";
	open( my \$CHR, ">>", "\$CID_HTML_REPFILE" ) or die "Cannot open \$CID_HTML_REPFILE: \$!";
	while(my \$sfh_line = <\$FH>) {
		chomp(\$sfh_line);
	        my (\$sfh_lined) =       \$sfh_line;
	        \$sfh_lined =~ s/TO REVIEW COLLECTED //;
	        \$sfh_lined =~ s/>/\&gt;/g;
	        \$sfh_lined =~ s/</\&lt;/g;
	
	        my (\$SFH_MNAME);
	        my (\$INST_NAME);
	
	        if ( \$SFH_RCNT > 1 && \$sfh_line =~ m/TO REVIEW COLLECTED DATA/i ) {
	            if ( \$sfh_line =~ m/ DATABASE -/i or \$sfh_line =~ m/ ORACLE_HOME -/i ) {
	                \$SFH_MNAME      = (split ' ', \$sfh_line)[7];
	            }
	            else {
	                \$SFH_MNAME      = (split ' ', \$sfh_line)[5];
	            }
	
	            if ( \$SFH_HOSTS =~ m/\$SFH_MNAME/i ) {
	                \$SFH_SHOW_LINE  = 1;
	            }
	            else {
	                \$SFH_SHOW_LINE  = 0;
	            }
	
	            if ( \$sfh_line =~ m/ DATABASE_HOME -/i or \$sfh_line =~ m/DATABASE_HOME - TIMESTEN/i ) {
	                \$SFH_MNAME      = (split ' ', \$sfh_line)[7];
	                if ( \$sfh_line =~ m/BI_INSTANCE -/i ) {
	                    if ( \$WH_HOSTS =~ m/\$SFH_MNAME:/i ) {
	                        \$INST_NAME      = (split ' ', \$sfh_line)[10];
	                        if ( \$WH_HOSTS =~ m/\$INST_NAME/i ) {
	                            \$SFH_SHOW_LINE  = 1;
	                        }
	                        else {
	                            \$SFH_SHOW_LINE  = 0;
	                        }
	                    }
	                    else {
	                        \$SFH_SHOW_LINE = 0;
	                    }
	                }
	                else {
	                    if ( \$WH_HOSTS =~ m/\$SFH_MNAME\$/i ) {
	                        \$SFH_SHOW_LINE  = 1;
	                    }
	                    else {
	                        \$SFH_SHOW_LINE  = 0;
	                    }
	                }
	            }
	        }
	
	        if ( \$SFH_SHOW_LINE == 1 ) {
	            if ( \$SFH_DINDEX == \$G_OUT_LINES ) {
	                print \$CHR "<div id=\$SFH_ID" . '_more_text' . \$SFH_SUFFIX . ' style="DISPLAY: none">' . "\n";
	
	                \$SFH_DISPLAY_MORE = 1;
	            }
	            print \$CHR "\$sfh_lined"."\n";
	
	            \$SFH_DINDEX++;
	        }
	        \$SFH_INDEX++;
	
	        if ( \$SFH_INDEX >= \$WOH_LINE_CNT && \$SFH_DINDEX > \$G_OUT_LINES && \$SFH_DISPLAY_MORE == 1 ) {
	            print \$CHR qq{</div><a id="\$SFH_ID} . qq{_more_text\$SFH_SUFFIX} . qq{_mh" class=more_less_style onclick="javascript:ShowHide('} . qq{\$SFH_ID} . qq{_more_text\$SFH_SUFFIX')" href="javascript:;">Click for more data</a>\n};
	        }
	
	}
	close(\$CHR);
	close(\$FH);
PERLEOF
}

show_file_in_html ()
{
  sfh_index=0
  sfh_dindex=0
  sfh_show_line=1
  sfh_id=$(echo $G_SOURCEFIL_REPORT | awk -F"/" '{print $NF}' | sed 's/\./_/g')
  sfh_display_more=0

  sfh_hosts="$g_hosts"
  sfh_suffix="$cch_check_id"
  if [[ -n "$parse_passed_list" && $parse_passed_list -eq "1" ]]
  then
    sfh_hosts="$g_hosts_passed"
    sfh_suffix=$cch_check_id"_passed"
  fi

  sfh_suffix=$RANDOM

  sfh_rcnt=$(grep -ic "TO REVIEW COLLECTED" $G_SOURCEFIL_REPORT)
  if [ "$COMTYPE" = "CLUSTERWIDE_CHECK" ] ; then  sfh_rcnt=0; fi;

  echo "<a name=\"${sfh_id}_more_text${sfh_suffix}_a\"></a>" >> $CID_HTML_REPFILE

  if [[ -z $RAT_NO_SHOW_FILE ]]
  then
    show_file_in_html_perl
    return;
  fi

  old_IFS=$IFS
  IFS=$'\n'

  while read sfh_line
  do
    sfh_lined=$(echo "$sfh_line" | sed 's/TO REVIEW COLLECTED //' | sed 's/>/\&gt;/g' | sed 's/</\&lt;/g')

    if [[ $sfh_rcnt -gt "1" && `echo "$sfh_line" | grep -ic "TO REVIEW COLLECTED DATA"` -gt 0 ]]
    then # Multiple o/p in a single file
      if [[ `echo "$sfh_line" | grep -ic " DATABASE -"` -gt "0" || `echo "$sfh_line" | grep -ic " ORACLE_HOME -"` -gt "0" ]]
      then # by db/instance/oracle_home name
        sfh_mname=$(echo "$sfh_line" | awk '{print $8}')
      else # by host name
        sfh_mname=$(echo "$sfh_line" | awk '{print $6}')
      fi
      if [[ `echo $sfh_hosts | grep -icw $sfh_mname` -gt 0 ]]
      then # Its from failed host
        sfh_show_line=1
      else # Its not from failed host
        sfh_show_line=0
      fi
      #-------------------------TimesTen
      if [[ `echo "$sfh_line" | grep -ic " DATABASE_HOME -"` -gt "0" || `echo "$sfh_line" | grep -ic "DATABASE_HOME - TIMESTEN"` -gt "0" ]]
      then
        sfh_mname=$(echo "$sfh_line" | awk '{print $8}')
	if [[ `echo "$sfh_line" | grep -ic "BI_INSTANCE -"` -gt "0" ]]
	then
	  if [[ `echo "$wh_hosts" |  grep -ic "$sfh_mname:"` -gt "0" ]]
          then
	    inst_name=$(echo "$sfh_line" | awk '{print $11}')
	    if [[ `echo "$wh_hosts" |  grep -ic "$inst_name"` -gt "0" ]]
	    then
	      sfh_show_line=1
	    else
	      sfh_show_line=0	
	    fi
	  else
            sfh_show_line=0
	  fi  
	else
	  if [[ `echo "$wh_hosts" |  grep -ic "$sfh_mname$"` -gt "0" ]]
          then
            sfh_show_line=1
	  else
            sfh_show_line=0
	  fi  
	fi     
      fi      
      #-------------------------
    fi
    if [ $sfh_show_line -eq "1" ]
    then
      if [[ $sfh_dindex -eq $G_OUT_LINES ]]
      then # After $G_OUT_LINES lines are displayed, hide rest of lines
        echo "<div id=\"${sfh_id}_more_text$sfh_suffix\" style=\"DISPLAY: none\">" >> $CID_HTML_REPFILE
        sfh_display_more=1
      fi

      echo "$sfh_lined" >> $CID_HTML_REPFILE
      let sfh_dindex=$sfh_dindex+1
    fi

    let sfh_index=$sfh_index+1
    # sfh_index may not be visible outside while.. so below workaround
    if [[ $sfh_index -ge $woh_line_cnt && $sfh_dindex -gt $G_OUT_LINES && $sfh_display_more -eq 1 ]]
    then
      echo "</div><a id=\"${sfh_id}_more_text${sfh_suffix}_mh\" class=more_less_style onclick=\"javascript:ShowHide('${sfh_id}_more_text$sfh_suffix')\" href=\"javascript:;\" >Click for more data</a>" >> $CID_HTML_REPFILE
    fi
  done < ${G_SOURCEFIL_REPORT}
  IFS=$old_IFS

  # Alternatives
  # 1. cat ${G_SOURCEFIL_REPORT} >> $CID_HTML_REPFILE
  # 2. a.txt has 48 lines. then
  # head -20 a.txt > 1.txt
  # Display div
  # tail -28 readme.txt >> 1.txt
  # Close div
}

# Append the .out file contents  to <checkid>.html from each run for the check.
write_output_to_html ()
{
  wh_status="$1"
  parse_passed_list=0
  wh_hosts=$g_hosts

  if [[ $wh_status = "PASS" && -n "$print_pass_in_report" && $print_pass_in_report -eq "0" ]] ; then return; fi

  if [ ! -e "$CID_HTML_REPFILE" ]
  then # OS_PACKAGE does not print from appendix. So create_checkid_html was never called
    echo "<hr><br>" >> $CID_HTML_REPFILE
    echo "<a name=\"${cch_check_id}_details\"></a>" >> $CID_HTML_REPFILE
    echo "<a href=\"#${cch_check_id}_summary\" class=\"a_bgw\">Top</a><br>" >> $CID_HTML_REPFILE
  fi

  if [[ `echo ${G_SOURCEFIL_REPORT} |grep -ic "$CHECK_ID.html"` -gt 0 ]] ; then
    # just append contents
    lines=$(grep -n -w "Status on $sl_hosts" ${G_SOURCEFIL_REPORT} | cut -d":" -f1 | head -1)
    if [ -z "$lines" ] ; then lines=0; fi;
    tlines=$(wc -l ${G_SOURCEFIL_REPORT}| awk '{print $1}')
    lines_to_tail=$(expr $tlines - $lines)
    lines_to_tail=$(expr $lines_to_tail + 1)
    #tail -$lines_to_tail ${G_SOURCEFIL_REPORT} >> $CID_HTML_REPFILE
    tail -$lines_to_tail ${G_SOURCEFIL_REPORT} > ${G_SOURCEFIL_REPORT}.tailed
    if [[ `grep -ic "<b>Status on" ${G_SOURCEFIL_REPORT}.tailed` -gt 1 ]] ; then
      hlines=$(grep -n "<b>Status on" ${G_SOURCEFIL_REPORT}.tailed | cut -d":" -f1 |head -2 |tail -1)
      hlines=$(expr $hlines - 1)    
      
      if [[ -n "$MERGEFILES" && -z "$sl_hosts" ]]; then
        head -$hlines ${G_SOURCEFIL_REPORT}.tailed > $CID_HTML_REPFILE
      else
        head -$hlines ${G_SOURCEFIL_REPORT}.tailed >> $CID_HTML_REPFILE
      fi
    else
      if [[ -n "$MERGEFILES" && -z "$sl_hosts" ]]; then
        cat ${G_SOURCEFIL_REPORT}.tailed > $CID_HTML_REPFILE
      else
        cat ${G_SOURCEFIL_REPORT}.tailed >> $CID_HTML_REPFILE
      fi
    fi
    #rm -f ${G_SOURCEFIL_REPORT}
    return;
  fi

  if [[ -n "$g_hosts_passed" && $wh_status = "PASS" ]]
  then # On cells when check passed on all cells
    wh_hosts=$g_hosts_passed
    parse_passed_list=1
  fi

  show_full_file=1
  if [[ `echo $COMTYPE | grep -ic "PARAM"` -gt 0 ]]
  then
    show_full_file=0
  fi

  if [[  $COMTYPE = "OS_PACKAGE" || $COMTYPE = "OS_PATCH" ]]
  then
    show_full_file=0
  fi
  if [[ "$PARAM_PATH" = "UNSPECIFIED" ]]
  then
    show_full_file=1
  fi

  if [ -e "${G_SOURCEFIL_REPORT}" ]
  then
    # Write status only if there is output
    echo "<br>" >> $CID_HTML_REPFILE
    echo "<table class=\"td_output\" summary=\"Audit check output\"><tr class=\"td_output\"><td class=\"td_output\" scope=\"row\"><p class=a_bgw><b>Status on $wh_hosts</b>:<br/><span class=\"status_$wh_status\">$wh_status</span> => ${cch_cname}</p></td></tr>" >> $CID_HTML_REPFILE
    woh_line_cnt=$(cat $G_SOURCEFIL_REPORT | wc -l | sed 's/ //g')
    if [ $woh_line_cnt -gt 0 ]
    then # We dont want to show row if file is blank
      echo "<tr class=\"td_output\"><td class=\"td_output\" scope=\"row\"><pre>" >> $CID_HTML_REPFILE
      if [[ $show_full_file -eq 1 ]]
      then
        html_comment_tag=$(grep -ic '<!-- HTML OUTPUT -->' ${G_SOURCEFIL_REPORT});
        if [[ $html_comment_tag -gt 0 ]];
        then
          show_file ${G_SOURCEFIL_REPORT}
	else
          show_file_in_html ${G_SOURCEFIL_REPORT}
        fi
      else
        # When the check is about a parameter, dont display the whole file. 
        # Just grep for parameter
        #Added -w to following three grep exression becuase pfile check is displaying spfile parameters 
        woth_param=$(echo $PARAM_PATH | awk -F"|" '{print $1}') # PARAM_PATH can be like gcc|4.0.1 In such cases we only grep first token
        #echo "PARAM_PATH=$PARAM_PATH ${g_hosts}.$woth_param" >> $CID_HTML_REPFILE
        wot_param_line=$(grep -iw "${g_hosts}.$woth_param" ${G_SOURCEFIL_REPORT})
        if [ -z "$wot_param_line" ]
        then # Instance name is not added to parameter name. So grep just param name
          grep -iw "$woth_param" ${G_SOURCEFIL_REPORT} >> $CID_HTML_REPFILE
        else
          grep -iw "${g_hosts}.$woth_param" ${G_SOURCEFIL_REPORT} >> $CID_HTML_REPFILE
        fi
      fi
      echo "</pre></td></tr>" >> $CID_HTML_REPFILE
    fi # end if  $woh_line_cnt -gt 0 
    echo "</table>" >> $CID_HTML_REPFILE
  fi # end if -e $G_SOURCEFIL_REPORT

  if [[ -n "$g_hosts_passed" && $wh_status != "PASS" ]]
  then #Passed on some cells. No seperate message.
    if [ -e "${G_SOURCEFIL_REPORT}" ]
    then
      echo "<br>" >> $CID_HTML_REPFILE
      echo "<table class=\"td_output\" summary=\"Audit check output\"><tr class=\"td_output\"><td class=\"td_output\" scope=\"row\"><p class=a_bgw><b>Status on $g_hosts_passed</b>:<br/><span class=\"status_PASS\">PASS</span></p></td></tr>" >> $CID_HTML_REPFILE
      woh_line_cnt=$(cat $G_SOURCEFIL_REPORT | wc -l | sed 's/ //g')
      if [ $woh_line_cnt -gt 0 ]
      then # We dont want to show row if file is blank
        echo "<tr class=\"td_output\"><td class=\"td_output\" scope=\"row\"><pre>" >> $CID_HTML_REPFILE
        if [[ $show_full_file -eq 1 ]]
        then
          parse_passed_list=1
          html_comment_tag=$(grep -ic '<!-- HTML OUTPUT -->' ${G_SOURCEFIL_REPORT});
          if [[ $html_comment_tag -gt 0 ]];
          then
            show_file ${G_SOURCEFIL_REPORT}
	  else
            show_file_in_html ${G_SOURCEFIL_REPORT}
          fi
          parse_passed_list=0
        else
          # When the check is about a parameter, dont display the whole file. 
          # Just grep for parameter
          woth_param=$(echo $PARAM_PATH | awk -F"|" '{print $1}') # PARAM_PATH can be like gcc|4.0.1 In such cases we only grep first token
          wot_param_line=$(grep -i "${g_hosts_passed}.$woth_param" ${G_SOURCEFIL_REPORT})
          if [ -z "$wot_param_line" ]
          then # Instance name is not added to parameter name. So grep just param name
            grep -i "$woth_param" ${G_SOURCEFIL_REPORT} >> $CID_HTML_REPFILE
          else
            grep -i "${g_hosts_passed}.$woth_param" ${G_SOURCEFIL_REPORT} >> $CID_HTML_REPFILE
          fi
        fi
        echo "</pre></td></tr>" >> $CID_HTML_REPFILE
      fi # end if  $woh_line_cnt -gt 0 
      echo "</table>" >> $CID_HTML_REPFILE
    fi # end if -e $G_SOURCEFIL_REPORT
  fi
}

# Link can be like
# 1 VMM Page Replacement Tuning - http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.prftungd/doc/prftungd/values_minperm_maxperm_param.htm
# 2 Virtual Memory Mgmt -Tuning Parameter: lru_file_repage (PDF) - http://www-03.ibm.com/support/techdocs/atsmastr.nsf/5cb5ed706d254a8186256c71006d2e0a/125bda8fe26e45008625718000719309/$FILE/LruFileRepage.pdf
# 3 Optimizing AIX 5L performance: Tuning your memory settings - http://www.ibm.com/developerworks/aix/library/au-aixoptimization-memtun1/index.html?ca=drs-
# 4 Note: 811293.1 - RAC Starter Kit (AIX) - 
#
# When there is a http://, just create text before that as a link to http url.
# When there is a note, link like below
#      https://support.oracle.com/CSP/main/article?cmd=show&type=NOT&id=<noteid>
append_links_html ()
{
  if [[ $1 = "PASS" && -n "$print_pass_in_report" && $print_pass_in_report -eq "0" ]] ; then return; fi

  # Remove the first digit
  alh_link=$(echo $LINK | sed 's/^[0-9]* //')
  if [[ `echo "$alh_link" | grep -ic "http:"` -ge 1 ]]
  then # Link exists in variable
    alh_link_text=$(echo $alh_link | sed 's/http:.*//'| sed 's/- *$//')
    alh_link_url=$(echo $alh_link | sed 's/.*http:/http:/'| sed 's/ *$//')
    alh_link="<a href=\"$alh_link_url\" target=\"_blank\">$alh_link_text</a>";
  elif [[ `echo "$alh_link" | grep -ic "https:"` -ge 1 ]]
  then # Link exists in variable
    alh_link_text=$(echo $alh_link | sed 's/https:.*//'| sed 's/- *$//')
    alh_link_url=$(echo $alh_link | sed 's/.*https:/https:/'| sed 's/ *$//')
    alh_link="<a href=\"$alh_link_url\" target=\"_blank\">$alh_link_text</a>";
  elif [[ `echo "$alh_link" | grep -ic "Note: "` -ge 1 ]]
  then # MOS Note
    alh_link_text=$(echo "$alh_link" | sed 's/[ -]*$//g')
    alh_note_id=$(echo $alh_link | sed 's/Note: *//' | awk -F"-" '{print $1}' | sed 's/ //g')
    alh_link="<a href=\"https://support.oracle.com/CSP/main/article?cmd=show&type=NOT&id=$alh_note_id\" target=\"_blank\">$alh_link_text</a>";
    #alh_link="<a href=\"https://support.oracle.com/CSP/main/article?cmd=show&type=NOT&id=${alh_note_id}&cid=${TOOL_ID}${PLA_LINE}report\" target=\"_blank\">$alh_link_text</a>";
    #alh_link="<a href=\"https://support.oracle.com/CSP/main/article?id=${alh_note_id}&cid=${TOOL_ID}${PLA_LINE}report\" target=\"_blank\">$alh_link_text</a>";
    alh_link="<a href=\"https://support.oracle.com/epmos/faces/DocumentDisplay?parent=${program_name}Report&sourceId=${PLA_LINE}&id=${alh_note_id}\" target=\"_blank\">$alh_link_text</a>";
  fi
  G_LINKS="$G_LINKS<li>$alh_link</li>"
}

get_tail_html ()
{
    # MAA
    is_maa=0
    if [ ! -z "${G_CHECKID_MAA_SF[$crh_cnt]}" ]
    then # Show in maa scorecard. Files will be SF_STATUS_
      # echo "${G_CHECKID_MAA_SF[$crh_cnt]}"
      is_maa=1
      if [ ${G_CHECKID_MAA_SF[$crh_cnt]} = "DBMACHINE X2-2 AND X2-8 AUDIT CHECKS" ]
      then # some exadata sql checks should be updated manualy
        G_CHECKID_MAA_SF[$crh_cnt]="DATA CORRUPTION PREVENTION BEST PRACTICES"
      fi

      maa_msg=$(echo "${G_CHECKID_INFO[$crh_cnt]}" | tr "[a-z]" "[A-Z]")
      maa_sf_uc=$(echo ${G_CHECKID_MAA_SF[$crh_cnt]} |tr "[a-z]" "[A-Z]")
      maa_sfname=$(echo ${G_CHECKID_MAA_SF[$crh_cnt]} |  sed 's/[^a-zA-Z0-9]//g')
      if [ $maa_msg = $maa_sf_uc ]
      then # The SF = MSG. dont display view.
        if [ ! -e "${OUTPUTDIR}/${maa_sfname}_TOP.html" ]
        then
          MAA_IDS[$maa_id]=$maa_sfname
          let maa_id=$maa_id+1
        fi
        CHECK_ID=${G_CHECKIDS[$crh_cnt]}
        LINKNUM=`grep -c _$CHECK_ID-LINK $REFFIL1`
        BEGPAT="_$CHECK_ID-BEGIN_COMMENTS"
        ENDPAT="_$CHECK_ID-END_COMMENTS"
        ONFAIL=`sed -n /$BEGPAT/,/$ENDPAT/p $REFFIL1 |sed s/$BEGPAT//g | sed s/$ENDPAT//g |sed 's/ / /g'`
        PLA_LINE=`grep "_"$CHECK_ID"-PLA_LINE"" " $REFFIL1 | sed -n 's/.*-PLA_LINE//p' | sed 's/^\s*//g' | sed 's/\s*$//g'`
        if [ $LINKNUM -gt 0 ]
        then
          unset G_LINKS
          for ((j=1;j<=$LINKNUM;j+=1));
          do
            LINK=`grep "_"$CHECK_ID"-LINK"$j" " $REFFIL1 |sed  -n 's/.*-LINK//p'`
            append_links_html "INFO"
          done
          if [ ! -z "$G_LINKS" ] ; then
            ONFAIL="<b>Description</b><br>$ONFAIL<br><b>Best Practices</b><br><ul>$G_LINKS</ul>"
          fi
        fi

        echo "<tr><td colspan=7 scope=\"row\">.</td></tr>" > ${OUTPUTDIR}/${maa_sfname}_TOP.html
        echo "<tr><td valign=center rowspan=PLACEHOLDER_TO_REPLACE>${G_CHECKID_MAA_SF[$crh_cnt]}</td><td name='checkid' style='DISPLAY: none'></td><td scope=\"row\">PLACEHOLDER_STATUS</td><td colspan=4><pre>$ONFAIL</pre></td></tr>" >> ${OUTPUTDIR}/${maa_sfname}_TOP.html
      else # Normal message
        maa_ofile="${maa_sfname}_${chk_status}_SF.html"
        if [ ! -e "${OUTPUTDIR}/$maa_ofile" ]
        then
          MAA_IDS[$maa_id]=$maa_sfname
          let maa_id=$maa_id+1
        fi
        echo "<tr><td name='checkid' style='DISPLAY: none'>${G_CHECKIDS[$crh_cnt]}</td><td><input id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('maasctbl_${crh_rep_prefix}', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status</td><td>${G_CHECKID_TYPE[$crh_cnt]}</td><td scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td>$crh_hosts</td><td><a href=\"#${G_CHECKIDS[$crh_cnt]}_details\">View</a></td></tr>" >> ${OUTPUTDIR}/$maa_ofile
      fi
    fi

    if [ -z "${G_CHECKIDS[$crh_cnt]}" ]; then continue; fi;
    if [[ $is_maa -eq "0" && `echo ${G_CHECKID_STATUS[$crh_cnt]} | grep -ic "PASS"` -ge 1 ]]
    then # Passed check
      if [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${gg_id}.prf"` -gt 0 ]]
      then
        gg_cnt=1
        gg_type='PASS'
        if [ ! -r "${OUTPUTDIR}/GG_${gg_type}.html" ]; then
                touch "${OUTPUTDIR}/GG_${gg_type}.html"
        fi
        echo "<tr><td name='checkid' style='DISPLAY: none'>${G_CHECKIDS[$crh_cnt]}</td><td><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('passedtbl_goldengate', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status</td><td>${G_CHECKID_TYPE[$crh_cnt]}</td><td scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td>$crh_hosts</td><td><a href=\"#${G_CHECKIDS[$crh_cnt]}_details\">View</a></td></tr>" >> ${OUTPUTDIR}/GG_${gg_type}.html
      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${corroborate_id}.prf"` -gt 0 ]]
      then
        corroborate_cnt=1
        corroborate_type='PASS'
        if [ ! -r "${OUTPUTDIR}/CORROBORATE_${corroborate_type}.html" ]; then
          touch "${OUTPUTDIR}/CORROBORATE_${corroborate_type}.html"
        fi
        echo "<tr><td name='checkid' style='DISPLAY: none'>${G_CHECKIDS[$crh_cnt]}</td><td><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('passedtbl_corroborate', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status</td><td>${G_CHECKID_TYPE[$crh_cnt]}</td><td scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td>$crh_hosts</td><td><a href=\"#${G_CHECKIDS[$crh_cnt]}_details\">View</a></td></tr>" >> ${OUTPUTDIR}/CORROBORATE_${corroborate_type}.html
      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${platinum_id}.prf"` -gt 0 ]]
      then
        platinum_cnt=1
        platinum_type='PASS'
        if [ ! -r "${OUTPUTDIR}/PLATINUM_${platinum_type}.html" ]; then
          touch "${OUTPUTDIR}/PLATINUM_${platinum_type}.html"
        fi
        echo "<tr><td name='checkid' style='DISPLAY: none'>${G_CHECKIDS[$crh_cnt]}</td><td><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('passedtbl_platinum', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status</td><td>${G_CHECKID_TYPE[$crh_cnt]}</td><td scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td>$crh_hosts</td><td><a href=\"#${G_CHECKIDS[$crh_cnt]}_details\">View</a></td></tr>" >> ${OUTPUTDIR}/PLATINUM_${platinum_type}.html
      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${ebs_id}.prf"` -gt 0 ]]
      then
        ebs_cnt=1
        ebs_type='PASS'
        if [ ! -r "${OUTPUTDIR}/EBS_${ebs_type}.html" ]; then
          touch "${OUTPUTDIR}/EBS_${ebs_type}.html"
        fi
        echo "<tr><td name='checkid' style='DISPLAY: none'>${G_CHECKIDS[$crh_cnt]}</td><td><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('passedtbl_ebs', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status</td><td>${G_CHECKID_TYPE[$crh_cnt]}</td><td scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td>$crh_hosts</td><td><a href=\"#${G_CHECKIDS[$crh_cnt]}_details\">View</a></td></tr>" >> ${OUTPUTDIR}/EBS_${ebs_type}.html
      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${em_id}.prf"` -gt 0 ]]
      then
        em_cnt=1
        em_type='PASS'
        if [ ! -r "${OUTPUTDIR}/EM_${em_type}.html" ]; then
          touch "${OUTPUTDIR}/EM_${em_type}.html"
        fi
        echo "<tr><td name='checkid' style='DISPLAY: none'>${G_CHECKIDS[$crh_cnt]}</td><td><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('passedtbl_em', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status</td><td>${G_CHECKID_TYPE[$crh_cnt]}</td><td scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td>$crh_hosts</td><td><a href=\"#${G_CHECKIDS[$crh_cnt]}_details\">View</a></td></tr>" >> ${OUTPUTDIR}/EM_${em_type}.html
      else
        if [ ! -r "${OUTPUTDIR}/PASS_${crh_rep_prefix}.html" ]
        then # Write the header
          if [[ -n "$crh_rep_ptext_h" ]] ; then crh_rep_ptext=$crh_rep_ptext_h; fi;
          if [[ -n "$crh_rep_ptext_h" ]] ; then crh_rep_ptext=$crh_rep_ptext_h; fi;
          cat > ${OUTPUTDIR}/PASS_${crh_rep_prefix}.html <<EOF
             <a name="passed_checks_${crh_rep_prefix}"></a>
             <H2>$crh_rep_ptext</h2>
             <table border=1 id="passedtbl_${crh_rep_prefix}" summary="Passed checks">
             <tr><th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
             <th scope="col">Status</th>
             <th scope="col">Type</th>
             <th scope="col">Message</th>
             <th scope="col">Status On</th>
             <th scope="col">Details</th></tr>
EOF
        fi
        echo "<tr><td name='checkid' style='DISPLAY: none'>${G_CHECKIDS[$crh_cnt]}</td><td><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('passedtbl_${crh_rep_prefix}', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status</td><td>${G_CHECKID_TYPE[$crh_cnt]}</td><td scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td>$crh_hosts</td><td><a href=\"#${G_CHECKIDS[$crh_cnt]}_details\">View</a></td></tr>" >> ${OUTPUTDIR}/PASS_${crh_rep_prefix}.html
      fi
    elif [ $is_maa -eq "0" ]
    then
      # Split the checks into different html files to sort the table based on severity
      if [[ $chk_status = "ERROR" || $chk_status = "FAIL" || $chk_status = "WARNING" || $chk_status = "INFO" ]]
      then
        if [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${gg_id}.prf"` -gt 0 ]]
        then
          gg_cnt=1
          if [[ "$chk_status" = "ERROR" ]]; then gg_type="ERROR";
          elif [[ "$chk_status" = "FAIL" ]]; then gg_type="FAIL";
          elif [[ "$chk_status" = "WARNING" ]]; then gg_type="WARNING";
          elif [[ "$chk_status" = "INFO" ]]; then gg_type="INFO";
          fi
        elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${corroborate_id}.prf"` -gt 0 ]]
        then
          corroborate_cnt=1
          if [[ "$chk_status" = "ERROR" ]]; then corroborate_type="ERROR";
          elif [[ "$chk_status" = "FAIL" ]]; then corroborate_type="FAIL";
          elif [[ "$chk_status" = "WARNING" ]]; then corroborate_type="WARNING";
          elif [[ "$chk_status" = "INFO" ]]; then corroborate_type="INFO";
          fi
        elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${platinum_id}.prf"` -gt 0 ]]
        then
          platinum_cnt=1
          if [[ "$chk_status" = "ERROR" ]]; then platinum_type="ERROR";
          elif [[ "$chk_status" = "FAIL" ]]; then platinum_type="FAIL";
          elif [[ "$chk_status" = "WARNING" ]]; then platinum_type="WARNING";
          elif [[ "$chk_status" = "INFO" ]]; then platinum_type="INFO";
          fi
        elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${ebs_id}.prf"` -gt 0 ]]
        then
          ebs_cnt=1
          if [[ "$chk_status" = "ERROR" ]]; then ebs_type="ERROR";
          elif [[ "$chk_status" = "FAIL" ]]; then ebs_type="FAIL";
          elif [[ "$chk_status" = "WARNING" ]]; then ebs_type="WARNING";
          elif [[ "$chk_status" = "INFO" ]]; then ebs_type="INFO";
          fi
        elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${em_id}.prf"` -gt 0 ]]
        then
          em_cnt=1
          if [[ "$chk_status" = "ERROR" ]]; then em_type="ERROR";
          elif [[ "$chk_status" = "FAIL" ]]; then em_type="FAIL";
          elif [[ "$chk_status" = "WARNING" ]]; then em_type="WARNING";
          elif [[ "$chk_status" = "INFO" ]]; then em_type="INFO";
          fi
        else
          crh_file_name="${OUTPUTDIR}/${chk_status}_${crh_rep_prefix}.html"
        fi
      else
        if [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${gg_id}.prf"` -gt 0 ]]
        then
          gg_cnt=1
          gg_type="OTHER"
        elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${corroborate_id}.prf"` -gt 0 ]]
        then
          corroborate_cnt=1
          corroborate_type="OTHER"
        elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${platinum_id}.prf"` -gt 0 ]]
        then
          platinum_cnt=1
          platinum_type="OTHER"
        elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${ebs_id}.prf"` -gt 0 ]]
        then
          ebs_cnt=1
          ebs_type="OTHER"
        elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${em_id}.prf"` -gt 0 ]]
        then
          em_cnt=1
          em_type="OTHER"
        else
          crh_file_name="${OUTPUTDIR}/OTHER_${crh_rep_prefix}.html"
        fi
      fi

      if [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${gg_id}.prf"` -gt 0 ]]
      then
        if [ ! -r "${OUTPUTDIR}/GG_${gg_type}.html" ]; then
          touch "${OUTPUTDIR}/GG_${gg_type}.html"
        fi
        echo "<tr><td name='checkid' style='DISPLAY: none'>${G_CHECKIDS[$crh_cnt]}</td><td><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('failedtbl_goldengate', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status</td><td>${G_CHECKID_TYPE[$crh_cnt]}</td><td scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td>$crh_hosts</td><td><a href=\"#${G_CHECKIDS[$crh_cnt]}_details\">View</a></td></tr>" >> ${OUTPUTDIR}/GG_${gg_type}.html
      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${corroborate_id}.prf"` -gt 0 ]]
      then
        if [ ! -r "${OUTPUTDIR}/CORROBORATE_${corroborate_type}.html" ]; then
          touch "${OUTPUTDIR}/CORROBORATE_${corroborate_type}.html"
        fi
        echo "<tr><td name='checkid' style='DISPLAY: none'>${G_CHECKIDS[$crh_cnt]}</td><td><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('failedtbl_corroborate', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status</td><td>${G_CHECKID_TYPE[$crh_cnt]}</td><td scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td>$crh_hosts</td><td><a href=\"#${G_CHECKIDS[$crh_cnt]}_details\">View</a></td></tr>" >> ${OUTPUTDIR}/CORROBORATE_${corroborate_type}.html
      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${platinum_id}.prf"` -gt 0 ]]
      then
        if [ ! -r "${OUTPUTDIR}/PLATINUM_${platinum_type}.html" ]; then
          touch "${OUTPUTDIR}/PLATINUM_${platinum_type}.html"
        fi
        echo "<tr><td name='checkid' style='DISPLAY: none'>${G_CHECKIDS[$crh_cnt]}</td><td><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('failedtbl_platinum', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status</td><td>${G_CHECKID_TYPE[$crh_cnt]}</td><td scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td>$crh_hosts</td><td><a href=\"#${G_CHECKIDS[$crh_cnt]}_details\">View</a></td></tr>" >> ${OUTPUTDIR}/PLATINUM_${platinum_type}.html
      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${ebs_id}.prf"` -gt 0 ]]
      then
        if [ ! -r "${OUTPUTDIR}/EBS_${ebs_type}.html" ]; then
          touch "${OUTPUTDIR}/EBS_${ebs_type}.html"
        fi
        echo "<tr><td name='checkid' style='DISPLAY: none'>${G_CHECKIDS[$crh_cnt]}</td><td><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('failedtbl_ebs', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status</td><td>${G_CHECKID_TYPE[$crh_cnt]}</td><td scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td>$crh_hosts</td><td><a href=\"#${G_CHECKIDS[$crh_cnt]}_details\">View</a></td></tr>" >> ${OUTPUTDIR}/EBS_${ebs_type}.html
      elif [[ `grep -ic "${G_CHECKIDS[$crh_cnt]}|" "$SCRIPTPATH/.cgrep/profiles/${em_id}.prf"` -gt 0 ]]
      then
        if [ ! -r "${OUTPUTDIR}/EM_${em_type}.html" ]; then
          touch "${OUTPUTDIR}/EM_${em_type}.html"
        fi
        echo "<tr><td name='checkid' style='DISPLAY: none'>${G_CHECKIDS[$crh_cnt]}</td><td><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('failedtbl_em', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status</td><td>${G_CHECKID_TYPE[$crh_cnt]}</td><td scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td>$crh_hosts</td><td><a href=\"#${G_CHECKIDS[$crh_cnt]}_details\">View</a></td></tr>" >> ${OUTPUTDIR}/EM_${em_type}.html
      else
        echo "<tr><td name='checkid' style='DISPLAY: none'>${G_CHECKIDS[$crh_cnt]}</td><td><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('failedtbl_${crh_rep_prefix}', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status</td><td>${G_CHECKID_TYPE[$crh_cnt]}</td><td scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td>$crh_hosts</td><td><a href=\"#${G_CHECKIDS[$crh_cnt]}_details\">View</a></td></tr>" >> $crh_file_name
      fi
    fi
    let g_tr_index=$g_tr_index+1
}

# Display only $G_HOST_CNT hosts and display more link
# When all hosts, then display All
# Output:
#   $crh_hosts with html for displaying in summary table
get_host_string_html ()
{
  ghs_cid="A${G_CHECKIDS[$crh_cnt]}"
  ghs_status=$(eval echo \${$ghs_cid})

  el_prefix=""
  ghs_ctype=""
  crh_rep_ptext_h=""
  crh_rep_prefix="compute" # Compute node check is default
  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
  then
    crh_rep_ptext="Compute Node"
    if [[ -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" ]] ; then
      crh_first_host=$1
      el_prefix=$2
      #crh_first_host=$(echo ${G_CHECKID_HOSTS[$crh_cnt]} | awk -F"," '{print $1}')
      #crh_second_host=$(echo ${G_CHECKID_HOSTS[$crh_cnt]} | awk -F"," '{print $2}')
      #get_el_prefix "$crh_first_host"
      #el_prefix_first=$el_prefix
      #if [[ -n "$crh_second_host" && $el_prefix_first != "CN" ]] ; then
      #  get_el_prefix "$crh_second_host"
      #  if [[ $el_prefix_first = "PC" && $el_prefix = "PC" ]] ; then
      #    el_prefix="PC"
      #  else
      #    el_prefix="CS"
      #  fi
      #fi
      if [[ $el_prefix = "DB" ]] ; then
        crh_rep_ptext="Control DB Node"
      elif [[ $el_prefix = "EC" ]] ; then
        crh_rep_ptext="Enterprise Controller"
      elif [[ $el_prefix = "PC" ]] ; then
        crh_rep_ptext="Proxy Controller"
      elif [[ $el_prefix = "OVMM" ]] ; then
        crh_rep_ptext="OVM Manager Node"
      elif [[ $el_prefix = "CS" ]] ; then
        crh_rep_ptext="Control vServer"
      fi
      if [[ $el_prefix != "CN" ]] ; then
        crh_rep_prefix="cvserver"
        crh_rep_ptext_h="Control vServer"
        ghs_status="2"
      fi
    fi
    if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "1" ]]
    then
      crh_rep_ptext="Guest VM";
    fi    
  elif [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq "1" ]] ; then
    crh_rep_ptext="Compute Node"
  elif [[ -n "$is_bda_machine" && $is_bda_machine -eq 1 ]] ; then
    crh_rep_ptext="Compute Node"
  else
    crh_rep_ptext="Database Server"
  fi

  case ${G_CHECKID_TYPE[$crh_cnt]} in
  "Storage Server Check")
                       ghs_ctype="Storage Servers"
                       crh_rep_prefix="cell" 
                       crh_rep_ptext="Storage Server"
                       ;;
  "ZFS Storage Appliance Check")
                       ghs_ctype="ZFS Storage Appliances"
                       crh_rep_prefix="zfscell" 
                       crh_rep_ptext="ZFS Storage Appliance"
                       ;;
  "Switch Check")
                       ghs_ctype="Infiniband Switches"
                       crh_rep_prefix="switch" 
                       crh_rep_ptext="Infiniband Switch"
                       ;;
  "OS Check")
                       ghs_ctype="${crh_rep_ptext}s"
                       ;;
  "Database Check"|"SQL Check")
                       ghs_ctype="Databases"
                       ;;
  "Patch Check")
                       ghs_ctype="Homes"
                       ;;
  "ORACLE_HOME Check")
                       ghs_ctype="ORACLE_HOME's"
                       ;;
  "ASM Check")
                       ghs_ctype="ASM Instances"
                       ;;
  "SQL Parameter Check")
                       ghs_ctype="Instances"
                       ;;
  esac

  tmp_crh_hosts=""
  par_match=0
  if [ $ghs_status -eq "2" ]
  then
    #exalogic hybrid(virtual + physical division)
    if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
    then
      if [[ ! -z "$phy_nodes" ]] && [[ $crh_rep_prefix = "compute" ]]
      then
        tmp_crh_hosts=$(echo "${G_CHECKID_HOSTS[$crh_cnt]}"|sed 's/ //g')
        if [[ "$tmp_crh_hosts" = "$phy_nodes" ]] 
	then
          crh_hosts="All Physical Compute Nodes"
        else
	  phy_cnt=0
	  
	  tmp_ifs=$IFS
	  IFS=$',';
	  for ind_phy_node in `echo "$phy_nodes"`
	  do
	    if [ `echo "$tmp_crh_hosts"|grep -icw "$ind_phy_node"` -gt 0 ]
	    then
	      phy_cnt=1
	    fi
	  done
	  IFS=$tmp_ifs

	  if [ $phy_cnt -eq 1 ]
	  then
	     par_match=1	
	  else
	     if [[ "$tmp_crh_hosts" = "$exa_vcomp_list" ]]
	     then 
	       crh_hosts="All Virtual Compute Nodes"
	     else
	       par_match=1	
	     fi
	  fi
        fi
      else
        par_match=1
      fi
    else
      par_match=1
    fi
    if [ $par_match -eq 1 ]
    then
      ghs_cnt=$(echo ${G_CHECKID_HOSTS[$crh_cnt]} | awk -F"," '{print NF}')
      if [ $ghs_cnt -gt $G_HOST_CNT ]
      then
        crh_host_names=$(echo ${G_CHECKID_HOSTS[$crh_cnt]} | cut -d"," -f"1-5") #First 5 hosts
        crh_hosts="<a href=\"#${G_CHECKIDS[$crh_cnt]}_machines\" title=\"${G_CHECKID_HOSTS[$crh_cnt]}\">${crh_host_names}  more</a>";
      else
        crh_hosts=${G_CHECKID_HOSTS[$crh_cnt]}
      fi
    fi
  else
    if [ ${G_CHECKID_TYPE[$crh_cnt]} = "$html_rack_type Wide Check" ]
    then
      crh_hosts="$html_rack_type Wide"
      crh_rep_prefix="cluster"
      crh_rep_ptext="$html_rack_type Wide"
    else
      if [ ${G_CHECKID_TYPE[$crh_cnt]} = "System Wide Check" ]
      then
        crh_hosts="System Wide"
        crh_rep_prefix="system"
        crh_rep_ptext="System Wide"
      else
        #exalogic hybrid(virtual + physical division)
        if [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]]
	then
          crh_hosts=${G_CHECKID_HOSTS[$crh_cnt]}
        else
          if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
          then
            if [[ ! -z "$phy_nodes" ]] && [[ $crh_rep_prefix = "compute" ]]
	    then
              tmp_crh_hosts=$(echo "${G_CHECKID_HOSTS[$crh_cnt]}"|sed 's/ //g');
              if [ `echo "$tmp_crh_hosts"|grep -ic "$phy_nodes"` -gt 0 ]
	      then
		if [[ "$tmp_crh_hosts" = "$phy_nodes" ]] 
		then
		  crh_hosts="All Physical Compute Nodes"
		else
		  crh_hosts="All Compute Nodes"
		fi
              else
                phy_match_cnt=0
	  	tmp_ifs=$IFS
		IFS=$',';
                for exa_phy_node in `echo "$phy_nodes"`
                do
                  if [ `echo "$tmp_crh_hosts"|grep -icw "$exa_phy_node"` -gt 0 ]
	     	  then 
	       	    phy_match_cnt=1 
		  fi
                done
		IFS=$tmp_ifs

                if [[ $phy_match_cnt -eq 0 ]]
                then
                  crh_hosts="All Virtual Compute Nodes"
                else
                  ghs_cnt=$(echo ${G_CHECKID_HOSTS[$crh_cnt]} | awk -F"," '{print NF}')
                  if [ $ghs_cnt -gt $G_HOST_CNT ]
                  then
                    crh_host_names=$(echo ${G_CHECKID_HOSTS[$crh_cnt]} | cut -d"," -f"1-5")
                    crh_hosts="<a href=\"#${G_CHECKIDS[$crh_cnt]}_machines\" title=\"${G_CHECKID_HOSTS[$crh_cnt]}\">${crh_host_names}  more</a>";
                  else
                    crh_hosts=${G_CHECKID_HOSTS[$crh_cnt]}
                  fi
                fi
              fi
            else
              crh_hosts="All $ghs_ctype"
            fi
          else
            crh_hosts="All $ghs_ctype"
          fi
        fi
      fi
    fi
  fi
}

# Below function writes a row report directly to the <status>.html which later gets appended
# to raccheck.html. Some cluster-wide-checks does not use log_fail infrastructure. 
# This function is called in such cases. Status on is always "All" as its cluster-wide-check
# Input:
#    Status (FAIL/PASS etc)
#    Message (Actual message)
# Output:
#    <status>.html
write_cwc_status_html ()
{
  wts_status=$1
  wts_msg=$2

  if [[ $wts_status = "PASS" ]]
  then
    if [ ! -r "${OUTPUTDIR}/PASS_cluster.html" ]
    then # Write the header
      cat > ${OUTPUTDIR}/PASS_cluster.html <<EOF
           <a name="passed_checks_cluster"></a>
           <H2>$html_rack_type Wide</h2>
           <table border=1 id="passedtbl_cluster" summary="Clusterwide checks">
           <tr><th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
           <th scope="col">Status</th>
           <th scope="col">Type</th>
           <th scope="col">Message</th>
           <th scope="col">Status On</th>
           <th scope="col">Details</th></tr>
EOF
    fi

    echo "<tr><td name='checkid' style='DISPLAY: none'>-</td><td><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('passedtbl_cluster', this,'')\">$wts_status</td><td>$html_rack_type Wide Check</td><td scope=\"row\">$wts_msg</td><td>$html_rack_type Wide</td><td>-</td></tr>" >> ${OUTPUTDIR}/PASS_cluster.html
  else
    if [[ $wts_status = "ERROR" || $wts_status = "FAIL" || $wts_status = "WARNING" || $wts_status = "INFO" ]]
    then
      wts_file_name="${OUTPUTDIR}/${wts_status}_cluster.html"
    else
      wts_file_name="${OUTPUTDIR}/OTHER_cluster.html"
    fi
    echo "<tr><td name='checkid' style='DISPLAY: none'>-</td><td><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('failedtbl_cluster', this,'')\">$wts_status</td><td>$html_rack_type Wide Check</td><td scope=\"row\">$wts_msg</td><td>$html_rack_type Wide</td><td>-</td></tr>" >> $wts_file_name
  fi
  let g_tr_index=$g_tr_index+1
}

# This function creates the raccheck.html file by appending all the <checkid>.html files
# Output:
#   raccheck.html
create_raccheck_html ()
{
  crh_obname=$(basename $OUTPUTDIR)
  HTML_REPFILE=${OUTPUTDIR}/${crh_obname}.html 
  HTML_PASS_FILE=${OUTPUTDIR}/passed_checks.html
  HTML_FAILED_FILE=${OUTPUTDIR}/failed_checks.html
  HTML_MAA_SC=${OUTPUTDIR}/maa_scorecard.html
  TOOL_NAME=$program_name

  if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] || [[ -n "$is_ssc_machine" && $is_ssc_machine -eq 1 ]]; then
    #Generate Infrastructure Software and Configuration Summary
    chmod 544 $SCRIPTPATH/.cgrep/isc_summary.pl >/dev/null 2>&1
    $perl_exe $SCRIPTPATH/.cgrep/isc_summary.pl -o ${OUTPUTDIR} -n ${OUTPUTDIR}/o_host_list.out -c ${CELLDIR}/cells.out -s ${OUTPUTDIR}/o_ibswitches.out
  fi

  if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
  then
    SYSTEM_NAME="Exadata"
    if [[ "$is_avm_machine" &&  $is_avm_machine -eq 1 ]]; then SYSTEM_NAME="Recovery Appliance";fi
    if [ -e "$OUTPUTDIR/check_env.out" ]
    then
      MASTERFIL1=$OUTPUTDIR/check_env.out
    else
      MASTERFIL1=$OUTPUTDIR/raccheck_env.out
    fi
    if [ -n "$MERGEFILES" ]
    then
      MASTERFIL1=$NEW_MASTERFIL1;
    fi
    #Generate Version Matrix (in MAA Section)
    chmod 544 $SCRIPTPATH/.cgrep/create_version.pl >/dev/null 2>&1
    if [[ $OFFLINE -eq 1 ]];
    then
      $perl_exe $SCRIPTPATH/.cgrep/create_version.pl ${OUTPUTDIR} ${OUTPUTDIR} ${MASTERFIL1}
    else
      $perl_exe $SCRIPTPATH/.cgrep/create_version.pl ${OUTPUTDIR} ${INPUTDIR} ${MASTERFIL1}
    fi 
  elif [[ -n "$oda_machine" && $oda_machine -eq 1 ]]
  then
    SYSTEM_NAME="Database Appliance"
  elif [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]]
  then
    SYSTEM_NAME="Exalogic"
  elif [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]]
  then
    SYSTEM_NAME="Exalytics"
  elif [[ -n "$single_instance_run" && $single_instance_run -eq 1 ]]
  then
    #report header change as requested by Support for EBS
    SYSTEM_NAME=${program_name}
  elif [[  -n "$is_bda_machine" && $is_bda_machine -eq 1 ]]
  then
    SYSTEM_NAME="Big Data Appliance"
  else
    SYSTEM_NAME="RAC"
  fi

  if [[ -n "$upgrade_mode" && $upgrade_mode -gt 0 ]]
  then
    report_type="Upgrade Readiness"
  else
    report_type="Assessment"
  fi

  # System Health Score
  let crh_failed_checks=$G_FAIL_CHECKS+$G_WARN_CHECKS+$G_INFO_CHECKS+$G_SKIP_CHECKS
  #let crh_failed_checks=$G_FAIL_CHECKS+$G_WARN_CHECKS+$G_INFO_CHECKS
  let crh_passed_checks=$G_TOTAL_CHECKS-$crh_failed_checks

  if [ -n "$MERGEFILES" ]
  then
    if [ -e "$CELLIBNTFILE" ]
    then
      up_cell_ib_fail_count=$(grep 'FAIL' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
      up_cell_ib_warn_count=$(grep 'WARN' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
      up_cell_ib_info_count=$(grep 'INFO' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
      up_cell_ib_total_count=$(grep 'TOTAL' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
      
      let cell_ib_failed_checks=$up_cell_ib_fail_count+$up_cell_ib_warn_count+$up_cell_ib_info_count
      let crh_failed_checks=$crh_failed_checks+$cell_ib_failed_checks
      let crh_passed_checks=$crh_passed_checks+$up_cell_ib_total_count-$cell_ib_failed_checks
      let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+$up_cell_ib_total_count; 
      validate_needs_running;
    fi
  fi
  
  echo "TOTAL=$G_TOTAL_CHECKS
PASS=$crh_passed_checks
FAIL=$G_FAIL_CHECKS
WARN=$G_WARN_CHECKS
INFO=$G_INFO_CHECKS
SKIP=$G_SKIP_CHECKS" > $CHECKSFILE;

  zfscnt=0
  ibscnt=0
  cncount=0
  dbserverscnt=0
  elsnodecnt=0
  cells_cnt=0
  
  if [ -e "$ZFSIP" ]
  then
    zfscnt=$(cat $ZFSIP|wc -l)
  fi
  
  if [ -e "$OUTPUTDIR/o_ibswitches.out" ]
  then
    ibscnt=$(cat $OUTPUTDIR/o_ibswitches.out|wc -l)
  fi
  
  get_dbserverscnt;
  
  if [ -e "$CELLDIR/cells.out" ]
  then
    cells_cnt=$(cat $CELLDIR/cells.out|wc -l)
  fi
  let cncount=$dbserverscnt+$cells_cnt+$elsnodecnt

  if [ $zfscnt -ne 0 ]
  then  
    G_CELL=$(echo "$G_CELL/$zfscnt" | bc);
  fi
  if [ $ibscnt -ne 0 ] 
  then
    G_SWITCH=$(echo "$G_SWITCH/$ibscnt" | bc);
  fi
  if [ $cncount -ne 0 ] 
  then
    if [ $is_windows -eq "1" ] ; then
      G_COMPUTE=$(perl -e "printf \"%.0f\", $G_COMPUTE/$cncount;")
    else
      #G_COMPUTE=$(echo "$G_COMPUTE/$cncount" | bc);
      let G_COMPUTE=$G_COMPUTE/$cncount;
    fi
  fi
  
 # Score reduction due to Skipped components 
 if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]  
 then
   if [[ -e "$OUTPUTDIR/${program_name}_skipped_nodes_txt.log" ]] ; then
     for nodeval in `cat $OUTPUTDIR/${program_name}_skipped_nodes_txt.log`
     do
       if [[ -e $WRKDIR/o_storage.out && `grep -iwc "$nodeval" $WRKDIR/o_storage.out` -gt "0" ]]
       then
         let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+$G_CELL;
         let G_FAIL_CHECKS=$G_FAIL_CHECKS+$G_CELL;
       elif [[ -e $WRKDIR/o_ibswitches.out && `grep -iwc "$nodeval" $WRKDIR/o_ibswitches.out` -gt "0" ]]
       then
         let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+$G_SWITCH;
         let G_FAIL_CHECKS=$G_FAIL_CHECKS+$G_SWITCH;
       else
         let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+$G_COMPUTE;
         let G_FAIL_CHECKS=$G_FAIL_CHECKS+$G_COMPUTE;
       fi
     done
    fi
  fi

  let crh_total_points=$G_TOTAL_CHECKS*10
 
  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]]; then
    let crh_err_points=$G_FAIL_CHECKS*10+$G_WARN_CHECKS*5+$G_INFO_CHECKS_SCORE*3+$G_SKIP_CHECKS*10
  else
    let crh_err_points=$G_FAIL_CHECKS*10+$G_WARN_CHECKS*5+$G_INFO_CHECKS_SCORE*3+$G_SKIP_CHECKS*3
  fi
  #let crh_err_points=$G_FAIL_CHECKS*10+$G_WARN_CHECKS*5+$G_INFO_CHECKS*3+$G_SKIP_CHECKS*3
  #let crh_err_points=$G_FAIL_CHECKS*10+$G_WARN_CHECKS*5+$G_INFO_CHECKS*3

  let crh_less_points=$crh_total_points-$crh_err_points
  crh_health=0
  crh_health_int=0
  crh_health_text="";
  if [[ $crh_total_points -gt "0" && `echo $components|grep -icw EXALOGIC_VM` -lt 1 ]]
  then
    #crh_health=$(echo "scale=0;($crh_less_points*100)/$crh_total_points" | bc)
    #crh_health_int=$(echo "($crh_less_points*100)/$crh_total_points" | bc)
    crh_health=$(perl -e "printf \"%.0f\", ($crh_less_points*100)/$crh_total_points;")
    crh_health_int=$(perl -e "printf \"%.0f\", ($crh_less_points*100)/$crh_total_points;")
    crh_health_text="";
  fi

  crh_bar_color="#00FF00" # Green.. everything is passed
  if [[ -n "$crh_health_int" &&  $crh_health_int -lt 75 ]]
  then # less than 75.. bad condition
    crh_bar_color="#FF0000"
  elif [[ $crh_health_int -ge 75 && $crh_health_int -lt 85 ]]
  then # Better.. dark orange
    crh_bar_color="#FF6600"
  elif [[ $crh_health_int -ge 85 && $crh_health_int -lt 100 ]]
  then # Better.. dark orange
    crh_bar_color="#FF9933"
  fi
  # Number of nodes in cluster by type
  dbservers_cnt=0
  cells_cnt=0
  ibs_cnt=0
  zfs_cnt=0
  dbservers_link=""
  cells_link=""
  ibs_link=""
  ogg_homes_link=""

  # Cluster, platform details are read from end file in offline mode
  if [ -e "$OUTPUTDIR/check_env.out" ]
  then
    MASTERFIL1=$OUTPUTDIR/check_env.out
  else
    MASTERFIL1=$OUTPUTDIR/raccheck_env.out
  fi
  if [ -n "$MERGEFILES" ]
  then
    MASTERFIL1=$NEW_MASTERFIL1;
    #rm $HOSTLIST
    HOSTLIST=$WRKDIR/.MERGED_COLLECTIONS/o_host_list.out.merge

    single_instance_run=`grep SINGLE_INSTANCE_RUN $MASTERFIL1 | awk '{print $3}'` 
    oracle_restart=`grep ORACLE_RESTART $MASTERFIL1 | awk '{print $3}'`
  fi

  el_db_node=""
  el_ec1_node=""
  el_ovmm_node=""
  el_pc_nodes=""
  el_pc1_node=""
  el_pc2_node=""
  el_exclude=""
  if [[ -n "$in_ec_exalogic" &&  $in_ec_exalogic -eq "1" ]] ;then
    el_db_node=$(grep '\.COMPONENT = .*EXALOGIC_DB' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u| sed 's/ //g')
    el_ec1_node=$(grep '\.COMPONENT = .*EXALOGIC_EC' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u| sed 's/ //g')
    el_ovmm_node=$(grep '\.COMPONENT = .*EXALOGIC_OVMM' $MASTERFIL1 |sed 's/\.COMPONENT.*//' | sort -u| sed 's/ //g')
    el_pc_nodes=$(grep '\.COMPONENT = .*EXALOGIC_PC' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u| sed 's/ //g')
    el_pc1_node=$(grep '\.COMPONENT = .*EXALOGIC_PC' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u | head -1| sed 's/ //g')
    el_pc2_node=$(grep '\.COMPONENT = .*EXALOGIC_PC' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u | tail -1| sed 's/ //g')
  fi

  if [ -e "$HOSTLIST" ]
  then
    dbservers_cnt=0
    p_dbservers_cnt=0
    v_dbservers_cnt=0
    el_snode_cnt=0
    exa_vcomp_list=""
    #for hostname in `cat $HOSTLIST |grep "[a-zA-Z0-9]" `
    for hostname in `grep "[a-zA-Z0-9]" $HOSTLIST`
    do
      db_server_component=""	
      if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
      then
        #db_server_component=`grep -iw COMPONENTS $MASTERFIL1 |grep $hostname|cut -d= -f2|cut -d: -f1|sed 's/^\s//g'|sed 's/\s$//g'`
        db_server_component=`grep -iw COMPONENTS $MASTERFIL1 |grep -w $hostname|cut -d= -f2|cut -d: -f1|sed 's/ //g'`
        if [[ -n "$db_server_component" ]]
        then
	  if [[ "$db_server_component" = "NONE" ]]
	  then
	    #db_server_component=`grep -iw COMPONENTS $MASTERFIL1 |grep $hostname|cut -d: -f2|sed 's/^\s//g'|sed 's/\s$//g'`
	    db_server_component=`grep -iw COMPONENTS $MASTERFIL1 |grep -w $hostname|cut -d: -f2|sed 's/ //g'`
	  fi

          if [[ "$db_server_component" = "EXADATA" ]]
          then
            db_server_component="V2"
          elif [[ "$db_server_component" = "EDVM" ]]
          then
	      db_server_component="Exadata VM Guest"  
          elif [[ $(echo "$db_server_component"|grep -ic VMX) -ge 1 ]]
          then 
              db_server_component=$(echo $db_server_component|sed 's/VM/DOM0 /g')
          fi
          db_server_component=' : '$db_server_component
        fi
      fi
	
      if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "1" ]] 
      then
	skipnode=`grep LOCALNODE $MASTERFIL1 |awk '{print $3}'`
        if [ $hostname = $skipnode ]
        then
          continue
        fi
      fi

      if [[  -n "$in_ec_exalogic" &&  $in_ec_exalogic -eq "1" ]] ; then
        if [[ $hostname != $el_db_node && $hostname != $el_ec1_node && $hostname != $el_ovmm_node && `grep -ic "$hostname\.COMPONENT.*EXALOGIC_PC" $MASTERFIL1` -eq "0" ]] ; then
          dbservers_cnt=$(expr $dbservers_cnt + 1);

	  is_it_physical_node=0	
	  if [ ! -z "$phy_nodes" ]
          then
	    if [ `echo "$phy_nodes"|grep -ic "$hostname"` -gt 0 ]
	    then
	      is_it_physical_node=1	
	    else
	      exa_vcomp_list=$exa_vcomp_list,$hostname
	    fi
	    
	    if [[ -n "$is_it_physical_node" && $is_it_physical_node -eq "1" ]]
            then
              p_dbservers_cnt=$(expr $p_dbservers_cnt + 1);
	      p_dbservers_link="<br>&nbsp;&nbsp;${hostname}${p_dbservers_link}"
	    else
              v_dbservers_cnt=$(expr $v_dbservers_cnt + 1);
              v_dbservers_link="<br>&nbsp;&nbsp;${hostname}${v_dbservers_link}" 
	    fi
	  else
	    dbservers_link="<br>&nbsp;&nbsp;${hostname}${dbservers_link}"
	  fi
        else
          el_snode_cnt=$(expr $el_snode_cnt + 1)
        fi
      else
        dbservers_cnt=$(expr $dbservers_cnt + 1);
        dbservers_link="<br>&nbsp;&nbsp;${hostname}${db_server_component}${dbservers_link}" 
      fi
    done
    exa_vcomp_list=$(echo "$exa_vcomp_list"|sed 's/^,//g'|sed 's/,$//g')

    if [ ! -z "$phy_nodes" ]
    then
      p_dbservers_link="<a href=\"javascript:ShowHideRegion('p_dbservers_summary');\">$p_dbservers_cnt</a><div id=\"p_dbservers_summary\" style=\"DISPLAY: none\">$p_dbservers_link<a href=\"javascript:ShowHideRegion('p_dbservers_summary');\"> ..Hide</a></div>"
      v_dbservers_link="<a href=\"javascript:ShowHideRegion('v_dbservers_summary');\">$v_dbservers_cnt</a><div id=\"v_dbservers_summary\" style=\"DISPLAY: none\">$v_dbservers_link<a href=\"javascript:ShowHideRegion('v_dbservers_summary');\"> ..Hide</a></div>"

      phy_node_dlink=""
      vir_node_dlink=""
      if [ $p_dbservers_cnt != "0" ];
      then
        phy_node_dlink="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Physical Compute Nodes</td><td>$p_dbservers_link</td></tr>"
      fi
      if [ $v_dbservers_cnt != "0" ];
      then
        vir_node_dlink="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Virtual Compute Nodes</td><td>$v_dbservers_link</td></tr>"
      fi
      dbservers_link="$dbservers_cnt"
    else
      dbservers_link="<a href=\"javascript:ShowHideRegion('dbservers_summary');\">$dbservers_cnt</a><div id=\"dbservers_summary\" style=\"DISPLAY: none\">$dbservers_link<a href=\"javascript:ShowHideRegion('dbservers_summary');\"> ..Hide</a></div>"
    fi
  fi
  if [ $dbservers_cnt = "0" ]
  then
    dbservers_link="0"
  fi
  #print goldengate homes and version in report header 
  if [[ -e $OGGHOMESVERSIONFIL && `cat $OGGHOMESVERSIONFIL|wc -l` -gt 0 ]];
  then
      ogg_home_count=0
      for mb_ogg_home_full in `cat  $OGGHOMESVERSIONFIL`
      do
        ogg_home_node=$(echo $mb_ogg_home_full|cut -d'|' -f1|cut -d= -f2)
        ogg_home_home=$(echo $mb_ogg_home_full|cut -d'|' -f2)
        ogg_home_version=$(echo $mb_ogg_home_full|cut -d'|' -f3)
        l_version=$ogg_home_version
        format_l_version 
        ogg_home_all=$(echo $ogg_home_node - $ogg_home_home - $l_version)
        ogg_homes_link="<br>&nbsp;&nbsp;${ogg_home_all}${ogg_homes_link}"
        ogg_home_count=$(expr $ogg_home_count + 1 )
      done     
      ogg_homes_link="<a href=\"javascript:ShowHideRegion('ogg_homes_summary');\">$ogg_home_count</a><div id=\"ogg_homes_summary\" style=\"DISPLAY: none\">$ogg_homes_link<a href=\"javascript:ShowHideRegion('ogg_homes_summary');\"> ..Hide</a></div>"
  else
      ogg_homes_link="0"
  fi 

  if [ -n "$MERGEFILES" ]
  then
    cell_password_status=$(grep CELL_PASSWORD_OPTION $MASTERFIL1 |awk '{print $3}')
    ibswitch_password_status=$(grep IBSWITCH_PASSWORD_OPTION $MASTERFIL1 |awk '{print $3}')	
    zfs_password_status=$(grep ZFS_PASSWORD_OPTION $MASTERFIL1 |awk '{print $3}')	

    #storagecells
    for xdir in $dirarr 
    do
      xdir=$(echo $xdir|sed 's/\.zip//g');
      cell_password_status=$(grep CELL_PASSWORD_OPTION ${xdir}/outfiles/check_env.out | awk -F"=" '{print $2}' | tr -d ' ')
      cell_ssh_user=$(grep CELL_SSH_USER ${xdir}/outfiles/check_env.out | awk -F"=" '{print $2}' | tr -d ' ')
      if [[ -n "$cell_password_status" && $cell_password_status -eq "1" ]] || [[ -n "$cell_password_status" && $cell_password_status -eq "0" && "$cell_ssh_user" = "root" ]]; then
        TCELLDIR="$xdir/.CELLDIR";
        if [[ -n "$TCELLDIR" && -e "$TCELLDIR/cells.out" ]]; then break; fi
      fi
    done

    #zfscells
    for xdir in $dirarr 
    do
      xdir=$(echo $xdir|sed 's/\.zip//g');
      zfs_password_status=$(grep ZFS_PASSWORD_OPTION ${xdir}/outfiles/check_env.out | awk -F"=" '{print $2}' | tr -d ' ')
      if [[ -n "$zfs_password_status" && $zfs_password_status -eq "1" ]]; then 
        TZFSDIR="$xdir"; 
	ZFSIP="$TZFSDIR/.CELLDIR/zfsip.ora"; if [ $is_ssc_machine -eq 1 ]; then ZFSIP=$TZFSDIR/outfiles/zfsip.ora;fi
	if [ -e "$ZFSIP" ]; then break; fi
      fi
    done
    
    #ibswitches
    for xdir in $dirarr 
    do
      xdir=$(echo $xdir|sed 's/\.zip//g');
      ibswitch_password_status=$(grep IBSWITCH_PASSWORD_OPTION ${xdir}/outfiles/check_env.out | awk -F"=" '{print $2}' | tr -d ' ')
      if [[ -n "$ibswitch_password_status" && $ibswitch_password_status -eq "1" ]]; then TIBDIR="$xdir/outfiles"; break; fi
    done
  fi

  #if [[ -n "$CELLDIR" && -e "$CELLDIR/cells.out" && -n "$cell_password_status" && $cell_password_status -ne 3  ]] || [[ -n "$CELLDIR" && -e "$CELLDIR/cells.out" && -n "$MERGEFILES" ]]
  if [[ -n "$CELLDIR" && -e "$CELLDIR/cells.out" && -n "$cell_password_status" && $cell_password_status -ne 3  ]]
  then
    cells_cnt=$(cat $CELLDIR/cells.out|wc -l)
    for cellname in `cat $CELLDIR/cells.out | awk '{print $NF}' | cut -d. -f1`
    do
      storage_server_component=""
      #cellname_short=$(cat $CELLDIR/cells.out|grep -w $cellname|cut -d= -f1|cut -d: -f1|sed 's/ //g')
      cellname_short=$(grep -w $cellname $CELLDIR/cells.out|cut -d= -f1|cut -d: -f1|sed 's/ //g')
      storage_server_component=`grep -iw COMPONENTS $MASTERFIL1 |grep -w $cellname_short|cut -d= -f2|cut -d: -f1|sed 's/ //g'`
      cells_link="<br>&nbsp;&nbsp;$cellname : $storage_server_component$cells_link"
    done
    cells_link="<a href=\"javascript:ShowHideRegion('cells_summary');\">$cells_cnt</a><div id=\"cells_summary\" style=\"DISPLAY: none\">$cells_link<a href=\"javascript:ShowHideRegion('cells_summary');\"> ..Hide</a></div>"
  fi
  cells_link="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;Storage Servers</td><td>$cells_link</td></tr>"
  if [ "$cells_cnt" = "0" ]
  then
    cells_link=""
  fi
  #code to generate links for ZFS appliances
  zfs_link=""
  if [ $is_ssc_machine -eq 1 ]; then ZFSIP=$OUTPUTDIR/zfsip.ora;fi
  if [[ -n "$CELLDIR" && -e "$ZFSIP" && -n "$zfs_password_status" && $zfs_password_status -ne 3  ]]
  then
    zfs_cnt=$(cat $ZFSIP|wc -l)
    for zfsname in `cat $ZFSIP |cut -d= -f2 |sed 's/\"//g'`
    do
      zfs_link="<br>&nbsp;&nbsp;$zfsname$zfs_link"
    done
    zfs_link="<a href=\"javascript:ShowHideRegion('zfs_summary');\">$zfs_cnt</a><div id=\"zfs_summary\" style=\"DISPLAY: none\">$zfs_link<a href=\"javascript:ShowHideRegion('zfs_summary');\"> ..Hide</a></div>"
    zfs_link="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;ZFS Storage Appliances</td><td>$zfs_link</td></tr>"
  fi

  #if [[ -n "$OUTPUTDIR/o_ibswitches.out" && -e "$OUTPUTDIR/o_ibswitches.out" && -n "$ibswitch_password_status" && $ibswitch_password_status -ne 3 ]] || [[ -n "$OUTPUTDIR/o_ibswitches.out" && -e "$OUTPUTDIR/o_ibswitches.out" && -n "$MERGEFILES" ]]
  if [[ -n "$OUTPUTDIR/o_ibswitches.out" && -e "$OUTPUTDIR/o_ibswitches.out" && -n "$ibswitch_password_status" && $ibswitch_password_status -ne 3 ]]
  then
    ibs_cnt=$(cat $OUTPUTDIR/o_ibswitches.out|wc -l)
    for switchname in `cat $OUTPUTDIR/o_ibswitches.out`
    do
      sw_pname=$switchname
      if [[ `echo $switchname | grep -ic '[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*'` -eq 0 ]] ; then
        sw_pname=$(echo $switchname |cut -d. -f1)
      fi
      ibs_link="<br>&nbsp;&nbsp;$sw_pname$ibs_link"
    done
    ibs_link="<a href=\"javascript:ShowHideRegion('ibs_summary');\">$ibs_cnt</a><div id=\"ibs_summary\" style=\"DISPLAY: none\">$ibs_link<a href=\"javascript:ShowHideRegion('ibs_summary');\"> ..Hide</a></div>"
  fi
  ibs_link="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;IB Switches</td><td>$ibs_link</td></tr>"
  if [ "$ibs_cnt" = "0" ]
  then
    ibs_link=""
  fi

  if [ -n "$MERGEFILES" ]; then
    if [[ "$cells_cnt" = "0" && -n "$cell_password_status" && $cell_password_status -ne 3  ]]; then
      cells_cnt=$(cat $TCELLDIR/cells.out|wc -l)
      for cellname in `cat $TCELLDIR/cells.out | awk '{print $NF}' | cut -d. -f1`
      do
        storage_server_component=""
        cellname_short=$(grep -w $cellname $TCELLDIR/cells.out|cut -d= -f1|cut -d: -f1|sed 's/ //g')
        storage_server_component=`grep -iw COMPONENTS $MASTERFIL1 |grep -w $cellname_short|cut -d= -f2|cut -d: -f1|sed 's/ //g'`
        cells_link="<br>&nbsp;&nbsp;$cellname : $storage_server_component$cells_link"
      done
      cells_link="<a href=\"javascript:ShowHideRegion('cells_summary');\">$cells_cnt</a><div id=\"cells_summary\" style=\"DISPLAY: none\">$cells_link<a href=\"javascript:ShowHideRegion('cells_summary');\"> ..Hide</a></div>"
      cells_link="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;Storage Servers</td><td>$cells_link</td></tr>"
      if [ "$cells_cnt" = "0" ]; then cells_link=""; fi
    fi
    if [[ "$zfs_cnt" = "0" && -n "$zfs_password_status" && $zfs_password_status -ne 3  ]]; then
      ZFSIP="$TZFSDIR/.CELLDIR/zfsip.ora"
      if [ $is_ssc_machine -eq 1 ]; then ZFSIP=$TZFSDIR/outfiles/zfsip.ora;fi
      zfs_cnt=$(cat $ZFSIP|wc -l)
      for zfsname in `cat $ZFSIP |cut -d= -f2 |sed 's/\"//g'`
      do
        zfs_link="<br>&nbsp;&nbsp;$zfsname$zfs_link"
      done
      zfs_link="<a href=\"javascript:ShowHideRegion('zfs_summary');\">$zfs_cnt</a><div id=\"zfs_summary\" style=\"DISPLAY: none\">$zfs_link<a href=\"javascript:ShowHideRegion('zfs_summary');\"> ..Hide</a></div>"
      zfs_link="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;ZFS Storage Appliances</td><td>$zfs_link</td></tr>"
  	if [ "$zfs_cnt" = "0" ]; then zfs_link=""; fi
    fi
    if [[ "$ibs_cnt" = "0" && -n "$ibswitch_password_status" && $ibswitch_password_status -ne 3 ]]; then
      ibs_cnt=$(cat $TIBDIR/o_ibswitches.out|wc -l)
      for switchname in `cat $TIBDIR/o_ibswitches.out`
      do
        sw_pname=$switchname
        if [[ `echo $switchname | grep -ic '[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*'` -eq 0 ]] ; then
          sw_pname=$(echo $switchname |cut -d. -f1)
        fi
        ibs_link="<br>&nbsp;&nbsp;$sw_pname$ibs_link"
      done
      ibs_link="<a href=\"javascript:ShowHideRegion('ibs_summary');\">$ibs_cnt</a><div id=\"ibs_summary\" style=\"DISPLAY: none\">$ibs_link<a href=\"javascript:ShowHideRegion('ibs_summary');\"> ..Hide</a></div>"
      ibs_link="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;IB Switches</td><td>$ibs_link</td></tr>"
      if [ "$ibs_cnt" = "0" ]; then ibs_link="";  fi
    fi
  fi

  merge_collection_link=""
  profile_link=""
  ex_profile_link=""

  if [ -n "$MERGEFILES" ]; then
    for xdir in $dirarr
    do
      attribute_cnt=0
      xdir=$(echo $xdir|sed 's/\.zip//g');

      unset iprofiles2run iprofiles2exclude iexecuted_hdr icollection_date_hdr icluster_hdr

      iprofiles2run=$(grep "PROFILE_NAMES =" ${xdir}/outfiles/check_env.out |grep -v "EXCLUDE"|cut -d= -f2)
      iprofiles2exclude=$(grep "EXCLUDE_PROFILE_NAMES =" ${xdir}/outfiles/check_env.out | cut -d= -f2)
      iexecuted_hdr=$(grep "CURRENT_USER =" ${xdir}/outfiles/check_env.out | cut -d= -f2)
      icollection_date_hdr=$(grep "COLLECTION DATE =" ${xdir}/outfiles/check_env.out | cut -d= -f2)
      icluster_hdr=$(grep "CLUSTER_NAME =" ${xdir}/outfiles/check_env.out | cut -d= -f2) 
      
      if [ -n "$iprofiles2run" ]; then 
	i_profile_link="<tr><td class=\"td_column\">Selected Profiles</td><td>$iprofiles2run</td></tr>"; 
	attribute_cnt=$(expr $attribute_cnt + 1); 
      fi
      if [ -n "$iprofiles2exclude" ]; then 
	i_ex_profile_link="<tr><td class=\"td_column\">Excluded Profiles</td><td>$iprofiles2exclude</td></tr>"; 
	attribute_cnt=$(expr $attribute_cnt + 1); 
      fi
      if [ -n "$iexecuted_hdr" ]; then 
	i_executed_hdr="<tr><td class=\"td_column\">Executed by</td><td>$iexecuted_hdr</td></tr>"; 
	attribute_cnt=$(expr $attribute_cnt + 1); 
      fi
      if [ -n "$icollection_date_hdr" ]; then 
	i_collection_hdr="<tr><td class=\"td_column\">Collection Date</td><td>$icollection_date_hdr</td></tr>"; 
	attribute_cnt=$(expr $attribute_cnt + 1); 
      fi
      if [[ -n $SKIP_CRS_VAL && $SKIP_CRS_VAL -eq "1" ]]; then
        if [ -n "$icluster_hdr" ]; then 
	  i_cluster_hdr="<tr><td class=\"td_column\">Cluster Name</td><td>$icluster_hdr</td></tr>"; 
	  attribute_cnt=$(expr $attribute_cnt + 1); 
	fi
      fi

      i_collection_data="${i_cluster_hdr}${i_profile_link}${i_ex_profile_link}${i_executed_hdr}${i_collection_hdr}";

      base_xdir=`basename $xdir`
      collection_name="${base_xdir}"
      attribute_cnt=$(expr $attribute_cnt + 1);

      merge_link=$merge_link"<table width=100% border=0 id=\"$collection_name\" summary=\"$collection_name\"><tr><td width=60% class=\"td_column\" rowspan=\"$attribute_cnt\">$collection_name</td>$i_collection_data</table>"
    done    
    merge_collection_link="<tr><td class=\"td_column\">Merged Collections</td><td>$merge_link</td></tr>"

    #merge_collection_link="<tr><td class=\"td_column\">Merged Collections</td><td>$collection_names</td></tr>"
    #if [ `grep "PROFILE_NAMES =" $MASTERFIL1 |grep -v "EXCLUDE"|wc -l|sed 's/ //g'` -gt 0 ] ; then
    #  profiles2run=$(grep "PROFILE_NAMES =" $MASTERFIL1 |grep -v "EXCLUDE"|cut -d= -f2) 
    #  profile_link="<tr><td class=\"td_column\">Selected Profiles</td><td>$profiles2run</td></tr>"
    #fi
    #if [ `grep "EXCLUDE_PROFILE_NAMES =" $MASTERFIL1|wc -l|sed 's/ //g'` -gt 0 ]; then 
    #  profiles2exclude=$(grep "EXCLUDE_PROFILE_NAMES =" $MASTERFIL1 | cut -d= -f2) 
    #  ex_profile_link="<tr><td class=\"td_column\">Excluded Profiles</td><td>$profiles2exclude</td></tr>"
    #fi
  else
    if [ -n "$profiles2run" ] ; then
      profile_link="<tr><td class=\"td_column\">Selected Profiles</td><td>$profiles2run</td></tr>"
    fi
    if [ -n "$profiles2exclude" ] ; then
      ex_profile_link="<tr><td class=\"td_column\">Excluded Profiles</td><td>$profiles2exclude</td></tr>"
    fi
  fi

  let nodes_cnt=$dbservers_cnt+$cells_cnt+$ibs_cnt+$el_snode_cnt+$zfs_cnt

  # db names
  if [[ -n "$db_name_to_check_none" &&  $db_name_to_check_none -eq 1 ]]
  then # User selected none
    db_cnt=0
  else
    db_cnt=${#mb_db_names[@]}
  fi

  upg_link="";
  if [[ -n "$upgrade_mode" && $upgrade_mode -eq 2 ]] 
  then
    upg_link="<tr><td class=\"td_column\">Upgrade Mode</td><td>Pre-upgrade</td></tr>";
  elif [[ -n "$upgrade_mode" && $upgrade_mode -eq 3 ]]
  then
    upg_link="<tr><td class=\"td_column\">Upgrade Mode</td><td>Post-upgrade</td></tr>";
  fi

  dbn_link=""
  if [ $db_cnt -gt "0" ]
  then
    for db_name_to_check in "${mb_db_names[@]}"
    do
      dbn_link="<br>&nbsp;&nbsp;$db_name_to_check$dbn_link"
    done
    dbn_link="<tr><td class=\"td_column\">Database Names</td><td><a href=\"javascript:ShowHideRegion('dbn_summary');\">$db_cnt</a><div id=\"dbn_summary\" style=\"DISPLAY: none\">$dbn_link<a href=\"javascript:ShowHideRegion('dbn_summary');\"> ..Hide</a></div></td></tr>"
  else
     if [[ -n "$db_name_to_check_none" &&  $db_name_to_check_none -eq 1 ]]
     then # User selected none
       dbn_link="None"
     else
       dbn_link="0"
     fi
     if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "0" ]]
     then
       dbn_link="<tr><td class=\"td_column\">Database Names</td><td>$dbn_link</td></tr>";
     else
       dbn_link=""
     fi
  fi
  
  # DB versions
  rm -f $OUTPUTDIR/mb_db_tmp.out
  mb_db_counter=0
  #for db_name_to_check in "${mb_db_names[@]}"
  #do
  #  l_version=$(grep "${mb_oracle_homes[$mb_db_counter]}" $OUTPUTDIR/mb_db_homes_versions_distinct.out|cut -d'|' -f2)
  #  format_l_version
  #  oh_version=$l_version
  #  running_instance=`grep "$node.$db_name_to_check.INSTANCE_NAME" $MASTERFIL1 |awk '{print $3}'`
  #  echo "${mb_oracle_homes[$mb_db_counter]}|${oh_version}|$db_name_to_check|$running_instance" >> $OUTPUTDIR/mb_db_tmp.out
  #  mb_db_counter=$(expr $mb_db_counter + 1)
  #done

  none_db_text="None Discovered"
  for mb_db_homes in `grep "RDBMS_ORACLE_HOME =" $MASTERFIL1 | awk -F"=" '{print $2}' | awk -F"|" '{print $1}' | sed 's/ //g'`
  do
    l_version=$(grep "RDBMS_ORACLE_HOME = $mb_db_homes" $MASTERFIL1 | awk -F"=" '{print $2}' | awk -F"|" '{print $2}' | sed 's/ //g')
    format_l_version
    oh_version=$l_version
    if [[ `grep "DB_NAME =" $MASTERFIL1 |grep $mb_db_homes | awk -F"=" '{print $2}' | awk -F"|" '{print $1}' |wc -l` -gt 0 ]]
    then
      for db_name_to_check in `grep "DB_NAME =" $MASTERFIL1 |grep $mb_db_homes | awk -F"=" '{print $2}' | awk -F"|" '{print $1}'|sed 's/ //g'`
      do
        running_instance=`grep "$node.$db_name_to_check.INSTANCE_NAME" $MASTERFIL1 |awk '{print $3}'`
        echo "$mb_db_homes|${oh_version}|$db_name_to_check|$running_instance" >> $OUTPUTDIR/mb_db_tmp.out
      done
    else
      if [[ -n "$db_name_to_check_none" &&  $db_name_to_check_none -eq 1 ]]
      then
        none_db_text="None Selected"
      fi
      if [[ -n "$db_name_to_check_all" &&  $db_name_to_check_all -eq 1 ]]
      then
        none_db_text="None Discovered"
      else
        none_db_text="None Selected"
      fi
      echo "$mb_db_homes|${oh_version}|$none_db_text|$none_db_text" >> $OUTPUTDIR/mb_db_tmp.out
    fi
  done

  db_versions=""
  mb_db_counter=0

  if [ -n "$MERGEFILES" ];
  then
    MB_DB_TMP_FIL=$WRKDIR/.MERGED_COLLECTIONS/mb_db_tmp.out.merge
  else
    MB_DB_TMP_FIL=$OUTPUTDIR/mb_db_tmp.out
  fi

  if  [ -e $MB_DB_TMP_FIL ]
  then
    for mb_oh_name in `cut -d'|' -f1  $MB_DB_TMP_FIL |sort -u`
    do
      oh_version=$(grep "$mb_oh_name" $MB_DB_TMP_FIL |cut -d'|' -f2|sort -u)
      db_cnt=$(grep "$mb_oh_name" $MB_DB_TMP_FIL |cut -d'|' -f3|sort -u|wc -l)
      if [ $db_cnt -gt 0 ]
      then
        if [ $db_cnt -gt 1 ]
        then
          running_db_line=""
          for running_db in `grep "$mb_oh_name" $MB_DB_TMP_FIL |cut -d'|' -f3|sort -u`
          do
            running_db_line="<br>&nbsp;&nbsp;$running_db$running_db_line"
          done # Finished printing db info for a OH
          dbn_link="<a href=\"javascript:ShowHideRegion('dbn_summary2_$mb_db_counter');\">$db_cnt</a><div id=\"dbn_summary2_$mb_db_counter\" style=\"DISPLAY: none\">$running_db_line<a href=\"javascript:ShowHideRegion('dbn_summary2_$mb_db_counter');\"> ..Hide</a></div>"
        else
          dbn_link=`grep "$mb_oh_name" $MB_DB_TMP_FIL |cut -d'|' -f3|sort -u`
        fi
        db_versions="${mb_oh_name} - ${oh_version} - $dbn_link<br>$db_versions";
      else
        db_versions="${mb_oh_name} - ${oh_version} - 0<br>$db_versions";
      fi
      mb_db_counter=$(expr $mb_db_counter + 1)
    done # Finished printing all homes
  fi
  mb_db_counter=0

  #db_versions=$(grep "RDBMS_ORACLE_HOME =" $MASTERFIL1 | awk -F"=" '{print $2}' | awk -F"|" '{print $1" - "$2"<br>"}'| sort -u)
  crs_home_path=$(grep "CRS_HOME =" $MASTERFIL1 | awk '{print $3}')

  if [ -z "$cluster_name" ] 
  then
    cluster_name=$(grep CLUSTER_NAME $MASTERFIL1 | awk -F"=" '{print $2}')
  fi

  if [[ -n "$el_pc_nodes" && `echo $el_pc_nodes | wc -w` -gt 1 ]]
  then
    el_pc_node_cnt=0
    for hostname in $el_pc_nodes
    do
      el_pc_node_link="<br>&nbsp;&nbsp;$hostname$el_pc_node_link"
      el_pc_node_cnt=$(expr $el_pc_node_cnt + 1)
    done
    el_pc_node_link="<a href=\"javascript:ShowHideRegion('el_pc_summary');\">$el_pc_node_cnt</a><div id=\"el_pc_summary\" style=\"DISPLAY: none\">$el_pc_node_link<a href=\"javascript:ShowHideRegion('el_pc_summary');\"> ..Hide</a></div>"
  else
    el_pc_node_link="$el_pc_nodes"
  fi

  node_heading="Database Server"
  summary_heading="Cluster Summary"
  if [[ -n "$is_bda_machine" && $is_bda_machine -eq 1 ]]
  then
    summary_heading="Big Data Appliance Rack summary"
    skipped_checks_pass=0
    node_heading="Compute Node"
    exalogic_version_link="<tr><td class=\"td_column\">Big Data Appliance Version</td><td>$bda_actual_version</td></tr><tr><td class=\"td_column\">System Identifier</td><td>$bda_identifier</td></tr>"
  elif [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]]
  then
    summary_heading="Exalogic Rack summary"
    skipped_checks_pass=0
    if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "1" ]] 
    then
      node_heading="Guest VM"
      old_ifs=$IFS;IFS=$','
      for el_guest_file in `echo "$RAT_EL_GVM"`
      do
        if [ -e "$el_guest_file" ]
        then
          vmfiles=${vmfiles}${el_guest_file}"<br>" 
        fi
      done
      IFS=$old_ifs
      ex_vm_files="<tr><td class=\"td_column\">Guest VM Files</td><td>$vmfiles</td></tr>"
    else
      node_heading="Compute Node"
    fi
    crs_hv_link=""
    asm_h_link=""
    em_h_link=""
    dbhv_link=""
    cname_link=""
    el_cs_row=""
    if [[ -n "$el_ec1_node" ]] ; then
      el_cs_row="$el_cs_row<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;Enterprise Controller</td><td>$el_ec1_node</td></tr>"
      el_cs_row="$el_cs_row<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;Control DB Node</td><td>$el_db_node</td></tr>"
      el_cs_row="$el_cs_row<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;OVM Manager Node</td><td>$el_ovmm_node</td></tr>"
      el_cs_row="$el_cs_row<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;Proxy Controllers</td><td>$el_pc_node_link</td></tr>"
    fi
    if [[ `grep -ic EXALOGIC_ACTUAL_VERSION_CN $MASTERFIL1` -gt 0 ]] ; then
      l_version=$(grep EXALOGIC_ACTUAL_VERSION_CN $MASTERFIL1 | tail -1 | awk -F"=" '{print $2}')
 
      l_version=$(echo "$l_version"|sed 's/^\s//g'|sed 's/\s$//g');
      if [ -z "$l_version" ] ; then l_version=$(grep EXALOGIC_ACTUAL_VERSION_CN $MASTERFIL1 | head -1 | awk -F"=" '{print $2}'); fi;
    else
      l_version=$exalogic_version_actual
    fi
    #format_l_version 1
    exalogic_version_link="<tr><td class=\"td_column\">Exalogic Version</td><td>$l_version</td></tr><tr><td class=\"td_column\">System Identifier</td><td>$RackIdentifier</td></tr>"
  elif [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]]
  then
    summary_heading="Exalytics System Summary"
    skipped_checks_pass=0
    node_heading="Compute Node"
    crs_hv_link=""
    asm_h_link=""
    em_h_link=""
    dbhv_link=""
    cname_link=""
    el_cs_row=""
    if [[ `grep -ic EXALYTICS_VERSION_ACTUAL $MASTERFIL1` -gt 0 ]] ; then
      l_version=$(grep EXALYTICS_VERSION_ACTUAL $MASTERFIL1 | tail -1 | awk -F"= " '{print $2}')
    else
      l_version=$exalytics_version
    fi
    #format_l_version 1
    obiee_homes_link=""
    #-------------------------TimesTen
    tt_homes_link=""
    str=""
    if [ -e "$OUTPUTDIR/mb_db_homes_distinct.out" ] ; then
      for bi_home in `cat $OUTPUTDIR/mb_db_homes_distinct.out`
      do
	match=0;
	dbs="";
	ver="";
	if [ `echo $str|grep -ic "$bi_home "` -gt 0 ]
	then
	  continue;
	else
	  str="$str $bi_home";
	fi
	mcount=0;
	for (( i=1; i<=${#ttx_home[@]};i++ ))
	do
	  if [ ${ttx_home[$i]} = $bi_home ]
	  then
	    match=1;
	    mcount=$(expr $mcount + 1)
	    dbs="$dbs<br>${ttx_dbpath[$i]}"
	    ver="${ttx_version[$i]}"
	  fi
	done
	if [ $match -eq 1 ]
	then
	  if [ $mcount -le 1 ]
	  then
	    tt_homes="$bi_home - $ver - $dbs<br>$tt_homes";
	  else
	    tstr="<a href=\"javascript:ShowHideRegion('$bi_home');\">$mcount</a><div id=$bi_home style=\"DISPLAY: none\">$dbs<a href=\"javascript:ShowHideRegion('$bi_home');\"> ..Hide</a></div>";
	    tt_homes="$bi_home - $ver - $tstr<br>$tt_homes";
	  fi
	else
	  ver=$(grep -i 'OBIEE Release Version:' $MASTERFIL| grep -i "$bi_home " | awk -F"=" '{print $2}' | sed 's/ //g');
	  obiee_homes="$bi_home - $ver<br>$obiee_homes";
	fi
      done
      if [ -n "$obiee_homes" ] ; then
	obiee_homes_link="<tr><td class=\"td_column\">OBIEE Homes - Versions</td><td>$obiee_homes</td></tr>";
      fi
      if [ -n "$tt_homes" ] ; then
        tt_homes_link="<tr><td class=\"td_column\">TimesTen Homes - Versions - Names</td><td>$tt_homes</td></tr>";
      fi
      #---------------------------------
    fi

    exalogic_version_link="<tr><td class=\"td_column\">Base Image Version</td><td>$l_version</td></tr><tr><td class=\"td_column\">System Identifier</td><td>$RackIdentifier</td></tr>"
  else
   #changed this to 0 for bug 14148335
    skipped_checks_pass=0
    exalogic_version_link=""
    el_cs_row=""
    if [[ $is_exadata_dom0_machine -eq 1 || $is_ssc_globalzone_machine -eq 1 ]]
    then
      em_h_link=""
      asm_h_link=""
      crs_hv_link=""
      dbhv_link=""
      cname_link=""
    else
      if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
        asm_h_link="<tr><td class=\"td_column\">GRID Home</td><td>$CRS</td></tr>"
      else
        asm_h_link=""
      fi

      if [ -n "$MERGEFILES" ] ; then
        for xdir in $dirarr
        do
	  xdir=$(echo $xdir|sed 's/\.zip//g');

	  if [ -z $mb_emagent_home ]; then mb_emagent_home=`grep "EMAGENT_HOME" ${xdir}/outfiles/check_env.out | awk '{print $3}'| head -1 | sed 's/ //g'`; fi
          if [[ -z "${stack_crs_version[0]}" ]]; then stack_crs_version[0]=`grep -i "CRS_ACTIVE_VERSION" ${xdir}/outfiles/check_env.out | awk '{print $3}'| head -1 | sed 's/ //g'`; fi
	  if [[ -z "$crs_home_path" ]]; then crs_home_path=`grep "CRS_HOME =" ${xdir}/outfiles/check_env.out | awk '{print $3}' | head -1 | sed 's/ //g'`; fi

   	  cluster_name=$(echo "$cluster_name"|sed 's/ //g'); 
	  if [[ -z "$cluster_name" ]]; then cluster_name=`grep "CLUSTER_NAME =" ${xdir}/outfiles/check_env.out | awk '{print $3}' | head -1 | sed 's/ //g'`; fi	  
        done
      fi

      if [ -n "$mb_emagent_home" ]
      then
        em_h_link="<tr><td class=\"td_column\">EM Agent Home</td><td>$mb_emagent_home</td></tr>"
      else
        em_h_link="";
      fi 

      crs_hv_link="<tr><td class=\"td_column\">CRS Home - Version</td><td>$crs_home_path - ${stack_crs_version[0]}</td></tr>"
      dbhv_link="<tr><td class=\"td_column\">DB Home - Version - Names</td><td>$db_versions</td></tr>"
      cname_link="<tr><td class=\"td_column\">Cluster Name</td><td>$cluster_name</td></tr>"
    fi
  fi

  if [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]]; then 
    #hosts_txt=`cat $HOSTLIST |grep "[a-zA-Z0-9]" `
    hosts_txt=`grep "[a-zA-Z0-9]" $HOSTLIST `
    node_dlink="<tr><td class=\"td_column\">${node_heading}</td><td>$hosts_txt</td></tr>"
  else
    node_slink="<tr><td class=\"td_column\">Number of nodes</td><td>$nodes_cnt</td></tr>"
    node_dlink="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;${node_heading}s</td><td>$dbservers_link</td></tr>"
  fi
  if [[ -e $OGGHOMESVERSIONFIL && `cat $OGGHOMESVERSIONFIL|wc -l` -gt 0 ]]
  then
    ogg_home_dlink="<tr><td class=\"td_column\">Oracle GoldenGate Homes</td><td>$ogg_homes_link</td></tr>"
  fi

  if [[ $single_instance_run -eq "1" ]] ; then
    node_slink=""
    hostname=`cat $HOSTLIST`;
    node_dlink="<tr><td class=\"td_column\">Database Server</td><td>$hostname</td></tr>"
  fi

  if [[ $single_instance_run -eq "1" ]] ; then
    summary_heading="Summary";
    if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
      asm_h_link="<tr><td class=\"td_column\">GRID Home</td><td>$CRS</td></tr>"
    fi
    if [ -n "$mb_emagent_home" ]
    then
      em_h_link="<tr><td class=\"td_column\">EM Agent Home</td><td>$mb_emagent_home</td></tr>"
    fi

    crs_hv_link=""
    cname_link=""
  fi;

  if [ -z "$upload_dbplatform" ]
  then
    upload_dbplatform=$(grep DB_PLATFORM $MASTERFIL1 | awk -F"=" '{print $2}' | sed 's/^\s//g' | sed 's/\s$//g') 
  fi
  if [ -z "$upload_osdistro" ] 
  then
    upload_osdistro=$(grep OS_DISTRO $MASTERFIL1 | awk -F"=" '{print $2}' | sed 's/^\s//g' | sed 's/\s$//g')
  fi
  if [ -z "$upload_oskernel" ]
  then
    upload_oskernel=$(grep OS_KERNEL $MASTERFIL1 | awk -F"=" '{print $2}' | sed 's/^\s//g' | sed 's/\s$//g')
  fi
  if [ -z "$upload_osversion" ]
  then
    upload_osversion=$(grep OS_VERSION $MASTERFIL1 | awk -F"=" '{print $2}' | sed 's/^\s//g' | sed 's/\s$//g')
  fi
  if [ -z "$collection_date" ]
  then
    collection_date=$(grep "COLLECTION DATE" $MASTERFIL1 | awk -F"=" '{print $2}' | sed 's/^\s//g' | sed 's/\s$//g')
  fi

  tool_version=$(echo $show_version_envfile | awk -F"=" '{print $2}' | sed 's/ //g')

  collection_name=$(basename "${UPLOADFIL}.zip")

  if [ -n "$MERGEFILES" ];
  then
    current_exadata_version=$(grep CURRENT_EXADATA_VERSION $MASTERFIL1 |awk '{print $3}')
  fi

  if [ -n "$current_exadata_version" ]
  then
    l_version=$current_exadata_version
    format_l_version
    cev_link="<tr><td class=\"td_column\">Exadata Version</td><td>$l_version</td></tr>"
  else
    cev_link=""
  fi

  #if [ $upgrade_mode -gt 0 ]
  if [[ $upgrade_mode -gt 0 && $upgrade_mode -lt 3 ]] || [[ "$profiles2run" = "preinstall" && $crs_up -eq 0 ]]
  then
    if [ -z "$TARGET_VERSION" ]
    then
      targetversion=$(grep "TARGET_VERSION" $MASTERFIL1 | awk -F"=" '{print $2}')
    fi
    l_version=$targetversion
    format_l_version
    tv_link="<tr><td class=\"td_column\">Target Version</td><td>$l_version</td></tr>"
  else
    tv_link=""
  fi

  cat > $HTML_REPFILE <<EOF
<html lang="en"><head>
<style type="text/css">
body {font-family: Lucida Grande,Lucida Sans,Arial,sans-serif;
    font-size: 14px;
    background:white;
}
h1 {color:black;}
h2 {color:black; background:white}
h3 {color:black; background:white}
a {color: #000000;}
p {font-family: Lucida Grande,Lucida Sans,Arial,sans-serif;
    font-size: 14px;
}
.a_bgw {
  color: #000000;
  background:white;
}

.scrollc{
        display:block;
        border: 0px;
        padding:5px;
        margin-top:5px;
        width:1500px;
        height:450px;
        overflow-y:hidden;
        }

.scrolle{
        display:block;
        border: 0px;
        padding:5px;
        margin-top:5px;
        width:1500px;
        height:100%;
        overflow-y:hidden;
        }
table {
    color: #000000;
    font-weight: bold;
    border-spacing: 0;
    outline: medium none;
font-family: Lucida Grande,Lucida Sans,Arial,sans-serif;
font-size: 14px;

}

th {
 background: #F2F5F7;
    border: 1px solid grey;
    font-size: 14px;
    font-weight: bold;
}
td {

 background: #F2F5F7;
    border: 1px solid grey;
    font-weight: normal;
    padding: 5;
}

.status_FAIL
{
    font-weight: bold;
    color: #c70303;
}
.status_WARNING
{
    font-weight: bold;
    color: #b05c1c;
}
.status_INFO
{
    font-weight: bold;
    color: blue;
}
.status_PASS
{
    font-weight: bold;
    color: #006600;
}

.td_output {
  color: #000000;
 background: white;
    border: 1px solid grey;
font-family: Lucida Grande,Lucida Sans,Arial,sans-serif;
font-size: 14px;
    font-weight: normal;
    padding: 1;
}
.td_column {
 background: #F2F5F7;
    border: 1px solid grey;
    font-size: 14px;
    font-weight: bold;
}

.td_title {

 background: #F2F5F7;
    border: 0px solid grey;
    font-weight: normal;
    padding: 5;
}

pre {
 overflow-x: auto; /* Use horizontal scroller if needed; for Firefox 2, not needed in Firefox 3 */
 white-space: pre-wrap; /* css-3 */
 white-space: -moz-pre-wrap !important; /* Mozilla, since 1999 */
 white-space: -pre-wrap; /* Opera 4-6 */
 white-space: -o-pre-wrap; /* Opera 7 */
 /* width: 99%; */
 word-wrap: break-word; /* Internet Explorer 5.5+ */
}

.shs_bar {
width: 500px ;
height: 20px ;
float: left ;
border: 1px solid #444444;
background-color: white ;
}

.shs_barfill {
height: 20px ;
float: left ;
background-color: $crh_bar_color ;
width: $crh_health% ;
}

.more_less_style {
  font-family: Lucida Grande,Lucida Sans,Arial,sans-serif;
  font-weight: bold;
  color: black;
}

</style>
<script language="JavaScript">
var report_format = "new";
function processForm()
{
    
    if (report_format == "old")
    {
        report_format = "new";
	var i;
	var bo = document.querySelectorAll("body");
        for (i = 0; i < bo.length; i++) 
        {
                bo[i].style.fontSize = "14px";
        }
	var hc1 = document.querySelectorAll("h1");
        for (i = 0; i < hc1.length; i++) 
        {
                hc1[i].style.color = "black";
        }
        var hc2 = document.querySelectorAll("h2");
	for (i = 0; i < hc2.length; i++) 
	{
		hc2[i].style.color = "black";
	}
	var hc3 = document.querySelectorAll("h3");
        for (i = 0; i < hc3.length; i++) 
        {
                hc3[i].style.color = "black";
        }
	var pf = document.querySelectorAll("p");
        for (i = 0; i < pf.length; i++) 
        {
                pf[i].style.fontSize = "14px";
        }
	var tf = document.querySelectorAll("table");
        for (i = 0; i < tf.length; i++) 
        {
                tf[i].style.fontSize = "14px";
        }
	var th = document.querySelectorAll("th");
        for (i = 0; i < th.length; i++) 
        {
                th[i].style.background = "#F2F5F7";
		th[i].style.border = "1px solid grey";
		th[i].style.fontSize = "14px";
        }
	var td = document.querySelectorAll("td");
        for (i = 0; i < td.length; i++) 
        {
                td[i].style.border = "1px solid grey";
        }
	var tdo = document.querySelectorAll(".td_output");
        for (i = 0; i < tdo.length; i++) 
        {
                tdo[i].style.background = "white";
                tdo[i].style.border = "1px solid grey";
                tdo[i].style.fontSize = "14px";
        }
	var tdc = document.querySelectorAll(".td_column");
        for (i = 0; i < tdc.length; i++) 
        {
                tdc[i].style.background = "#F2F5F7";
                tdc[i].style.border = "1px solid grey";
                tdc[i].style.fontSize = "14px";
        }
	var tdt = document.querySelectorAll(".td_title");
        for (i = 0; i < tdt.length; i++) 
        {
                tdt[i].style.border = "0px solid grey";
        }
	var shs = document.querySelectorAll(".shs_bar");
        for (i = 0; i < shs.length; i++) 
        {
                shs[i].style.background = "white";
        }
	var ml = document.querySelectorAll(".more_less_style");
        for (i = 0; i < ml.length; i++) 
        {
                ml[i].style.color = "black";
        }
	document.getElementById('results').innerHTML ="Switch to old format";

    }
    else
    {
        report_format = "old";
	var i;
	var bo = document.querySelectorAll("body");
        for (i = 0; i < bo.length; i++) 
        {
                bo[i].style.fontSize = "13px";
        }
	var hc1 = document.querySelectorAll("h1");
        for (i = 0; i < hc1.length; i++) 
        {
                hc1[i].style.color = "blue";
        }
        var hc2 = document.querySelectorAll("h2");
        for (i = 0; i < hc2.length; i++) 
        {
                hc2[i].style.color = "blue";
        }
	var hc3 = document.querySelectorAll("h3");
        for (i = 0; i < hc3.length; i++) 
        {
                hc3[i].style.color = "blue";
        }
        var pf = document.querySelectorAll("p");
        for (i = 0; i < pf.length; i++) 
        {
                pf[i].style.fontSize = "13px";
        }
	var tf = document.querySelectorAll("table");
        for (i = 0; i < tf.length; i++) 
        {
                tf[i].style.fontSize = "12px";
        }
	var th = document.querySelectorAll("th");
        for (i = 0; i < th.length; i++) 
        {
                th[i].style.background = "#D7EBF9";
                th[i].style.border = "1px solid #AED0EA";
                th[i].style.fontSize = "13px";
        }
	var td = document.querySelectorAll("td");
        for (i = 0; i < td.length; i++) 
        {
                td[i].style.border = "1px solid #AED0EA";
        }
	var tdo = document.querySelectorAll(".td_output");
        for (i = 0; i < tdo.length; i++) 
        {
                tdo[i].style.background = "#E0E0E0";
                tdo[i].style.border = "1px solid #AED0EA";
                tdo[i].style.fontSize = "13px";
        }
	var tdc = document.querySelectorAll(".td_column");
        for (i = 0; i < tdc.length; i++) 
        {
                tdc[i].style.background = "#D7EBF9";
                tdc[i].style.border = "1px solid #AED0EA";
                tdc[i].style.fontSize = "13px";
        }
	var tdt = document.querySelectorAll(".td_title");
        for (i = 0; i < tdt.length; i++) 
        {
                tdt[i].style.border = "0px solid #AED0EA";
        }
	var shs = document.querySelectorAll(".shs_bar");
        for (i = 0; i < shs.length; i++) 
        {
                shs[i].style.background = "#656565";
        }
	var ml = document.querySelectorAll(".more_less_style");
        for (i = 0; i < ml.length; i++) 
        {
                ml[i].style.color = "blue";
        }
	document.getElementById('results').innerHTML ="Switch to new format";
    }
}

function ExpandContract(divId)
{
  if(document.getElementById(divId).className == 'scrollc')
  {
    document.getElementById(divId).setAttribute('class','scrolle');
    document.getElementById(divId+'_mh').innerHTML = 'Click for less data';
  }
  else
  {
    document.getElementById(divId).setAttribute('class','scrollc')
    document.getElementById(divId + '_mh').innerHTML = 'Click for more data';
    window.location.hash = divId + '_a';
  }
}

function ShowHide(divId)
{
  if(document.getElementById(divId).style.display == 'none')
  {
    document.getElementById(divId).style.display='block';
    document.getElementById(divId+'_mh').innerHTML = 'Click for less data';
  }
   else
  {
    document.getElementById(divId).style.display = 'none';
    document.getElementById(divId + '_mh').innerHTML = 'Click for more data';
    window.location.hash = divId + '_a';
  }
}

function ShowHideRegion(divId)
{
  if(document.getElementById(divId).style.display == 'none')
  {
    document.getElementById(divId).style.display='block';
  }
   else
  {
    document.getElementById(divId).style.display = 'none';
  }
}

var showMode = 'table-cell';
if (document.all) showMode='block';
function toggleVis(btn , callid)
{
  cells = document.getElementsByName(btn);
  if(cells[0].style.display == 'none')
  {
        mode=showMode;
  }
  else
  {
        mode='none';
  }

  for(j = 0; j < cells.length; j++) cells[j].style.display = mode;

  if(callid == 'hide_check_link')
  {
        document.getElementById('hide_check_link').style.display='none';
        document.getElementById('show_check_link').style.display="";
  }
  else
  {
        document.getElementById('show_check_link').style.display='none';
        document.getElementById('hide_check_link').style.display="";
  }
}

function getParam(name)
{
  var start=location.search.indexOf("?"+name+"=");
  if (start<0) start=location.search.indexOf("&"+name+"=");
  if (start<0) return 0;
  return 1;
}

function deleteRow(t, r, s)
{
  var i=r.parentNode.parentNode.rowIndex;
  document.getElementById(t).deleteRow(i);
  if ( document.getElementById(s) != null )
    document.getElementById(s).innerHTML="";
}

function createDeleteButton(k)
{
  var rc=document.getElementById('checkscnt').innerHTML;

  if (k == 1)
  {
    for (i=0; i<=rc; i++)
    {
      var pn = 'deletebutton' +i;
      if (document.getElementById(pn) != null )
          document.getElementById(pn).style.display="";
    }
    document.getElementById("show_hide_link").style.display="";
    document.getElementById("message_on_hide").style.display="";
    document.getElementById("show_edit_link").style.display="none";
  }
   else
  {
    for (i=0; i<=rc; i++)
    {
      var pn = 'deletebutton' +i;
      if (document.getElementById(pn) != null )
          document.getElementById(pn).style.display="none";
    }
    document.getElementById("show_hide_link").style.display="none";
    document.getElementById("message_on_hide").style.display="none";
    document.getElementById("show_edit_link").style.display="";
  }
}
</script>
<title>Oracle $SYSTEM_NAME $report_type Report</title>
<meta name="FILE ID" content=$FILEID>
<meta name="FILE SIG" content=$FILESIG>
<meta name="FILE DATE" content=$FILEDATE>
</head><body>
<!-- Adding below gif will add a dependency to html report. So removed
<img border=0 src="rac_assurance_home.gif">
-->
<center><table border=0 width=100% summary="Oracle $SYSTEM_NAME $report_type Report Summary"><tr><td class="td_title" align="center">
 <h1>Oracle $SYSTEM_NAME $report_type Report<br><br>
EOF

if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]]; then
  skip_msg="<li>Skip will deduct 10 points</li>
            <li>Skipped component will deduct (No. of checks to be run on that component)*10 points</li>"
else
  skip_msg="<li>Skip will deduct 3 points</li>"
fi

if [[ $crh_total_points -gt "0" && `echo $components|grep -icw EXALOGIC_VM` -lt 1 && $print_score_in_report -ne 0 ]]
then 
  cat >> $HTML_REPFILE <<EOF
<span style="color:black;">System Health Score is $crh_health out of 100 <a style="color:black;" href="javascript:ShowHideRegion('shs_help');" title="What is this">(detail)</a> </span></h1>
<div id="shs_help" style="DISPLAY: none"><table border=0 summary="System Health Score formula"><tr><td align=left>System Health Score is derived using following formula.<ul>
<li>Every check has 10 points</li>
<li>Failure will deduct 10 points</li>
<li>Warning will deduct 5 points</li>
<li>Info will deduct 3 points</li>
$skip_msg</ul>
<table summary="PASS and FAIL statistics">
<tr><td>Total checks</td><td align=center>$G_TOTAL_CHECKS</td></tr>
<tr><td>Passed checks</td><td align=center>$crh_passed_checks</td></tr>
<tr><td>Failed(fail/warn/info/skip) checks</td><td align=center>$crh_failed_checks</td></tr>
</table>
<a href="javascript:ShowHideRegion('shs_help');"> ..Hide</a>
</td></tr></table>
</div>
EOF

fi

if [[ -n "$RAT_OS" ]] ; then
  os_version_print="$RAT_OS"
else
  os_version_print="$upload_dbplatform $upload_osdistro $upload_osversion $upload_oskernel"
fi

executed_hdr="<tr><td class=\"td_column\">Executed by</td><td>$usern</td></tr>"
if [[ -z "$MERGEFILES" ]]
then
  duration_hdr="<tr><td class=\"td_column\">Duration</td><td>$checks_duration</td></tr>"
  collection_hdr="<tr><td class=\"td_column\">Collection Date</td><td>$collection_date</td></tr>"
else
  if [[ -n $SKIP_CRS_VAL && $SKIP_CRS_VAL -eq "1" ]]; then cname_link=""; fi
  profile_link=""
  ex_profile_link=""
  collection_hdr=""
  executed_hdr="<tr><td class=\"td_column\">Merge Executed by</td><td>$usern</td></tr>"
fi


cat >> $HTML_REPFILE <<EOF
</td></tr></table></center>
<H2>$summary_heading</H2>
<table border=1 summary="Cluster Summary" role="presentation">
$cname_link
$merge_collection_link
<tr><td class="td_column">OS/Kernel Version</td><td>$os_version_print</td></tr>
$exalogic_version_link
$asm_h_link
$crs_hv_link
$dbhv_link
$em_h_link
$obiee_homes_link
$tt_homes_link
$ogg_home_dlink
$cev_link
$tv_link
$node_slink
$node_dlink
$phy_node_dlink
$vir_node_dlink
$el_cs_row
$cells_link
$zfs_link
$ibs_link
$upg_link
$profile_link
$ex_profile_link
$ex_vm_files
<tr><td class="td_column">$program_name Version</td><td>$tool_version</td></tr>
<tr><td class="td_column">Collection</td><td>$collection_name</td></tr>
$duration_hdr
$executed_hdr
$collection_hdr
</table>
EOF


if [[ -n "$print_pass_in_report" && $print_pass_in_report -eq "1" ]] ; then
cat >$HTML_PASS_FILE <<EOF
<hr>
<a class="a_bgw" href="#">Top</a>
<a name="passed_checks"></a>
<H2>Findings Passed</h2>

EOF
fi

  #GoldenGate--
  gg_id=$(grep -i "^goldengate|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2) 
  #--
  #CORROBORATE--
  corroborate_id=$(grep -i "^corroborate|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2)
  #PLATINUM--
  platinum_id=$(grep -i "^platinum|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2)
  #EBS--
  ebs_id=$(grep -i "^ebs|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2)
  #EBS--
  em_id=$(grep -i "^em|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2)
  

  crh_cnt=${#G_CHECKIDS[@]}
  maa_id=0
  gg_cnt=0
  corroborate_cnt=0
  platinum_cnt=0
  ebs_cnt=0
  em_cnt=0
  #echo "Total=$crh_cnt"
  while [ $crh_cnt -gt 0 ] 
  do
    let crh_cnt=$crh_cnt-1
    chk_status=$(echo ${G_CHECKID_STATUS[$crh_cnt]} | awk -F":" '{print $1}')

    # Display only $G_HOST_CNT hosts and display more link
    # When all hosts, then display All
    crh_hosts=""
    # The prefix for seprating reports from storage servers, compute nodes etc
    # It will be compute, cell, switch, cluster or system
    crh_rep_prefix=""
    crh_rep_ptext=""
    if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" && -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" ]]
    then
      el_prefix=""
      nodearr=$(echo ${G_CHECKID_HOSTS[$crh_cnt]} | tr "," "\n")
      convserver=0
      cnode=0
       for crh_first_host in $nodearr
       do
         get_el_prefix "$crh_first_host"
         if [[ $el_prefix = "DB" ||  $el_prefix = "OVMM" || $el_prefix = "EC" || $el_prefix = "PC" ]] ; then
           let convserver=$convserver+1
           isconvserver=1
           iscnode=0 
        else
          let cnode=$cnode+1
          iscnode=1
          isconvserver=0
        fi

       if [[ $isconvserver -eq "1" &&  $convserver -eq "1" ]] || [[ $iscnode -eq "1" &&  $cnode -eq "1" ]] ; then
        get_host_string_html $crh_first_host $el_prefix
        get_tail_html
       fi
      done
    else
      get_host_string_html
      get_tail_html
    fi
  done

  #GoldenGate Block....
  if [ $gg_cnt -gt 0 ]
  then
    goldengate_toc_entry="<li><a href=\"#goldengate\">GoldenGate</a></li>"
    
    HTML_GG_MAIN=${OUTPUTDIR}/goldengate.html
    cat > $HTML_GG_MAIN <<EOF
       <hr>
       <a href="#" class="a_bgw">Top</a>
       <a name="goldengate"></a>
       <h2>GoldenGate</h2>
       <table border=1 id="GoldenGate" summary="GoldenGate checks">
       <tr><th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
       <th scope="col">Status</th>
       <th scope="col">Type</th>
       <th scope="col">Message</th>
       <th scope="col">Status On</th>
       <th scope="col">Details</th></tr>
EOF
    for gg_etype in ERROR FAIL WARNING INFO OTHER PASS
    do
      if [ -r "${OUTPUTDIR}/GG_${gg_etype}.html" ]; 
      then 
        cat ${OUTPUTDIR}/GG_${gg_etype}.html >> $HTML_GG_MAIN 
        rm -f ${OUTPUTDIR}/GG_${gg_etype}.html
      fi
    done
    echo "</table>" >> $HTML_GG_MAIN
  fi


  #CORROBORATE Block....
  if [ $corroborate_cnt -gt 0 ]
  then
    corroborate_toc_entry="<li><a href=\"#corroborate\">Findings needing further review</a></li>"

    HTML_CORROBORATE_MAIN=${OUTPUTDIR}/corroborate.html
    cat > $HTML_CORROBORATE_MAIN <<EOF
       <hr>
       <a href="#" class="a_bgw">Top</a>
       <a name="corroborate"></a>
       <h2>Findings needing further review</h2>
EOF
    echo "<p>NOTE: This section contains best practices that ${program_name} can only do a partial check for because a complete check requires information it cannot gather (ex: data outside of ${program_name} run scope, requires customer knowledge, etc). Please investigate the partial finding that ${program_name} reports in this section, paying particular attention to the details, to determine if any action is required. </p>"  >> $HTML_CORROBORATE_MAIN;

    cat >> $HTML_CORROBORATE_MAIN <<EOF
         <table border=1 id="corroborate" summary="Findings needing further review">
         <tr><th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
         <th scope="col">Status</th>
         <th scope="col">Type</th>
         <th scope="col">Message</th>
         <th scope="col">Status On</th>
         <th scope="col">Details</th></tr>
EOF
    for corroborate_etype in ERROR FAIL WARNING INFO OTHER PASS
    do
      if [ -r "${OUTPUTDIR}/CORROBORATE_${corroborate_etype}.html" ];
      then
        cat ${OUTPUTDIR}/CORROBORATE_${corroborate_etype}.html >> $HTML_CORROBORATE_MAIN
        rm -f ${OUTPUTDIR}/CORROBORATE_${corroborate_etype}.html
      fi
    done
    echo "</table>" >> $HTML_CORROBORATE_MAIN
  fi

  #PLATINUM Block....
  if [ $platinum_cnt -gt 0 ]
  then
    platinum_toc_entry="<li><a href=\"#platinum\">Platinum Certification</a></li>"

    HTML_PLATINUM_MAIN=${OUTPUTDIR}/platinum.html
    cat > $HTML_PLATINUM_MAIN <<EOF
       <hr>
       <a href="#" class="a_bgw">Top</a>
       <a name="platinum"></a>
       <h2>Platinum Certification</h2>
EOF

    cat >> $HTML_PLATINUM_MAIN <<EOF
         <table border=1 id="platinum" summary="Platinum Certification checks">
         <tr><th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
         <th scope="col">Status</th>
         <th scope="col">Type</th>
         <th scope="col">Message</th>
         <th scope="col">Status On</th>
         <th scope="col">Details</th></tr>
EOF
    for platinum_etype in ERROR FAIL WARNING INFO OTHER PASS
    do
      if [ -r "${OUTPUTDIR}/PLATINUM_${platinum_etype}.html" ];
      then
        cat ${OUTPUTDIR}/PLATINUM_${platinum_etype}.html >> $HTML_PLATINUM_MAIN
        rm -f ${OUTPUTDIR}/PLATINUM_${platinum_etype}.html
      fi
    done
    echo "</table>" >> $HTML_PLATINUM_MAIN
  fi

  #EBS Block....
  if [ $ebs_cnt -gt 0 ]
  then
    ebs_toc_entry="<li><a href=\"#e-business_suite\">E-Business Suite</a></li>"
    
    HTML_EBS_MAIN=${OUTPUTDIR}/ebs.html
    cat > $HTML_EBS_MAIN <<EOF
       <hr>
       <a href="#" class="a_bgw">Top</a>
       <a name="e-business_suite"></a>
       <h2>E-Business Suite</h2>
EOF
    #Message for skipped checks

    if [ -e $OUTPUTDIR/${program_name}_skipped_checks.log  ] && [[ `cat $OUTPUTDIR/${program_name}_skipped_checks.log|wc -l` -gt $skipped_checks_pass || `cat $OUTPUTDIR/${program_name}_skipped_checks.log|grep -ic "A4C28178C200A9CBE040E50A1EC00952"` -ge 1 ]]
    then
      custom_msg=0
      for chkid in `cat  $OUTPUTDIR/${program_name}_skipped_checks.log| cut -d'(' -f2 | cut -d')' -f1|sed 's/checkid:-//'`
      do
        if [[ `grep -iwc "$chkid" $SCRIPTPATH/.cgrep/profiles/E8DF76E07DD82E0DE04313C0E50AA55D.prf` -gt 0 ]]
        then
          custom_msg=1
        fi
      done

      if [[ $custom_msg -eq "1" ]]
      then
        echo "<b><p style=\"font-size:14px\"><span style=\"color:red;font-size:14px\">WARNING!</span> Some EBS checks have been skipped, most likely because they were taking longer than the current query timeout value: $RAT_TIMEOUT seconds to run.  This can occur for EBS systems with very large  data sets.  The timeout value can be temporarily increased for checks by  setting the runtime environment variable RAT_TIMEOUT  to a higher value, eg.  export RAT_TIMEOUT=120.  It may be necessary to experiment with different  settings to find the right value for a given environment.  Please note that  changing the RAT_TIMEOUT changes the timeout for ALL checks and not just EBS  checks.  This may result in longer overall run times for the tool. If you  find a particular check is taking an extremely long time to execute, please report this via the <a href="https://community.oracle.com/community/support/_my_oracle_support/orachk" target="_blank"> ORAchk support community</a>.</p></b>"  >> $HTML_EBS_MAIN;
      fi
    fi

    cat >> $HTML_EBS_MAIN <<EOF
         <table border=1 id="E-Business_Suite" summary="E-Business Suite checks">
         <tr><th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
         <th scope="col">Status</th>
         <th scope="col">Type</th>
         <th scope="col">Message</th>
         <th scope="col">Status On</th>
         <th scope="col">Details</th></tr>
EOF

    for ebs_etype in ERROR FAIL WARNING INFO OTHER PASS
    do
      if [ -r "${OUTPUTDIR}/EBS_${ebs_etype}.html" ]; 
      then 
        cat ${OUTPUTDIR}/EBS_${ebs_etype}.html >> $HTML_EBS_MAIN 
        rm -f ${OUTPUTDIR}/EBS_${ebs_etype}.html
      fi
    done
    echo "</table>" >> $HTML_EBS_MAIN
  fi

  #EM Block....
  if [ $em_cnt -gt 0 ]
  then
    em_toc_entry="<li><a href=\"#enterprise_manager\">Enterprise Manager</a></li>"

    HTML_EM_MAIN=${OUTPUTDIR}/em.html
    cat > $HTML_EM_MAIN <<EOF
       <hr>
       <a href="#" class="a_bgw">Top</a>
       <a name="enterprise_manager"></a>
       <h2>Enterprise Manager</h2>
       <table border=1 id="Enterprise_Manager" summary="Enterprise Manager checks">
       <tr><th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
       <th scope="col">Status</th>
       <th scope="col">Type</th>
       <th scope="col">Message</th>
       <th scope="col">Status On</th>
       <th scope="col">Details</th></tr>
EOF
    for em_etype in ERROR FAIL WARNING INFO OTHER PASS
    do
      if [ -r "${OUTPUTDIR}/EM_${em_etype}.html" ];
      then
        cat ${OUTPUTDIR}/EM_${em_etype}.html >> $HTML_EM_MAIN
        rm -f ${OUTPUTDIR}/EM_${em_etype}.html
      fi
    done
    echo "</table>" >> $HTML_EM_MAIN
  fi

  # Append all MAA files
  maa_ids_cnt=$maa_id
  if [ $maa_id -gt 0 ]
  then
    maa_toc_entry="<li><a href=\"#maa_scorecard\">Maximum Availability Architecture (MAA) Scorecard</a></li>"
    cat > $HTML_MAA_SC <<EOF
      <hr>
      <a href="#"  class="a_bgw">Top</a>
      <a name="maa_scorecard"></a>
      <H2>Maximum Availability Architecture (MAA) Scorecard</h2>
           <table border=1 id="maasctbl_${crh_rep_prefix}" summary="Maximum Availability Architecture (MAA) scorecard">
           <tr><th>Outage Type</th>
	   <th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
           <th scope="col">Status</th>
           <th scope="col">Type</th>
           <th scope="col">Message</th>
           <th scope="col">Status On</th>
           <th scope="col">Details</th></tr>
EOF

    # Hack to sort the MAA Scorecard 
    # 1) computer failure 
    # 2) storage failure
    # 3) data corruptions
    # 4) logical corruptions
    # 5) database/cluster/site failure
    # 6) network failures
    # 7) client failover
    # 8) Oracle recovery manager(rman) best practices
    # 9) operational practices
    # 10) Software maintainance best practices
    # 11) consolidation practices
    # We read array from end to start. So add entries in reverse order

    for maa_sf2 in "CONSOLIDATION DATABASE PRACTICES" "OPERATIONAL BEST PRACTICES" "ORACLE RECOVERY MANAGER (RMAN) BEST PRACTICES" "CLIENT FAILOVER OPERATIONAL BEST PRACTICES" "NETWORK FAILURE PREVENTION BEST PRACTICES" "DATABASE/CLUSTER/SITE FAILURE PREVENTION BEST PRACTICES" "LOGICAL CORRUPTION PREVENTION BEST PRACTICES" "DATA CORRUPTION PREVENTION BEST PRACTICES" "STORAGE FAILURES PREVENTION BEST PRACTICES" "COMPUTER FAILURE PREVENTION BEST PRACTICES" "DATABASE FAILURE PREVENTION BEST PRACTICES" "SOFTWARE MAINTENANCE BEST PRACTICES"
    do
      maa_sfname2=$(echo $maa_sf2 |  sed 's/[^a-zA-Z0-9]//g')
      MAA_IDS[$maa_id]=$maa_sfname2
      let maa_id=$maa_id+1
    done

    # echo "maa_id = $maa_id"
    while [ $maa_id -ge 0 ]
    do
      maa_otstatus="INFO"
      if [ -e "${OUTPUTDIR}/${MAA_IDS[$maa_id]}_PASS_SF.html" ]
      then
        maa_otstatus="PASS"
      fi
    
      chk_matrix=1
      for crh_etype in ERROR FAIL WARNING INFO OTHER
      do
        maa_ofile="${OUTPUTDIR}/${MAA_IDS[$maa_id]}_${crh_etype}_SF.html"
        if [ -e "$maa_ofile" ]
        then
          maa_otstatus="FAIL"
        fi
	if [[ $crh_etype != "INFO" ]]; then chk_matrix=0; fi
      done

      if [ `echo ${MAA_IDS[$maa_id]} | grep 'SOFTWAREMAINTENANCEBESTPRACTICES'| wc -l` -eq 1 ] 
      then
        if [[ $chk_matrix -eq "1" ]]; then
          if [[ $OFFLINE -eq 1 ]];then
	    VDIR="${OUTPUTDIR}/versions.dat"
	  else
	    VDIR="${INPUTDIR}/versions.dat"
	  fi

      	  version_ofile="${OUTPUTDIR}/versions.html"
	  if [ -e "$version_ofile" ]; then
	    if [ -e "$VDIR" ] ; then
  	      OIFS=$IFS
	      IFS=$'\n'
	      for pattern in `awk -F';' '{print $8}' "$VDIR"|grep -v "^\s*$"|grep -v "^MESSAGE$"|sed 's/^\s*//g'|sed 's/\s*$//g'`
	      do
	        if [[ `grep -c "$pattern" $version_ofile` -eq "0" ]]; then maa_otstatus="PASS"; else maa_otstatus="FAIL"; break; fi
	      done
    	      if [[ `grep -ic "Version is different from peers" "$version_ofile"` -gt "0" ]]; then maa_otstatus="FAIL"; fi
	      IFS=$OIFS		
	    fi
	  fi
	fi
      fi

      maa_ofile="${OUTPUTDIR}/${MAA_IDS[$maa_id]}_TOP.html"
      if [ -e "$maa_ofile" ] 
      then
        if [ $maa_otstatus = "INFO" ]
        then # No other *_SF files exists
          maa_otcnt=0
        else
          maa_otcnt=$(wc -l ${OUTPUTDIR}/${MAA_IDS[$maa_id]}_*_SF.html| tail -1 | awk '{print $1}')
        fi
        let maa_otcnt=$maa_otcnt+1
        replace_command="sed 's/PLACEHOLDER_TO_REPLACE/${maa_otcnt}/'"
        replace_command_status="sed 's/PLACEHOLDER_STATUS/${maa_otstatus}/'"
        cat $maa_ofile | eval $replace_command | eval $replace_command_status >> $HTML_MAA_SC
        rm -f $maa_ofile
      fi
      for crh_etype in ERROR FAIL WARNING INFO OTHER PASS
      do
        maa_ofile="${OUTPUTDIR}/${MAA_IDS[$maa_id]}_${crh_etype}_SF.html"
        # echo "-- $maa_ofile"
        if [ -e "$maa_ofile" ] 
        then
          cat $maa_ofile >> $HTML_MAA_SC
          rm -f $maa_ofile
        fi
      done
      if [ `echo ${MAA_IDS[$maa_id]} | grep 'SOFTWAREMAINTENANCEBESTPRACTICES'| wc -l` -eq 1 ] 
      then
      	version_ofile="${OUTPUTDIR}/versions.html"
	if [ -e "$version_ofile" ]
	then
  	  cat $version_ofile >> $HTML_MAA_SC
	  echo "" > $version_ofile
	fi
      fi
      let maa_id=$maa_id-1
    done
    echo "</table>" >> $HTML_MAA_SC
  fi

  if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 && -e ${OUTPUTDIR}/isc_summary.html ]] || [[ -n "$is_ssc_machine" && $is_ssc_machine -eq 1 && -e ${OUTPUTDIR}/isc_summary.html ]]; then
    iscs_toc_entry="<li><a class=\"a_bgw\" href=\"#iscs_versions\">Infrastructure Software and Configuration Summary</a></li>"
  fi 

  #append all passed html reports to HTML_PASS_FILE
  crh_toc_pass_compute=""
  if [ -r "${OUTPUTDIR}/PASS_compute.html" ]
  then
    cat ${OUTPUTDIR}/PASS_compute.html >> $HTML_PASS_FILE
    rm -f ${OUTPUTDIR}/PASS_compute.html
    echo "</table>" >> $HTML_PASS_FILE
    crh_toc_pass_compute="<li><a class=\"a_bgw\" href=\"#passed_checks_compute\">On $node_heading</a></li>"
  fi

  crh_toc_pass_cvserver=""
  if [ -r "${OUTPUTDIR}/PASS_cvserver.html" ]
  then
    cat ${OUTPUTDIR}/PASS_cvserver.html >> $HTML_PASS_FILE
    rm -f ${OUTPUTDIR}/PASS_cvserver.html
    echo "</table>" >> $HTML_PASS_FILE
    crh_toc_pass_cvserver="<li><a class=\"a_bgw\" href=\"#passed_checks_cvserver\">On Control vServer</a></li>"
  fi

  crh_toc_pass_cell=""
  if [ -r "${OUTPUTDIR}/PASS_cell.html" ]
  then
    cat ${OUTPUTDIR}/PASS_cell.html >> $HTML_PASS_FILE
    rm -f ${OUTPUTDIR}/PASS_cell.html
    echo "</table>" >> $HTML_PASS_FILE
    crh_toc_pass_cell="<li><a class=\"a_bgw\" href=\"#passed_checks_cell\">On Storage Server</a></li>"
  fi

  crh_toc_pass_zfscell=""
  if [[ -r "${OUTPUTDIR}/PASS_zfscell.html" && -n "$CELLDIR" && -e "$ZFSIP" ]]
  then
    cat ${OUTPUTDIR}/PASS_zfscell.html >> $HTML_PASS_FILE
    rm -f ${OUTPUTDIR}/PASS_zfscell.html
    echo "</table>" >> $HTML_PASS_FILE
    crh_toc_pass_zfscell="<li><a class=\"a_bgw\" href=\"#passed_checks_zfscell\">On ZFS Storage Appliance</a></li>"
  fi

  crh_toc_pass_switch=""
  if [ -r "${OUTPUTDIR}/PASS_switch.html" ]
  then
    cat ${OUTPUTDIR}/PASS_switch.html >> $HTML_PASS_FILE
    rm -f ${OUTPUTDIR}/PASS_switch.html
    echo "</table>" >> $HTML_PASS_FILE
    crh_toc_pass_switch="<li><a class=\"a_bgw\" href=\"#passed_checks_switch\">On Infiniband Switch</a></li>"
  fi

  crh_toc_pass_cluster=""
  if [ -r "${OUTPUTDIR}/PASS_cluster.html" ]
  then
    cat ${OUTPUTDIR}/PASS_cluster.html >> $HTML_PASS_FILE
    rm -f ${OUTPUTDIR}/PASS_cluster.html
    echo "</table>" >> $HTML_PASS_FILE
    crh_toc_pass_cluster="<li><a class=\"a_bgw\" href=\"#passed_checks_cluster\">$html_rack_type Wide</a></li>"
  fi

  crh_toc_pass_system=""
  if [ -r "${OUTPUTDIR}/PASS_system.html" ]
  then
    cat ${OUTPUTDIR}/PASS_system.html >> $HTML_PASS_FILE
    rm -f ${OUTPUTDIR}/PASS_system.html
    echo "</table>" >> $HTML_PASS_FILE
    crh_toc_pass_system="<li><a class=\"a_bgw\" href=\"#passed_checks_system\">System Wide</a></li>"
  fi


  # Append the <errortype>.html to FAILED_<type>.html 
  for crh_ctype in compute cvserver cell zfscell switch cluster system
  do
    case  $crh_ctype in
         compute)
            crh_ctext="$node_heading"
            ;;
         cvserver)
            crh_ctext="Control vServer"
            ;;
         zfscell)
            crh_ctext="ZFS Storage Appliance"
            ;;
         cell)
            crh_ctext="Storage Server"
            ;;
         switch)
            crh_ctext="Infiniband Switch"
            ;;
         cluster)
            crh_ctext="$html_rack_type Wide"
            ;;
         system)
            crh_ctext="System Wide"
            ;;
         *)
            crh_ctext="$node_heading"
            ;;
    esac

    for crh_etype in ERROR FAIL WARNING INFO OTHER
    do
      crh_file_name="${OUTPUTDIR}/${crh_etype}_${crh_ctype}.html";
      if [ -e "${crh_file_name}" ]
      then
        if [ ! -r "${OUTPUTDIR}/FAILED_${crh_ctype}.html" ]
        then
          cat > ${OUTPUTDIR}/FAILED_${crh_ctype}.html <<EOF
             <a name="failed_checks_${crh_ctype}"></a>
             <H2>$crh_ctext</h2>
             <table border=1 id="failedtbl_${crh_ctype}" summary="Failed checks">
             <tr><th scope="col" name='checkid' style="DISPLAY: none">Check Id</th>
             <th scope="col">Status</th>
             <th scope="col">Type</th>
             <th scope="col">Message</th>
             <th scope="col">Status On</th>
             <th scope="col">Details</th></tr>
EOF
        fi
        cat ${crh_file_name} >> ${OUTPUTDIR}/FAILED_${crh_ctype}.html
        rm -f ${crh_file_name}
      fi
    done
    if [ -r "${OUTPUTDIR}/FAILED_${crh_ctype}.html" ]
    then
      echo "</table>" >> ${OUTPUTDIR}/FAILED_${crh_ctype}.html
    fi
  done

  has_killed_procs=0
  has_skipped_checks=0
  has_skipped_nodes=0
  all_passed_text=" - All Checks Passed"
  #if [[ -e "$OUTPUTDIR/watchdog.log" && `grep -iv "watcher" $OUTPUTDIR/watchdog.log |grep -ivc "candidate" | grep -v '^[0-9]*$' | grep -v '^[0-9]*-$' ` -gt 0 ]]
  if [[ -e "$OUTPUTDIR/watchdog.log" && `grep -ic "timed out" $OUTPUTDIR/watchdog.log ` -gt 0 ]]
  then
    has_killed_procs=1
    #has_killed_procs=0
  fi
  if [ -e $OUTPUTDIR/${program_name}_skipped_checks.log  ] && [[ `cat $OUTPUTDIR/${program_name}_skipped_checks.log|wc -l` -gt $skipped_checks_pass || `cat $OUTPUTDIR/${program_name}_skipped_checks.log|grep -ic "A4C28178C200A9CBE040E50A1EC00952"` -ge 1 ]]
  then
    has_skipped_checks=1
  fi
  if [ -e $OUTPUTDIR/${program_name}_skipped_nodes.log  ] && [[ `cat $OUTPUTDIR/${program_name}_skipped_nodes.log|wc -l` -gt 0 ]] 
  then
    has_skipped_nodes=1
  fi
  # Added this to print a warning if user ran older version of tool or print how many days this is version good
  if [[ -n "$cdfYes" && $cdfYes -eq 1 ]]
  then
    echo "<br/><b><p style=\"font-size:14px\"><span style=\"color:red;font-size:14px\">WARNING!</span> $oldVersionWarningMessage.</p></b>" >> $HTML_REPFILE
  else
    echo "<br/><b><p style=\"font-size:14px\"><span style=\"color:green;font-size:14px\">Note!</span> This version of ${program_name} is considered valid for ${validVersionDays} days from today or until a new version is available</p></b>" >> $HTML_REPFILE
     
  fi
  if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1  && $is_avm_machine -eq 0 ]]
  then
    echo "<br/><br/><p><b>NOTE : </b>$program_name is only one part of the MAA Best Practices recommendation methodology. My Oracle Support \"Oracle Exadata Best Practices (Doc <a href=\"https://support.oracle.com/CSP/main/article?cmd=show&type=NOT&id=757552.1\" target=\"_blank\">ID757552.1</a>)\" should be reviewed thoroughly as it is the driver for exachk and contains additional operational and diagnostic guidance that is not programmed within $program_name.</p>" >> $HTML_REPFILE
  fi

  if [[ $has_killed_procs -eq "1" || $has_skipped_checks -eq "1" ]] ; then
    if [[ `uname -s` = "SunOS" || `uname -s` = "AIX" || `uname -s` = "HP-UX" ]] ; then
      tname=$(echo ${program_name} | sed -e 's/^./\E/g')
    else
      tname=$(echo ${program_name} | sed -e 's/^./\U&\E/g')
    fi
    
    echo "<br/><b><p style=\"font-size:14px\"><span style=\"color:red;font-size:14px\">WARNING!</span> The data collection activity appears to be incomplete for this ${program_name} run.  Please review the \"Killed Processes\" and / or \"Skipped Checks\" section and refer to \"Appendix A - Troubleshooting Scenarios\" of the \"${tname} User Guide\" for corrective actions.</p></b>" >> $HTML_REPFILE
    all_passed_text=" - No failed checks reported; review  \"Killed Processes\" and / or \"Skipped Checks\""
  fi
  if [ -e $OUTPUTDIR/${program_name}_skipped_nodes.log  ] && [[ `cat $OUTPUTDIR/${program_name}_skipped_nodes.log|wc -l` -gt 0 ]]
  then
    echo "<br/><b><p style=\"font-size:14px\"><span style=\"color:red;font-size:14px\">WARNING!</span> ${program_name} was unable to connect to few nodes. This condition will result in missing data and an incomplete ${program_name} report.  Click on \"<a href=\"#skipped_nodes\">Skipped Nodes</a>\" link in Table of contents to see list of nodes. Investigate why these nodes could not be pinged from the database server where ${program_name} was launched, and take corrective action, followed by another ${program_name} run.</p></b>" >> $HTML_REPFILE
  fi
  # append all failed html reports to HTML_FAILED_FILE
  crh_toc_failed_compute=""
  if [ -r "${OUTPUTDIR}/FAILED_compute.html" ]
  then
    cat ${OUTPUTDIR}/FAILED_compute.html >> $HTML_FAILED_FILE
    rm -f ${OUTPUTDIR}/FAILED_compute.html
    echo "</table>" >> $HTML_FAILED_FILE
    crh_toc_failed_compute="<li><a class=\"a_bgw\" href=\"#failed_checks_compute\">On $node_heading</a></li>"
  else
    crh_toc_failed_compute="<li>On $node_heading$all_passed_text</li>"
  fi

  crh_toc_failed_cvserver=""
  if [ -r "${OUTPUTDIR}/FAILED_cvserver.html" ]
  then
    cat ${OUTPUTDIR}/FAILED_cvserver.html >> $HTML_FAILED_FILE
    rm -f ${OUTPUTDIR}/FAILED_cvserver.html
    echo "</table>" >> $HTML_FAILED_FILE
    crh_toc_failed_cvserver="<li><a class=\"a_bgw\" href=\"#failed_checks_cvserver\">On Control vServer</a></li>"
  elif [[ $in_ec_exalogic -eq "1" ]] ; then
    if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "0" ]]; then
      crh_toc_failed_cvserver="<li>On Control vServer$all_passed_text</li>"
    fi
  fi

  crh_toc_failed_cell=""
  if [ -r "${OUTPUTDIR}/FAILED_cell.html" ]
  then
    cat ${OUTPUTDIR}/FAILED_cell.html >> $HTML_FAILED_FILE
    rm -f ${OUTPUTDIR}/FAILED_cell.html
    echo "</table>" >> $HTML_FAILED_FILE
    crh_toc_failed_cell="<li><a class=\"a_bgw\" href=\"#failed_checks_cell\">On Storage Server</a></li>"
  elif [[ -n "$cells_link" ]] ; then
    crh_toc_failed_cell="<li>On Storage Server$all_passed_text</li>"
  fi

  crh_toc_failed_zfscell=""
  if [[ -r "${OUTPUTDIR}/FAILED_zfscell.html" && -n "$CELLDIR" && -e "$ZFSIP" ]] 
  then
    cat ${OUTPUTDIR}/FAILED_zfscell.html >> $HTML_FAILED_FILE
    rm -f ${OUTPUTDIR}/FAILED_zfscell.html
    echo "</table>" >> $HTML_FAILED_FILE
    crh_toc_failed_zfscell="<li><a class=\"a_bgw\" href=\"#failed_checks_zfscell\">On ZFS Storage Appliance</a></li>"
  elif [[ -n "$zfs_link" ]] ; then
    crh_toc_failed_zfscell="<li>On ZFS Storage Appliance$all_passed_text</li>"
  fi

  crh_toc_failed_switch=""
  if [ -r "${OUTPUTDIR}/FAILED_switch.html" ]
  then
    cat ${OUTPUTDIR}/FAILED_switch.html >> $HTML_FAILED_FILE
    rm -f ${OUTPUTDIR}/FAILED_switch.html
    echo "</table>" >> $HTML_FAILED_FILE
    crh_toc_failed_switch="<li><a class=\"a_bgw\" href=\"#failed_checks_switch\">On Infiniband Switch</a></li>"
  elif [[ -n "$ibs_link" ]] ; then
    crh_toc_failed_switch="<li>On Infiniband Switch$all_passed_text</li>"
  fi

  crh_toc_failed_cluster=""
  if [ -r "${OUTPUTDIR}/FAILED_cluster.html" ]
  then
    cat ${OUTPUTDIR}/FAILED_cluster.html >> $HTML_FAILED_FILE
    rm -f ${OUTPUTDIR}/FAILED_cluster.html
    echo "</table>" >> $HTML_FAILED_FILE
    crh_toc_failed_cluster="<li><a class=\"a_bgw\" href=\"#failed_checks_cluster\">$html_rack_type Wide</a></li>"
  elif [[ -z "$is_exalogic_machine" ]] ; then
    crh_toc_failed_cluster="<li>$html_rack_type Wide$all_passed_text</li>"
  fi

  crh_toc_failed_system=""
  if [ -r "${OUTPUTDIR}/FAILED_system.html" ]
  then
    cat ${OUTPUTDIR}/FAILED_system.html >> $HTML_FAILED_FILE
    rm -f ${OUTPUTDIR}/FAILED_system.html
    echo "</table>" >> $HTML_FAILED_FILE
    crh_toc_failed_system="<li><a class=\"a_bgw\" href=\"#failed_checks_system\">System Wide</a></li>"
    #crh_toc_failed_system="<li>System Wide$all_passed_text</li>"
  fi
  
  pass_toc="<li><a href=\"#passed_checks\">Findings Passed</a></li>";
  if [[ -n "$print_pass_in_report" && $print_pass_in_report -eq "0" ]] 
  then 
    pass_toc=""
  fi

  cat >> $HTML_REPFILE <<EOF
<H2>Table of Contents</H2>

<ul>
<li><a class="a_bgw" href="#failed_checks">Findings Needing Attention</a></li>
<ul>
$crh_toc_failed_compute
$crh_toc_failed_cvserver
$crh_toc_failed_cell
$crh_toc_failed_zfscell
$crh_toc_failed_switch
$crh_toc_failed_cluster
$crh_toc_failed_system
</ul>
$maa_toc_entry
$iscs_toc_entry
$goldengate_toc_entry
$corroborate_toc_entry
$platinum_toc_entry
$ebs_toc_entry
$em_toc_entry
$pass_toc
<ul>
$crh_toc_pass_compute
$crh_toc_pass_cvserver
$crh_toc_pass_cell
$crh_toc_pass_zfscell
$crh_toc_pass_switch
$crh_toc_pass_cluster
$crh_toc_pass_system
</ul>
EOF

  patch_heading_prefix="GRID and";
  if [[ $single_instance_run -eq "1" && $oracle_restart -ne "1" ]] ; then
    patch_heading_prefix="";
  fi

  if [ -e "$OUTPUTDIR/patch_summary.html" ]
  then
    echo "<li><a href=\"#patch_summary\">$patch_heading_prefix RDBMS patch recommendation Summary report</a></li>" >> $HTML_REPFILE
  fi
  if [[ -e "$OUTPUTDIR/patch_detailed.html" ]]
  then
    echo "<li><a href=\"#patch_detailed\">$patch_heading_prefix RDBMS patch recommendation Detailed report</a></li>" >> $HTML_REPFILE
  fi
  if [[ -e "$OUTPUTDIR/${program_name}_versions.html" && $db_machine_compute -ne 1 ]]
  then
    echo "<li><a href=\"#fs_versions\">Systemwide firmware and software versions</a></li>" >> $HTML_REPFILE
  fi
  if [[ -e "$OUTPUTDIR/${program_name}_${ASREXACHK}.html" ]]
  then
    echo "<li><a href=\"#fs_asrreport\">Systemwide Automatic Service Request (ASR) healthcheck</a></li>" >> $HTML_REPFILE
  fi
  #--removes killed processess section
  if [[ -e "$OUTPUTDIR/watchdog.log" ]]; then
   #if [[ `grep -ic "killing stuck command" $OUTPUTDIR/watchdog.log` -gt 0 || `grep -ic "timed out" $OUTPUTDIR/watchdog.log` -gt 0 ]]
   if [[ `grep -ic "timed out" $OUTPUTDIR/watchdog.log` -gt 0 ]]
   then
     echo "<li><a href=\"#killed_procs\">Killed Processes</a></li>" >> $HTML_REPFILE
   fi
  fi

  if [ -e $OUTPUTDIR/${program_name}_skipped_checks.log  ] && [[ `cat $OUTPUTDIR/${program_name}_skipped_checks.log|wc -l` -gt $skipped_checks_pass || `cat $OUTPUTDIR/${program_name}_skipped_checks.log|grep -ic "A4C28178C200A9CBE040E50A1EC00952"` -ge 1 ]] 
  then
    echo "<li><a href=\"#skipped_checks\">Skipped Checks</a></li>" >> $HTML_REPFILE
  fi
  if [ -e $OUTPUTDIR/${program_name}_skipped_nodes.log  ] && [[ `cat $OUTPUTDIR/${program_name}_skipped_nodes.log|wc -l` -gt 0 ]]
  then
    echo "<li><a href=\"#skipped_nodes\">Skipped Nodes</a></li>" >> $HTML_REPFILE
  fi

  if [ -e $EXCLUDELOG ] && [[ `cat $EXCLUDELOG|wc -l` -gt 0 ]]
  then
    echo "<li><a href=\"#excluded_checks\">Excluded Checks</a></li>" >> $HTML_REPFILE
  fi

  if [[ -e  $OUTPUTDIR/${program_name}_consumers.html ]] && [[ -z "$MERGEFILES" ]]
  then
    echo "<li><a href=\"#top_consumers\">Top 10 Time Consuming Checks</a></li>" >> $HTML_REPFILE
  fi

  cat >> $HTML_REPFILE <<EOF
</ul>
<br>
<a href="javascript:toggleVis('checkid', 'show_check_link');" id="show_check_link">Show Check Ids</a>
<a href="javascript:toggleVis('checkid', 'hide_check_link');" style="DISPLAY: none" id="hide_check_link">Hide Check Ids</a>
<p>
<a href="javascript:createDeleteButton(1);" id="show_edit_link">Remove finding from report</a>
<a href="javascript:createDeleteButton(0);" id="show_hide_link" style="DISPLAY: none">Hide Remove Buttons</a> 
<p id="message_on_hide" style="DISPLAY: none"><br><b><span style="color:red">Removing findings in page does not change the original html file. Please use browsers save page button (or press Ctrl+S) to save the report.</span></b></p>
<hr>
<a name="failed_checks"></a>
<H2>Findings Needing Attention</h2>
<p style="backrgound:white"><b>FAIL, WARNING, ERROR and INFO finding details should be reviewed in the
context of your environment.</b></br>
<br/><b>NOTE:</b> Any recommended change should be applied to and thoroughly tested (functionality and load) in one or more non-production environments before applying the change to a production environment.</p>
EOF

  # Append failed file to report
  if [ -e "$HTML_FAILED_FILE" ] 
  then
    cat $HTML_FAILED_FILE >> $HTML_REPFILE
    rm -f $HTML_FAILED_FILE
  fi

  if [ -e "$HTML_MAA_SC" ]
  then
    cat $HTML_MAA_SC >> $HTML_REPFILE
    rm -f $HTML_MAA_SC
  fi

  if [[ -e "$OUTPUTDIR/isc_summary.html" ]]
  then
    echo "<hr>" >> $HTML_REPFILE
    echo "<a href=\"#\"  class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    echo "<a name=\"iscs_versions\"></a>" >> $HTML_REPFILE
    echo "<h2>Infrastructure Software and Configuration Summary</h2>" >> $HTML_REPFILE
    echo "<p>NOTE: This table displays the configuration summary of the system.  It is for informational purposes only. No action is required.</p>" >> $HTML_REPFILE
    cat $OUTPUTDIR/isc_summary.html >> $HTML_REPFILE
    rm -f $OUTPUTDIR/isc_summary.html
  fi

  if [ -e "$HTML_GG_MAIN" ]
  then
    cat $HTML_GG_MAIN >> $HTML_REPFILE
    rm -f $HTML_GG_MAIN
  fi

  if [ -e "$HTML_CORROBORATE_MAIN" ]
  then
    cat $HTML_CORROBORATE_MAIN >> $HTML_REPFILE
    rm -f $HTML_CORROBORATE_MAIN
  fi

  if [ -e "$HTML_PLATINUM_MAIN" ]
  then
    cat $HTML_PLATINUM_MAIN >> $HTML_REPFILE
    rm -f $HTML_PLATINUM_MAIN
  fi

  if [ -e "$HTML_EBS_MAIN" ]
  then
    cat $HTML_EBS_MAIN >> $HTML_REPFILE
    rm -f $HTML_EBS_MAIN
  fi

  if [ -e "$HTML_EM_MAIN" ]
  then
    cat $HTML_EM_MAIN >> $HTML_REPFILE
    rm -f $HTML_EM_MAIN
  fi

  #for crh_ctype in compute cell switch cluster system
  #do
  #  crh_file_name="${OUTPUTDIR}/FAILED_${crh_ctype}.html";
  #  if [ -e "${crh_file_name}" ]
  #  then
  #    cat ${crh_file_name} >> $HTML_REPFILE
  #    rm -f ${crh_file_name}
  #  fi
  #done

  #append patch summary
  if [[ -e "$OUTPUTDIR/patch_summary.html" ]]
  then
    echo "<hr><a name=\"patch_summary\"></a><a href=\"#\"  class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    echo "<h2>$patch_heading_prefix RDBMS patch recommendation Summary report</h2>" >> $HTML_REPFILE
    cat $OUTPUTDIR/patch_summary.html >> $HTML_REPFILE
    rm -f $OUTPUTDIR/patch_summary.html
  fi

  # append detailed patch report
  if [[ -e "$OUTPUTDIR/patch_detailed.html" ]]
  then
    echo "<hr><a name=\"patch_detailed\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    echo "<h2>$patch_heading_prefix RDBMS patch recommendation Detailed report</h2>" >> $HTML_REPFILE
    cat $OUTPUTDIR/patch_detailed.html >> $HTML_REPFILE
    rm -f $OUTPUTDIR/patch_detailed.html
  fi

  # append passed checks report
  echo "</table>" >> $HTML_PASS_FILE
  cat $HTML_PASS_FILE >> $HTML_REPFILE
  rm -f $HTML_PASS_FILE

  # Now append the detailed description for each check
  echo "<hr><a href=\"#\" class=\"a_bgw\">Top</a><h2>Best Practices and Other Recommendations</h2>" >> $HTML_REPFILE
  echo "<p>Best Practices and Other Recommendations are generally items documented in various sources which could be overlooked. ${program_name} assesses them and calls attention to any findings.</p>" >> $HTML_REPFILE

  # replace the host names
  crh_cnt=${#G_CHECKIDS[@]}
  while [ $crh_cnt -gt 0 ] 
  do
    let crh_cnt=$crh_cnt-1
    #if [[ -e "$OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html" && `echo ${G_CHECKID_STATUS[$crh_cnt]} | grep -ic "PASS"` -eq "0" ]] 
    if [[ -e "$OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html" ]]
    then 
      crh_hosts=$(echo ${G_CHECKID_HOSTS[$crh_cnt]} | sed 's/\//\\\//g') # ORACLE_HOME will have / and below sed fails. So replace / with \/
      crh_hosts_passed=$(echo ${G_CHECKID_HOSTS_PASSED[$crh_cnt]} | sed 's/\//\\\//g') # ORACLE_HOME will have / and below sed fails. So replace / with \/
      if [[ `echo ${G_CHECKID_STATUS[$crh_cnt]} | grep -ic "PASS"` -eq "0" ]]
      then
 	if [ -n "$MERGEFILES" ] ; then	
	  if [ -z "$crh_hosts" ]; then 
	    crh_hosts=`grep "${G_CHECKIDS[$crh_cnt]}" $CURRDIR/.MERGED_COLLECTIONS/slave_results.out.merge| awk -F'|' '{print $10}'`;	  
	  fi
	fi
        replace_command="sed 's/PLACEHOLDER_TO_REPLACE_FAIL/${crh_hosts}/'"
      else
        if [ -n "$crh_hosts_passed" ]
        then
          replace_command="sed 's/PLACEHOLDER_TO_REPLACE_PASS/${crh_hosts_passed}/'"
        else
          replace_command="sed 's/PLACEHOLDER_TO_REPLACE_PASS/${crh_hosts}/'"
        fi
      fi
      cat $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html | eval $replace_command > $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html.new
      mv $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html.new $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html
      if [[ -n "$crh_hosts_passed" && `echo ${G_CHECKID_STATUS[$crh_cnt]} | grep -ic "PASS"` -eq "0" ]]
      then # Partially failed on cells
        replace_command="sed 's/PLACEHOLDER_TO_REPLACE_PASS/${crh_hosts_passed}/'"
        cat $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html | eval $replace_command > $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html.new
        mv $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html.new $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html
      fi
    fi
  done
  
  # Append each check-id.html to main report
  crh_cnt=${#G_CHECKIDS[@]}
  while [ $crh_cnt -gt 0 ] 
  do
    let crh_cnt=$crh_cnt-1

    if [ ! -z "${G_CHECKID_MAA_SF[$crh_cnt]}" ]
    then # MAA
      maa_msg=$(echo "${G_CHECKID_INFO[$crh_cnt]}" | tr "[a-z]" "[A-Z]")
      maa_sf_uc=$(echo ${G_CHECKID_MAA_SF[$crh_cnt]} |tr "[a-z]" "[A-Z]")
      if [ $maa_msg = $maa_sf_uc ]
      then # The SF = MSG. dont display detailed as its a dummy check.
        echo ""
        #rm -f $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html
        mv $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html.out
      fi
    fi

    #if [[ -e "$OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html" && `echo ${G_CHECKID_STATUS[$crh_cnt]} | grep -ic "PASS"` -eq "0" ]] 
    if [[ -e "$OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html" ]]
    then # No html details for passed checks
      echo "<div id=\"${G_CHECKIDS[$crh_cnt]}_contents\">" >> $HTML_REPFILE
      replace_command="sed 's/PLACEHOLDER_TO_REPLACE_..../-/'"
      cat $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html | eval $replace_command >> $HTML_REPFILE
      # Add a top link at bottom also
      echo "<a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\" class=\"a_bgw\">Top</a><br>" >>$HTML_REPFILE
      echo "</div>" >> $HTML_REPFILE
      #rm -f $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html
      mv $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html.out
    fi
  done
  
  # append exadata version report if available.
  #if [[ $OFFLINE -eq 0 &&  -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] && [[ $dbm_x2_2 -eq 1 ]]
  if [[ -e "$OUTPUTDIR/${program_name}_versions.html" && $db_machine_compute -ne 1 ]]
  then
    echo "<hr><a name=\"fs_versions\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    cat $OUTPUTDIR/${program_name}_versions.html | sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $HTML_REPFILE
  fi
  # append Exadata ASR healthcheck report if available.
  if [ -e "$OUTPUTDIR/${program_name}_${ASREXACHK}.html" ]
  then
    echo "<hr><a name=\"fs_asrreport\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    echo "<h2>Systemwide Automatic Service Request (ASR) healthcheck</h2>" >> $HTML_REPFILE
    cat $OUTPUTDIR/${program_name}_${ASREXACHK}.html | sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $HTML_REPFILE
  fi
  if [[ -e "$OUTPUTDIR/${program_name}_iscs.html" && -n $db_machine_compute && $db_machine_compute -eq 1 ]]
  then
    echo "<hr><a name=\"iscs_versions\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    cat $OUTPUTDIR/${program_name}_iscs_versions.html | sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $HTML_REPFILE
  fi
  #Append info about killed processes
  #if [[ -e "$OUTPUTDIR/watchdog.log" && `grep -iv "watcher" $OUTPUTDIR/watchdog.log |grep -ivc "candidate" | grep -v '^[0-9]*$' | grep -v '^[0-9]*-$' ` -gt 0 ]]
  if [[ -e "$OUTPUTDIR/watchdog.log" ]] ; then
  #if [[ `grep -ic "timed out" $OUTPUTDIR/watchdog.log` -gt 0 ]]
  if [[ `grep -i "timed out" $OUTPUTDIR/watchdog.log|grep -vi 'expect:'|wc -l|sed 's/ //g'` -gt 0 ]]
  then
    echo "<hr><a name=\"killed_procs\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    echo "<h2>Killed Processes</h2>" >> $HTML_REPFILE
    echo "<p>${program_name} found that below commands were killed during the run, so some checks might have failed to execute properly. Refer to the troubleshooting section of the user guide to resolve the issues.</p>" >> $HTML_REPFILE
    echo "<pre>" >> $HTML_REPFILE
    #grep -iv "watcher" $OUTPUTDIR/watchdog.log |grep -iv "candidate" | grep -v '^[0-9]*$' | grep -v '^[0-9]*-$' |grep -v "LOG FROM" >> $HTML_REPFILE
    grep -i "timed out" $OUTPUTDIR/watchdog.log >> $HTML_REPFILE
    echo "</pre>" >> $HTML_REPFILE
  fi
  fi

  # append skipped checks
  if [ -e $OUTPUTDIR/${program_name}_skipped_checks.log  ] && [[ `cat $OUTPUTDIR/${program_name}_skipped_checks.log|wc -l` -gt $skipped_checks_pass || `cat $OUTPUTDIR/${program_name}_skipped_checks.log|grep -ic "A4C28178C200A9CBE040E50A1EC00952"` -ge 1 ]] 
  then
  #  custom_msg=0	
  #  for chkid in `cat  $OUTPUTDIR/${program_name}_skipped_checks.log| cut -d'(' -f2 | cut -d')' -f1|sed 's/checkid:-//'`
  #  do   
  #   	if [ `grep -iwc "$chkid" $SCRIPTPATH/.cgrep/profiles/E8DF76E07DD82E0DE04313C0E50AA55D.prf` -gt 0 ]
  #   	then
  #   		custom_msg=1
  #   	fi
  #  done
    echo "<hr><a name=\"skipped_checks\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    echo "<h2>Skipped Checks</h2>" >> $HTML_REPFILE
    echo "<pre>" >> $HTML_REPFILE
    cat $OUTPUTDIR/${program_name}_skipped_checks.log >> $HTML_REPFILE
  #  if [ $custom_msg -eq "1" ]
  #  then
  #    echo "Note: Some EBS checks have been skipped, most likely because they were taking longer than the current query timeout value: $RAT_TIMEOUT seconds to run.  This can occur for EBS systems with very large  data sets.  The timeout value can be temporarily increased for checks by  setting the runtime environment variable RAT_TIMEOUT  to a higher value, eg.  export RAT_TIMEOUT=120.  It may be necessary to experiment with different  settings to find the right value for a given environment.  Please note that  changing the RAT_TIMEOUT changes the timeout for ALL checks and not just EBS  checks.  This may result in longer overall run times for the tool. If you  find a particular check is taking an extremely long time to execute, please report this via the <a href="https://community.oracle.com/community/support/_my_oracle_support/orachk"> ORAchk support community</a>."  >> $HTML_REPFILE;
  #  fi	
    echo "</pre>" >> $HTML_REPFILE
  fi

  # append skipped nodes
  if [ -e $OUTPUTDIR/${program_name}_skipped_nodes.log  ] && [[ `cat $OUTPUTDIR/${program_name}_skipped_nodes.log|wc -l` -gt 0 ]]
  then
    echo "<hr><a name=\"skipped_nodes\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    echo "<h2>Skipped Nodes</h2>" >> $HTML_REPFILE
    echo "<pre>" >> $HTML_REPFILE
    cat $OUTPUTDIR/${program_name}_skipped_nodes.log >> $HTML_REPFILE
    echo "</table></pre>" >> $HTML_REPFILE
  fi
  # append excluded checks 
  if [ -e $EXCLUDELOG  ] && [[ `cat $EXCLUDELOG|wc -l` -gt 0 ]]
  then
    echo "<hr><a name=\"excluded_checks\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    echo "<h2>Excluded Checks</h2>" >> $HTML_REPFILE
    echo "<pre>" >> $HTML_REPFILE
    cat $EXCLUDELOG >> $HTML_REPFILE
    echo "</table></pre>" >> $HTML_REPFILE
  fi

  if [[ -e $OUTPUTDIR/${program_name}_consumers.html ]] && [[ -z "$MERGEFILES" ]]
  then
    echo "<hr>" >> $HTML_REPFILE
    cat $OUTPUTDIR/${program_name}_consumers.html >> $HTML_REPFILE
  fi 

  echo "<div id=\"checkscnt\" style=\"display: none\">$g_tr_index</div>" >> $HTML_REPFILE
  cat >> $HTML_REPFILE <<EOF
    <script>
      var k=getParam('debug');
      createDeleteButton(k);
    </script>
EOF

  echo "</body>
<br><a href=\"#\" onclick=\"javascript:processForm();\"><div id=\"results\">Switch to old format</div></a>
</html>" >> $HTML_REPFILE

}

# Prints the Clusterware patches summary report table.
print_cluster_patch_summary_html ()
{
  if [[ $single_instance_run -eq "1" && $oracle_restart -ne "1" ]] ; then return; fi;
  cat >> $OUTPUTDIR/patch_summary.html <<EOF
    <a name="${i}_crssummary"></a>
    <h3>Summary Report for "$i"</h3>
    <b>Clusterware patches</b>
    <table border=1 summary="Clusterware patches">
    <tr><th>Total patches</th>
    <th scope="col">Applied on CRS</th>
    <th scope="col">Applied on RDBMS</th>
    <th scope="col">Applied on ASM</th>
    <th scope="col">Details</th></tr>
    <tr><td align="right" scope="row">$pp_crs_tcount</td>
    <td align="right">$pp_crs_pcount</td>
    <td align="right">$pp_rdbms_pcount</td>
    <td align="right">$pp_asm_pcount</td>
    <td align="center"><a href="#${i}_crsdetailed">View</a></td>
    </tr></table>
EOF

}

# Print heading for each host. Can't use print_crs_patch_detail_html as its called
# only if there are patchs
print_crs_patch_detail_heading_html ()
{
  if [[ $single_instance_run -eq "1" && $oracle_restart -ne "1" ]] ; then return; fi;
  echo "<h3>Detailed report for \"${fmt_hname}\"</h3><hr>" >> $OUTPUTDIR/patch_detailed.html
}

# Prints the Clusterware patches detailed table.
print_crs_patch_detail_html ()
{
  SUBJ=$SUBJ_PRINT
  PATCH=$PATCH_PRINT
  
  if [[ $single_instance_run -eq "1" && $oracle_restart -ne "1" ]] ; then return; fi;

  if [ $crs_patch_printed_html -eq "0" ] 
  then
    crs_patch_printed_html=1
    p_crs_patch=""
    pcp_hostname=$(echo ${stack_crs_version[$stack_counter]}|sed 's/\.//g')
    cat >> $OUTPUTDIR/patch_detailed.html <<EOF
      <a name="${fmt_hname}_crsdetailed"></a>
      <br><br><b>$pp_crs_tcount Recommended CRS patches for $pcp_hostname from ${CRS}</b>
EOF

    if [ $PCW_NUM -gt 0 ]
    then
      cat >> $OUTPUTDIR/patch_detailed.html <<EOF
      <table border=1 summary="Detailed CRS patches">
      <tr><th scope="col">Patch#</th>
      <th scope="col">CRS</th>
      <th scope="col">ASM</th>
      <th scope="col">RDBMS</th>
      <th scope="col">RDBMS_HOME</th>
      <th scope="col">Patch-Description</th></tr>
EOF
    else
      echo "<br>" >> $OUTPUTDIR/patch_detailed.html
    fi
  fi
  if [ $PCW_NUM -gt 0 ]
  then
    if [[ -n "$fmt_crs_applied" && $fmt_crs_applied = "yes" ]] ; then
      fmt_crs_applied_p="applied"
    else
      fmt_crs_applied_p="not-applied"
    fi
    if [[ -n "$fmt_asm_applied" && $fmt_asm_applied = "yes" ]] ; then
      fmt_asm_applied_p="applied"
    else
      fmt_asm_applied_p="not-applied"
    fi
    if [[ -n "$fmt_rdbms_applied" && $fmt_rdbms_applied = "yes" ]] ; then
      fmt_rdbms_applied_p="applied"
    else
      fmt_rdbms_applied_p="not-applied"
    fi
    if [[ -n "$crs112" && $crs112 -ge 1 ]]
    then # No seperate asm home in 11.2
      fmt_asm_applied_p="n/a"
    fi
    if [[ -z "$ASM_HOME" ]] ; then
      fmt_asm_applied_p="n/a"
    fi
    if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
	fmt_asm_applied_p="n/a"
    fi

    if [ "$p_crs_patch" != "$PATCH" ] ; then
      echo "<tr><td scope=\"row\">$PATCH</td><td scope=\"row\">$fmt_crs_applied_p</td><td scope=\"row\">$fmt_asm_applied_p</td><td scope=\"row\">$fmt_rdbms_applied_p</td><td scope=\"row\">$fmt_patch_type</td><td scope=\"row\">$SUBJ</td></tr>" >> $OUTPUTDIR/patch_detailed.html
      p_crs_patch=$PATCH
    fi
    if [ $j -eq $PCW_NUM ]
    then
      echo "</table><a href=\"#${fmt_hname}_crssummary\" class=\"a_bgw\">Top</a>" >> $OUTPUTDIR/patch_detailed.html
    fi
  else
    echo "<a href=\"#${fmt_hname}_crssummary\" class=\"a_bgw\">Top</a>" >> $OUTPUTDIR/patch_detailed.html
  fi
}

# Print the rdbms patch summary report table.
# As we may have more oracle home's, print headings only when mb_db_counter=0
# else just print the row. At the end print </table>, 
# i.e when $mb_db_counter = ${#mb_oracle_homes_distinct[@]}
print_rdbms_patch_summary_html ()
{
  pr_print=$1
  if [ $mb_db_counter_printed -eq "0" ]
  then # Its first time 
    mb_db_counter_printed=1
    p_rdbms_patch=""
    cat >> $OUTPUTDIR/patch_summary.html <<EOF
      <br><b>RDBMS homes patches</b>
      <table border=1 summary="RDBMS homes patches">
      <tr><th scope="col">Total patches</th>
      <th scope="col">Applied on RDBMS</th>
      <th scope="col">Applied on ASM</th>
      <th scope="col">ORACLE_HOME</th>
      <th scope="col">Details</th></tr>
EOF
  fi
  
  if [[ -n "$pr_print" && "$pr_print" = "1" ]]
  then
    prp_ohome=$(echo "${i}_${mb_db_homes}" | sed 's/\///g')
    cat >> $OUTPUTDIR/patch_summary.html <<EOF
      <tr><td align="right" scope="row"><a name="${prp_ohome}_rdbmssummary"></a>${mb_non_pcw_num[$mb_db_counter]}</td>
      <td align="right">${mb_rp_rdbms_pcount[$mb_db_counter]}</td>
      <td align="right">${mb_rp_asm_pcount[$mb_db_counter]}</td>
      <td align="right">$mb_db_homes</td>
      <td align="center"><a href="#${prp_ohome}_rdbmsdetailed">View</a></td></tr>
EOF
  fi

  let prp_index=$mb_db_counter+1
  if [ $prp_index -eq ${#mb_oracle_homes_distinct[@]} ]
  then # No more rows
    echo "</table>" >> $OUTPUTDIR/patch_summary.html
  fi
}

# Print detailed patch report for every oracle_home
print_rdbms_patch_detailed_html ()
{
  if [ $printed_rdbms_patch_html -eq "0" ]
  then
    printed_rdbms_patch_html=1;
    prp_ohome=$(echo "${i}_${mb_oracle_homes_distinct[$mb_db_counter]}" | sed 's/\///g')
    cat >> $OUTPUTDIR/patch_detailed.html <<EOF
      <a name="${prp_ohome}_rdbmsdetailed"></a>
      <br><br><b>$rp_rdbms_tcount Recommended RDBMS patches for ${rdbms_home_version} from ${mb_oracle_homes_distinct[$mb_db_counter]}</b>
EOF
    if [ "$NON_PCW_NUM" -gt 0 ]
    then
      cat >> $OUTPUTDIR/patch_detailed.html <<EOF
      <table border=1 summary="Detailed rdbms home patches">
      <tr><th>Patch#</th>
      <th scope="col">RDBMS</th>
      <th scope="col">ASM</th>
      <th scope="col">Type</th>
      <th scope="col">Patch-Description</th></tr>
EOF
    else
      echo "<br>" >> $OUTPUTDIR/patch_detailed.html
    fi
  fi
  if [ "$NON_PCW_NUM" -gt 0 ]
  then
    if [[ -n "$2" && $2 = "yes" ]] ; then
      fmt_rdbms_applied_p="applied"
    else
      fmt_rdbms_applied_p="not-applied"
    fi
    if [[ -n "$3" && $3 = "yes" ]] ; then
      fmt_asm_applied_p="applied"
    else
      fmt_asm_applied_p="not-applied"
    fi
    if [[ -n "$crs112" && $crs112 -ge 1 ]] 
    then # No seperate asm home in 11.2
      fmt_asm_applied_p="n/a"
    fi
    if [[ -z "$ASM_HOME" ]] ; then
      fmt_asm_applied_p="n/a"
    fi
    if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
      fmt_asm_applied_p="n/a"
    fi
    
    if [ "$p_rdbms_patch" != "$1" ] ; then
      echo "<tr><td scope=\"row\">$1</td><td scope=\"row\">$fmt_rdbms_applied_p</td><td scope=\"row\">$fmt_asm_applied_p</td><td scope=\"row\">$4</td><td scope=\"row\">$SUBJ</td></tr>" >> $OUTPUTDIR/patch_detailed.html
    p_rdbms_patch=$1
    fi
    if [[ $j -eq $NON_PCW_NUM || $rp_rdbms_tcount -eq 1 ]]
    then
      echo "</table>" >> $OUTPUTDIR/patch_detailed.html
      if [[ -f $napply_missing_list  ]]
      then
        echo "<pre>" >> $OUTPUTDIR/patch_detailed.html
        cat $napply_missing_list >> $OUTPUTDIR/patch_detailed.html
        echo "</pre>" >> $OUTPUTDIR/patch_detailed.html
      fi
      echo "<a href=\"#${prp_ohome}_rdbmssummary\" class=\"a_bgw\">Top</a>" >> $OUTPUTDIR/patch_detailed.html
    fi
  else
    echo "<a href=\"#${prp_ohome}_rdbmssummary\" class=\"a_bgw\">Top</a>" >> $OUTPUTDIR/patch_detailed.html
  fi
}
#-- End writing html reports

function assign_scr_switches ()
{
  crs_version_switch="crs activeversion"
  #if [ `uname -s` = "HP-UX" ] ; then
  #  crs_version_switch="has releaseversion"
  #fi
  bash_scr="/bin/env bash"
  bash_path=""
  if [[ ! -f "/bin/bash" || ! -f "/bin/env" ]] ; then
    bash_scr=$(which bash)
  fi
  if [[ ! -f "/bin/bash" ]] ; then
    bash_path=$(dirname $bash_scr)
  fi
  #$READ -p "bash_scr = $bash_scr and bash_path=$bash_path" somevar
  #bash_scr="/bin/bash -xv";
  bash_source="if [ -e \"/etc/profile\" ] ; then . /etc/profile >/dev/null 2>&1; fi; if [ -e \"\$HOME/.bash_profile\" ] ; then . \$HOME/.bash_profile >/dev/null 2>&1; elif [ -e \"\$HOME/.bash_login\" ] ; then . \$HOME/.bash_login >/dev/null 2>&1; elif [ -e \"\$HOME/.profile\" ] ; then . \$HOME/.profile >/dev/null 2>&1; fi;set +u"
  bash_source_check="if [ -e \"/etc/profile\" ] ; then (. /etc/profile >/dev/null 2>&1); fi; if [ -e \"\$HOME/.bash_profile\" ] ; then (. \$HOME/.bash_profile >/dev/null 2>&1); elif [ -e \"\$HOME/.bash_login\" ] ; then (. \$HOME/.bash_login >/dev/null 2>&1); elif [ -e \"\$HOME/.profile\" ] ; then (. \$HOME/.profile >/dev/null 2>&1); fi;set +u"
}

log_fail ()
{
  if [ $OFFLINE -eq "0" ]; then 
    get_current_epoch 
    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $pval] Check:log_fail Start Time: $epoch_time" >> $CHK_TIMINGS
  fi

  #we should never end up in here when in SILENT mode
  #pass/fail is not a concept for SILENT mode
  if [ $SILENT -eq "1" ]
  then
    echo "DEBUG MESSAGE - log_fail() should not be called in SILENT mode".|tee -a $LOGFIL >/dev/null
  fi

  if [[ $ISBRANCH -eq 1 && $SILENT -eq 0 ]]
  then
    echo "BRANCH CONDITION FALSE" >>$LOGFIL
  elif [[ $ISBRANCH -ne 1 && $SILENT -eq 0 ]]
  then
    # gadiga for SHS
    if [[ $OFFLINE -eq 0 ]];
    then
      cell_ib_fail_count=$(grep 'FAIL' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
      cell_ib_warn_count=$(grep 'WARN' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
      cell_ib_info_count=$(grep 'INFO' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
      cell_ib_total_count=$(grep 'TOTAL' $CELLIBNTFILE|cut -d= -f2|sed 's/ //g')
    fi

    case "$ALVL" in
    "FAIL")
       if [[ "$COMTYPE" = "OS_OUT_CHECK" && "$NEEDS_RUNNING" = "STORAGE_CELL" ]]
       then
         failedChecksOnCells=0
         for failType in "${a_cellCheckStatus[@]}";do if [ $failType != "PASS" ];then failedChecksOnCells=$(expr $failedChecksOnCells + 1 );fi;done
         let G_FAIL_CHECKS=$G_FAIL_CHECKS+$failedChecksOnCells

      	  if [[ $OFFLINE -eq 0 ]]; then cell_ib_fail_count=$(expr $cell_ib_fail_count + $failedChecksOnCells); fi;
       else     
         let G_FAIL_CHECKS=$G_FAIL_CHECKS+1
       fi
       ;;
    "WARNING")
      if [[ "$COMTYPE" = "OS_OUT_CHECK" && "$NEEDS_RUNNING" = "STORAGE_CELL" ]]
      then
        warnChecksOnCells=0
        for failType in "${a_cellCheckStatus[@]}";do if [ $failType != "PASS" ];then warnChecksOnCells=$(expr $warnChecksOnCells + 1 );fi;done
        let G_FAIL_CHECKS=$G_FAIL_CHECKS+$warnChecksOnCells

        if [[ $OFFLINE -eq 0 ]]; then cell_ib_warn_count=$(expr $cell_ib_warn_count + $warnChecksOnCells); fi;
      else     
        let G_WARN_CHECKS=$G_WARN_CHECKS+1
      fi
      ;;
    "INFO")
      if [[ "$COMTYPE" = "OS_OUT_CHECK" && "$NEEDS_RUNNING" = "STORAGE_CELL" ]]
      then
        infoChecksOnCells=0
        for failType in "${a_cellCheckStatus[@]}";do if [ $failType != "PASS" ];then infoChecksOnCells=$(expr $infoChecksOnCells + 1 );fi;done
        let G_FAIL_CHECKS=$G_FAIL_CHECKS+$infoChecksOnCells

        if [[ $OFFLINE -eq 0 ]]; then cell_ib_info_count=$(expr $cell_ib_info_count + $infoChecksOnCells); fi;
      else     
	let G_INFO_CHECKS=$G_INFO_CHECKS+1
	if [[ -n "$LOGIC" && "$LOGIC" = "Y" ]]
        then
	        let G_INFO_CHECKS_SCORE=$G_INFO_CHECKS_SCORE+1
	fi
      fi
      ;;
    *)
      if [[ "$COMTYPE" = "OS_OUT_CHECK" && "$NEEDS_RUNNING" = "STORAGE_CELL" ]]
      then
        failedChecksOnCells=0
        for failType in "${a_cellCheckStatus[@]}";do if [ $failType != "PASS" ];then failedChecksOnCells=$(expr $failedChecksOnCells + 1 );fi;done
        let G_FAIL_CHECKS=$G_FAIL_CHECKS+$failedChecksOnCells

        if [[ $OFFLINE -eq 0 ]]; then cell_ib_fail_count=$(expr $cell_ib_fail_count + $failedChecksOnCells); fi;
      else     
        let G_FAIL_CHECKS=$G_FAIL_CHECKS+1
      fi
      ;;
    esac

    if [[ "$COMTYPE" = "OS_OUT_CHECK" && "$NEEDS_RUNNING" = "STORAGE_CELL" ]]
    then
      let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+$outcheck_cell_counter; 
      validate_needs_running;
      if [[ $OFFLINE -eq 0 ]]; then cell_ib_total_count=$(expr $cell_ib_total_count + $outcheck_cell_counter); fi;
    else
      let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1; 
      validate_needs_running
    fi 
    outcheck_cell_counter=0
    # end code for SHS

     echo "" >>$LOGFIL
     if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
     then
         echo "" >>$CELLREPFIL_FAIL
     elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
     then
          echo "" >>$IBREPFIL_FAIL
     else
         echo "" >>$REPFIL_FAIL
     fi

     if [[ $OFFLINE -eq 0 ]]; 
     then
       echo "FAIL = $cell_ib_fail_count" >> $CELLIBNTFILE.new
       echo "WARN = $cell_ib_warn_count" >> $CELLIBNTFILE.new
       echo "INFO = $cell_ib_info_count" >> $CELLIBNTFILE.new
       echo "TOTAL = $cell_ib_total_count" >> $CELLIBNTFILE.new
          
       rm -f $CELLIBNTFILE 2>/dev/null
       mv -f $CELLIBNTFILE.new $CELLIBNTFILE 2>/dev/null
     fi

     #ACREPCOUNT=`expr $ACREPCOUNT + 1`
     #echo "------------------------------" >>$LOGFIL
     #echo "------------------------------" >>$REPFIL
     #$READ -p "ACREPCOUNT1=$ACREPCOUNT1"
     echo  "Check:- $ALVL => $FMSG" >>$LOGFIL
      
     if [ $CREATE_HTML_REPORT -eq 1 ]
     then # gadiga
       init_arrays_html "FAIL"
     fi

     if [  $COMTYPE = "CLUSTERWIDE_CHECK" ]
     then 
       echo  "Check:- $ALVL => $FMSG" >>$CWCREPFIL_FAIL
       echo  "Check:- $ALVL => $FMSG" >>$SCWCREPFIL_FAIL
     else  
       if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
       then
         echo "" >>$CELLREPFIL_FAIL
         echo "Check:- $ALVL => $FMSG" >>$CELLREPFIL_FAIL
         echo "Check:- $ALVL => $FMSG" >>$CELLSREPFIL_FAIL
       elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
       then
         echo "" >>$IBREPFIL_FAIL
         echo "Check:- $ALVL => $FMSG" >>$IBREPFIL_FAIL
         echo "Check:- $ALVL => $FMSG" >>$IBSREPFIL_FAIL
       else
         echo "" >>$REPFIL_FAIL
         echo "Check:- $ALVL => $FMSG" >>$REPFIL_FAIL
         echo "Check:- $ALVL => $FMSG" >>$SREPFIL_FAIL
       fi 
     fi
     if [ $COMTYPE = "OS_PACKAGE" ]
     then
       echo  "Audit check # $ACREPCOUNT@RPM Version Check@$actual@$PARAM_PATH@$ALVL=>$FMSG@$rpm_status@$rpm_arch">>$OSCHECKRESULT
     else        
       if [ -z "$audit_check_name" ]
       then
         audit_check_name=$COM
       fi
       echo  "Audit check # $ACREPCOUNT@$audit_check_name@$VAL@$COMP@$ALVL=>$FMSG">>$OSCHECKRESULT
     fi
     #audit_check_name=""
     #echo "------------------------------" >>$LOGFIL
     #echo "------------------------------" >>$REPFIL
     echo "" >>$LOGFIL
     if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
     then
       echo "" >>$CELLREPFIL_FAIL
     elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
     then
       echo "" >>$IBREPFIL_FAIL
     else 
       echo "" >>$REPFIL_FAIL
     fi

     #echo "DEBUG - ALERT_LEVEL = $ALVL"
     #$READ -p "stop"

     if [ -z "$MERGEFILES" ];
     then
     if [[ $ALVL = "WARNING" && $ISBRANCH -eq 0 ]]
     then
       echo -e "$ORANGE $ALVL =>$NORM $FMSG"
     elif [[ $ALVL = "FAIL" && $ISBRANCH -eq 0 ]]
     then
       echo -e "$RED $ALVL =>$NORM    $FMSG"
     elif [[ $ALVL = "INFO" && $ISBRANCH -eq 0 ]]
     then 
       echo -e "$BLUE $ALVL =>$NORM    $FMSG"
     elif [[ $ALVL = "ERROR" && $ISBRANCH -eq 0 ]]
     then
       echo -e "$RED $ALVL =>$NORM    $FMSG"
     fi
     fi
     generate_result_xml "FAIL"     
     #follwoing if is not to print anything in report for for package from appendix
     if [ $COMTYPE != "OS_PACKAGE-DISABLED" ]
     then
       #grab the details from the appendix
       LINKNUM=0
       LINK=
       if [ $op_mode -eq 0 ]
       then
         LINKNUM=`grep -c _$ROW-LINK $REFFIL1`
         BEGPAT="_$ROW-BEGIN_COMMENTS"
         ENDPAT="_$ROW-END_COMMENTS"
       else
         if [ $COMTYPE = "CLUSTERWIDE_CHECK" ]
         then
           CHECK_ID=${crs_check_id[$crs_check_file_counter]} 
         fi 
         LINKNUM=`grep -c _$CHECK_ID-LINK $REFFIL1`
         BEGPAT="_$CHECK_ID-BEGIN_COMMENTS"
         ENDPAT="_$CHECK_ID-END_COMMENTS"
       fi
       ONFAIL=`sed -n /$BEGPAT/,/$ENDPAT/p $REFFIL1 |sed s/$BEGPAT//g | sed s/$ENDPAT//g |sed 's/ / /g'`
       #Added this line to add pass/fail message as rational if its ORACLE_PATH and ratinoal is empty
       if [[ "$COMTYPE" = "ORACLE_PATCH" && `echo $ONFAIL|sed '/^$/d'|wc -l` -eq 0 ]];then ONFAIL=$FMSG;fi
  
       case  $OP in
       -eq)
          rep_op="="
         ;;
       -ne)
          rep_op="!="
        ;;
       -ge)
          rep_op=">="
        ;;
       -gt)
          rep_op=">"
        ;;
       -lt)
          rep_op="<"
        ;;
       -le)
          rep_op="<="
        ;;
        *)
         rep_op=$OP
        ;;
       esac 
       #echo "LINKNUM = $LINKNUM"
       #echo "$ROW LINKNUM = $LINKNUM" >>$REPFIL
       #if [ -n "$LINK" ]
       #then
       #  echo "" >>$LOGFIL
       #  echo "" >>$REPFIL
       #fi
       #echo "COMMENTS - $ONFAIL" >>$LOGFIL
       #echo " Additional information to resolve above problem ">>$LOGFIL
       #echo "$ONFAIL" >>$LOGFIL
       if [[  $COMTYPE = "CLUSTERWIDE_CHECK" && -n "$write_report_on_fail" && $write_report_on_fail -eq 1 ]]
       then
         echo "Additional information to resolve above problem">>$CWCREPFIL_FAIL
         echo "-----------------------------------------------">>$CWCREPFIL_FAIL
         if [[ -n "$db_machine_compute" && $db_machine_compute -eq 0 ]]; then echo -e "Success factor name = $SF \n">>$CWCREPFIL_FAIL;fi
         #echo -e "Recommended value is  \"$COMP\", Comparision operator is \"$rep_op\"  and Actual found on system is  \"$VAL\" \n">>$REPFIL
         echo "$ONFAIL" >>$CWCREPFIL_FAIL
         if [[ -e $SOURCEFIL_REPORT ]]
         then
           echo -e "TO REVIEW COLLECTED DATA :- ${SOURCEFIL_REPORT_NEW}\n">>$CWCREPFIL_FAIL
         fi
         unset SOURCEFIL_REPORT SOURCEFIL_REPORT_NEW
       elif [[ -n "$write_report_on_fail" && $write_report_on_fail -eq 1 ]]
       then
         if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
         then
           echo "Additional information to resolve above problem">>$CELLREPFIL_FAIL
           echo "-----------------------------------------------">>$CELLREPFIL_FAIL
           if [[ -n "$db_machine_compute" && $db_machine_compute -eq 0 ]];then echo -e "Success factor name = $SF \n">>$CELLREPFIL_FAIL;fi
           echo "$ONFAIL" >>$CELLREPFIL_FAIL
           if  [ -e $SOURCEFIL_REPORT ]
           then
             echo -e "TO REVIEW COLLECTED DATA FROM $(echo $cellname|tr "[a-z]" "[A-Z]") :- ${SOURCEFIL_REPORT_NEW}\n">>$CELLREPFIL_FAIL
           fi
         elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
         then 
           echo "Additional information to resolve above problem">>$IBREPFIL_FAIL
           echo "-----------------------------------------------">>$IBREPFIL_FAIL
           if [[ -n "$db_machine_compute" && $db_machine_compute -eq 0 ]];then echo -e "Success factor name = $SF \n">>$IBREPFIL_FAIL;fi
           echo "$ONFAIL" >>$IBREPFIL_FAIL
           if [ -e $SOURCEFIL_REPORT ]
           then
             echo -e "TO REVIEW COLLECTED DATA FROM $(echo $switchname|tr "[a-z]" "[A-Z]") :- ${SOURCEFIL_REPORT_NEW}\n">>$IBREPFIL_FAIL
           fi 
         else
           echo "Additional information to resolve above problem">>$REPFIL_FAIL
           echo "-----------------------------------------------">>$REPFIL_FAIL
           if [[ -n "$db_machine_compute" && $db_machine_compute -eq 0 ]];then echo -e "Success factor name = $SF \n">>$REPFIL_FAIL;fi
           echo "$ONFAIL" >>$REPFIL_FAIL
           if [[ -e $SOURCEFIL_REPORT ]]
           then
             echo -e "TO REVIEW COLLECTED DATA :- ${SOURCEFIL_REPORT_NEW}\n">>$REPFIL_FAIL
           fi 
         fi
         unset SOURCEFIL_REPORT SOURCEFIL_REPORT_NEW
       fi
       if [ $LINKNUM -gt 0 ]
       then
         #echo "$ROW LINKNUM = $LINKNUM" >>$REPFIL
         for ((j=1;j<=$LINKNUM;j+=1));
         do
           #echo "j=$j, ROW=$ROW" >>$REPFIL
           if [ $op_mode -eq 0 ]
           then
             LINK=`grep "_"$ROW"-LINK"$j" " $REFFIL1 |sed  -n 's/.*-LINK//p'`
             PLA_LINE=`grep "_"$ROW"-PLA_LINE"" " $REFFIL1 | sed -n 's/.*-PLA_LINE//p' | sed 's/^\s*//g' | sed 's/\s*$//g'` 
           else
             LINK=`grep "_"$CHECK_ID"-LINK"$j" " $REFFIL1 |sed  -n 's/.*-LINK//p'`
	     PLA_LINE=`grep "_"$CHECK_ID"-PLA_LINE"" " $REFFIL1 | sed -n 's/.*-PLA_LINE//p' | sed 's/^\s*//g' | sed 's/\s*$//g'`
           fi
           if [ $CREATE_HTML_REPORT -eq 1 ]
           then
             append_links_html "$ALVL"
           fi
           if [[  $COMTYPE = "CLUSTERWIDE_CHECK" && -n "$write_report_on_fail" && $write_report_on_fail -eq 1 ]]
           then 
             echo "  $LINK" >>$CWCREPFIL_FAIL;
           elif [[ -n "$write_report_on_fail" && $write_report_on_fail -eq 1 ]]
           then 
             if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
             then
               echo "  $LINK" >>$CELLREPFIL_FAIL; 
             elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
             then
               echo "  $LINK" >>$IBREPFIL_FAIL; 
             else
               echo "  $LINK" >>$REPFIL_FAIL; 
             fi
           fi
         done
       fi
       if [ $CREATE_HTML_REPORT -eq 1 ]
       then # gadiga - for html reports
         create_checkid_html $ALVL
         write_output_to_html $ALVL
       fi
     else
       if [[ -e $SOURCEFIL_REPORT ]]
       then
           echo -e "TO REVIEW COLLECTED DATA :- ${SOURCEFIL_REPORT_NEW}\n">>$REPFIL_FAIL
       fi
       if [ $CREATE_HTML_REPORT -eq 1 ]
       then  # gadiga - for html reports
         write_output_to_html $ALVL
       fi
       unset SOURCEFIL_REPORT SOURCEFIL_REPORT_NEW
     fi # end if not to print in report file for OS_PACAKGE
     echo -e "CHECK ID = $CHECK_ID \nAUDIT CHECK NAME = $audit_check_name\n">>$LOGFIL
     echo "---------------------------------------------" >>$LOGFIL
     if [  $COMTYPE = "CLUSTERWIDE_CHECK" ]
     then
       echo "">>$CWCREPFIL_FAIL
       echo "">>$CWCREPFIL_FAIL
     else
       if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
       then
         echo "" >>$CELLREPFIL_FAIL
         echo "" >>$CELLREPFIL_FAIL
       elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]] 
       then
         echo "" >>$IBREPFIL_FAIL
         echo "" >>$IBREPFIL_FAIL
       else
         echo "">>$REPFIL_FAIL
         echo "">>$REPFIL_FAIL
       fi
     fi
   fi
   #echo "---------------------------------------------" >>$LOGFIL

   case $COMTYPE in
   SQL|SQL_PARAM)
     #echo ""
     ;;
   OS|OS_PARAM)
     SQL1=`echo "$SQL'$PARAM_PATH' ,'$OP $COMP','$VAL');"`
     #this loop is a hack to eliminate error for missing comma
     #in the sql statements that are output which contain strings
     #like 'print $1', these need double single quotes
     #this will handle up to |awk {'print $5'}, more than that
     #and we would need to increase the number of loops
     for ((s=1;s<=5;s+=1));
     do
       SQL1=${SQL1/\{print \$$s\}/\'\{print \$$s\}\'}
       #echo "SQL1 = $SQL1"
     done

     #set failure flag
     ;;
   *)
     echo "Unexpected argument log_result [1] = $TYPE" >>$UPDATEFIL
     ;;
   esac

   if [ $OFFLINE -eq "0" ]; then 
     get_current_epoch 
     echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $pval] Check:log_fail End Time: $epoch_time" >> $CHK_TIMINGS
   fi
}

get_log_result ()
{
  cmd_type=$1 # Populate m_opstat
  cmd_value=$2 # db name or ohome

  if [[ $cmd_value = "-" ]]; then pval=$db_name_to_check; else pval=$cmd_value; fi
  if [ $OFFLINE -eq "0" ]; then 
    get_current_epoch
    if [[ "$NEEDS_RUNNING" = "ASM" && ${stack_asm_up[$stack_counter]} -eq 1 ]]; then pval=${stack_asm_sid[$stack_counter]}; fi;
    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $pval] Check:get_log_result Start Time: $epoch_time" >> $CHK_TIMINGS
  fi

  #$1 = SQL or OS, what type of command is being processed
  #$2 = whether to print the SF (1 - for standalone SF or root branch) or branch step (0) info
  #$3 = the number of the current step within a branch
  #$4 = the total number of steps in the branch
  #echo "TYPE = $TYPE" >>$LOGFIL
  #added to remove space before and after from value returned by command 
  VAL=$(echo $VAL|tr -d ' ')
  #To add correct audit_check_name in log file and fix bug 14514471, added this one following line
  if [ -z "$audit_check_name" ]; then audit_check_name=$PARAM_PATH;fi
  echo "" >>$LOGFIL
  if [[ $ISBRANCH -eq 1 && $COMTYPE = OS ]]
  then
    echo "HOST $i BRANCH $ROW" >>$LOGFIL
  elif [[ $ISBRANCH -eq 0 && $COMTYPE = OS ]]
  then
    echo "HOST $i STEP $ROW" >>$LOGFIL
  elif [[ $ISBRANCH -eq 1 && $COMTYPE = SQL ]]
  then
    echo "SQL BRANCH $ROW" >>$LOGFIL
  elif [[ $ISBRANCH -eq 0 && $COMTYPE = SQL ]]
  then
    echo "SQL STEP $ROW" >>$LOGFIL
  elif [[ $ISBRANCH -eq 1 && $COMTYPE = OS_PARAM ]]
  then
    echo "HOST $i BRANCH $ROW" >>$LOGFIL
  elif [[ $ISBRANCH -eq 0 && $COMTYPE = OS_PARAM ]]
  then
    echo "HOST $i STEP $ROW" >>$LOGFIL
  elif [[ $ISBRANCH -eq 1 && $COMTYPE = OS_PACKAGE ]]
  then
    echo "HOST $i BRANCH $ROW" >>$LOGFIL
  elif [[ $ISBRANCH -eq 0 && $COMTYPE = OS_PACKAGE ]]
  then
    echo "HOST $i STEP $ROW" >>$LOGFIL
  elif [[ $ISBRANCH -eq 1 && $COMTYPE = SQL_PARAM ]]
  then
    echo "SQL BRANCH $ROW" >>$LOGFIL
  elif [[ $ISBRANCH -eq 0 && $COMTYPE = SQL_PARAM ]]
  then
    echo "SQL STEP $ROW" >>$LOGFIL
  elif [[ $ISBRANCH -eq 0 && $COMTYPE = SQL_COLLECT ]]
  then
    echo "SQL DATA COLLECTION $ROW" >>$LOGFIL
  elif [[ $ISBRANCH -eq 0 && $COMTYPE = OS_COLLECT ]]
  then
    echo "OS DATA COLLECTION $ROW" >>$LOGFIL
  fi

  if [[ $LEVEL -eq "1" && $SILENT -eq "0" ]]
  then
    if [[ $COMTYPE != "OS_COLLECT" && $COMTYPE != "SQL_COLLECT" ]]
    then
      #only want the verbose output for root level checks
      #everything in the hierarchy below that is referring
      #to the original check
      echo "  SF = $SF" >>$LOGFIL
      echo "  CATEGORY = $CAT" >>$LOGFIL
      echo "  SUBCATEGORY = $SUBCAT" >>$LOGFIL
      echo "  IS_BRANCH = $ISBRANCH" >>$LOGFIL 
    fi
  fi
  echo "  PARAMETER OR PATH = $PARAM_PATH" >>$LOGFIL
  echo "  COMMAND = $COM" >>$LOGFIL
  echo "AUDIT_CHECK_COMPONENTS = $check_components" >>$LOGFIL
  echo "AUDIT_CHECK_ID = $CHECK_ID" >>$LOGFIL
  if [[ $COMTYPE != "OS_COLLECT" && $COMTYPE != "SQL_COLLECT" ]]
  then
    echo "  COMMAND RESULT = $VAL" >>$LOGFIL
  fi
  if [ $SILENT -eq "0" ]
  then
    echo "  OPERATOR = $OP" >>$LOGFIL
    echo "  COMPARISON VALUE = $COMP" >>$LOGFIL
  fi
  echo "" >>$LOGFIL
  #code to print audit check number in report file 
  sql_collect=$(grep -c  "SQL_COLLECT_COMMAND_START" $REFFIL)
  os_collect=$(grep -c  "OS_COLLECT_COMMAND_START" $REFFIL)
  sql_os_collect=$(expr $sql_collect + $os_collect)
  curr_row_number=$(echo $ROW|cut -d. -f1)
  ACREPCOUNT=$(expr $curr_row_number - $sql_os_collect 2>/dev/null)
  #echo "ROW number is $ROW">/dev/null

  case $OP in
  -z|-f|-d|-n|"! -f"|"! -d")
  #we should never come in here if in SILENT mode
  #we will have no comparison operator if that is the case
  #SO nothing to do here if in SILENT mode
  #
  #echo "DEBUG: This should be correct - $COMP"

  #this handles -n and -z type operators where there is no comparison value
  #$VAL is either empty or non-empty, non-empty = TRUE, EM{TY = FALSE
  #This should never be the case for OS_COLLECT or SQL_COLLECT
    case $COMTYPE in
    SQL_PARAM)
      #echo "VAL=$VAL  for $PARAM_PATH"
      if [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter" && ${stack_db_status[$mb_db_conter]} -ne 0 ]]
      then 
        VAL=$(echo $VAL|tr "[a-z]" "[A-Z]")
        if [ "$OP" "$VAL" ]
        then
          if [[ $execute_once -eq 1 && $i != $localnode ]]
          then
            execute_once_sql_param=0
          elif [[ $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave" ]]
          then
            execute_once_sql_param=0
          else
            execute_once_sql_param=1
            OPSTAT=1
            log_pass
          fi
        else
           OPSTAT=0
           echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
           log_fail
        fi
        if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
        if [[ "$OP" = "-z" || "$OP" = "-n"  ]]; then VAL_ACTUAL=$OPSTAT; fi;
        if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
        then
          echo "$inst_name|$CHECK_ID|$VAL_ACTUAL">>$DBACTUAL
        elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
        then
          echo "$inst_name|$CHECK_ID|$VAL_ACTUAL">>$DBACTUAL
        fi
        #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
        if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

        if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
        then
          if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
          if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
          if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 

	  if [[ $insert_stmt_printed -eq 0 ]]; then
            echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$target','$inst_name','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	  fi
          echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$i','$inst_name','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
        fi
      elif [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_asm" && ${stack_asm_up[$stack_counter]} -eq 1 ]]
      then 
        VAL=$(echo $VAL|tr "[a-z]" "[A-Z]")
        if [ "$OP" "$VAL" ]
        then
          if [[ $execute_once -eq 1 && $i != $localnode ]]
          then
            execute_once_sql_param=0
          elif [[ $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave" ]]
          then
            execute_once_sql_param=0
          else
            execute_once_sql_param=1
            OPSTAT=1
            log_pass
          fi
        else
          OPSTAT=0
          echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
          log_fail
        fi
        if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
        if [[ "$OP" = "-z" || "$OP" = "-n"  ]]; then VAL_ACTUAL=$OPSTAT; fi;
        if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
        then
          echo "${stack_asm_sid[$stack_counter]}|$CHECK_ID|$VAL_ACTUAL">>$AACTUAL
        elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
        then
          echo "${stack_asm_sid[$stack_counter]}|$CHECK_ID|$VAL_ACTUAL">>$AACTUAL
        fi
        #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
        if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

        if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
        then
          if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
          if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
          if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 

	  if [[ $insert_stmt_printed -eq 0 ]]; then
            echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$target','ASM on $target','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	  fi
          echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$i','ASM on $i','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
        fi 
      elif  [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_u" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
      then
        VAL=$(echo $VAL|tr "[a-z]" "[A-Z]")
        if [ "$OP" "$VAL" ]
        then
          if [[ $execute_once -eq 1 && $i != $localnode ]]
          then
            execute_once_sql_param=0
          elif [[ $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave" ]]
          then
            execute_once_sql_param=0
          else
            execute_once_sql_param=1
            OPSTAT=1
            log_pass
          fi
        else
          OPSTAT=0
          echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
          log_fail
        fi
        if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
        if [[ "$OP" = "-z" || "$OP" = "-n"  ]]; then VAL_ACTUAL=$OPSTAT; fi;
        if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
        then
          echo "$inst_name|$CHECK_ID|$VAL_ACTUAL">>$DBACTUAL
        elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
        then
          echo "$inst_name|$CHECK_ID|$VAL_ACTUAL">>$DBACTUAL
        fi
        #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
        if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

        if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]
        then
          if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
          if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
          if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 

	  if [[ $insert_stmt_printed -eq 0 ]]; then
            echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$target','$inst_name','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	  fi
          echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$i','$inst_name','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
        fi
      fi  
      ;;
      SQL|SQL_OUT_CHECK)
      if [ $SILENT -eq "0"  ]
      then
        if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_dbinst_up[$stack_counter]} -eq 3 ]]
        then
          if [ "$OP" "$VAL" ] 
          then
            if [[ $execute_once -eq 1 && $i != $localnode ]]
            then
              execute_once_sql=0
            else
              execute_once_sql=0
              OPSTAT=1
              log_pass
            fi
          else
            OPSTAT=0
            log_fail
          fi
          #if [ $ISBRANCH -eq 0 ]; then echo "$CHECK_ID|$VAL">>$DBACTUAL ; fi
          #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
          if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

          if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
          then
            #echo "$CHECK_ID|$VAL">>$DBACTUAL
            if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
            if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
            if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 

	    if [[ $insert_stmt_printed -eq 0 ]]; then
              echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	    fi
            echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
          fi
        fi  
      elif [ $SILENT -eq "1" ]
      then
        OPSTAT=1
        log_pass
      fi 
      if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi 
      if [[ "$OP" = "-z" || "$OP" = "-n"  ]]; then VAL_ACTUAL=$OPSTAT; fi;
      if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
      then
        if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS" ]]
        then
          echo "$CHECK_ID|$VAL_ACTUAL">>$DBACTUAL
        fi;
      elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
      then
        if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS" ]]
        then
          echo "$CHECK_ID|$VAL_ACTUAL">>$DBACTUAL
        fi
      fi    
      ;;
      *)
      if [[ "$OP" = "-f" || "$OP" = "-d" || "$OP" = "! -f" || "$OP" = "! -d" ]]; then VAL=$COMP; fi;
      if [[ "$OP" = "-f" && `echo $COMP|grep -ic OUTPUTDIR`  -ge 1 ]]
      then
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  VAL_DIR=$TMP_OUTPUT
	else
          VAL_DIR=$OUTPUTDIR
	fi
        VAL_FIL=$(echo $COMP|cut -d/ -f2)
        VAL=$(echo ${VAL_DIR}/${VAL_FIL})
        os_check_needs_collect_file=1  
      else
        os_check_needs_collect_file=0 
      fi
      if [ $RAT_DEBUG -eq 1 ]
      then
        if [ $OP "$VAL" ]
        then
          if [[ $execute_once -eq 1 && $i != $localnode ]]
          then
       	    execute_once_os=0
          elif [[ $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave" ]]
          then
            execute_once_os=0
          else
            execute_once_os=1
            OPSTAT=1
            log_pass
          fi
        else
          OPSTAT=0
          log_fail
        fi
      else
        if [ $OP "$VAL"  2>>$ERRFIL ]
        then
          if [[ $execute_once -eq 1 && $i != $localnode ]]
          then
            execute_once_os=0
          elif [[ $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave" ]]
          then
            execute_once_os=0
          else
            execute_once_os=1
            OPSTAT=1
            log_pass
          fi
        else
          OPSTAT=0
          log_fail
        fi
      fi
      if [[ "$OP" = "-f" || "$OP" = "-d" || "$OP" = "! -f" || "$OP" = "! -d" || "$OP" = "-z" || "$OP" = "-n" ]]; then VAL_ACTUAL=$OPSTAT; fi;
      if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi 
      if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
      then
        if [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "RDBMS" ]]
        then
          echo "${db_name_to_check}|${CHECK_ID}|${VAL_ACTUAL}" >>$OSACTUAL
        elif [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && `echo $COM|grep -ic "limits.conf"` -lt 1 ]]
        then
          echo "${mb_db_homes_without_slash}|${CHECK_ID}|${VAL_ACTUAL}" >>$OSACTUAL
        else
          echo "${CHECK_ID}|${VAL_ACTUAL}" >>$OSACTUAL
        fi
      elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0  ]] && [ $write_info_actual_files -eq 1 ]
      then
        if [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "RDBMS" ]]
        then
          echo "${db_name_to_check}|${CHECK_ID}|${VAL_ACTUAL}" >>$OSACTUAL
        elif [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && `echo $COM|grep -ic "limits.conf"` -lt 1 ]]
        then
          echo "${mb_db_homes_without_slash}|${CHECK_ID}|${VAL_ACTUAL}" >>$OSACTUAL
        else
          echo "${CHECK_ID}|${VAL_ACTUAL}" >>$OSACTUAL
        fi
      fi
      #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
      if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

      if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
      then 
        if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
        if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
        if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 

	if [[ $insert_stmt_printed -eq 0 ]]; then
          echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	else
	  cellname_counter=0
	  for cellname in ${a_cellname[@]}
	  do
	    target=$cellname
	    ACT_TARGET=$cellname
 	    ALVL_MB=${a_cellCheckStatus[$cellname_counter]}
            echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
 	    cellname_counter=$(expr $cellname_counter + 1 ) 
	  done
	fi
        echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
      fi
      ;;
      esac
    ;;
   *)
   #if we have a comaprison value then the operator must not be -n or -z

   #echo "DEBUG: What am I doing in here? - $COMP"  

   #$READ -p "it comes here execute_once=$execute_once node=$i and localnode=$localnode com type =$COMTYPE"
   #$READ -p "DEBUG OP=$OP VAL=$COMP $ROW $SOURCEFIL it came here for -f OPSTAT=$OPSTAT VAL_DIR=$VAL_DIR VAL_FIL=$VAL_FIL VAL=$VAL"
   case $COMTYPE in
   OS_COLLECT)
     #if in SILENT mode, just collect the data as usual
     #all this branch does is run the OS command
     #no pass fail decisions to be made at this point
     #
     #echo "DEBUG - PATH = $OUTPUTDIR/$PARAM_PATH.out"
     #VAL would have been intialized in OS_COLLECT section below
     #same for $OUTFIL
     if [ $OFFLINE -eq "0"  ]  
     then
       if [[ $execute_once -eq 1 && $i != $localnode  ]]
       then
         execute_once_exce=0
       elif [[ $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave"  ]]
       then
         execute_once_exce=0
       else
         execute_once_exce=1
         COMSUBSTR=`echo $COM |awk '{print substr($0,0,67)}' |sed 's/ //g'`
         #COMSUBSTR=`echo $COM |awk '{print substr($0,0,57)}' |sed 's/ //g'`
         if [ -z "$COLLECTION_NAME" ] 
         then
           echo "Collecting - $COMSUBSTR" 
           #echo "Collecting $COLLECTION_NAME - $COMSUBSTR" 
         else
           echo "Collecting - $COLLECTION_NAME" 
         fi
         echo "" >>$LOGFIL
         echo "Command executed on $i - $COM" >>$LOGFIL
         echo "" >>$LOGFIL
         #execute the command and redirect output to specified file
         #$READ -p "OUTFILE=$OUTFIL"
         if [[ -e $COLLECT_TIMING ]]; then echo -e "`date '+%a %b %d %H:%M:%S %Y'` - $COLLECTION_NAME on $i">>$COLLECT_TIMING; fi

         if [ $RAT_DEBUG -eq 1 ]
         then
           #$READ -p "$VAL"
           if [[ $i = $localnode ]]
           then
             if [[ "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" ]]
             then
               for mb_db_homes in ${mb_oracle_homes_distinct[@]}
               do
                 skip_this_version=0
                 set_skip_this_version "$mb_db_homes"
                 if [ $skip_this_version -eq 1 ]
                 then #dont run
                   mb_db_counter=$(expr $mb_db_counter + 1)
                   echo "Skipping check($CHECK_ID) on version(9) db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                   continue
                 fi
                 mb_db_homes_without_slash=$(echo $mb_db_homes|sed 's/\///g')
                 mb_db_homes_without_slash=$(echo $mb_db_homes_without_slash|sed 's/\.//g')
		 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                   OUTFIL=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OLD_OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OUTFIL_REPORT=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   OLD_OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   TRGTORCLENV_PATCEHS=${TMP_OUTPUT}/set_orcl_env_patches.sh
                   localcmd=$TMP_OUTPUT/localcmd.sh
		 else
                   OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   TRGTORCLENV_PATCEHS=${RTEMPDIR}/set_orcl_env_patches.sh
                   localcmd=$TMPDIR/localcmd.sh
		 fi
      	         nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_db_homes_without_slash}.sh/g");

                 cp $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                 echo "export ORACLE_HOME=$mb_db_homes">>$TRGTORCLENV_PATCEHS
                 echo "#!$bash_scr" >$localcmd
      	         echo "$RAT_DEBUG_FLG" >>$localcmd
                 echo "$bash_source" >>$localcmd
                 echo ". $TRGTORCLENV_PATCEHS">>$localcmd
                 echo $COM>>$localcmd
                 if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi

                 chmod 744 $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                 chmod 744 $localcmd

      	         get_current_epoch 
      	         echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

		 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		   OLD_OH=$ORACLE_HOME
		   ORACLE_HOME=${mb_db_homes}
		   get_dbOwner
		   ORACLE_HOME=$OLD_OH

		   chown $dbOwner:$dbGroup $TRGTORCLENV_PATCEHS
                   chown $dbOwner:$dbGroup $localcmd
 
		   su $dbOwner -c "$localcmd" >>$OUTFIL

		   move_files "$OUTFIL" "$OLD_OUTFIL" "append"
		   move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
		   cd $OLD_DIR
	    	   unset OLD_DIR
		 else
                   $localcmd >>$OUTFIL
		 fi

      	         get_current_epoch 
      	         echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes] Execution End Time: $epoch_time" >> $CHK_TIMINGS

      	         #if [ -e $localcmd ]; then mv $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
		 if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm $localcmd; fi

                 #if [ -n "$COM_REPORT" ]
                 #then
                 #    localcmd_report=/tmp/localcmd_report.sh
                 #    echo "#!$bash_scr" >$localcmd_report
      	      	 #    echo "$RAT_DEBUG_FLG" >>$localcmd_report
                 #    echo "$bash_source" >>$localcmd_report
                 #    chmod 754 $localcmd_report
                 #    echo ". $TRGTORCLENV_PATCEHS">>$localcmd_report
                 #    echo $COM_REPORT>>$localcmd_report
                 #fi
                 #$localcmd >>$OUTFIL
                 #if [ -e $localcmd_report ]; then $localcmd_report >>$OUTFIL_REPORT; returncode=`echo $?`; fi
               done

             elif [[ $is_goldengate_installed -eq 1 && "$PARAM" = "GOLDENGATE_HOME" ]]
             then
               for mb_ogg_home in `cat $OGGHOMESVERSIONFIL|grep -wi $i|cut -d'|' -f2`
               do
                 mb_ogg_home_version=$(cat  $OGGHOMESVERSIONFIL|grep -wi $mb_ogg_home|cut -d'|' -f3)
                 ogg_version_found=$(echo $check_exadata_version|grep -iwc $mb_ogg_home_version)
                 if [ $ogg_version_found -gt 0 ]
                 then
                   mb_ogg_home_without_slash=$(echo $mb_ogg_home|sed 's/\///g')
                   mb_ogg_home_without_slash=$(echo $mb_ogg_home_without_slash|sed 's/\.//g') 
		   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                     OUTFIL=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OLD_OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OUTFIL_REPORT=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
                     OLD_OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
                     TRGTORCLENV_PATCEHS=${TMP_OUTPUT}/set_orcl_env_patches.sh
      	             localcmd=$TMP_OUTPUT/localcmd.sh
		   else
                     OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
                     TRGTORCLENV_PATCEHS=${RTEMPDIR}/set_orcl_env_patches.sh
      	             localcmd=$TMPDIR/localcmd.sh
		   fi
      	           nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_ogg_home_without_slash}.sh/g");

      	           cp $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                   echo "export ORACLE_OGG_HOME=${mb_ogg_home}">>$TRGTORCLENV_PATCEHS   
      	           echo "#!$bash_scr" >$localcmd
      	           echo "$RAT_DEBUG_FLG" >>$localcmd
      	           echo "$bash_source" >>$localcmd
      	           echo ". $TRGTORCLENV_PATCEHS">>$localcmd
      	           echo $COM>>$localcmd
                   if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT}">>$localcmd;fi

      	           chmod 744 $localcmd
      	           chmod 744 $TRGTORCLENV_PATCEHS >/dev/null 2>&1

      	           get_current_epoch 
      	           echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

                   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                     OLD_OH=$ORACLE_HOME
                     ORACLE_HOME=${mb_ogg_home}
                     get_dbOwner
                     ORACLE_HOME=$OLD_OH

		     chown $dbOwner:$dbGroup $TRGTORCLENV_PATCEHS
                     chown $dbOwner:$dbGroup $localcmd
                     su $dbOwner -c "$localcmd" >>$OUTFIL

		     move_files "$OUTFIL" "$OLD_OUTFIL" "append"
		     move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
		     cd $OLD_DIR
	    	     unset OLD_DIR
                   else
                     $localcmd >>$OUTFIL
                   fi

      	           get_current_epoch 
      	           echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes] Execution End Time: $epoch_time" >> $CHK_TIMINGS

      	           #if [ -e $localcmd ]; then mv $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
		   if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm $localcmd; fi

      	           #if [ -n "$COM_REPORT" ]
      	           #then
      	           #localcmd_report=/tmp/localcmd_report.sh
      	           #echo "#!$bash_scr" >$localcmd_report
      	           #echo "$RAT_DEBUG_FLG" >>$localcmd_report
      	           #echo "$bash_source" >>$localcmd_report
      	           #chmod 754 $localcmd_report
      	           #echo ". $TRGTORCLENV_PATCEHS">>$localcmd_report
      	           #echo $COM_REPORT>>$localcmd_report
      	           #fi
      	           #if [ -e $localcmd_report ]; then $localcmd_report >>$OUTFIL_REPORT; returncode=`echo $?`; fi
                 else
                   echo "skipping $collection_name at $CHECK_ID for $mb_ogg_home because collection version OGG_HOME_VERSION($mb_ogg_home_version) is not applied to check ($check_exadata_version)">>$LOGFIL
                 fi 
               done   
             else
		if [[ -z $is_exalogic_machine ]] || [[ -n "$is_exalogic_machine" && $is_exalogic_machine -ne "1" ]] ; then
      	    		get_current_epoch 
	      	       	echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

	               	#if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT}">>$localcmd;fi
        	       	$localcmd >>$OUTFIL
	               	#if [ -e $localcmd_report ]; then $localcmd_report >>$OUTFIL_REPORT; returncode=`echo $?`; fi

			get_current_epoch 
      		       	echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution End Time: $epoch_time" >> $CHK_TIMINGS
		fi
             fi
           else
             if [[ "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" ]]
             then
               for mb_db_homes in ${mb_oracle_homes_distinct[@]}
               do
                 skip_this_version=0
                 set_skip_this_version "$mb_db_homes"
                 if [ $skip_this_version -eq 1 ]
                 then #dont run
                   mb_db_counter=$(expr $mb_db_counter + 1)
                   echo "Skipping check($CHECK_ID) on version(10) db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                   continue
                 fi
                 mb_db_homes_without_slash=$(echo $mb_db_homes|sed 's/\///g')
                 mb_db_homes_without_slash=$(echo $mb_db_homes_without_slash|sed 's/\.//g')
		 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                   OUTFIL=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OLD_OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OUTFIL_REPORT=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   OLD_OUTFIL_REPORT=$RTEMPDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   TRGTORCLENV_PATCEHS=${TMP_OUTPUT}/set_orcl_env_patches.sh
		 else
                   OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OUTFIL_REPORT=$RTEMPDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   TRGTORCLENV_PATCEHS=${RTEMPDIR}/set_orcl_env_patches.sh
		 fi

                 cp $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                 echo "export ORACLE_HOME=$mb_db_homes">>$TRGTORCLENV_PATCEHS
                 echo "#!$bash_scr" >$localcmd
      	     	 echo "$RAT_DEBUG_FLG" >>$localcmd
                 echo "$bash_source" >>$localcmd
                 echo ". $TRGTORCLENV_PATCEHS">>$localcmd
                 echo $COM>>$localcmd
                 if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT}">>$localcmd;fi

                 chmod 744 $localcmd
                 chmod 744 $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                 #if [ -n "$COM_REPORT" ]
                 #then
                 #    localcmd_report=/tmp/localcmd_report.sh
                 #    echo "#!$bash_scr" >$localcmd_report
      	         #    echo "$RAT_DEBUG_FLG" >>$localcmd_report
                 #    echo "$bash_source" >>$localcmd_report
                 #    chmod 755 $localcmd_report
                 #    echo ". $TRGTORCLENV_PATCEHS">>$localcmd_report
                 #    echo $COM_REPORT>>$localcmd_report
                 #fi

      	         #if [ -e $localcmd ]; then cp $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
		 if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

      	         get_current_epoch 
      	         echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

                 get_cygpath "localcmd"
                 get_cygpath "TRGTORCLENV_PATCEHS"
                 $SCOPY $localcmd $i:${TMPDIR} >/dev/null 2>&1 
      	         $SCOPY $TRGTORCLENV_PATCEHS $i:${RTEMPDIR} >/dev/null 2>&1
                 restore_cygpath "localcmd"
                 restore_cygpath "TRGTORCLENV_PATCEHS"

		 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                   OLD_OH=$ORACLE_HOME
                   ORACLE_HOME=${mb_db_homes}
                   get_dbOwner
                   ORACLE_HOME=$OLD_OH

		   $SSHELL $i "chown $dbOwner:$dbGroup $localcmd"
		   $SSHELL $i "chown $dbOwner:$dbGroup $TRGTORCLENV_PATCEHS"
		   $SSHELL $i "su $dbOwner -c \"$localcmd\"" >>$OUTFIL 

		   move_files "$OUTFIL" "$OLD_OUTFIL" "append"
		   cd $OLD_DIR
	    	   unset OLD_DIR
		 else
                   $SSHELL $i $localcmd >>$OUTFIL
		 fi

                 get_cygpath "OUTFIL_REPORT"
                 get_cygpath "OUTPUTDIR"
                 $SCOPY $i:${OUTFIL_REPORT} $OUTPUTDIR >/dev/null 2>&1
                 restore_cygpath "OUTFIL_REPORT"
                 restore_cygpath "OUTPUTDIR"
                 #if [ -e $localcmd_report ]; then $SSHELL $i $localcmd_report >>$OUTFIL_REPORT; returncode=`echo $?`; fi
                 $SSHELL $i rm -f $localcmd >/dev/null 2>&1
      	         $SSHELL $i rm -f $TRGTORCLENV_PATCEHS >/dev/null 2>&1

      	         get_current_epoch 
      	         echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes] Execution End Time: $epoch_time" >> $CHK_TIMINGS
               done
             elif [[ $is_goldengate_installed -eq 1 && "$PARAM" = "GOLDENGATE_HOME" ]]
             then
               #for mb_ogg_home in `cat  $OGGHOMESVERSIONFIL|grep -wi $i|cut -d'|' -f2`
               for mb_ogg_home in `grep -wi $i $OGGHOMESVERSIONFIL|cut -d'|' -f2`
               do
                 #mb_ogg_home_version=$(cat  $OGGHOMESVERSIONFIL|grep -wi $mb_ogg_home|cut -d'|' -f3)
                 mb_ogg_home_version=$(grep -wi $mb_ogg_home $OGGHOMESVERSIONFIL|cut -d'|' -f3)
                 ogg_version_found=$(echo $check_exadata_version|grep -iwc $mb_ogg_home_version)
                 if [ $ogg_version_found -gt 0 ]
                 then
                   mb_ogg_home_without_slash=$(echo $mb_ogg_home|sed 's/\///g')
                   mb_ogg_home_without_slash=$(echo $mb_ogg_home_without_slash|sed 's/\.//g') 
		   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                     OUTFIL=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OLD_OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OUTFIL_REPORT=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
                     OLD_OUTFIL_REPORT=$RTEMPDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
		     TRGTORCLENV_PATCEHS=$TMP_OUTPUT/set_orcl_env_patches.sh
		   else
                     OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OUTFIL_REPORT=$RTEMPDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
                     TRGTORCLENV_PATCEHS=${RTEMPDIR}/set_orcl_env_patches.sh
      	             localcmd=$TMPDIR/localcmd.sh
		   fi
      	           nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_ogg_home_without_slash}.sh/g");

      	           cp $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                   echo "export ORACLE_OGG_HOME=${mb_ogg_home}">>$TRGTORCLENV_PATCEHS   
      	           echo "#!$bash_scr" >$localcmd
      	           echo "$RAT_DEBUG_FLG" >>$localcmd
      	           echo "$bash_source" >>$localcmd
      	           echo ". $TRGTORCLENV_PATCEHS">>$localcmd
      	           echo $COM>>$localcmd
                   if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT}">>$localcmd;fi

      	           chmod 744 $localcmd
      	           chmod 744 $TRGTORCLENV_PATCEHS >/dev/null 2>&1
      	           #if [ -n "$COM_REPORT" ]
      	           #then
      	           #localcmd_report=/tmp/localcmd_report.sh
      	           #echo "#!$bash_scr" >$localcmd_report
      	           #echo "$RAT_DEBUG_FLG" >>$localcmd_report
      	           #echo "$bash_source" >>$localcmd_report
      	           #chmod 754 $localcmd_report
      	           #echo ". $TRGTORCLENV_PATCEHS">>$localcmd_report
      	           #echo $COM_REPORT>>$localcmd_report
                   #fi

                   #if [ -e $localcmd ]; then cp $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
		   if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

      	           get_current_epoch 
      	           echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_ogg_home] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

                   get_cygpath "localcmd"
                   get_cygpath "TRGTORCLENV_PATCEHS"
                   $SCOPY $localcmd $i:$TMPDIR >/dev/null 2>&1 
      	           $SCOPY $TRGTORCLENV_PATCEHS $i:${RTEMPDIR} >/dev/null 2>&1
                   restore_cygpath "localcmd"
                   restore_cygpath "TRGTORCLENV_PATCEHS"

		   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                     OLD_OH=$ORACLE_HOME
                     ORACLE_HOME=${mb_ogg_home}
                     get_dbOwner
                     ORACLE_HOME=$OLD_OH

		     $SSHELL $i "chown $dbOwner:$dbGroup $localcmd"
		     $SSHELL $i "chown $dbOwner:$dbGroup $TRGTORCLENV_PATCEHS"
		     $SSHELL $i "su $dbOwner -c \"$localcmd\"" >>$OUTFIL 
	
		     move_files "$OUTFIL" "$OLD_OUTFIL" "append"
		     cd $OLD_DIR
	    	     unset OLD_DIR
		   else
                     $SSHELL $i $localcmd >>$OUTFIL
		   fi

                   get_cygpath "OUTFIL_REPORT"
                   get_cygpath "OUTPUTDIR"
                   $SCOPY $i:${OUTFIL_REPORT} $OUTPUTDIR >/dev/null 2>&1 
                   restore_cygpath "OUTFIL_REPORT"
                   restore_cygpath "OUTPUTDIR"
                   #if [ -e $localcmd_report ]; then $SSHELL $i $localcmd_report >>$OUTFIL_REPORT; returncode=`echo $?`; fi
                   $SSHELL $i rm -f $localcmd >/dev/null 2>&1
      	           $SSHELL $i rm -f $TRGTORCLENV_PATCEHS >/dev/null 2>&1

      	           get_current_epoch 
      	           echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_ogg_home] Execution End Time: $epoch_time" >> $CHK_TIMINGS
                 else
                   echo "skipping $collection_name at $CHECK_ID for $mb_ogg_home because collection version OGG_HOME_VERSION($mb_ogg_home_version) is not applied to check ($check_exadata_version)">>$LOGFIL
                 fi 
               done 
             else
               #if [ -e $localcmd ]; then cp $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
	       if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

      	       get_current_epoch 
               echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

               get_cygpath "localcmd"
               get_cygpath "OUTFIL_REPORT"
               get_cygpath "OUTPUTDIR"
               $SCOPY $localcmd $i:$TMPDIR >/dev/null 2>&1
               $SSHELL $i $localcmd >>$OUTFIL
               $SCOPY $i:${OUTFIL_REPORT} $OUTPUTDIR >/dev/null 2>&1
               #if [ -e $localcmd_report ]; then $SCOPY $localcmd_report $i:/tmp >/dev/null 2>&1;fi
               #if [ -e $localcmd_report ]; then $SSHELL $i $localcmd_report >>$OUTFIL_REPORT; returncode=`echo $?`; fi
               $SSHELL $i rm -f $localcmd >/dev/null 2>&1
               #$SSHELL $i rm -f $localcmd_report >/dev/null 2>&1
               restore_cygpath "localcmd"
               restore_cygpath "OUTFIL_REPORT"
               restore_cygpath "OUTPUTDIR"

      	       get_current_epoch 
               echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution Start Time: $epoch_time" >> $CHK_TIMINGS
             fi
           fi
           #cat $localcmd
           #$READ -p "see above"
           #ssh ratus-vm2 . /tmp/set_orcl_env.sh;/sbin/sysctl -a >>$OUTFIL
         else
           if [[ $i = $localnode ]]
           then
             if [[ "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" ]]
             then
               for mb_db_homes in ${mb_oracle_homes_distinct[@]}
               do
                 skip_this_version=0
                 set_skip_this_version "$mb_db_homes"
                 if [ $skip_this_version -eq 1 ]
                 then #dont run
                   mb_db_counter=$(expr $mb_db_counter + 1)
                   echo "Skipping check($CHECK_ID) on version(11) db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                   continue
                 fi
                 mb_db_homes_without_slash=$(echo $mb_db_homes|sed 's/\///g')
                 mb_db_homes_without_slash=$(echo $mb_db_homes_without_slash|sed 's/\.//g')
		 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                   OUTFIL=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OLD_OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OUTFIL_REPORT=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   OLD_OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   TRGTORCLENV_PATCEHS=${TMP_OUTPUT}/set_orcl_env_patches.sh
                   localcmd=$TMP_OUTPUT/localcmd.sh
		 else
                   OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   TRGTORCLENV_PATCEHS=${RTEMPDIR}/set_orcl_env_patches.sh
                   localcmd=$TMPDIR/localcmd.sh
		 fi
      	         nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_db_homes_without_slash}.sh/g");

                 cp $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                 echo "export ORACLE_HOME=$mb_db_homes">>$TRGTORCLENV_PATCEHS
                 echo "#!$bash_scr" >$localcmd
      	         echo "$RAT_DEBUG_FLG" >>$localcmd
                 echo "$bash_source" >>$localcmd
                 echo ". $TRGTORCLENV_PATCEHS">>$localcmd
                 echo $COM>>$localcmd
                 if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT}">>$localcmd;fi

                 chmod 744 $localcmd
                 chmod 744 $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                 #if [ -n "$COM_REPORT" ]
                 #then
                 #    localcmd_report=/tmp/localcmd_report.sh
                 #    echo "#!$bash_scr" >$localcmd_report
      	         #    echo "$RAT_DEBUG_FLG" >>$localcmd_report
                 #    echo "$bash_source" >>$localcmd_report
                 #    chmod 755 $localcmd_report
                 #    echo ". $TRGTORCLENV_PATCEHS">>$localcmd_report
                 #    echo $COM_REPORT>>$localcmd_report
                 #fi

      	         get_current_epoch 
                 echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

                 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                   OLD_OH=$ORACLE_HOME
                   ORACLE_HOME=${mb_db_homes}
                   get_dbOwner
                   ORACLE_HOME=$OLD_OH

		   chown $dbOwner:$dbGroup $TRGTORCLENV_PATCEHS
		   chown $dbOwner:$dbGroup $localcmd
                   su $dbOwner -c "$localcmd" >>$OUTFIL 2>>$ERRFIL

		   move_files "$OUTFIL" "$OLD_OUTFIL" "append"
		   move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
		   cd $OLD_DIR
	    	   unset OLD_DIR
                 else
                   $localcmd >>$OUTFIL 2>>$ERRFIL
                 fi

      	         get_current_epoch 
                 echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes] Execution End Time: $epoch_time" >> $CHK_TIMINGS

                 #if [ -e $localcmd ]; then cp $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
		 if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

                 #if [ -e $localcmd_report ]; then $localcmd_report >>$OUTFIL_REPORT 2>>$ERRFIL; returncode=`echo $?`; fi
                 #cat $TRGTORCLENV_PATCEHS
                 #cat $localcmd
                 #cat $localcmd_report 
               done
             elif [[ $is_goldengate_installed -eq 1 && "$PARAM" = "GOLDENGATE_HOME" ]]
             then
               #for mb_ogg_home in `cat  $OGGHOMESVERSIONFIL|grep -wi $i|cut -d'|' -f2`
               for mb_ogg_home in `grep -wi $i $OGGHOMESVERSIONFIL|cut -d'|' -f2`
               do
                 #mb_ogg_home_version=$(cat  $OGGHOMESVERSIONFIL|grep -wi $mb_ogg_home|cut -d'|' -f3)
                 mb_ogg_home_version=$(grep -wi $mb_ogg_home $OGGHOMESVERSIONFIL|cut -d'|' -f3)
                 ogg_version_found=$(echo $check_exadata_version|grep -iwc $mb_ogg_home_version)
                 if [ $ogg_version_found -gt 0 ]
                 then
                   mb_ogg_home_without_slash=$(echo $mb_ogg_home|sed 's/\///g')
                   mb_ogg_home_without_slash=$(echo $mb_ogg_home_without_slash|sed 's/\.//g') 
		   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                     OUTFIL=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OLD_OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
                     OLD_OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
                     TRGTORCLENV_PATCEHS=${TMP_OUTPUT}/set_orcl_env_patches.sh
      	             localcmd=$TMP_OUTPUT/localcmd.sh
  		   else
                     OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
                     TRGTORCLENV_PATCEHS=${RTEMPDIR}/set_orcl_env_patches.sh
      	             localcmd=$TMPDIR/localcmd.sh
		   fi
      	           nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_ogg_home_without_slash}.sh/g");

      	           cp $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                   echo "export ORACLE_OGG_HOME=${mb_ogg_home}">>$TRGTORCLENV_PATCEHS   
      	           echo "#!$bash_scr" >$localcmd
      	           echo "$RAT_DEBUG_FLG" >>$localcmd
      	           echo "$bash_source" >>$localcmd
      	           echo ". $TRGTORCLENV_PATCEHS">>$localcmd
      	           echo $COM>>$localcmd
                   if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT}">>$localcmd;fi

      	           chmod 744 $localcmd
      	           chmod 744 $TRGTORCLENV_PATCEHS >/dev/null 2>&1
      	           #if [ -n "$COM_REPORT" ]
      	           #then
      	           #	   localcmd_report=/tmp/localcmd_report.sh
      	           # 	   echo "#!$bash_scr" >$localcmd_report
      	           #	   echo "$RAT_DEBUG_FLG" >>$localcmd_report
      	           #	   echo "$bash_source" >>$localcmd_report
      	           #  	   chmod 754 $localcmd_report
      	           #	   echo ". $TRGTORCLENV_PATCEHS">>$localcmd_report
      	           # 	   echo $COM_REPORT>>$localcmd_report
      	           #fi

      	           get_current_epoch 
                   echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_ogg_home] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

                   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                     OLD_OH=$ORACLE_HOME
                     ORACLE_HOME=${mb_ogg_home}
                     get_dbOwner
                     ORACLE_HOME=$OLD_OH

		     chown $dbOwner:$dbGroup $TRGTORCLENV_PATCEHS
		     chown $dbOwner:$dbGroup $localcmd 
                     su $dbOwner -c "$localcmd" >>$OUTFIL 2>>$ERRFIL

		     move_files "$OUTFIL" "$OLD_OUTFIL" "append"
		     move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
		     cd $OLD_DIR
	    	     unset OLD_DIR
                   else
                     $localcmd >>$OUTFIL 2>>$ERRFIL
                   fi

      	           get_current_epoch 
                   echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_ogg_home] Execution End Time: $epoch_time" >> $CHK_TIMINGS

                   #if [ -e $localcmd ]; then cp $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
		   if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1;fi
      	           #if [ -e $localcmd_report ]; then $localcmd_report >>$OUTFIL_REPORT; returncode=`echo $?`; fi
                 else
                   echo "skipping $collection_name at $CHECK_ID for $mb_ogg_home because collection version OGG_HOME_VERSION($mb_ogg_home_version) is not applied to check ($check_exadata_version)">>$LOGFIL
                 fi 
               done
             else
	       if [[ -z $is_exalogic_machine ]] || [[ -n "$is_exalogic_machine" && $is_exalogic_machine -ne "1" ]] ; then
      	         get_current_epoch 
      	         echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_ogg_home] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

      	         $localcmd >>$OUTFIL 2>>$ERRFIL
      	         get_current_epoch 
      	         echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_ogg_home] Execution End Time: $epoch_time" >> $CHK_TIMINGS

                 #if [ -e $localcmd ]; then cp $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
	         if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
               fi
               #if [ -e $localcmd_report ]; then $localcmd_report >>$OUTFIL_REPORT 2>>$ERRFIL; returncode=`echo $?`; fi
             fi
           else
             if [[ "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" ]]
             then
               for mb_db_homes in ${mb_oracle_homes_distinct[@]}
               do
                 skip_this_version=0
                 set_skip_this_version "$mb_db_homes"
                 if [ $skip_this_version -eq 1 ]
                 then #dont run
                   mb_db_counter=$(expr $mb_db_counter + 1)
                   echo "Skipping check($CHECK_ID) on version(12) db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                   continue
                 fi
                 mb_db_homes_without_slash=$(echo $mb_db_homes|sed 's/\///g')
                 mb_db_homes_without_slash=$(echo $mb_db_homes_without_slash|sed 's/\.//g')
		 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                   OUTFIL=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OLD_OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OUTFIL_REPORT=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   OLD_OUTFIL_REPORT=$RTEMPDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   TRGTORCLENV_PATCEHS=${TMP_OUTPUT}/set_orcl_env_patches.sh
                   localcmd=$TMP_OUTPUT/localcmd.sh
		 else
                   OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                   OUTFIL_REPORT=$RTEMPDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                   TRGTORCLENV_PATCEHS=${RTEMPDIR}/set_orcl_env_patches.sh
                   localcmd=$TMPDIR/localcmd.sh
		 fi
      	         nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_db_homes_without_slash}.sh/g");

                 cp $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                 echo "export ORACLE_HOME=$mb_db_homes">>$TRGTORCLENV_PATCEHS
                 echo "#!$bash_scr" >$localcmd
      	         echo "$RAT_DEBUG_FLG" >>$localcmd
                 echo "$bash_source" >>$localcmd
                 echo ". $TRGTORCLENV_PATCEHS">>$localcmd
                 echo $COM>>$localcmd
                 if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT}">>$localcmd;fi

                 chmod 744 $localcmd
                 chmod 744 $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                 #if [ -n "$COM_REPORT" ]
                 #then
                 #    localcmd_report=/tmp/localcmd_report.sh
                 #    echo "#!$bash_scr" >$localcmd_report
      	         #    echo "$RAT_DEBUG_FLG" >>$localcmd_report
                 #    echo "$bash_source" >>$localcmd_report
                 #    chmod 755 $localcmd_report
                 #    echo ". $TRGTORCLENV_PATCEHS">>$localcmd_report
                 #    echo $COM_REPORT>>$localcmd_report
                 #fi  

      	         #if [ -e $localcmd ]; then cp $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
		 if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi	

                 get_current_epoch 
                 echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

                 $SCOPY $localcmd $i:$TMPDIR >/dev/null 2>&1
                 $SCOPY $TRGTORCLENV_PATCEHS $i:${RTEMPDIR} >/dev/null 2>&1

                 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                   OLD_OH=$ORACLE_HOME
                   ORACLE_HOME=${mb_db_homes}
                   get_dbOwner
                   ORACLE_HOME=$OLD_OH

                   $SSHELL $i "chown $dbOwner:$dbGroup $localcmd"
                   $SSHELL $i "chown $dbOwner:$dbGroup $TRGTORCLENV_PATCEHS"
                   $SSHELL $i "su $dbOwner -c \"$localcmd\"" >>$OUTFIL 2>>$ERRFIL

		   move_files "$OUTFIL" "$OLD_OUTFIL" "append"
		   cd $OLD_DIR
	    	   unset OLD_DIR
                 else
                   $SSHELL $i $localcmd >>$OUTFIL 2>>$ERRFIL
                 fi         

                 $SCOPY $i:${OUTFIL_REPORT} $OUTPUTDIR >/dev/null 2>&1
                 #if [ -e $localcmd_report ]; then $SSHELL $i $localcmd_report >>$OUTFIL_REPORT 2>>$ERRFIL; returncode=`echo $?`; fi
                 $SSHELL $i rm -f $localcmd >/dev/null 2>&1
                 $SSHELL $i rm -f $TRGTORCLENV_PATCEHS >/dev/null 2>&1

                 get_current_epoch 
                 echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes] Execution End Time: $epoch_time" >> $CHK_TIMINGS
               done
             elif [[ $is_goldengate_installed -eq 1 && "$PARAM" = "GOLDENGATE_HOME" ]]
             then
               #for mb_ogg_home in `cat  $OGGHOMESVERSIONFIL|grep -wi $i|cut -d'|' -f2`
               for mb_ogg_home in `grep -wi $i $OGGHOMESVERSIONFIL|cut -d'|' -f2`
               do
                 #mb_ogg_home_version=$(cat  $OGGHOMESVERSIONFIL|grep -wi $mb_ogg_home|cut -d'|' -f3)
                 mb_ogg_home_version=$(grep -wi $mb_ogg_home $OGGHOMESVERSIONFIL|cut -d'|' -f3)
                 ogg_version_found=$(echo $check_exadata_version|grep -iwc $mb_ogg_home_version)
                 if [ $ogg_version_found -gt 0 ]
                 then
                   mb_ogg_home_without_slash=$(echo $mb_ogg_home|sed 's/\///g')
                   mb_ogg_home_without_slash=$(echo $mb_ogg_home_without_slash|sed 's/\.//g') 
		   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                     OUTFIL=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OLD_OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OUTFIL_REPORT=$TMP_OUTPUT/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
                     OLD_OUTFIL_REPORT=$RTEMPDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
                     TRGTORCLENV_PATCEHS=${TMP_OUTPUT}/set_orcl_env_patches.sh
      	             localcmd=$TMP_OUTPUT/localcmd.sh
		   else
                     OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i".out"
                     OUTFIL_REPORT=$RTEMPDIR/"o_"$OUTFILNAM"_${mb_ogg_home_without_slash}_"$i"_report.out"
                     TRGTORCLENV_PATCEHS=${RTEMPDIR}/set_orcl_env_patches.sh
      	             localcmd=$TMPDIR/localcmd.sh
		   fi
      	           nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_ogg_home_without_slash}.sh/g");

      	           cp $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                   echo "export ORACLE_OGG_HOME=${mb_ogg_home}">>$TRGTORCLENV_PATCEHS   
      	           echo "#!$bash_scr" >$localcmd
      	           echo "$RAT_DEBUG_FLG" >>$localcmd
      	           echo "$bash_source" >>$localcmd
      	           echo ". $TRGTORCLENV_PATCEHS">>$localcmd
      	           echo $COM>>$localcmd 
                   if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT}">>$localcmd;fi

      	           chmod 744 $localcmd
      	           chmod 744 $TRGTORCLENV_PATCEHS >/dev/null 2>&1

      	           #if [ -n "$COM_REPORT" ]
      	           #then
      	           #	   localcmd_report=/tmp/localcmd_report.sh
      	           #	   echo "#!$bash_scr" >$localcmd_report
      	           #	   echo "$RAT_DEBUG_FLG" >>$localcmd_report
      	           #	   echo "$bash_source" >>$localcmd_report
      	           #	   chmod 754 $localcmd_report
      	           #	   echo ". $TRGTORCLENV_PATCEHS">>$localcmd_report
      	           #	   echo $COM_REPORT>>$localcmd_report
                   #fi

                   get_current_epoch 
                   echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_ogg_home] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

                   $SCOPY $localcmd $i:$TMPDIR >/dev/null 2>&1 
      	           $SCOPY $TRGTORCLENV_PATCEHS $i:${RTEMPDIR} >/dev/null 2>&1

                   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                     OLD_OH=$ORACLE_HOME
                     ORACLE_HOME=${mb_ogg_home}
                     get_dbOwner
                     ORACLE_HOME=$OLD_OH

                     $SSHELL $i "chown $dbOwner:$dbGroup $localcmd"
                     $SSHELL $i "chown $dbOwner:$dbGroup $TRGTORCLENV_PATCEHS"
                     $SSHELL $i "su $dbOwner -c \"$localcmd\"" >>$OUTFIL 2>>$ERRFIL

		     move_files "$OUTFIL" "$OLD_OUTFIL" "append"
		     cd $OLD_DIR
	       	     unset OLD_DIR
                   else
                     $SSHELL $i $localcmd >>$OUTFIL 2>>$ERRFIL
                   fi         

                   $SCOPY $i:${OUTFIL_REPORT} $OUTPUTDIR >/dev/null 2>&1
                   #if [ -e $localcmd_report ]; then $SSHELL $i $localcmd_report >>$OUTFIL_REPORT; returncode=`echo $?`; fi
                   $SSHELL $i rm -f $localcmd >/dev/null 2>&1
      	           $SSHELL $i rm -f $TRGTORCLENV_PATCEHS >/dev/null 2>&1

                   get_current_epoch 
                   echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_ogg_home] Execution End Time: $epoch_time" >> $CHK_TIMINGS
                 else
                   echo "skipping $collection_name at $CHECK_ID for $mb_ogg_home because collection version OGG_HOME_VERSION($mb_ogg_home_version) is not applied to check ($check_exadata_version)">>$LOGFIL
                 fi 
               done
             else  
               get_current_epoch 
               echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

               $SCOPY $localcmd $i:$TMPDIR >/dev/null 2>&1
               $SSHELL $i $localcmd >>$OUTFIL 2>>$ERRFIL
               $SCOPY $i:${OUTFIL_REPORT} $OUTPUTDIR >/dev/null 2>&1
               #if [ -e $localcmd_report ]; then $SCOPY $localcmd_report $i:/tmp >/dev/null 2>&1;fi
               #if [ -e $localcmd_report ]; then $SSHELL $i $localcmd_report >>$OUTFIL_REPORT 2>>$ERRFIL; returncode=`echo $?`; fi
               $SSHELL $i rm -f $localcmd >/dev/null 2>&1
               #$SSHELL $i rm -f $localcmd_report >/dev/null 2>&1

               get_current_epoch 
               echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution End Time: $epoch_time" >> $CHK_TIMINGS
             fi
           fi
           #$localcmd >>$OUTFIL 2>>$ERRFIL
         fi
         if [ -e "$localcmd" ]; then rm -f $localcmd 2>/dev/null;fi
         if [ -e "$localcmd_report" ]; then rm -f $localcmd_report  2>/dev/null;fi
         if [ -e "$TRGTORCLENV_PATCEHS" ]; then rm -f $TRGTORCLENV_PATCEHS 2>/dev/null;fi
       fi
     fi
     ;;
   SQL_COLLECT)
     #if in SILENT mode then just collect the data as usual
     #
     #all this branch does is run the SQL command
     #no pass or fail decisions to be made at this point
     #
     #for each SQL_COLLECT we'll make a new script file
     #execute it in SQLPLUS and spool the result to the outpu directory
     #echo "DEBUG - PARAM_PATH = $PARAM_PATH, COM = $COM"
   
     #we only want to do these spool files once per database
     #not once per node so we check here if the file already exists
     #if it does we do not want to do the collection again
     #echo " $SF `echo $SF|grep -ic "DBMACHINE V1"` db_machine_compute=$db_machine_compute " 
     #$READ -p "see this"
      
     if [ ! -f $OUTFIL ] && [ $OFFLINE -eq "0" ] && [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]] && [ ${stack_asm_up[$stack_counter]} -eq 1 -o ${stack_db_status[$mb_db_counter]} -ne 0 -o ${stack_dbinst_up[$stack_counter]} -ne 0 ]
     then
       if  [[ $component_match_count  -lt 1 ]]
       then
         echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
       elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$COLLECTION_NAME" $EXCLUDEFIL` -ge 1 ]]
       then
         call_get_log_result=0
         echo "Skipping $COLLECTION_NAME (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
         generate_exceptions_xml "Skipping $audit_check_name because its in exclude file $EXCLUDEFIL"

         #commented this branch to execute all SQL_COLLECT to on all databases  
         #elif [[ "${mb_database_role[$mb_db_counter]}" != "$check_database_role" ]] 
         #then
         #    echo "$COM skipped for $db_name_to_check because database role does not match">>$LOGFIL
         #    call_get_log_result=0
         else
	   #create the script file that will be executed in SQL*Plus
	   #echo "DEBUG - INFIL = $INFIL"
	   #COMSUBSTR_NAME=`echo $COM |awk '{print substr($0,0,57)}' |sed 's/ //g'`
	   if [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 0 ]] || [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 && "$NEEDS_RUNNING" = "ASM" ]]; then
	     #if [ $OFFLINE -eq "0" ]; then 
	     #  get_current_epoch 
	     #  echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $db_name_to_check] Execution Start Time: $epoch_time" >> $CHK_TIMINGS
	     #fi

	     COMSUBSTR=`echo $COM |awk '{print substr($0,0,67)}' |sed 's/ //g'`
             if [ "${mb_database_type[$mb_db_counter]}" = "PDB" ]; then echo "alter session set container=$db_name_to_check;">$INFIL;fi 
	     echo "$COM" >>$INFIL
	     pl_sql=`echo $COM|grep -ic "begin" `
	     if [ $pl_sql -gt 0 ]
	     then
	       echo "/" >>$INFIL
	       #$READ -p "see $INFIL for /"
	     fi
	     if [[ "$NEEDS_RUNNING" = "ASM" && ${stack_asm_up[$stack_counter]} -eq 1 ]]
	     then
	       if [ -z "$COLLECTION_NAME" ] 
	       then
	         echo "Collecting - $COMSUBSTR" 
	       else
	         echo "Collecting - $COLLECTION_NAME " 
	       fi
	       #OLD_ORACLE_HOME=$ORACLE_HOME
	       #OLD_ORACLE_SID=$ORACLE_SID
               if [[ -n "$crs112" && $crs112 -ge 1 ]]
	       then
	         export ORACLE_SID=${stack_asm_sid[$stack_counter]}
	         export ORACLE_HOME=$CRS
	       else
	         export ORACLE_HOME=${stack_asm_home[$stack_counter]}
	         export ORACLE_SID=${stack_asm_sid[$stack_counter]}
	       fi
	       #$READ -p "ORACLE_HOME=$ORACLE_HOME and ORACLE_SID=$ORACLE_SID infile is $INFIL and query is $COM"
               if [[ -e $COLLECT_TIMING ]]; then echo -e "`date '+%a %b %d %H:%M:%S %Y'` - $COLLECTION_NAME">>$COLLECT_TIMING; fi
               #added 1=2 not to execute first part of this if not execute asm collection with username/password becuase we never ask asm sysdba password

	       get_current_epoch 
               echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ${stack_asm_sid[$stack_counter]}] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

	       if [[ -n "${mb_checksysdba[$mb_db_counter]}" && ${mb_checksysdba[$mb_db_counter]} -eq 0 && 1 -eq 2 ]]
	       then
                 DBUSR=${mb_sysdba_user[$mb_db_counter]}
                 DBPWD=${mb_sysdba_pswd[$mb_db_counter]}

		 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		   get_dbOwner

		   cp $INFIL $NEW_INFIL
		   chown $dbOwner:$dbGroup $NEW_INFIL

	           su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
	           set head off
	           set lines 80
	           set feedback off
                   set timing off  
	           set serveroutput on
	           spool $NEW_OUTFIL
	           @@$NEW_INFIL
	           spool off
	           exit
EOF
"
		   move_files "$NEW_OUTFIL" "$OUTFIL"
		   rm -f $NEW_INFIL
		   cd $OLD_DIR
	    	   unset OLD_DIR
		 else
	           $ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
	           set head off
	           set lines 80
	           set feedback off
                   set timing off  
	           set serveroutput on
	           spool $OUTFIL
	           @@$INFIL
	           spool off
	           exit
EOF
	   	 fi
	       else
		 if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		   get_dbOwner

		   cp $INFIL $NEW_INFIL
		   chown $dbOwner:$dbGroup $NEW_INFIL

	           su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	           set head off
	           set lines 80
	           set feedback off
                   set timing off  
	           set serveroutput on
	           spool $NEW_OUTFIL
	           @@$NEW_INFIL
	           spool off
	           exit
EOF
"	
		   move_files "$NEW_OUTFIL" "$OUTFIL"
		   rm -f $NEW_INFIL
		   cd $OLD_DIR
	    	   unset OLD_DIR
		 else
	           #$READ -p "before asm collection"
	           $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	           set head off
	           set lines 80
	           set feedback off
                   set timing off  
	           set serveroutput on
	           spool $OUTFIL
	           @@$INFIL
	           spool off
	           exit
EOF
		fi
	          #$READ -p "check asm collection $ORACLE_SID and $ORACLE_HOME $OUTFIL and infile=$INFIL"
	       fi

	       get_current_epoch 
               echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ${stack_asm_sid[$stack_counter]}] Execution End Time: $epoch_time" >> $CHK_TIMINGS

	       #ORACLE_SID=$OLD_ORACLE_SID
	       #ORACLE_HOME=$OLD_ORACLE_HOME   
	     elif [[ "$NEEDS_RUNNING" != "ASM" ]] && [ ${stack_db_status[$mb_db_counter]} -ne 0 -o ${stack_dbinst_up[$stack_counter]} -ne 0 ]
	     then
               #echo "calling sql collect for $db_name_name_to_check oralce_Sid $ORACLE_SID and Oracle_home $ORACLE_HOME"
	       if [ -z "$COLLECTION_NAME" ] 
	       then
	         echo "Collecting - $COMSUBSTR for ${db_name_to_check} database" 
	       else
	         echo "Collecting - $COLLECTION_NAME for ${db_name_to_check} database " 
	       fi
	       #$READ -p "IS_SYSDBA=$IS_SYSDBA" 
               if [[ -e $COLLECT_TIMING ]]; then echo -e "`date '+%a %b %d %H:%M:%S %Y'` - $COLLECTION_NAME on ${db_name_to_check}">>$COLLECT_TIMING; fi
	       if [ "${mb_database_type[$mb_db_counter]}" = "PDB" ]
	       then
	         #mb_checksysdba[$mb_db_counter]=0
	         dbConnectString="${RAT_PDB_USER}/${mb_db_sys_password[$mb_db_counter]}@"${mb_db_connect_string[$mb_db_counter]}" as sysdba"
	       else
                 DBUSR=${mb_sysdba_user[$mb_db_counter]}
                 DBPWD=${mb_sysdba_pswd[$mb_db_counter]}
	         dbConnectString="$DBUSR/$DBPWD as sysdba"
	       fi      

	       get_current_epoch 
               echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $ORACLE_SID] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

	       if [ ${mb_checksysdba[$mb_db_counter]} -eq 0 ]
	       then
	         if [ ${mb_running_host[$mb_db_counter]} = $localnode ]
	         then
		   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		     get_dbOwner

                     cp $INFIL $NEW_INFIL
                     chown $dbOwner:$dbGroup $NEW_INFIL

	             su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s \"$dbConnectString\" >/dev/null 2>&1 <<EOF
	             set head off
	             set lines 80
	             set feedback off
                     set timing off
	             set serveroutput on
	             spool $OUTFIL
	             @@$INFIL
	             spool off
	             exit
EOF
"
		     move_files "$NEW_OUTFIL" "$OUTFIL"
		     rm -f $NEW_INFIL
		     cd $OLD_DIR
	             unset OLD_DIR
		   else
	             #$READ -p "came here for SQL_COLLECT RDBMS without issysdba"
	             $ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
	             set head off
	             set lines 80
	             set feedback off
                     set timing off
	             set serveroutput on
	             spool $OUTFIL
	             @@$INFIL
	             spool off
	             exit
EOF
		   fi
		 else #remote_database_code
		   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		     TMP_SPOOLFIL=$TMP_OUTPUT/sqltorun.out
		     get_dbOwner

		     cp $INFIL $NEW_INFIL
		     $SCOPY $NEW_INFIL ${mb_running_host[$mb_db_counter]}:$TMP_OUTPUT/sqltorun.sql
		     $SSHELL ${mb_running_host[$mb_db_counter]} "chown $dbOwner:$dbGroup $TMP_OUTPUT/sqltorun.sql"
		     $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
		     export ORACLE_HOME=$ORACLE_HOME;
		     export ORACLE_SID=$ORACLE_SID;
		     su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s \"$dbConnectString\" >/dev/null 2>&1 <<EOF
		     set head off
		     set lines 80
		     set feedback off
                     set timing off
		     set serveroutput on
		     spool $RTEMPDIR/sqltorun.out
		     @@$RTEMPDIR/sqltorun.sql
		     spool off
		     exit
EOF
"
EOF2
		     rm -f $NEW_INFIL
		     cd $OLD_DIR
		     unset OLD_DIR
		   else
		     TMP_SPOOLFIL=$RTEMPDIR/sqltorun.out
		     $SCOPY $INFIL ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.sql
		     $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
		     export ORACLE_HOME=$ORACLE_HOME;
		     export ORACLE_SID=$ORACLE_SID;
		     $ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
		     set head off
		     set lines 80
		     set feedback off
                     set timing off
		     set serveroutput on
		     spool $RTEMPDIR/sqltorun.out
		     @@$RTEMPDIR/sqltorun.sql
		     spool off
		     exit
EOF
EOF2
		     fi
		     #$SCOPY ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.out $RTEMPDIR
		     $SCOPY ${mb_running_host[$mb_db_counter]}:$TMP_SPOOLFIL $RTEMPDIR
		     cat $RTEMPDIR/sqltorun.out > $OUTFIL
		 fi
	       else
		 #$ORACLE_HOME/bin/sqlplus -s / as sysdba
	         #$READ -p "came here for SQL_COLLECT RDBMS with issysdba see $OUTFIL"
	         if [ ${mb_running_host[$mb_db_counter]} = $localnode ]
	         then
		   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		     get_dbOwner

                     cp $INFIL $NEW_INFIL
                     chown $dbOwner:$dbGroup $NEW_INFIL

	             su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	             set head off
	             set lines 80
	             set feedback off
                     set timing off  
	             set serveroutput on
	             spool $NEW_OUTFIL
	             @@$NEW_INFIL
	             spool off
	             exit
EOF
"
		     move_files "$NEW_OUTFIL" "$OUTFIL"
		     rm -f $NEW_INFIL
		     cd $OLD_DIR
	             unset OLD_DIR
		   else
	             $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	             set head off
	             set lines 80
	             set feedback off
                     set timing off  
	             set serveroutput on
	             spool $OUTFIL
	             @@$INFIL
	             spool off
	             exit
EOF
		   fi
		 else #remote_database_code
		   if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		     TMP_SPOOLFIL=$TMP_OUTPUT/sqltorun.out
		     get_dbOwner

                     cp $INFIL $NEW_INFIL

		     $SCOPY $NEW_INFIL ${mb_running_host[$mb_db_counter]}:$TMP_OUTPUT/sqltorun.sql
		     $SSHELL ${mb_running_host[$mb_db_counter]} "chown $dbOwner:$dbGroup $TMP_OUTPUT/sqltorun.sql"
		     $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
	             export ORACLE_HOME=$ORACLE_HOME;
		     export ORACLE_SID=$ORACLE_SID;
		     su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		     set head off
		     set lines 80
		     set feedback off
                     set timing off
		     set serveroutput on
		     spool $TMP_SPOOLFIL
		     @@$TMP_OUTPUT/sqltorun.sql
		     spool off
		     exit
EOF
"
EOF2
		     rm -f $NEW_INFIL
		     cd $OLD_DIR
	    	     unset OLD_DIR
		   else
		     TMP_SPOOLFIL=$RTEMPDIR/sqltorun.out
		     $SCOPY $INFIL ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.sql
		     $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
	             export ORACLE_HOME=$ORACLE_HOME;
		     export ORACLE_SID=$ORACLE_SID;
		     $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		     set head off
		     set lines 80
		     set feedback off
                     set timing off
		     set serveroutput on
		     spool $RTEMPDIR/sqltorun.out
		     @@$RTEMPDIR/sqltorun.sql
		     spool off
		     exit
EOF
EOF2
		   fi
		   #$SCOPY ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.out $RTEMPDIR
		   $SCOPY ${mb_running_host[$mb_db_counter]}:$TMP_SPOOLFIL $RTEMPDIR
		   cat $RTEMPDIR/sqltorun.out > $OUTFIL
		 fi
	       fi

	       get_current_epoch 
               echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $ORACLE_SID] Execution End Time: $epoch_time" >> $CHK_TIMINGS
	     fi
	     #if [ $OFFLINE -eq "0" ]; then 
  	     #  get_current_epoch 
	     #  echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $db_name_to_check] Execution End Time: $epoch_time" >> $CHK_TIMINGS
	     #fi
           fi
	 fi
	 #log_pass
     fi
     ;;
  OS_PACKAGE)
     #OS PAckages are a special case
     #what we want to know is if the package is installed
     #is the package that is installed a bad version of the package?
     #if the package is installed and it's not a bad version then => PASS
     #if the package that is installed is bad then => WARN/FAIL
     #$READ -p "RPM status $rpm_status"
  
     if [ $SILENT -eq 0 ]
     then
       echo "ROW=$ROW" >>$LOGFIL
       echo "RPM Checked.recommended rpm is $PARAM_PATH and actual found on system is $actual" and rpm status=$rpm_status>>$LOGFIL
       PARAM_PATH_PASS=""
       if [ -n "${rpm_arr1}" ]
       then
         for array_item in ${rpm_arr1[*]}
         do
           #if [ $element_count -ne 3 ] && [ -n "$array_item" ]
           if [ -n "$array_item" ]
           then
             if [ -z "$PARAM_PATH_PASS" ]
             then
               PARAM_PATH_PASS=$array_item
             else
               PARAM_PATH_PASS=$(echo $PARAM_PATH_PASS"-"$array_item)
             fi
           fi
           element_count=$(expr $element_count + 1)
         done 
       else
         PARAM_PATH_PASS=$(echo $PARAM_PATH|sed 's/|/-/g')
         PARAM_PATH_PASS=$(echo $PARAM_PATH_PASS|sed 's/--/-/g')
       fi
       element_count=0
       ACTUAL_PASS=""
       if [ -n "${rpm_arr2}" ]
       then
         for array_item in ${rpm_arr2[*]}
         do
           #if [ $element_count -ne 3 ] && [ -n "$array_item" ]
           if [ -n "$array_item" ]
           then
             if [ -z "$ACTUAL_PASS" ]
             then
               ACTUAL_PASS=$array_item
             else
               ACTUAL_PASS=$(echo $ACTUAL_PASS"-"$array_item)
             fi
           fi
           element_count=$(expr $element_count + 1)
         done 
       else
         ACTUAL_PASS=$(echo $actual|sed 's/|/-/g')
         ACTUAL_PASS=$(echo $ACTUAL_PASS|sed 's/--/-/g')
       fi
       element_count=0
       if [ $RAT_DEBUG -eq 1 ]
       then
         if [ $rpm_status -eq 0 ] 
         then
           OPSTAT=1
           if [ $rpm_arch -ne 99 ]
           then
             echo "Package $PARAM_PATH_PASS meets or exceeds recommendation but different ${rpm_arr2[3]} architecture">>$LOGFIL
           fi     
           if [ -z "$PMSG" ]; then  PMSG="Package $PARAM_PATH_PASS meets or exceeds recommendation";fi
           log_pass
           ALVL="PASS"
         elif [ $rpm_status -eq 1 ]
         then
           OPSTAT=1
           if [ $rpm_arch -ne 99 ]
           then
             echo "Package $PARAM_PATH_PASS meets or exceeds recommendation but different ${rpm_arr2[3]} architecture">>$LOGFIL
           fi     
           if [ -z "$PMSG" ]; then  PMSG="Package $PARAM_PATH_PASS meets or exceeds recommendation";fi
           log_pass
           ALVL="PASS"
         elif [ $rpm_status -eq 2 ]
         then
           OPSTAT=0
           if [ -z "$FMSG" ]; then FMSG="Package $ACTUAL_PASS does not meet recommendation for $PARAM_PATH_PASS ";fi
           echo "Package $PARAM_PATH_PASS failed for node $i">>$CWOSPKG
           log_fail
           if [ -z "$ALVL" ]; then ALVL="WARNING";fi
         elif [ $rpm_status -eq 3 ]
         then
           OPSTAT=0
           if [ -z "$ALVL" ]; then ALVL="FAIL";fi
           if [ -z "$FMSG" ]; then FMSG="Package $PARAM_PATH_PASS is recommended but NOT installed";fi
           echo "Package $PARAM_PATH_PASS failed for node $i">>$CWOSPKG
           log_fail
         fi
       else
         if [ $rpm_status -eq 0 ] 
         then
           OPSTAT=1
           if [ $rpm_arch -ne 99 ]
           then
              echo "Package $PARAM_PATH_PASS meets or exceeds recommendation but different ${rpm_arr2[3]} architecture">>$LOGFIL
           fi     
           if [ -z "$PMSG" ]; then  PMSG="Package $PARAM_PATH_PASS meets or exceeds recommendation";fi
           log_pass
           ALVL="PASS"
         elif [ $rpm_status -eq 1 ]
         then
           OPSTAT=1
           if [ $rpm_arch -ne 99 ]
           then
              echo "Package $PARAM_PATH_PASS meets or exceeds recommendation but different ${rpm_arr2[3]} architecture">>$LOGFIL
           fi     
           if [ -z "$PMSG" ]; then  PMSG="Package $PARAM_PATH_PASS meets or exceeds recommendation";fi
           ALVL="PASS"
           log_pass
         elif [ $rpm_status -eq  2 ]
         then
           OPSTAT=0
           if [ -z "$FMSG" ]; then FMSG="Package $ACTUAL_PASS does not meet recommendation for $PARAM_PATH_PASS ";fi
           echo "Package $PARAM_PATH_PASS failed for node $i">>$CWOSPKG
           log_fail
           if [ -z "$ALVL" ]; then ALVL="WARNING";fi
         elif [ $rpm_status -eq 3 ]
         then
           OPSTAT=0
           if [ -z "$ALVL" ]; then ALVL="FAIL";fi
           if [ -z "$FMSG" ]; then FMSG="Package $PARAM_PATH_PASS is recommended but NOT installed";fi
           echo "Package $PARAM_PATH_PASS failed for node $i">>$CWOSPKG
           log_fail
         fi 
       fi 
       if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi 
       if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 ]] && [ $write_info_actual_files -eq 1 ]
       then
         echo "${CHECK_ID}|${rpm_status}@$PARAM_PATH_PASS" >>$OSACTUAL
       elif [ $OFFLINE -eq 0 ] && [ $write_info_actual_files -eq 1 ]
       then
         echo "${CHECK_ID}|${rpm_status}@$actual" >>$OSACTUAL
       fi
       #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
       if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

       if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
       then
         if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
         if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
         if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 

	 if [[ $insert_stmt_printed -eq 0 ]]; then
           echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$PARAM_PATH_PASS','$PARAM_PATH_PASS','$ALVL_MB','$status_message','$PARAM_PATH_PASS','$ACTUAL_PASS','NA','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','NA','$CHECK_ID','N/A','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	 fi
         echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$PARAM_PATH_PASS','$PARAM_PATH_PASS','$ALVL_MB','$status_message','$PARAM_PATH_PASS','$ACTUAL_PASS','NA','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','NA','$CHECK_ID','N/A','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
       fi
     else
       #commented below code and above if condition not to generate silent files because i did not find these files being used anywhere else
       #code to generate os check result file in slent mode
       #ACREPCOUNT=`expr $ACREPCOUNT + 1`
       echo  "RPM check # $ACREPCOUNT@RPM Version Check@$actual@$PARAM_PATH@$ALVL=>$FMSG@$rpm_status@$rpm_arch">>$OSPKGSILENT
     fi
     ;;
   OS_PATCH)
     if [ $SILENT -eq 0 ] 
     then
       if [ $RAT_DEBUG -eq 1 ]
       then
         if [ $os_patch_status -eq 1 ]
         then
           #ALVL="PASS"
           OPSTAT=1
           if [ -z "$PMSG" ]; then PMSG="OS Patch $PARAM_PATH meets or exceeds recommendation";fi
           log_pass
           ALVL="PASS"
         elif [ $os_patch_status -eq 2 ]
         then
           #ALVL="WARNING"
           OPSTAT=0
           if [ -z "$FMSG" ]; then FMSG="OS Patch $PARAM_PATH does not satisfy recommendation";fi
           echo "OS Patch $PARAM_PATH failed for node $i">>$CWOSPATCH
           if [ -z "$ALVL" ]; then ALVL="WARNING";fi
           log_fail
         else
           #ALVL="FAIL"
           OPSTAT=0
           if [ -z "$FMSG" ]; then FMSG="OS Patch $PARAM_PATH is recommended but not installed";fi
           echo "OS Patch $PARAM_PATH failed for node $i">>$CWOSPATCH
           if [ -z "$ALVL" ]; then ALVL="FAIL";fi
           log_fail
         fi 
       else   
         if [ $os_patch_status -eq 1 2>>$ERRFIL ]
         then
           #ALVL="PASS"
           OPSTAT=1
           if [ -z "$PMSG" ]; then PMSG="OS Patch $PARAM_PATH meets or exceeds recommendation";fi
           log_pass
           ALVL="PASS"
         elif [ $os_patch_status -eq 2 2>>$ERRFIL ]
         then
           #ALVL="WARNING"
           OPSTAT=0
           if [ -z "$FMSG" ]; then FMSG="OS Patch $PARAM_PATH does not satisfy recommendation";fi
           echo "OS Patch $PARAM_PATH failed for node $i">>$CWOSPATCH
           if [ -z "$ALVL" ]; then ALVL="WARNING";fi 
           log_fail
         else
           #ALVL="FAIL"
           OPSTAT=0
           if [ -z "$FMSG" ]; then FMSG="OS Patch $PARAM_PATH is recommended but not installed";fi
           echo "OS Patch $PARAM_PATH failed for node $i">>$CWOSPATCH
           if [ -z "$ALVL" ]; then ALVL="FAIL";fi   
           log_fail
         fi 
       fi
       #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
       if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

       if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
       then
         #echo "${CHECK_ID}|${os_patch_status}@$os_patch_rls_actual" >>$OSACTUAL  
         if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
         if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
         if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 
	 if [[ $insert_stmt_printed -eq 0 ]]; then
           echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'NA','$PARAM_PATH','$ALVL_MB','$status_message','$os_patch_rls_actual','$PARAM_PASS','NA','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','NA','$CHECK_ID','N/A','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	 fi
         echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'NA','$PARAM_PATH','$ALVL_MB','$status_message','$os_patch_rls_actual','$PARAM_PASS','NA','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','NA','$CHECK_ID','N/A','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
       fi
     fi
     if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
     if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
     then
       echo "$CHECK_ID|$os_patch_status">>$OSACTUAL
     elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
     then
       echo "$CHECK_ID|$os_patch_status">>$OSACTUAL
     fi
     ;;
  SQL|SQL_OUT_CHECK)
     if [ $SILENT -eq "0"  ]
     then
       echo "ROW=$ROW command=$COM actual value=$VAL opeartor=$OP required value $COMP">>$LOGFIL
       #$READ -p  "ROW=$ROW command=$COM actual value=$VAL opeartor=$OP required value $COMP alert level=$ALVL"
       #if [ $COMTYPE = "SQL_OUT_CHECK" ]
       #then
       #$READ -p "Press any key"    
       #$READ -p "rdbms status = ${stack_dbinst_up[$stack_counter]} and asm status =${stack_asm_up[$stack_counter]} and needs running=$NEEDS_RUNNING comtype=$COMTYPE" 
       #fi
       if [[ $i = $localnode &&  ${stack_dbinst_up[$stack_counter]} -ge ${database_mode} && $NEEDS_RUNNING = "RDBMS" && $RAT_RUNMODE_INTERNAL = "master" ]]
       #if [[ $i = $localnode &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS"  ]]
       #if [[ $i = ${mb_running_host[$mb_db_counter]} &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS"  ]]
       then
         if [ $RAT_DEBUG -eq 1 ]
         then
           if [ "$VAL" "$OP" "$COMP" ] #2>>$ERRFIL
           then
             OPSTAT=1
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             if [[ -e $SOURCEFIL_REPORT && `cat $SOURCEFIL_REPORT|sed '/^$/d'|wc -l` -lt 1 ]]
             then
               echo -e "\nQuery returned no rows which is expected when the SQL check passes.\n">>$SOURCEFIL_REPORT
             fi
             log_pass
           else
             OPSTAT=0
             log_fail
           fi
         else
           if [ "${VAL}1" "$OP" "${COMP}1" ] 2>>$ERRFIL
           then
             OPSTAT=1
             if [[ -e $SOURCEFIL_REPORT && `cat $SOURCEFIL_REPORT|sed '/^$/d'|wc -l` -lt 1 ]]
             then
               echo -e "\nQuery returned no rows which is expected when the SQL check passes.\n">>$SOURCEFIL_REPORT
               #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             fi 
             log_pass
           else
             OPSTAT=0
             log_fail
           fi
         fi 
         #$READ -p "ALVL=$ALVL and ALVL_MB=$ALVL_MB"
         #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
         if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

         if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
	 then
           #echo "$CHECK_ID|$VAL">>$DBACTUAL
	   if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
	   if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
	   if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 
           #$READ -p "ALVL=$ALVL and ALVL_MB=$ALVL_MB"
	   #$READ -p "ALVL=$ALVL status_message=$status_message"
	   if [[ $insert_stmt_printed -eq 0 ]]; then
  	     echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	   fi
	   echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
	 fi
       elif [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_asm_up[$stack_counter]} -eq 1 && $NEEDS_RUNNING = "ASM"  ]]
       then
         if [ $RAT_DEBUG -eq 1 ]
         then
           if [ "$VAL" "$OP" "$COMP" ] #2>>$ERRFIL
           then
             OPSTAT=1
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             log_pass
           else
             OPSTAT=0
             log_fail
           fi
         else
           if [ "${VAL}1" "$OP" "${COMP}1" ] 2>>$ERRFIL
           then
             OPSTAT=1
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             log_pass
           else
             OPSTAT=0
             log_fail
           fi
         fi
         #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
         if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

         if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
	 then
           #echo "$CHECK_ID|$VAL">>$AACTUAL
	   if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
	   if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
	   if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 
	   #$READ -p "ALVL=$ALVL status_message=$status_message"
	   if [[ $insert_stmt_printed -eq 0 ]]; then
	     echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	   fi
	   echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
	 fi
       fi 
     elif [ $SILENT -eq "1" ]
     then
       #whenever we are in SILENT mode we want every branch to evaluate to 
       #true so that we traverse the entire tree and so we do not miss 
       #collecting any data for any branch or step
       #
       # so we will declare each pass to be TRUE and go on to log_pass()
       #as if we had evaluated the expression and found it to be TRUE
       OPSTAT=1
       log_pass
     else
       echo "SILENT was not equal to 1 or 0.  This should not happen" >>$LOGFIL
     fi
     if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
     if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
     then
       #if [[ $i = $mb_running_host[$mb_db_counter]} &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS" ]] 
       if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS" ]] 
       then 
         echo "$CHECK_ID|$VAL">>$DBACTUAL
       elif [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_asm_up[$stack_counter]} -eq 1 && $NEEDS_RUNNING = "ASM"  ]] 
       then  
         echo "$CHECK_ID|$VAL">>$AACTUAL
       fi
     elif [[ $OFFLINE -eq 0 &&  $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
     then
       #if [[ $i = ${mb_running_host[$mb_db_counter]} &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS" ]] 
       if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS" ]] 
       then 
         echo "$CHECK_ID|$VAL">>$DBACTUAL
       elif [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_asm_up[$stack_counter]} -eq 1 && $NEEDS_RUNNING = "ASM"  ]] 
       then 
         echo "$CHECK_ID|$VAL">>$AACTUAL
       fi
     fi
     #if [ $COMTYPE = "SQL_OUT_CHECK" ]
     #then
     #  $READ -p "Press any key"    
     #  $READ -p " after execute rdbms status = ${stack_dbinst_up[$stack_counter]} and asm status =${stack_asm_up[$stack_counter]} and needs running=$NEEDS_RUNNING comtype=$COMTYPE" 
     #fi
     ;;
  SQL_PARAM)
     if [ $SILENT -eq "0"  ]
     then
       #echo "$VAL $OP $COMP at $ROW"
       #$READ -p "Press any key"
       echo "ROW=$ROW command=$COM actual value=$VAL opeartor=$OP required value $COMP SOURCEFILENAME=$SOURCEFILENAME">>$LOGFIL
       #$READ -p "Insance status= ${stack_dbinst_up[$stack_counter]} and stack counter is $stack_counter"
       #$READ -p "${stack_dbinst_name[$stack_counter]}.${PARAM_PATH} compare=$COMP and $FMSG"
       if [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
       #if [[ ${stack_dbinst_up[$stack_counter]} -ne 0 || ${stack_asm_up[$stack_counter]} -eq 1 ]]
       then
         VAL=$(echo $VAL|tr "[a-z]" "[A-Z]") 
         COMP=$(echo $COMP|tr "[a-z]" "[A-Z]")
         if [ $RAT_DEBUG -eq 1 ]
         then
           if [ "$VAL" "$OP" "$COMP" ]  #2>>$ERRFIL
           then
             OPSTAT=1
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             log_pass
           else
             OPSTAT=0
             echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
             log_fail
           fi
         else
           if [ "${VAL}1" "$OP" "${COMP}1" ]  2>>$ERRFIL
           then
             OPSTAT=1
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             log_pass
           else
             OPSTAT=0
             echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
             log_fail
           fi
         fi
         #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
         if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

         if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
         then
           #echo "$inst_name|$CHECK_ID|$VAL">>$DBACTUAL
           if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
	   if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
	   if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 

	   if [[ $insert_stmt_printed -eq 0 ]]; then
             echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$target','$inst_name','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	   fi
           echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$i','$inst_name','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
         fi
       elif [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_asm" && ${stack_asm_up[$stack_counter]} -eq 1 ]]
       then
         if [ $RAT_DEBUG -eq 1 ]
         then
           if [ "$VAL" "$OP" "$COMP" ]  #2>>$ERRFIL
           then
             OPSTAT=1
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             log_pass
           else
             OPSTAT=0
             echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
             log_fail
           fi
         else
           if [ "${VAL}1" "$OP" "${COMP}1" ]  2>>$ERRFIL
           then
             OPSTAT=1
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             log_pass
           else
             OPSTAT=0
             echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
             log_fail
           fi
         fi
         #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
         if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

         if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
         then
	   #echo "${stack_asm_sid[$stack_counter]}|$CHECK_ID|$VAL">>$AACTUAL
	   if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
	   if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
	   if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 

	   if [[ $insert_stmt_printed -eq 0 ]]; then
	     echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$target','ASM on $i','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	   fi
	   echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$i','ASM on $i','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
         fi
       elif  [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_u" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
       then
         if [ $RAT_DEBUG -eq 1 ]
         then
           if [ "$VAL" "$OP" "$COMP" ]  #2>>$ERRFIL
           then
             OPSTAT=1
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             log_pass
           else
             OPSTAT=0
             echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
             log_fail
           fi
         else
           if [ "${VAL}1" "$OP" "${COMP}1" ]  2>>$ERRFIL
           then
             OPSTAT=1
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             log_pass
           else
             OPSTAT=0
             echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
             log_fail
           fi
         fi
         #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
         if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

         if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
         then 
           #echo "$inst_name|$CHECK_ID|$VAL">>$DBACTUAL
           if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
	   if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
	   if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 

	   if [[ $insert_stmt_printed -eq 0 ]]; then
             echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$target','$inst_name','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	   fi
           echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$i','$inst_name','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
         fi
       fi
     elif [ $SILENT -eq "1" ]
     then
       #whenever we are in SILENT mode we want every branch to evaluate to
       #true so that we traverse the entire tree and so we do not miss
       #collecting any data for any branch or step
       #
       #so we will declare each pass to be TRUE and go on to log_pass()
       #as if we had evaluated the expression and found it to be TRUE
       OPSTAT=1
       log_pass
     else
       echo "SILENT was not equal to 1 or 0.  This should not happen" >>$LOGFIL
     fi
     if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
     if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
     then
       if [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
       then 
         echo "$inst_name|$CHECK_ID|$VAL">>$DBACTUAL;
       elif [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_asm" && ${stack_asm_up[$stack_counter]} -eq 1 && -e $SOURCEFIL ]]
       then 
         echo "${stack_asm_sid[$stack_counter]}|$CHECK_ID|$VAL">>$AACTUAL
       elif  [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_u" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
       then
         echo "$inst_name|$CHECK_ID|$VAL">>$DBACTUAL
       fi;
     elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
     then
       if [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
       then
         echo "$inst_name|$CHECK_ID|$VAL">>$DBACTUAL;
       elif [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_asm" && ${stack_asm_up[$stack_counter]} -eq 1 && -e $SOURCEFIL ]]
       then
         echo "${stack_asm_sid[$stack_counter]}|$CHECK_ID|$VAL">>$AACTUAL
       elif  [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_u" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
       then
         echo "$inst_name|$CHECK_ID|$VAL">>$DBACTUAL
       fi
     fi
     ;;
  CLUSTERWIDE_CHECK)
     #if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]]
     #then
     #    echo "$CHECK_ID|$CRS_VAL">>$CCACTUAL
     #elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]]
     #then
     #    echo "$CHECK_ID|$CRS_VAL">>$CCACTUAL
     #fi   
     if [[ -n "$cross_node_get_log_result_call" && $cross_node_get_log_result_call -eq 1 ]]
     then 
       if [ $RAT_DEBUG -eq 1 ]
       then
         if [ "$VAL" "$OP" "$COMP" ]; then CRS_VAL=1; else CRS_VAL=0;fi
       else
         if [ "${VAL}1" "$OP" "${COMP}1" ] 2>>$ERRFIL; then CRS_VAL=1; else CRS_VAL=0;fi
       fi 
     fi
     if [[ -n $CRS_VAL && $CRS_VAL -eq 1 ]]
     then
       #$READ -p  "cls_check_val1=$cls_check_val1 and cls_check_val2=$cls_check_val2 and CRS_VAL=$CRS_VAL $ROW $PMSG $FMSG $audit_check_name $COMTYPE"
       #$READ -p "COMTYPE=$COMTYPE"
       OPSTAT=1
       log_pass
       #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
       if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

       if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
       then
         #echo "$CHECK_ID|$VAL">>$CCACTUAL
         if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
         if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
         if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 
	
	 if [[ $insert_stmt_printed -eq 0 ]]; then
           echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$FILVAL','$COMP','$OP','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','NA','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	 else
	   cellname_counter=0
	   for cellname in ${a_cellname[@]}
	   do
	     target=$cellname
	     ACT_TARGET=$cellname
 	     ALVL_MB=${a_cellCheckStatus[$cellname_counter]}
             echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
 	     cellname_counter=$(expr $cellname_counter + 1 ) 
	   done
	 fi
         echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$FILVAL','$COMP','$OP','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','NA','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
       fi
     elif [[ -n $CRS_VAL && $CRS_VAL -eq 0 ]]
     then
       OPSTAT=0
       log_fail
       #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
       if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

       if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
       then
         if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
         if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
         if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 

	 if [[ $insert_stmt_printed -eq 0 ]]; then
           echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$FILVAL','$COMP','$OP','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','NA','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	 else
	   cellname_counter=0
	   for cellname in ${a_cellname[@]}
	   do
	     target=$cellname
	     ACT_TARGET=$cellname
 	     ALVL_MB=${a_cellCheckStatus[$cellname_counter]}
             echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
 	     cellname_counter=$(expr $cellname_counter + 1 ) 
	   done
	 fi
         echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$FILVAL','$COMP','$OP','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','NA','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
       fi
     fi   
     ;;
  *)
     #$READ -p "Press any key in get log result" 
     #We only want to do this comparison if we're NOT in SILENT mode
     #in SILENT mode we will not have a comparison operator or comparison value
     
     if [ $SILENT -eq "0"  ]
     then
       echo "ROW=$ROW command=$COM actual value=$VAL opeartor=$OP required value =$COMP execute once=$execute_once ">>$LOGFIL
       #echo "ROW=$ROW command=$COM actual value=$VAL opeartor=$OP required value =$COMP execute once=$execute_once "
       #$READ -p "Press any key"     
       #echo "VAL=%%%$VAL%%%%"
       if [[ $execute_once -eq 1 && $i != $localnode  ]]
       then
         execute_once_exec=0
       elif [[ $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave"  ]]
       then
         execute_once_exec=0
       else
	 #if [ `echo $COM|grep -ic copy_collect_file` -ge 1 ]
	 #then
	 #    copy_collect_file_name=$(echo $COM >/dev/null|cut -d= -f2|cut -d; -f1)
	 #    cp ${OUTPUTDIR}/${copy_collect_file_name} .
         #    $READ -p "see file $copy_collect_file_name"
	 #fi
         execute_once_exec=1
         if [ $RAT_DEBUG -eq 1 ] 
         then
           if [ "$VAL" "$OP" "$COMP" ] # 2>>$ERRFIL
           then
             OPSTAT=1
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             log_pass
           else
             OPSTAT=0
             log_fail
             if [ "$COMTYPE" = "OS_PARAM" ]; then echo "OS(kernel) parameter $PARAM_PATH failed for node $i">>$CWOSPARAM;fi;
           fi 
         else
           if [ "${VAL}1" "$OP" "${COMP}1" ]  2>>$ERRFIL
           then
             OPSTAT=1
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             log_pass
           else
             OPSTAT=0
             log_fail
             if [ "$COMTYPE" = "OS_PARAM" ]; then echo "OS(kernel) parameter $PARAM_PATH failed for node $i">>$CWOSPARAM;fi;
           fi 
         fi
         #if [[ -n  "$os_check_needs_collect_file" && $os_check_needs_collect_file -eq 1 ]]; then rm $VAL_FIL;os_check_needs_collect_file=0; unset VAL_DIR VAL_FIL ;fi;
         #if [[ `echo $COM|grep -ic copy_collect_file` -ge 1 && -f $copy_collect_file_name ]]; then rm $copy_collect_file_name;fi;
         #if [[ $OPSTAT -eq 1 && $print_pass_in_report -eq 0 && -z "$RAT_UPLOAD_PASS_CHECKS" ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi
         if [[ $OPSTAT -eq 1 ]] && [[ -n "$RAT_UPLOAD_PASS_CHECKS" && $RAT_UPLOAD_PASS_CHECKS -eq 0 ]]; then upload_pass_checks=0;else upload_pass_checks=1;fi

         if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 && $upload_pass_checks -eq 1 ]]   
	 then
           #if [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "RDBMS" ]]
           #then
           #    echo "${db_name_to_check}|${CHECK_ID}|${VAL}" >>$OSACTUAL
           #elif [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && `echo $COM|grep -ic "limits.conf"` -lt 1 ]]
           #then
           #    echo "${mb_db_homes_without_slash}|${CHECK_ID}|${VAL}" >>$OSACTUAL
           #else
           #    echo "${CHECK_ID}|${VAL}" >>$OSACTUAL
           #fi
	   if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
	   if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
           if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 

	   if [[ $insert_stmt_printed -eq 0 ]]; then
	     echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
	   else
	     cellname_counter=0
	     for cellname in ${a_cellname[@]}
	     do
	       target=$cellname
	       ACT_TARGET=$cellname	       
 	       ALVL_MB=${a_cellCheckStatus[$cellname_counter]}
               echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$target','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil
 	       cellname_counter=$(expr $cellname_counter + 1 ) 
	     done
	   fi
	   echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name,upload_collection_name,auditcheck_result_id,target_type,target_value)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$print_audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$current_version','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}','$upload_collection_name',sys_guid(),'$P_TARGET_TYPE','$ACT_TARGET');">>$upload_raccheck_result_fil_base
	 fi
       fi
     elif [ $SILENT -eq "1" ]
     then
       #whenever we are in SILENT mode we want every branch to evaluate to 
       #true so that we traverse the entire tree and so we do not miss 
       #collecting any data for any branch or step
       #
       #so we will declare each pass to be TRUE and go on to log_pass()
       #as if we had evaluated the expression and found it to be TRUE
       OPSTAT=1
       log_pass
     else
       echo "SILENT was not equal to 1 or 0.  This should not happen" >>$LOGFIL
     fi
     if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
     if [[ $execute_once -eq 1 && $i != $localnode  ]]
     then
       echo "" >/dev/null 2>&1 
     elif [[ $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave"  ]]
     then
       echo "" >/dev/null 2>&1 
     elif [ $write_info_actual_files -eq 1 ]
     then
       if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]]  
       then
         if [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "RDBMS" ]]
         then
           echo "${db_name_to_check}|${CHECK_ID}|${VAL}" >>$OSACTUAL
         elif [[ -n "$multiple_oracle_homes" && $multiple_oracle_homes -gt 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && -n "$ulimit_cmd" && $ulimit_cmd -eq 0 ]]   
         #elif [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && `echo $COM|grep -ic "limits.conf"` -lt 1 ]]
         then
           echo "${mb_db_homes_without_slash}|${CHECK_ID}|${VAL}" >>$OSACTUAL
         elif [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH" ]] && [[ -e $switch_name_file && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]]
         then
           echo "${switchname}|${CHECK_ID}|${VAL}" >>$OSACTUAL
         else
           echo "${CHECK_ID}|${VAL}" >>$OSACTUAL
         fi
       elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]]
       then
         if [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "RDBMS" ]]
         then
           echo "${db_name_to_check}|${CHECK_ID}|${VAL}" >>$OSACTUAL
         elif [[ -n "$multiple_oracle_homes" && $multiple_oracle_homes -gt 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && -n "$ulimit_cmd" && $ulimit_cmd -eq 0 ]]   
         #elif [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && `echo $COM|grep -ic "limits.conf"` -lt 1 ]]
         then
           echo "${mb_db_homes_without_slash}|${CHECK_ID}|${VAL}" >>$OSACTUAL
         elif [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH" ]] && [[ -e $switch_name_file && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]]
         then
           echo "${switchname}|${CHECK_ID}|${VAL}" >>$OSACTUAL    
         else
           echo "${CHECK_ID}|${VAL}" >>$OSACTUAL
         fi
       fi
     fi
     ;;
  esac
  ;;  
  esac
 
  if [[ -n "$cmd_type" && $cmd_type = "inloop" && $mb_db_counter_log -eq "0" ]]
  then
    m_opstat[$CUR_LEVEL]=""
  fi

  if [[ -n "$cmd_type" && $cmd_type = "inloop" && $OPSTAT -eq "1" ]]
  then # Load all succeeded target names into array
    #l_mb_db_homes is already set in set_skip_this_version
    if [ $cmd_value = "switch" ] ; then
      #echo "Pass on ${m_opstat[$CUR_LEVEL]},$switchname"
      m_opstat[$CUR_LEVEL]="${m_opstat[$CUR_LEVEL]},$switchname";
    else
      m_opstat[$CUR_LEVEL]="${m_opstat[$CUR_LEVEL]},$l_mb_db_homes-$l_mb_db_home_dname";
    fi
  elif [[  -n "$cmd_type" && $cmd_type = "inloop" && $OPSTAT -eq "0" ]]
  then
    m_opstat[$CUR_LEVEL]="${m_opstat[$CUR_LEVEL]},failedontarget"
  elif [[ -z "$cmd_type" && $OPSTAT -eq "1" ]] ; then
    m_opstat[$CUR_LEVEL]="passed_on_all_targets";
  elif [[ -z "$cmd_type" && $OPSTAT -eq "0" ]] ; then
    m_opstat[$CUR_LEVEL]="failedontarget"
  fi;

  if [ $OFFLINE -eq "0" ]; then 
    get_current_epoch 
    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $pval] Check:get_log_result End Time: $epoch_time" >> $CHK_TIMINGS
  fi
}

check_patch ()
{
  #if [ `$CRS/bin/olsnodes |wc -l` -gt 4 ]
  if [ `cat $HOSTLIST|wc -l` -gt 999 ] 
  then
    if [ "$1" = "crs" ]
    then
      APPLIED=`$SSHELL $i grep -c Oneoffs21\/$2 $CRS_INVENTORY`
    elif [ "$1" = "rdbms" ]
    then
      APPLIED=`$SSHELL $i grep -c Oneoffs21\/$2 $RDBMS_INVENTORY`
    elif [ "$1" = "asm" ]
    then
      APPLIED=`$SSHELL $i grep -c Oneoffs21\/$2 $ASM_INVENTORY`
    fi
  else
    if [ $OFFLINE -eq 0 ]
    then
      if [[ "$1" = "rdbms" ]]
      then 
        APPLIED=`grep -c $2 ${OUTPUTDIR}/o_${1}_inventory_${mb_db_homes_fil}_${i}.out`
        if [[ -z "$APPLIED" || $APPLIED -eq 0 ]]; then check_higher_patch "${OUTPUTDIR}/o_${1}_inventory_${mb_db_homes_fil}_${i}.out" "$2" "$1";fi
        #$READ -p " ${OUTPUTDIR}/o_${1}_inventory_${i}_${mb_db_homes_fil}.out"
      else 
        APPLIED=`grep -c $2 ${OUTPUTDIR}/o_${1}_inventory_${i}.out`
        if [[ -z "$APPLIED" || $APPLIED -eq 0 ]]; then check_higher_patch "${OUTPUTDIR}/o_${1}_inventory_${i}.out" "$2" "$1";fi
      fi
    else
      if [[ "$1" = "rdbms" ]]
      then
        APPLIED=`grep -c $2 ${DUMPDIR}/o_${1}_inventory_${mb_db_homes_fil}_${i}.out`
        if [[ -z "$APPLIED" || $APPLIED -eq 0 ]]; then check_higher_patch "${DUMPDIR}/o_${1}_inventory_${mb_db_homes_fil}_${i}.out" "$2" "$1";fi
        #$READ -p " ${OUTPUTDIR}/o_${1}_inventory_${i}_${mb_db_homes_fil}.out"
      else
        APPLIED=`grep -c $2 ${DUMPDIR}/o_${1}_inventory_${i}.out`
        if [[ -z "$APPLIED" || $APPLIED -eq 0 ]]; then check_higher_patch "${DUMPDIR}/o_${1}_inventory_${i}.out" "$2" "$1";fi
      fi
    fi
  fi
  #$READ -p "stop for higher_patch"
  return $APPLIED
}

check_higher_patch ()
{
  if [ "$3" = "rdbms" ]
  then 
    #applied_patches=$(cat $1|grep  ^"Patch description"|grep -i database|awk '{print $NF}'|sed 's/[^0-9]*//g')
    applied_patches=$(grep  ^"Patch description" $1|grep -i database|awk '{print $NF}'|sed 's/[^0-9]*//g')
  else
    #applied_patches=$(cat $1|grep  ^"Patch description"|grep -iv database|awk '{print $NF}'|sed 's/[^0-9]*//g')
    applied_patches=$(grep  ^"Patch description" $1|grep -iv database|awk '{print $NF}'|sed 's/[^0-9]*//g')
  fi
  #applied_patches="14727309 14727318 14727329 14727349"
  if [[ -e $1 && -n "$applied_patches" ]]
  then
    for applied_patch in $applied_patches
    do
      if [ "$applied_patch" -gt $2 ]
      then
        APPLIED=1
        PATCH=$applied_patch
        #SUBJ=$(cat $1|grep -iw $PATCH|grep -iw "description")
        SUBJ=$(grep -iw $PATCH $1|grep -iw "description")
        break
      else
        APPLIED=0
      fi
   done
  fi
}

checksysdba()
{
  if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
  then
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      get_dbOwner

      IS_SYSDBA=$(su $dbOwner -c "echo \"select 1 from dual;\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba 2>>$ERRFIL|grep -v ^$") 
      cd $OLD_DIR
      unset OLD_DIR
    else
      IS_SYSDBA=$(echo "select 1 from dual;"|$ORACLE_HOME/bin/sqlplus -s / as sysdba 2>>$ERRFIL|grep -v ^$) 
    fi
  else #remote_database_code
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      get_dbOwner "${mb_running_host[$mb_db_counter]}"

      IS_SYSDBA=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
      export ORACLE_HOME=$ORACLE_HOME ; \
      export ORACLE_SID=$ORACLE_SID; \
      cd "$dbhome_dir"; \
      su $dbOwner -c "echo \"select 1 from dual;\" | $ORACLE_HOME/bin/sqlplus -s / as sysdba |grep -v ^$"
EOF
)
      cd $OLD_DIR
      unset OLD_DIR
    else
      IS_SYSDBA=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
      export ORACLE_HOME=$ORACLE_HOME ; \
      export ORACLE_SID=$ORACLE_SID; \
      echo "select 1 from dual;" | $ORACLE_HOME/bin/sqlplus -s / as sysdba |grep -v ^$
EOF
)
    fi
  fi
  echo "Value back from Database is  $IS_SYSDBA">>$LOGFIL
  if [ `echo $IS_SYSDBA|grep -c "ORA-"` -ge 1 ]
  then
    IS_SYSDBA=0
  else
    IS_SYSDBA=1
  fi
  echo -e "\nValue set to IS_SYSDBA for $db_name_to_check = ${IS_SYSDBA}\n\n">>$LOGFIL
}

checkpassword ()
{
  if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
  then
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      get_dbOwner
      is_password_correct=$(su $dbOwner -c "echo \"select 1 from dual;\"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba |grep -v ^$")
      cd $OLD_DIR
      unset OLD_DIR
    else
      is_password_correct=$(echo "select 1 from dual;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba |grep -v ^$)
    fi
  else #remote_database_code
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      get_dbOwner
      is_password_correct=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
      cd "$dbhome_dir"; 
      export ORACLE_HOME=$ORACLE_HOME
      export ORACLE_SID=$ORACLE_SID; \
      su $dbOwner -c "echo \"select 1 from dual;\"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba |grep -v ^$"
EOF
)
      cd $OLD_DIR
      unset OLD_DIR
    else
      is_password_correct=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
      export ORACLE_HOME=$ORACLE_HOME
      export ORACLE_SID=$ORACLE_SID; \
      echo "select 1 from dual;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba |grep -v ^$
EOF
)
    fi
  fi
  if [[ -n "$is_password_correct" && `echo $is_password_correct|grep -c "ORA-"` -ge 1 ]]
  then
    echo -e "\n${is_password_correct}\n"
    WRNDBPWD=`expr $WRNDBPWD + 1`
    if [ $WRNDBPWD -lt 3 ]; 
    then
      nosysdba
    else    
      unset mb_db_names[$mb_db_counter] 
      echo -e "${RED}\n\n$DBUSR is not able to login as sysdba to ${db_name_to_check}.Make sure password file is available on ${mb_running_host[$mb_db_counter]} and you are using password file password to login as sysdba.\nYou can cancel (ctrl+c) this run,configure password file and run it again. Otherwise best practice checks for $db_name_to_check database will be skipped.\n\n"${NORM}|tee -a $LOGFIL
      echo -e "$is_password_correct">>$LOGFIL 
      #removing database from list becauase password did not work
    fi
  fi
}

checkdictionary ()
{
  if [ $IS_SYSDBA -eq 0 ]
  then
    if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
    then
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	get_dbOwner
        IS_DICTIONARY=$(su $dbOwner -c "echo \"select name from v\\\$database;\"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD sysdba |grep -v ^$")     
	cd $OLD_DIR
	unset OLD_DIR
      else
        IS_DICTIONARY=$(echo "select name from v\$database;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD sysdba |grep -v ^$)     
      fi
    else #remote_database_code
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	get_dbOwner
        IS_DICTIONARY=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
	cd "$dbhome_dir";
        export ORACLE_HOME=$ORACLE_HOME
        export ORACLE_SID=$ORACLE_SID; \
        su $dbOwner -c "echo \"select name from v\\\\\\$database;\" | $ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD sysdba|grep -v ^$"
EOF
)
	cd $OLD_DIR
	unset OLD_DIR
      else
        IS_DICTIONARY=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
        export ORACLE_HOME=$ORACLE_HOME
        export ORACLE_SID=$ORACLE_SID; \
        echo "select name from v\\\$database;" | $ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD sysdba|grep -v ^$
EOF
)
      fi
    fi
  fi
  #echo "checkdictionary IS_DICTIONARY=$IS_DICTIONARY";

  if [ `echo $IS_DICTIONARY|grep -c "ORA-00942"` -ge 1 ]
  then
    IS_DICTIONARY=0
  else
    IS_DICTIONARY=1
  fi
}

nosysdba ()
{
  if [ $WRNDBPWD -gt 0 ]
  then
    if [[ $EM_PROBE_MODE -eq 1 ]]; then return; fi

    exec 3<&2; exec 2<&0 
    $READ -p "Enter user name again for $db_name_to_check:- " DBUSR
    exec 2<&3
    printf  "Enter password for $DBUSR@$db_name_to_check:- " 
    tty -s && stty -echo
    $READ DBPWD
    read_code=`echo $?`;
    tty -s && stty echo
    if [[ $read_code -eq 1 ]]; then return; fi

    if [ `echo $DBUSR|wc -w` -gt 1 ]; then DBUSR=`echo $DBUSR|awk '{print $1}'`; fi
    checkpassword
  else
    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="TEXT" defaultId="" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n5_nlsid">
      OS authentication is not enabled so enter sysdba privileged user name for {1}
    </text>
    <tokens>
      <token index="1">$db_name_to_check</token>
    </tokens>
    </tokenizedtext>
  </question>
</group>
EOF
      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

      cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="SECRET" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n6_nlsid">
      Enter password for {1}@{2} 
    </text>
    <tokens>
      <token index="1">$DBUSR</token>
    </tokens>
    <tokens>
      <token index="2">$db_name_to_check</token>
    </tokens>
    </tokenizedtext>
  </question>
</group>
EOF
      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

      echo -e "\n"
      echo -e "OS authentication is not enabled so please enter sysdba privileged user name for $db_name_to_check:- "
      printf  "Enter password for $DBUSR@$db_name_to_check:- " 
    elif [[ $EM_XMLD_MODE -eq 1 ]]
    then
      echo "OS authentication is not enabled so please enter sysdba privileged user name for $db_name_to_check:- "
      read_probe_xml "<token index=\"1\">$db_name_to_check</token>" 
      DBUSR=$xml_rvalue

      printf  "Enter password for $DBUSR@$db_name_to_check:- "
      read_probe_xml "<token index=\"2\">$db_name_to_check</token>" 
      DBPWD=$xml_rvalue
    else
      #$READ -p "ORACLE_HOME=$ORACLE_HOME and ORACLE_SID=$ORACLE_SID"
      echo -e "\n"
      exec 3<&2; exec 2<&0
      $READ -p "OS authentication is not enabled so please enter sysdba privileged user name for $db_name_to_check:- " DBUSR
      exec 2<&3
      printf  "Enter password for $DBUSR@$db_name_to_check:- " 
      tty -s && stty -echo
      $READ DBPWD
      read_code=`echo $?`;
      tty -s && stty echo
      if [[ $read_code -eq 1 ]]; then return; fi

      if [ `echo $DBUSR|wc -w` -gt 1 ]; then DBUSR=`echo $DBUSR|awk '{print $1}'`; fi
      checkpassword
    fi
  fi
  #If user enter sys as sysdba, take only sys because script appends "as sysdba".
}

singleSqlValue ()
{
  colname=`echo $1 |tr 'a-z' 'A-Z'` 
  if [[ ${#mb_checksysdba[@]} -gt 0 && ${mb_checksysdba[$mb_db_counter]} -eq 1 ]]
  then
    if [ $# -eq 3  ]
    then 
      if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
      then
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  get_dbOwner

          sqlValue=$(su $dbOwner -c "echo \"set heading off feedback off timing off;
                    select '$colname = ' ||$colname from $3\$\"$2\";\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$|tail -1")
          cd $OLD_DIR
	  unset OLD_DIR
	else
          sqlValue=$( echo "set heading off feedback off timing off;
                    select '$colname = ' ||$colname from $3\$"$2";"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$|tail -1)
	fi
      else #remote_database_code
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  get_dbOwner "${mb_running_host[$mb_db_counter]}"

          sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
          export ORACLE_HOME=$ORACLE_HOME
          export ORACLE_SID=$ORACLE_SID; \
	  cd "$dbhome_dir"; \
          su $dbOwner -c "echo \"set heading off feedback off timing off;
                    select '$colname = ' ||$colname from $3\$\"$2\";\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$|tail -1"
EOF
)
          cd $OLD_DIR
	  unset OLD_DIR
	else
          sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
          export ORACLE_HOME=$ORACLE_HOME
          export ORACLE_SID=$ORACLE_SID; \
          echo "set heading off feedback off timing off;
                    select '$colname = ' ||$colname from $3\$"$2";"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$|tail -1
EOF
)
	fi
      fi
    else
      if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
      then
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  get_dbOwner

          sqlValue=$(su $dbOwner -c "echo \"set heading off feedback off timing off;
               select '$colname = '||$colname from $2;\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba |grep -v ^\$|tail -1")
          cd $OLD_DIR
	  unset OLD_DIR
	else
          sqlValue=$( echo "set heading off feedback off timing off;
               select '$colname = '||$colname from $2;"|$ORACLE_HOME/bin/sqlplus -s / as sysdba |grep -v ^\$|tail -1)
	fi
      else #remote_database_code
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  get_dbOwner "${mb_running_host[$mb_db_counter]}"

          sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
          export ORACLE_HOME=$ORACLE_HOME
          export ORACLE_SID=$ORACLE_SID; \
	  cd "$dbhome_dir"; \
          su $dbOwner -c "echo \"set heading off feedback off timing off;
              select '$colname = '||$colname from $2;\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba |grep -v ^\$|tail -1"
EOF
)
          cd $OLD_DIR
	  unset OLD_DIR
	else
          sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
          export ORACLE_HOME=$ORACLE_HOME
          export ORACLE_SID=$ORACLE_SID; \
          echo "set heading off feedback off timing off;
              select '$colname = '||$colname from $2;"|$ORACLE_HOME/bin/sqlplus -s / as sysdba |grep -v ^\$|tail -1
EOF
)
	fi
      fi
    fi
  else
    mb_sysdba_user[$mb_db_counter]=$DBUSR
    mb_sysdba_pswd[$mb_db_counter]=$DBPWD 
    if [ $# -eq 3  ]
    then
      if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
      then
          sqlValue=$( echo "set heading off feedback off timing off;
                     select '$colname = ' ||$colname from $3\$"$2";"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$|tail -1)
      else #remote_database_code
          sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
          export ORACLE_HOME=$ORACLE_HOME
          export ORACLE_SID=$ORACLE_SID; \
          echo "set heading off feedback off timing off;
               select '$colname = ' ||$colname from $3\$"$2";"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$|tail -1
EOF
)
      fi
      #echo $sqlValue
      #$READ -p "press any key f"
    else
      if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
      then
          sqlValue=$( echo "set heading off feedback off timing off;
              select '$colname = '||$colname from $2;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba |grep -v ^\$|tail -1)
      else #remote_database_code
          sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
          export ORACLE_HOME=$ORACLE_HOME
          export ORACLE_SID=$ORACLE_SID; \
          echo "set heading off feedback off timing off;
               select '$colname = '||$colname from $2;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$|tail -1
EOF
)
      fi
    fi
  fi
}

multipleSqlValue ()
{
  if [[ ${#mb_checksysdba[@]} -gt 0 && ${mb_checksysdba[$mb_db_counter]} -eq 1 ]]
  then
    if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
    then
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	get_dbOwner

        sql_stmt=$(echo $1 | sed 's/\$/\\\$/g')

        sqlValue=$(su $dbOwner -c "echo \"set heading off feedback off timing off;
		  $sql_stmt;\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$")
        cd $OLD_DIR
	unset OLD_DIR
      else
        sqlValue=$( echo "set heading off feedback off timing off;
		  $1;"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$)
      fi
    else #remote_database_code
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	get_dbOwner "${mb_running_host[$mb_db_counter]}"

        sql_stmt=$(echo $1 | sed 's/\$/\\\\\\$/g')
        sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
        export ORACLE_HOME=$ORACLE_HOME
        export ORACLE_SID=$ORACLE_SID; \
	cd "$dbhome_dir"; \
        su $dbOwner -c "echo \"set heading off feedback off timing off;
		  $sql_stmt;\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$"
EOF
 )
        cd $OLD_DIR
	unset OLD_DIR
      else
        sql_stmt=$(echo "$1" | sed 's/\$/\\\$/g')
        sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
        export ORACLE_HOME=$ORACLE_HOME
        export ORACLE_SID=$ORACLE_SID; \
        echo "set heading off feedback off timing off;
		  $sql_stmt;"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$
EOF
 )
      fi
    fi
  else
    mb_sysdba_user[$mb_db_counter]=$DBUSR
    mb_sysdba_pswd[$mb_db_counter]=$DBPWD
    if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
    then
        sqlValue=$( echo "set heading off feedback off timing off;
		  $1;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$)
    else #remote_database_code
        sql_stmt=$(echo $1 | sed 's/\$/\\\\\\$/g')
        sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
        export ORACLE_HOME=$ORACLE_HOME
        export ORACLE_SID=$ORACLE_SID; \
        echo "set heading off feedback off timing off;
	    $sql_stmt;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$
EOF
)
    fi
  fi
}

is_crs_up ()
{
  if [ $is_windows -eq "1" ] ; then
    crs_up=0
    if [ `grep -c OracleOHService $win_services` -gt "0" ] ; then
      crs_up=1
      v_crs_home_val=$(grep CRS_HOME= $windiscover | sed 's/CRS_HOME=//')
      #if [ `grep cluster_name= $v_crs_home_val/install/cluster.ini | sed 's/cluster_name=//'|wc -c` -lt 3 ] ; then
      if [[ -n "$RAT_ORACLE_RESTART" && $RAT_ORACLE_RESTART -eq "1" ]] ; then
        oracle_restart=1
        crs_version_switch="has softwareversion"
      fi
    fi
    return;
  fi
  check_crsd=$(ps -ef |grep -ic "crsd\.bin")
  check_crs=`ps -ef|grep -ic "d.bin"`
  if [[ ${check_crs} -ge 4 && $check_crsd -gt 0 ]]
  then
    crs_up=1
  else
    crs_up=0
  fi
  if [[ ${check_crs} -ge 4 && -n "$check_crsd" && $check_crsd -lt 1 ]]
  then
    crs_up=1
    oracle_restart=1
    crs_version_switch="has softwareversion"
  else 
    oracle_restart=0
  fi
  echo "ORACLE_RESTART = $oracle_restart" >>$MASTERFIL
}

is_db_up ()
{
  somebgproc=`echo $bgproc|cut -d_ -f2`
  somebgsid=`echo $bgproc|cut -d_ -f3|cut -d' ' -f1`
  #$READ -p "$bgproc and $somebgsid somebgproc=$somebgproc"
  if [ `echo $bgproc|grep -c "ora_pmon_$ORACLE_SID"` -ge 1 ]
  then
    db_up=1
    somedb_up=1  
    somedb_up=1  
  elif [ "$somebgproc" = "pmon" ]
  then
    somedb_up=1
    db_up=0
  else
    db_up=0
    somedb_up=0
  fi
  #$READ -p "db_up=$db_up"
}

#this function is to find out the inventory location dependet on platform
#if no inventory is found , means no CRS and RDBMS is installed
search_invntr_platform ()
{
  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]; then return; fi;
  invntr_counter=0
  for invntr in `cat $HOSTLIST`
  do
    case `/bin/uname` in
    Linux)
      if [[ -n "$RAT_ORATAB_LOC" ]]
      then
           v_oratab=$RAT_ORATAB_LOC;
      else
           v_oratab="/etc/oratab"
      fi
      if [ $invntr = $localnode ]
      then
        if [[ -e /etc/oraInst.loc && -z "$RAT_INV_LOC" ]]
        then
          #invntr_location[$invntr_counter]=`cat /etc/oraInst.loc|grep -v "^#"|grep inventory_loc|cut -d= -f2`
          invntr_location[$invntr_counter]=`grep -v "^#" /etc/oraInst.loc|grep inventory_loc|cut -d= -f2`
          if [ -z "${invntr_location[$invntr_counter]}" ] 
          then   
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
	      EMSG="${program_name} did not find the inventory location on $invntr from environment.\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it\neg export RAT_INV_LOC=/u01/app/oraInventory"
	      update_probe_xml "ERROR" "GENERIC" "$EMSG"
	    fi
            echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
            exit 1; 
          fi
        elif [[ ! -e /etc/oraInst.loc && -z "$RAT_INV_LOC" ]]
        then 
          if [ -z "$ask_inv_loc" ]; then
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
    	      cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o2" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n76_nlsid">
        Unable to find the inventory location on {1} from environment 
      </text>
      <tokens>
	<token index="1">$invntr</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n77_nlsid">
      Does {1} have Oracle software installed 
    </text>
    <tokens>
      <token index="1">$invntr</token>
    </tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
</group>
EOF
	      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	      ask_inv_loc="No"
	    elif [[ $EM_XMLD_MODE -eq 1 ]]
	    then
	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	     
	      read_probe_xml "Unable to find the inventory location on {1} from environment"
	      ask_inv_loc=$xml_rvalue
	    else
              exec 3<&2; exec 2<&0
              $READ -p "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?" ask_inv_loc
	      read_code=`echo $?`;
              exec 2<&3
	      process_prompt "$read_code" "ask_inv_loc" "n"
	    fi
          fi
          case $ask_inv_loc in
            y|Y|yes|YES|Yes)
              echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
              exit 1; 
              ;;
            n|N|No|NO)   
              #$READ -p "invntr_location= ${invntr_location[$invntr_counter]}"
              ;;
            *)     
              ;;    
          esac
        else 
          invntr_location[$invntr_counter]=$RAT_INV_LOC
        fi
      else
        $SSHELL $invntr ls -l /etc/oraInst.loc >/dev/null 2>&1
        inv_ptr_exist=$(echo $?) 
        if [[ $inv_ptr_exist -eq 0 && -z "$RAT_INV_LOC" ]]
        then
          invntr_location[$invntr_counter]=`$SSHELL $invntr cat /etc/oraInst.loc|grep -v "^#"|grep inventory_loc|cut -d= -f2`
          if [ -z "${invntr_location[$invntr_counter]}" ] 
          then   
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
	      EMSG="${program_name} did not find the inventory location on $invntr from environment.\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it.\neg export RAT_INV_LOC=/u01/app/oraInventory"
	      update_probe_xml "ERROR" "GENERIC" "$EMSG"
	    else
              echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
              exit 1; 
	    fi
          fi
        elif [[ $inv_ptr_exist -ne 0 && -z "$RAT_INV_LOC" ]]
        then 
          if [ -z "$ask_inv_loc" ]; then
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
    	      cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o2" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n76_nlsid">
        Unable to find the inventory location on {1} from environment 
      </text>
      <tokens>
	<token index="1">$invntr</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n77_nlsid">
      Does {1} have Oracle software installed 
    </text>
    <tokens>
      <token index="1">$invntr</token>
    </tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
</group>
EOF
	      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	      ask_inv_loc="No"
	    elif [[ $EM_XMLD_MODE -eq 1 ]]
	    then
	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	     
	      read_probe_xml "Unable to find the inventory location on {1} from environment"
	      ask_inv_loc=$xml_rvalue
	    else
              exec 3<&2; exec 2<&0
              $READ -p "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?" ask_inv_loc
	      read_code=`echo $?`;
              exec 2<&3
	      process_prompt "$read_code" "ask_inv_loc" "n"
	    fi
          fi
          case $ask_inv_loc in
            y|Y|yes|YES|Yes)
              echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
              exit 1; 
              ;;
            n|N|No|NO)   
              ;;
            *)     
              ;;    
          esac
        else
          invntr_location[$invntr_counter]=$RAT_INV_LOC
        fi
      fi
    ;;
    SunOS)
      if [[ -n "$RAT_ORATAB_LOC" ]]
      then
           v_oratab=$RAT_ORATAB_LOC;
      else
      	   v_oratab="/var/opt/oracle/oratab"
      fi
      if [ $invntr = $localnode ]
      then
        if [[ -e /var/opt/oracle/oraInst.loc && -z "$RAT_INV_LOC" ]]
        then
          invntr_location[$invntr_counter]=`cat /var/opt/oracle/oraInst.loc|grep -v "^#"|grep inventory_loc|cut -d= -f2`
          if [ -z "${invntr_location[$invntr_counter]}" ] 
          then   
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
	      EMSG="${program_name} did not find the inventory location on $invntr from environment.\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it\neg export RAT_INV_LOC=/u01/app/oraInventory"
	      update_probe_xml "ERROR" "GENERIC" "$EMSG"
	    fi
            echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
            exit 1; 
          fi
        elif [[ ! -e /var/opt/oracle/oraInst.loc && -z "$RAT_INV_LOC" ]]
        then 
          if [ -z "$ask_inv_loc" ]; then
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
    	      cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o2" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n76_nlsid">
        Unable to find the inventory location on {1} from environment 
      </text>
      <tokens>
	<token index="1">$invntr</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n77_nlsid">
      Does {1} have Oracle software installed 
    </text>
    <tokens>
      <token index="1">$invntr</token>
    </tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
</group>
EOF
	      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	      ask_inv_loc="No"
	    elif [[ $EM_XMLD_MODE -eq 1 ]]
	    then
	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	     
	      read_probe_xml "Unable to find the inventory location on {1} from environment"
	      ask_inv_loc=$xml_rvalue
	    else
       	      exec 3<&2; exec 2<&0
       	      $READ -p "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?" ask_inv_loc
	      read_code=`echo $?`;
       	      exec 2<&3
	      process_prompt "$read_code" "ask_inv_loc" "n"
	    fi
          fi
          case $ask_inv_loc in
            y|Y|yes|YES|Yes)
              echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
              exit 1; 
              ;;
            n|N|No|NO)   
              ;;
            *)     
              ;;    
          esac
        else
          invntr_location[$invntr_counter]=$RAT_INV_LOC
        fi
      else
        $SSHELL $invntr ls -l /var/opt/oracle/oraInst.loc >/dev/null 2>&1
        inv_ptr_exist=$(echo $?) 
        if [[ $inv_ptr_exist -eq 0 && -z "$RAT_INV_LOC" ]]
        then
          invntr_location[$invntr_counter]=` $SSHELL $invntr cat /var/opt/oracle/oraInst.loc|grep -v "^#"|grep inventory_loc|cut -d= -f2`
          if [ -z "${invntr_location[$invntr_counter]}" ] 
          then   
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
	      EMSG="${program_name} did not find the inventory location on $invntr from environment.\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it\neg export RAT_INV_LOC=/u01/app/oraInventory"
	      update_probe_xml "ERROR" "GENERIC" "$EMSG"
	    fi
            echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
            exit 1; 
          fi
        elif [[ $inv_ptr_exist -ne 0 && -z "$RAT_INV_LOC" ]]
        then 
          if [ -z "$ask_inv_loc" ]; then
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
    	      cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o2" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n76_nlsid">
        Unable to find the inventory location on {1} from environment 
      </text>
      <tokens>
	<token index="1">$invntr</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n77_nlsid">
      Does {1} have Oracle software installed 
    </text>
    <tokens>
      <token index="1">$invntr</token>
    </tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
</group>
EOF
	      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	      ask_inv_loc="No"
	    elif [[ $EM_XMLD_MODE -eq 1 ]]
	    then
	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	     
	      read_probe_xml "Unable to find the inventory location on {1} from environment"
	      ask_inv_loc=$xml_rvalue
	    else
              exec 3<&2; exec 2<&0
              $READ -p "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?" ask_inv_loc
	      read_code=`echo $?`;
              exec 2<&3
	      process_prompt "$read_code" "ask_inv_loc" "n"
	    fi
          fi
          case $ask_inv_loc in
            y|Y|yes|YES|Yes)
              echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
              exit 1; 
              ;;
            n|N|No|NO)   
              ;;
            *)     
             ;;    
          esac
          #$READ -p "inventory found at ${invntr_location[$invntr_counter]}"
        else
          invntr_location[$invntr_counter]=$RAT_INV_LOC
        fi
      fi
    ;;
    HP-UX) 
      if [[ -n "$RAT_ORATAB_LOC" ]]
      then
           v_oratab=$RAT_ORATAB_LOC;
      else
           v_oratab="/etc/oratab"
      fi
      if [ $invntr = $localnode ]
      then
        if [[ -e /var/opt/oracle/oraInst.loc && -z "$RAT_INV_LOC" ]]
        then
          #invntr_location[$invntr_counter]=`cat /var/opt/oracle/oraInst.loc|grep -v "^#"|grep inventory_loc|cut -d= -f2`
          invntr_location[$invntr_counter]=`grep -v "^#" /var/opt/oracle/oraInst.loc|grep inventory_loc|cut -d= -f2`
          if [ -z "${invntr_location[$invntr_counter]}" ] 
          then   
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
	      EMSG="${program_name} did not find the inventory location on $invntr from environment.\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it\neg export RAT_INV_LOC=/u01/app/oraInventory"
	      update_probe_xml "ERROR" "GENERIC" "$EMSG"
	    fi
            echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
            exit 1; 
          fi
        elif [[ ! -e /var/opt/oracle/oraInst.loc && -z "$RAT_INV_LOC" ]]
        then 
          if [ -z "$ask_inv_loc" ]; then
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
    	      cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o2" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n76_nlsid">
        Unable to find the inventory location on {1} from environment 
      </text>
      <tokens>
	<token index="1">$invntr</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n77_nlsid">
      Does {1} have Oracle software installed 
    </text>
    <tokens>
      <token index="1">$invntr</token>
    </tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
</group>
EOF
	      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	      ask_inv_loc="No"
	    elif [[ $EM_XMLD_MODE -eq 1 ]]
	    then
	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	     
	      read_probe_xml "Unable to find the inventory location on {1} from environment"
	      ask_inv_loc=$xml_rvalue
	    else
              exec 3<&2; exec 2<&0
              $READ -p "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?" ask_inv_loc
	      read_code=`echo $?`;
              exec 2<&3
	      process_prompt "$read_code" "ask_inv_loc" "n"
	    fi
          fi
          case $ask_inv_loc in
            y|Y|yes|YES|Yes)
              echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
              exit 1; 
              ;;
            n|N|No|NO)   
              ;;
            *)     
              ;;    
          esac
        else
          invntr_location[$invntr_counter]=$RAT_INV_LOC
        fi
      else
        $SSHELL $invntr ls -l /var/opt/oracle/oraInst.loc  >/dev/null 2>&1
        inv_ptr_exist=$(echo $?) 
        if [[ $inv_ptr_exist -eq 0 && -z "$RAT_INV_LOC" ]]
        then
          invntr_location[$invntr_counter]=`$SSHELL $invntr cat /var/opt/oracle/oraInst.loc|grep -v "^#"|grep inventory_loc|cut -d= -f2`
          if [ -z "${invntr_location[$invntr_counter]}" ] 
          then   
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
	      EMSG="${program_name} did not find the inventory location on $invntr from environment.\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it\neg export RAT_INV_LOC=/u01/app/oraInventory"
	      update_probe_xml "ERROR" "GENERIC" "$EMSG"
	    fi
            echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
            exit 1; 
          fi
        elif [[ $inv_ptr_exist -ne 0 && -z "$RAT_INV_LOC" ]]
        then 
          if [ -z "$ask_inv_loc" ]; then
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
    	      cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o2" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n76_nlsid">
        Unable to find the inventory location on {1} from environment 
      </text>
      <tokens>
	<token index="1">$invntr</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n77_nlsid">
      Does {1} have Oracle software installed 
    </text>
    <tokens>
      <token index="1">$invntr</token>
    </tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
</group>
EOF
	      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	      ask_inv_loc="No"
	    elif [[ $EM_XMLD_MODE -eq 1 ]]
	    then
	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	     
	      read_probe_xml "Unable to find the inventory location on {1} from environment"
	      ask_inv_loc=$xml_rvalue
	    else
       	      exec 3<&2; exec 2<&0
              $READ -p "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?" ask_inv_loc
	      read_code=`echo $?`;
       	      exec 2<&3
	      process_prompt "$read_code" "ask_inv_loc" "n"
  	    fi
          fi
          case $ask_inv_loc in
            y|Y|yes|YES|Yes)
              echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
       	      exit 1; 
              ;;
            n|N|No|NO)   
       	      ;;
            *)     
              ;;    
          esac
        else
          invntr_location[$invntr_counter]=$RAT_INV_LOC
        fi
      fi
    ;;
    AIX)
      if [[ -n "$RAT_ORATAB_LOC" ]]
      then
           v_oratab=$RAT_ORATAB_LOC;
      else
	   v_oratab="/etc/oratab"
      fi
      if [ $invntr = $localnode ]
      then
        if [[ -f /etc/oraInst.loc && -z "$RAT_INV_LOC" ]]
        then
          #invntr_location[$invntr_counter]=`cat /etc/oraInst.loc|grep -v "#"|grep inventory_loc|cut -d= -f2`
          invntr_location[$invntr_counter]=`grep -v "#" /etc/oraInst.loc|grep inventory_loc|cut -d= -f2`
          if [ -z "${invntr_location[$invntr_counter]}" ] 
          then   
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
	      EMSG="${program_name} did not find the inventory location on $invntr from environment.\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it\neg export RAT_INV_LOC=/u01/app/oraInventory"
	      update_probe_xml "ERROR" "GENERIC" "$EMSG"
	    fi
            echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
            exit 1; 
          fi
        elif [[ ! -e /etc/oraInst.loc && -z "$RAT_INV_LOC" ]]
        then 
          if [ -z "$ask_inv_loc" ]; then
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
    	      cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o2" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n76_nlsid">
        Unable to find the inventory location on {1} from environment 
      </text>
      <tokens>
	<token index="1">$invntr</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n77_nlsid">
      Does {1} have Oracle software installed 
    </text>
    <tokens>
      <token index="1">$invntr</token>
    </tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
</group>
EOF
	      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	      ask_inv_loc="No"
	    elif [[ $EM_XMLD_MODE -eq 1 ]]
	    then
	      echo -e "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?"
	     
	      read_probe_xml "Unable to find the inventory location on {1} from environment"
	      ask_inv_loc=$xml_rvalue
	    else
       	      exec 3<&2; exec 2<&0
       	      $READ -p "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?" ask_inv_loc
	      read_code=`echo $?`;
       	      exec 2<&3
	      process_prompt "$read_code" "ask_inv_loc" "n"
	    fi
          fi
          case $ask_inv_loc in
            y|Y|yes|YES|Yes)
              echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
              exit 1; 
              ;;
            n|N|No|NO)   
              #$READ -p "invntr_location= ${invntr_location[$invntr_counter]}"
              ;;
            *)     
              ;;    
          esac 
        else
          invntr_location[$invntr_counter]=$RAT_INV_LOC
        fi
      else
        $SSHELL $invntr ls -l /etc/oraInst.loc >/dev/null 2>&1
        inv_ptr_exist=$(echo $?) 
        if [[ $inv_ptr_exist -eq 0 && -z $RAT_INV_LOC ]]
        then
          invntr_location[$invntr_counter]=`$SSHELL $invntr cat /etc/oraInst.loc|grep -v "^#"|grep inventory_loc|cut -d= -f2`
          if [ -z "${invntr_location[$invntr_counter]}" ] 
          then   
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
	      EMSG="${program_name} did not find the inventory location on $invntr from environment.\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it\neg export RAT_INV_LOC=/u01/app/oraInventory"
	      update_probe_xml "ERROR" "GENERIC" "$EMSG"
	    fi
            echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
            exit 1; 
          fi
        elif [[ $inv_ptr_exist -ne 0 && -z "$RAT_INV_LOC" ]]
        then 
          case $ask_inv_loc in
            y|Y|yes|YES|Yes)
              echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
              exit 1; 
              ;;
            n|N|No|NO)   
              #$READ -p "invntr_location= ${invntr_location[$invntr_counter]}"
              ;;
            *)     
             ;;    
          esac 
        else
          invntr_location[$invntr_counter]=$RAT_INV_LOC
        fi
      fi
    ;;
    CYGWIN_NT-[0-9].[0-9])
      invntr_location[$invntr_counter]=$(grep INV_LOC= $windiscover |sed 's/INV_LOC=//' | sed 's/ *$//');
    ;;
    *)  /bin/echo "ERROR: Unknown Operating System"
        exit -1
    ;;
    esac
    invntr_counter=`expr $invntr_counter + 1 `
  done
  invntr_counter=0
}

#this function is to check that CRS is installed or not on all nodes in cluster
is_crs_installed()
{
  search_invntr_platform
  crs_counter=0
  for crs_install in `cat $HOSTLIST`
  do
    unset invntr_CH
    if [ $crs_install = $localnode ]
    then
      if [ -n "${invntr_location[$crs_counter]}" ]
      then
        #invntr_CH=`cat ${invntr_location[$crs_counter]}/ContentsXML/inventory.xml |grep "CRS=\"true\""|grep -v "REMOVED=\"T\""|awk '{print $3}'|cut -d= -f2|sed 's/\"//g'`
        invntr_CH=`grep "CRS=\"true\"" "${invntr_location[$crs_counter]}/ContentsXML/inventory.xml" 2>/dev/null |grep -v "REMOVED=\"T\""|awk '{print $3}'|cut -d= -f2|sed 's/\"//g' | sed 's|\\\\|\/|g'|head -1`
        local_invntr_CH=$invntr_CH
        if [[ -z "$invntr_CH" ||! -d $invntr_CH ||! -f $invntr_CH/bin/crsd ]] && [ -z "$RAT_CRS_HOME" ]
 	then 
	  if [[ $EM_PROBE_MODE -eq 1 ]]
	  then
	    EMSG="${program_name} did not find the CRS binaries on $crs_install from environment.\nPlease set RAT_CRS_HOME to CRS_HOME or GI_HOME in current shell to override and re-run it.\neg export RAT_CRS_HOME=/u01/app/11.2.0/grid"
	    update_probe_xml "ERROR" "GENERIC" "$EMSG"
	  fi
 	  echo -e "${RED}${program_name} did not find the CRS binaries on $crs_install from environment.\n\nPlease set RAT_CRS_HOME to CRS_HOME or GI_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_CRS_HOME=/u01/app/11.2.0/grid"
 	  exit 1; 
 	fi
      fi

      if [[  -d $invntr_CH || -n "$RAT_CRS_HOME" ]] 
      then
        if [[ -f $invntr_CH/bin/crsd || -n "$RAT_CRS_HOME" ]]
        then
          crs_installed[$crs_counter]=1
          echo $crs_install.CRS_INSTALLED = ${crs_installed[$crs_counter]}>>$MASTERFIL
          if [ -n "$RAT_CRS_HOME" ]
          then 
            echo "CRS_HOME = $RAT_CRS_HOME" >>$MASTERFIL
            crsSoftwareOwner=$(ls -l $RAT_CRS_HOME/bin/ocssd 2>/dev/null|awk '{print $3}')
          else  
            echo "CRS_HOME = $invntr_CH" >>$MASTERFIL
            #$READ -p "$nvntr_CH ls -l $invntr_CH/bin/crsd"
            crsSoftwareOwner=$(ls -l $invntr_CH/bin/ocssd 2>/dev/null|awk '{print $3}')
          fi
          #$READ -p "userid=$userid"
          root_user_allowed=0
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then 
	    root_user_allowed=1; 
	  fi

          if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_db_checks -eq "0" ]] || [[ -n "$exclude_profile" && $exclude_profile -eq "1" && $profile_db_checks -eq "0" ]]; then
            root_user_allowed=1
          fi
 
          if [[ $root_user_allowed -eq "0" ]] && [[ "$usern" = "${root_user}" || $userid -eq 0 ]] && [[ -n "$daemon_init_mode" && $daemon_init_mode -eq 0 ]]
          then
	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
	      EMSG="${program_name} found that oracle software owner exists and its being run by ${root_user}.Please change ownership and permission for ${program_name} and all accompanied files being ${root_user} to rdbms software owner,login as rdbms software owner and run it again."
	      update_probe_xml "ERROR" "GENERIC" "$EMSG"
	    fi
            echo -e "${RED}${program_name} found that oracle software owner exists and its being run by ${root_user}."
            echo -e "\nPlease change ownership and permission for ${program_name} and all accompanied files being ${root_user} to rdbms software owner,login as rdbms software owner and run it again\n${NORM}"
            exit 1
          fi
        else
          crs_installed[$crs_counter]=0
          echo $crs_install.CRS_INSTALLED = ${crs_installed[$crs_counter]}>>$MASTERFIL
        fi
      else
        crs_installed[$crs_counter]=0  
        echo $crs_install.CRS_INSTALLED = ${crs_installed[$crs_counter]}>>$MASTERFIL
      fi
    else
      if [ -n "${invntr_location[$crs_counter]}" ]
      then
        invntr_CH=`$SSHELL $crs_install cat \"${invntr_location[$crs_counter]}/ContentsXML/inventory.xml\" 2>/dev/null |grep "CRS=\"true\""|grep -v "REMOVED=\"T\""|awk '{print $3}'|cut -d= -f2|sed 's/\"//g'| sed 's|\\\\|\/|g'|head -1`

        #$READ -p "inventory laction ${invntr_location[$crs_counter]} and CRS_HOME $invntr_CH"
 	$SSHELL $crs_install ls -l $invntr_CH >/dev/null 2>&1
 	remote_crs_home_status=$(echo $?) 
 	if [[ -n "$remote_crs_home_status" && $remote_crs_home_status -ne 0 ]] && [[ -z "$RAT_CRS_HOME" ]]
 	then
	  if [[ $EM_PROBE_MODE -eq 1 ]]
	  then
	    EMSG="${program_name} did not find the CRS binaries on $crs_install from environment.\nPlease set RAT_CRS_HOME to CRS_HOME or GI_HOME in current shell to override and re-run it.\neg export RAT_CRS_HOME=/u01/app/11.2.0/grid"
	    update_probe_xml "ERROR" "GENERIC" "$EMSG"
	  fi
 	  echo -e "${RED}${program_name} did not find the CRS binaries on $crs_install from environment.\n\nPlease set RAT_CRS_HOME to CRS_HOME or GI_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_CRS_HOME=/u01/app/11.2.0/grid"
 	  exit 1;
 	fi
      fi

      if [[ -n "$remote_crs_home_status" && $remote_crs_home_status -eq 0 ]] || [[ -n "$RAT_CRS_HOME" ]] 
      then
        $SSHELL $crs_install ls -l $invntr_CH/bin/crsd >/dev/null 2>&1
        remote_crsd_file_status=$(echo $?)
  
        if [[ -n "$remote_crsd_file_status" && $remote_crsd_file_status -ne 0 ]] && [[ -z "$RAT_CRS_HOME" ]]
        then
	  if [[ $EM_PROBE_MODE -eq 1 ]]
	  then
	    EMSG="${program_name} did not find the CRS binaries on $crs_install from environment.\nPlease set RAT_CRS_HOME to CRS_HOME or GI_HOME in current shell to override and re-run it.eg export RAT_CRS_HOME=/u01/app/11.2.0/grid"
	    update_probe_xml "ERROR" "GENERIC" "$EMSG"
	  fi
          echo -e "${RED}${program_name} did not find the CRS binaries on $crs_install from environment.\n\nPlease set RAT_CRS_HOME to CRS_HOME or GI_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_CRS_HOME=/u01/app/11.2.0/grid"
 	  exit 1;
        fi
 	
        if [[ -n "$remote_crsd_file_status" && $remote_crsd_file_status -eq 0 ]] || [[ -n "$RAT_CRS_HOME" ]]
 	then
 	  crs_installed[$crs_counter]=1
 	  echo $crs_install.CRS_INSTALLED = ${crs_installed[$crs_counter]}>>$MASTERFIL
 	else
 	  crs_installed[$crs_counter]=0
 	  echo $crs_install.CRS_INSTALLED = ${crs_installed[$crs_counter]}>>$MASTERFIL
 	fi
      else
        crs_installed[$crs_counter]=0  
        echo $crs_install.CRS_INSTALLED = ${crs_installed[$crs_counter]}>>$MASTERFIL
      fi
    fi
    #$READ -p "crs installed at on $crs_install ${crs_installed[$crs_counter]}"
    crs_counter=`expr $crs_counter + 1`
  done
  crs_counter=0
}

function is_valid_ohome
{
  export ORACLE_SID=$1
  export ORACLE_HOME=$2
  export LD_LIBRARY_PATH=$ORACLE_HOME/lib
  if [ ! -e "$ORACLE_HOME/bin/sqlplus" ] ; then
    valid_ohome=0
    return;
  fi

  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
    get_dbOwner

    iname=`su $dbOwner -c "echo 'set feedback  off heading off lines 120 
        select INSTANCE_NAME from gv\\\$instance;' | $ORACLE_HOME/bin/sqlplus -s \"/as sysdba\" |  grep -v ^$ 2>&1"`
    cd $OLD_DIR
    unset OLD_DIR
  else
    iname=`echo 'set feedback  off heading off lines 120 
        select INSTANCE_NAME from gv\$instance;' | $ORACLE_HOME/bin/sqlplus -s "/as sysdba" |  grep -v ^$ 2>&1`
  fi

  if [[ $iname = $ORACLE_SID || `echo "$iname" | grep -ic "insufficient privileges"` -gt 0 ]] ; then
    valid_ohome=1
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      #what_db=$(su $dbOwner -c \"$ORACLE_HOME/bin/sqlplus -v|awk '{print \$3}'|sed 's/\.//g'|sed '/^$/d'\")
      what_db=$(su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s -version|awk '{print \$3}'|sed 's/\.//g'|sed '/^$/d'")   
    else 
      what_db=$($ORACLE_HOME/bin/sqlplus -v|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
    fi
    if [[ -n "$what_db" && $what_db -gt "$latest_si_version" ]] ; then
      latest_si_version=$what_db
    fi
  else
    valid_ohome=0
  fi
}

function search_oh_si()
{
  #Search config file ${program_name}_homes.conf
  oconf_file="${program_name}_homes.conf"
  if [ -e "$oconf_file" ] ; then
    #if [[ `cat $oconf_file | grep -ic "$sid|"` -gt 0 ]] ; then
    if [[ `grep -ic "$sid|" $oconf_file` -gt 0 ]] ; then
      oh=$(grep "$sid|" $oconf_file | head -1 | cut -d'|' -f2)
      valid_ohome=0
      in_conf=1
      is_valid_ohome $sid $oh
      if [ $valid_ohome -eq 1 ] ; then found_in="c"; return; fi;
    fi
  fi

  # oratab
  #oh=$(cat $ORATAB |grep ":/" |grep -v "+"|grep -v "^#"|grep -w "$sid:" |cut -d: -f2)
  if [ $is_windows -eq "1" ] ; then
    oh=$(grep ":" $ORATAB |grep -v "+"|grep -v "^#"|grep -i "$sid|" |cut -d\| -f2)
  else
    oh=$(grep ":/" $ORATAB |grep -v "+"|grep -v "^#"|grep -w "$sid:" |cut -d: -f2)
  fi
  if [[ -n "$oh" && "$oh" ]]
  then
    valid_ohome=0
    is_valid_ohome $sid $oh
    if [ $valid_ohome -eq 1 ] ; then
      found_in="oratab";
      return;
    fi;
  fi

  # If pmap exists, try parsing pmap output
  pmap_found=$(which pmap >/dev/null 2>&1;echo $?)
  if [[ -n "$pmap_found" && $pmap_found -eq "0"  ]] ; then
    ppid=$(ps -ef |grep "ora_pmon_$sid"|grep -v grep |awk '{print $2}')
    oh=$(pmap $ppid  | grep bin/oracle | awk '{print $NF}' | sort -u | sed 's/\/bin\/oracle//');
    is_valid_ohome $sid $oh
    if [ $valid_ohome -eq 1 ] ; then found_in="pmap"; return; fi;
  fi
 
  # Ask user if we are not in silent mode.
  attempt_cnt=3
  while [[ $attempt_cnt -ge "0" ]] ; do

    printf "Enter ORACLE_HOME for $sid : "

    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
    cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="TEXT" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n78_nlsid">
      Enter ORACLE_HOME for {1} 
    </text>
    <tokens>
      <token index="1">$sid</token>
    </tokens>
    </tokenizedtext>
  </question>
</group>
EOF
      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
      oh="" 
      break
    elif [[ $EM_XMLD_MODE -eq 1 ]]
    then
      read_probe_xml "<token index="1">$sid</token>"
      oh=$xml_rvalue  
      break
    else
      $READ oh
      valid_ohome=0
      if [ -n "$oh" ] ; then
        is_valid_ohome $sid $oh
        if [ $valid_ohome -eq 1 ] ; then found_in="input"; return; fi;
      fi
      if [[ $attempt_cnt -gt "0" ]] ; then
        echo "Could not login to $sid using $oh. Try again ($attempt_cnt attempts remaining)"
      else
        echo "Skipping database $sid"
      fi
      attempt_cnt=$(expr $attempt_cnt - 1)
    fi
  done
  oh=""
}

function save_to_conf ()
{
  if [[ $in_conf -eq "1" && $found_in = "c" ]] ; then
    return; # Valid one in conf file
  fi
  if [[ $in_conf -eq "0" ]] ; then
    echo "$sid|$oh" >> $oconf_file
  else
    grep -v "$sid|" $oconf_file > $oconf_file.bak
    echo "$sid|$oh" >> $oconf_file.bak
    mv -f $oconf_file.bak $oconf_file
  fi
}

function search_si ()
{
  cnt=0
  latest_si_version=0
  TMP_RAT_DBNAMES=$RAT_DBNAMES
  if [ $is_windows -eq "1" ] ; then
    sids=`grep "SERVICE_NAME: OracleService" $win_services  | sed 's/SERVICE_NAME: OracleService//' | tr -d '\r' |sort -u|tr '[:upper:]' '[:lower:]'`;
  else
    sids=`ps -ef |grep ora_pmon|grep -v grep |awk '{print $NF}'`
  fi
  for sid in $sids
  do
    sid=$(echo $sid | sed 's/ora_pmon_//')

    if [[ -n "$TMP_RAT_DBNAMES" ]]
    then
      if [[ `echo "$TMP_RAT_DBNAMES"|grep -wc "$sid"` -eq 0 ]]
      then
        continue;
      else
	RAT_DBNAMES=$(echo "$RAT_DBNAMES"|sed "s/$sid//g")
	RAT_DBNAMES=$(echo "$RAT_DBNAMES"|sed "s/^,|,$//g")
      fi
    fi

    oh=""
    in_conf=0
    search_oh_si
    if [ -n "$oh" ] ; then
      save_to_conf 
      sids_si[$cnt]=$sid
      homes_si[$cnt]=$oh
      if [[ -z "$RAT_DBNAMES" || `echo $RAT_DBNAMES | grep -ic $sid` -eq "0" ]]
      then # Add to RAT_DBNAMES If not exists
        RAT_DBNAMES="$RAT_DBNAMES $sid";
        RAT_DBHOMES="$RAT_DBHOMES $oh";
      fi
      cnt=$(expr $cnt + 1)
    fi
  done
}

function get_ohome_si_oh ()
{
  i_sid=$1
  l_cnt=0
  for l_sid in "${sids_si[@]}"
  do
    if [ "$l_sid" = "$i_sid" ] ; then
      l_oh=${homes_si[$l_cnt]}
      return;
    fi
    l_cnt=$(expr $l_cnt + 1);
  done
}

# Check for rdbms installation location for single instance db
function is_rdbms_installed_si()
{
  search_si
  if [[ -z "$RAT_DBNAMES" ]] ; then
    if [[ $latest_si_version -gt 0 && -z "$RAT_DB" ]] ; then
      RAT_DB=$latest_si_version
    fi
  fi
  #if [ "$TYP" != "-r" ]; then TYP="-b";fi
  rdbms_counter=0
  #RAT_DB=112030
  crs_up=0
  crs_installed=0
  crs_installed[0]=0
  asm_installed[0]=0
  stack_crs_up[0]=0
  echo $localnode.CRS_INSTALLED = 0 >> $MASTERFIL
  echo SINGLE_INSTANCE_RUN = 1 >> $MASTERFIL

  stack_counter=0
  mb_running_host[0]=$localnode
}

#this function is to check that RDBMS is installed or not on all nodes in cluster
is_rdbms_installed()
{
  #search_invntr_platform
  rdbms_counter=0
  for rdbms_install in `cat $HOSTLIST`
  do
    unset invntr_OH
    if [ $rdbms_install = $localnode ] 
    then
      if [ -n "${invntr_location[$rdbms_counter]}" ]
      then
        #for invntr_OH in `cat ${invntr_location[$rdbms_counter]}/ContentsXML/inventory.xml |grep LOC|grep -v "CRS=\"true\""|grep -iv ASM|grep -vi agent|grep -v "REMOVED=\"T\""|awk '{print $3}'|cut -d= -f2|sed 's/\"//g'`
        for invntr_OH in `grep LOC "${invntr_location[$rdbms_counter]}/ContentsXML/inventory.xml" |grep -v "CRS=\"true\""|grep -iv ASM|grep -vi agent|grep -v "REMOVED=\"T\""|awk '{print $3}'|cut -d= -f2|sed 's/\"//g'`
        do
          if [[  -d $invntr_OH || -n "$RAT_ORACLE_HOME" ]] 
          then
            if [[ -f $invntr_OH/bin/oracle || -n "$RAT_ORACLE_HOME" ]]
            then
              #oratab_OH=$(cat $v_oratab|grep ":/" |grep -v "+"|grep -v "^#"|head -1 |cut -d: -f2)
              oratab_OH=$(grep ":/" $v_oratab|grep -v "+"|grep -v "^#"|head -1 |cut -d: -f2)
              if [[ -n "$oratab_OH" && $invntr_OH = $oratab_OH ]]
              then
                rdbms_installed[$rdbms_counter]=1
                local_invntr_OH=$invntr_OH
                break
              else
                rdbms_installed[$rdbms_counter]=0
              fi
            else
              rdbms_installed[$rdbms_counter]=0
            fi
          else
            rdbms_installed[$rdbms_counter]=0  
          fi
        done
        if [[ -n "${rdbms_installed[$rdbms_counter]}" && ${rdbms_installed[$rdbms_counter]} -eq 1 ]]
        then
          echo "$rdbms_install.RDBMS_INSTALLED = 1" >>$MASTERFIL
        else
          echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL
        fi
      else
        rdbms_installed[$rdbms_counter]=0
        echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL
      fi
    else
      if [ -n "${invntr_location[$rdbms_counter]}" ]
      then
        for invntr_OH in `$SSHELL $rdbms_install cat \"${invntr_location[$rdbms_counter]}/ContentsXML/inventory.xml\" |grep LOC|grep -v "CRS=\"true\""|grep -iv ASM|grep -vi agent|grep -v "REMOVED=\"T\""|awk '{print $3}'|cut -d= -f2|sed 's/\"//g'` 
        do
          $SSHELL $rdbms_install ls -l $invntr_OH >/dev/null 2>&1
          if [[ $? -eq 0  || -n "$RAT_ORACLE_HOME" ]] 
          then
            $SSHELL $rdbms_install ls -l $invntr_OH/bin/oracle >/dev/null 2>&1
            if [[ $? -eq 0 || -n "$RAT_ORACLE_HOME" ]]
            then
              oratab_OH=$($SSHELL $rdbms_install cat $v_oratab|grep ":/" |grep -v "+"|grep -v "^#"|head -1 |cut -d: -f2)
              if [[ -n "$oratab_OH" && $invntr_OH = $oratab_OH ]]
              then
                rdbms_installed[$rdbms_counter]=1
                #echo $rdbms_install.RDBMS_INSTALLED = ${rdbms_installed[$rdbms_counter]}>>$MASTERFIL
                break
              else
                rdbms_installed[$rdbms_counter]=0
              fi
            else
              rdbms_installed[$rdbms_counter]=0
              #echo $rdbms_install.RDBMS_INSTALLED = ${rdbms_installed[$rdbms_counter]}>>$MASTERFIL
            fi
          else
            rdbms_installed[$rdbms_counter]=0  
            #echo $rdbms_install.RDBMS_INSTALLED = ${rdbms_installed[$rdbms_counter]}>>$MASTERFIL
          fi
        done
        if [[ -n "${rdbms_installed[$rdbms_counter]}" && ${rdbms_installed[$rdbms_counter]} -eq 1 ]]
        then
          echo "$rdbms_install.RDBMS_INSTALLED = 1" >>$MASTERFIL
        else
          echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL
        fi
      else
        rdbms_installed[$rdbms_counter]=0
        echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL
      fi
    fi
    #$READ -p "crs installed on $rdbms_install=${crs_installed[$rdbms_counter]}"
    rdbms_counter=`expr $rdbms_counter + 1`
  done
  if [ -n "$oratab_OH" ]
  then
    export ORACLE_HOME=$oratab_OH
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      get_dbOwner
      what_db=$(su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -v|awk '{print \$3}'|sed 's/\.//g'|sed '/^$/d'")
      cd $OLD_DIR
      unset OLD_DIR
    else
      what_db=$($ORACLE_HOME/bin/sqlplus -v|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
    fi
    echo "$oratab_OH|$what_db" >>$OUTPUTDIR/mb_db_homes_distinct.out
  fi
  mb_set_oracle_home_version_distinct 
  rdbms_counter=0
}

is_asm_installed()
{
  #search_invntr_platform
  asm_counter=0
  for asm_install in `cat $HOSTLIST`
  do
    unset invntr_AH
    if [ $asm_install = $localnode ] 
    then
      if [ -n "${invntr_location[$asm_counter]}" ]
      then
        #invntr_AH=`cat ${invntr_location[$asm_counter]}/ContentsXML/inventory.xml |grep LOC|grep -v "CRS=\"true\""|grep -v db|grep -vi agent|grep -v "REMOVED=\"T\""|awk '{print $3}'|cut -d= -f2|sed 's/\"//g'|head -1`
        invntr_AH=`grep LOC "${invntr_location[$asm_counter]}/ContentsXML/inventory.xml" |grep -v "CRS=\"true\""|grep -vi agent|grep -v "REMOVED=\"T\""|awk '{print $3}'|cut -d= -f2|sed 's/\"//g'|head -1`
        #if [[ -z "$invntr_AH" || ! -d $invntr_AH || ! -e $invntr_AH/bin/oracle ]] && [ -z "$RAT_ASM_HOME" ]
        #then
        #  echo -e "${RED}Raccheck did not find the ASM binaries on $asm_install from environment.\n\nPlease set RAT_ASM_HOME to ASM_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_ASM_HOME=/u01/app/oracle/product/11.1.0/asm_1"
        #  exit 1;
        #fi
      fi
      if [[  -d $invntr_AH || -n "$RAT_ASM_HOME" ]] 
      then
        if [[ -f $invntr_AH/bin/oracle || -n "$RAT_ASM_HOME" ]]
        then
          asm_installed[$asm_counter]=1
          echo $asm_install.ASM_INSTALLED = ${asm_installed[$asm_counter]}>>$MASTERFIL
        else
          asm_installed[$asm_counter]=0
          echo $asm_install.ASM_INSTALLED = ${asm_installed[$asm_counter]}>>$MASTERFIL
        fi
      else
        asm_installed[$asm_counter]=0  
        echo $asm_install.ASM_INSTALLED = ${asm_installed[$asm_counter]}>>$MASTERFIL
      fi
    else
      if [ -n "${invntr_location[$asm_counter]}" ]
      then
        invntr_AH=`$SSHELL $asm_install cat \"${invntr_location[$asm_counter]}/ContentsXML/inventory.xml\" |grep LOC|grep -v "CRS=\"true\""|grep -vi db|grep -vi agent|grep -v "REMOVED=\"T\""|awk '{print $3}'|cut -d= -f2|sed 's/\"//g'|head -1` 
        $SSHELL $asm_install ls -l $invntr_AH >/dev/null 2>&1
        remote_asm_home_status=$(echo $?)
        #if [[ $remote_asm_home_status -ne 0 &&  -z "$RAT_ASM_HOME" ]]
        #then
        #  echo -e "${RED}Raccheck did not find the ASM binaries on $asm_install from environment.\n\nPlease set RAT_ASM_HOME to ASM_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_ASM_HOME=/u01/app/oracle/product/11.1.0/asm_1"
        #  exit 1;
        #fi
      fi
      if [[ $remote_asm_home_status -eq 0  || -n "$RAT_ASM_HOME" ]] 
      then
        $SSHELL $asm_install ls -l $invntr_AH/bin/oracle >/dev/null 2>&1
        remote_asmd_file_status=$(echo $?)
        #if [[ $remote_asmd_file_status -ne 0 &&  -z "$RAT_ASM_HOME" ]]
        #then
        #  echo -e "${RED}Raccheck did not find the ASM binaries on $asm_install from environment.\n\nPlease set RAT_ASM_HOME to ASM_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_ASM_HOME=/u01/app/oracle/product/11.1.0/asm_1"
        #  exit 1;
        #fi
        if [[ $remote_asmd_file_status -eq 0 || -n "$RAT_ASM_HOME" ]]
        then
          asm_installed[$asm_counter]=1
          echo $asm_install.ASM_INSTALLED = ${asm_installed[$asm_counter]}>>$MASTERFIL
        else
          asm_installed[$asm_counter]=0
          echo $asm_install.ASM_INSTALLED = ${asm_installed[$asm_counter]}>>$MASTERFIL
        fi
      else
        asm_installed[$asm_counter]=0  
        echo $asm_install.ASM_INSTALLED = ${asm_installed[$asm_counter]}>>$MASTERFIL
      fi
    fi
    #$READ -p "crs installed on $rdbms_install=${crs_installed[$rdbms_counter]}"
    asm_counter=`expr $asm_counter + 1`
  done
  asm_counter=0
}

function create_running_db_list ()
{
  if [[ -z $CRS ]]; then
    crd_status=0;
    return;
  fi
  db_list=$(echo "$db_list"|sed "s/ //g")

  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then 
    OLD_OH=$ORACLE_HOME
    ORACLE_HOME=$CRS
    get_dbOwner
    ORACLE_HOME=$OLD_OH
    crs_db_hosts=$(su $dbOwner -c "$CRS/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep -i 'is running' | awk '{print \$NF}'")
    cd $OLD_DIR
    unset OLD_DIR
  else
    crs_db_hosts=$($CRS/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep -i "is running" | awk '{print $NF}')
  fi

  remote_crs_db_hosts=0
  if [[ -z $crs_db_hosts ]]; then
    for hosts in `cat $HOSTLIST`
    do
      t_flag="-T";
      if [ $hosts != $localnode ]; then
        if [ -e $db_list_fil_verbose ] ;then crs_db_home=$(grep -w $db_list $db_list_fil_verbose|awk '{print $2}');fi
        if [ -z "$crs_db_home" ];then 
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then 
	    OLD_OH=$ORACLE_HOME
	    ORACLE_HOME=$CRS
	    get_dbOwner
	    ORACLE_HOME=$OLD_OH
	    crs_db_home=$(su $dbOwner -c "$CRS/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep PRKR-1078|awk '{ print \$NF }'");
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
	    crs_db_home=$($CRS/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep PRKR-1078|awk '{ print $NF }');
	  fi
	fi
        if [ -z "$crs_db_home" ]; then 
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    OLD_OH=$ORACLE_HOME
	    ORACLE_HOME=$CRS
	    get_dbOwner
	    ORACLE_HOME=$OLD_OH
	    crs_db_home=$(su $dbOwner -c "$CRS/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep PRCD-1229|awk '{ printf \"%s\",substr(\$NF,1,length(\$NF)-1) }'");
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
	    crs_db_home=$($CRS/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep PRCD-1229|awk '{ printf "%s",substr($NF,1,length($NF)-1) }');
          fi
	fi
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  OLD_OH=$ORACLE_HOME
	  ORACLE_HOME=$crs_db_home
	  get_dbOwner
	  ORACLE_HOME=$OLD_OH
	  crs_db_hosts=`$SSHELL $t_flag $hosts<<EOF
	  cd $dbhome_dir 2>/dev/null;
          export ORACLE_HOME=$crs_db_home
          su $dbOwner -c "$crs_db_home/bin/srvctl$BAT status database -d $db_list 2>/dev/null"
EOF`
	  cd $OLD_DIR
	  unset OLD_DIR
        else
	  crs_db_hosts=`$SSHELL $t_flag $hosts<<EOF
	  cd $dbhome_dir 2>/dev/null;
          export ORACLE_HOME=$crs_db_home
          $crs_db_home/bin/srvctl$BAT status database -d $db_list 2>/dev/null
EOF`
	fi
	unset crs_db_home
	crs_db_hosts=$(echo "$crs_db_hosts"|grep -i "is running" | awk '{print $NF}')
      fi
      if [[ -n "$crs_db_hosts" && $crs_db_hosts = "running." ]]
      then
	remote_crs_db_hosts=1
        crs_db_hosts=$hosts
      fi
      if [[ -n $crs_db_hosts ]]; then break; fi
    done
  fi

  if [[ $olsnodes_ssh_disabled -eq 1 ]]; then
    for mapping in ${hostmap[@]}
    do
      management_host=${mapping%%:*}
      client_host=${mapping#*:}
  
      if [[ `echo "$client_host" | grep -ic "$crs_db_hosts"` -ge 1 ]]; then
        crs_db_hosts=$management_host;
      fi
     done
  fi
  
  #if [[ -n "$crs_db_hosts" && $crs_db_hosts = "running." ]]
  if [[ -n "$crs_db_hosts" && $crs_db_hosts = "running." ]] && [[ $remote_crs_db_hosts -eq 0 ]]
  then
    crs_db_hosts=$localnode
  fi

  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
    OLD_OH=$ORACLE_HOME
    ORACLE_HOME=$CRS
    get_dbOwner
    ORACLE_HOME=$OLD_OH
    crs_db_status=$(su $dbOwner -c "$CRS/bin/srvctl$BAT status database -d $db_list|grep -ic 'is running'")
    cd $OLD_DIR
    unset OLD_DIR
  else
    crs_db_status=$($CRS/bin/srvctl$BAT status database -d $db_list|grep -ic "is running")
  fi

  if [[ -n "$crs_db_status" && $crs_db_status -ge 1  ]]
  then
    crs_db_status=$(echo $crs_db_hosts| grep -ic $localnode)
    if [ $crs_db_status -eq 1 ]
    then
      echo $db_list >>$running_db_list;
      echo ":$db_list:$localnode" >>$running_db_host_list;
    else
      if [[ -n $localonly && $localonly -eq "0" ]] ; then
        for crs_db_running_host in $(echo $crs_db_hosts)
  	do
  	  if [[ -n "$crs_db_running_host" && `grep -ic "$crs_db_running_host" $HOSTLIST` -gt "0" ]]
  	  then
  	    echo $db_list >>$running_db_list;
  	    echo ":$db_list:$crs_db_running_host" >>$running_db_host_list;
  	    break;
  	  else
  	    if [[ $olsnodes_ssh_disabled -eq 1 ]]
  	    then
  	      for mapping in ${hostmap[@]}
  	      do
  	 	management_host=${mapping%%:*};
  		client_host=${mapping#*:};
  		if [[ -n "$crs_db_running_host" && `echo "$client_host" | grep -ic "$crs_db_running_host"` -gt "0" ]]
  		then
  		  echo $db_list >>$running_db_list;
  		  echo ":$db_list:$crs_db_running_host" >>$running_db_host_list;
  		  break;
  		fi
  	      done	
  	    fi
  	  fi;
  	done
      fi
    fi;
  else
    #below if condition to find $ORACLE_HOME using config database -v option 
    if [ -e $db_list_fil_verbose ] ;then crs_db_home=$(grep -w $db_list $db_list_fil_verbose|awk '{print $2}');fi
    if [ -z "$crs_db_home" ];then 
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        OLD_OH=$ORACLE_HOME
        ORACLE_HOME=$CRS
    	get_dbOwner
	ORACLE_HOME=$OLD_OH
        crs_db_home=$(su $dbOwner -c "$CRS/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep PRKR-1078|awk '{ print \$NF }'");
    	cd $OLD_DIR
    	unset OLD_DIR
      else
        crs_db_home=$($CRS/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep PRKR-1078|awk '{ print $NF }');
      fi
    fi
    if [ -z "$crs_db_home" ];then 
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        OLD_OH=$ORACLE_HOME
        ORACLE_HOME=$CRS
    	get_dbOwner
	ORACLE_HOME=$OLD_OH
        crs_db_home=$(su $dbOwner -c "$CRS/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep PRCD-1229|awk '{ printf \"%s\",substr(\$NF,1,length(\$NF)-1) }'");
    	cd $OLD_DIR
    	unset OLD_DIR
      else
        crs_db_home=$($CRS/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep PRCD-1229|awk '{ printf "%s",substr($NF,1,length($NF)-1) }');
      fi
    fi 
    if [ -n "$crs_db_home" ]; then 
      export ORACLE_HOME=$crs_db_home;
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
    	get_dbOwner
        crs_db_status=$(su $dbOwner -c "$ORACLE_HOME/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep -i $localnode |grep -ic 'is running'");
    	cd $OLD_DIR
    	unset OLD_DIR
      else
        crs_db_status=$($ORACLE_HOME/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep -i $localnode |grep -ic "is running");
      fi
    fi;

    if [ $crs_db_status -ge 1 ]
    then
      echo $db_list | tr -d '\r' >>$running_db_list;
      echo ":$db_list:$localnode" >>$running_db_host_list;
    elif [ -n "$ORACLE_HOME" ]
    then
      if [[ -n $localonly && $localonly -eq "0" ]] ; then
        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
          get_dbOwner
          crs_db_hosts=$(su $dbOwner -c "$ORACLE_HOME/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep -i 'is running' | awk '{print \$NF}'")
          cd $OLD_DIR
          unset OLD_DIR
        else
          crs_db_hosts=$($ORACLE_HOME/bin/srvctl$BAT status database -d $db_list 2>/dev/null|grep -i "is running" | awk '{print $NF}')
        fi
	database_found=0
  	for crs_db_running_host in $(echo $crs_db_hosts)
  	do
     	  if [[ -n "$crs_db_running_host" && `grep -ic "$crs_db_running_host" $HOSTLIST` -gt "0" ]]
  	  then
  	    echo $db_list | tr -d '\r' >>$running_db_list;
  	    echo ":$db_list:$crs_db_running_host" >>$running_db_host_list;
	    database_found=1
  	    break;
  	  else
  	    if [[ $olsnodes_ssh_disabled -eq 1 ]]
  	    then
  	      break_inside_loop=0
  	      for mapping in ${hostmap[@]}
  	      do
  		management_host=${mapping%%:*};
  		client_host=${mapping#*:};
  		if [[ -n "$crs_db_running_host" && `echo "$client_host" | grep -ic "$crs_db_running_host"` -gt "0" ]]
  		then
  		  echo $db_list | tr -d '\r' >>$running_db_list;
  		  echo ":$db_list:$crs_db_running_host" >>$running_db_host_list;
  		  break_inside_loop=1
	          database_found=1
  		  break;
  		fi
  	      done
  	      if [ $break_inside_loop -eq 1 ]; then break; fi; 
  	    else
  	      echo "$db_list: $crs_db_running_host is not selected" >> $LOGFIL
  	    fi
  	  fi
  	done

	if [ $database_found -eq 0 ]; then
          for hosts in `cat $HOSTLIST`
          do
	    t_flag="-T";
            if [ $hosts != $localnode ]; then
              if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                OLD_OH=$ORACLE_HOME
                ORACLE_HOME=$crs_db_home
                get_dbOwner
                ORACLE_HOME=$OLD_OH
                crs_db_status=`$SSHELL $t_flag $hosts<<EOF
	  	cd $dbhome_dir 2>/dev/null;
                export ORACLE_HOME=$crs_db_home
                su $dbOwner -c "$ORACLE_HOME/bin/srvctl$BAT status database -d $db_list 2>/dev/null"
EOF`      
                cd $OLD_DIR
                unset OLD_DIR
              else
                crs_db_status=`$SSHELL $t_flag $hosts<<EOF
                export ORACLE_HOME=$crs_db_home
                $ORACLE_HOME/bin/srvctl$BAT status database -d $db_list 2>/dev/null
EOF`      
              fi
	      crs_db_status=$(echo "$crs_db_status"|grep -i $hosts | grep -ic "is running")
              if [ $crs_db_status -ge 1 ]; then 
      		echo $db_list >>$running_db_list;
                echo ":$db_list:$hosts" >>$running_db_host_list;
		break;
              fi
            fi
          done
	fi	
      fi
    fi
  fi;
  crd_status=1
  return;
}

is_rdbms_installed_crs ()
{
  #search_invntr_platform
  crd_status=0
  rdbms_counter=0
  db_list_from_env=0
  db_list_fil=$INPUTDIR/db_list.out 
  db_list_fil_verbose=$INPUTDIR/db_list_verbose.out 
  db_config_fil=$INPUTDIR/db_config.out
  running_db_list=$INPUTDIR/running_db_list.out
  running_db_host_list=$INPUTDIR/running_db_host_list.out
  touch $running_db_list
  touch $running_db_host_list
  running_group=$(id|awk '{print $2}'|cut -d'(' -f2|cut -d')' -f1)
  db_counter=1
  #if [ -z "$RAT_DBNAMES" ];then RAT_DBHOMES=$RAT_DBNAMES;fi

  if [[ ${crs_up} = 1 && $check_crs_stat -eq 0 ]] || [[ $single_instance_run -eq "1" ]]
  then
    if [[ -z "$RAT_DBNAMES" &&  -z "$RAT_DBHOMES" && $single_instance_run -eq "0" ]]
    then
      if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_db_checks -eq "0" ]] || [[ -n "$exclude_profile" && $exclude_profile -eq "1" && $profile_db_checks -eq "0" ]]; then
        touch $db_list_fil
        db_list_from_env=1
      else
        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  unset dbconfig_write
          OLD_OH=$ORACLE_HOME
          ORACLE_HOME=$CRS
          get_dbOwner
          ORACLE_HOME=$OLD_OH
          dbconfig_write=$(su $dbOwner -c "$CRS/bin/srvctl$BAT config database | tr -d '\r'");
	  echo -e "$dbconfig_write" > $db_list_fil
          if [ $crs112 -gt 0 ]; then 
	    unset dbconfig_write
	    dbconfig_write=$(su $dbOwner -c "$CRS/bin/srvctl$BAT config database -v | tr -d '\r' 2>/dev/null");
            echo -e "$dbconfig_write" > $db_list_fil_verbose;
	  fi
          cd $OLD_DIR
          unset OLD_DIR
        else
          $CRS/bin/srvctl$BAT config database | tr -d '\r' > $db_list_fil
          if [ $crs112 -gt 0 ]; then $CRS/bin/srvctl$BAT config database -v | tr -d '\r' 2>/dev/null> $db_list_fil_verbose;fi
        fi
        db_list_from_env=1
      fi
    else 
      db_list_from_env=0
      if [[ -z "$RAT_DBHOMES" &&  -n "$RAT_DBNAMES" ]]
      then
        for db_list in $RAT_DBNAMES
        do
          create_running_db_list;
          if [[ $crd_status = 0 ]];
          then
            echo $db_list >> $running_db_list
  	    echo ":$db_list:$localnode" >> $running_db_host_list	
  	  fi
  	  echo $db_list >> $db_list_fil
  	  db_counter=$(expr ${db_counter} + 1)
  	done
      elif [[ -n "$RAT_DBHOMES" &&  -n "$RAT_DBNAMES" ]]
      then
        for db_list in $RAT_DBNAMES
        do
          create_running_db_list;
          if [[ $crd_status = 0 ]];
          then
            echo $db_list >> $running_db_list
  	    echo ":$db_list:$localnode" >> $running_db_host_list
  	  fi
          echo $db_list >> $db_list_fil
          db_counter=$(expr ${db_counter} + 1)
        done
        #for db_list in $RAT_DBHOMES
        #do
        #  echo $db_list >> $db_list_fil
        #done
      elif [[ -z "$RAT_DBNAMES" && -n "$RAT_DBHOMES" ]]
      then
        for db_list in $RAT_DBNAMES
        do
          #echo $db_list >> $running_db_list
          echo $db_list >> $db_list_fil
          db_counter=$(expr ${db_counter} + 1)
        done
      fi
    fi

    if [ $db_list_from_env -eq 1 ]
    then
      echo -e "\nSearching for running databases . . . . .\n"
      for db_list in `cat $db_list_fil`
      do 
        create_running_db_list
        #if [[ -n "$crs112" && $crs112 -ge 1 ]]
        #then 
        printf ". "
  
        #crs_db_hosts=$($CRS/bin/srvctl status database -d $db_list|grep -i "is running" | awk '{print $NF}')
        #if [[ -n "$crs_db_hosts" && $crs_db_hosts = "running." ]]
        #then
        #	crs_db_hosts=$localnode
        #fi
        #crs_db_status=$($CRS/bin/srvctl status database -d $db_list|grep -ic "is running")  
        #echo "$? for $db_list and crs_db_status= $crs_db_status"
        #if [[ -n "$crs_db_status" && $crs_db_status -ge 1  ]]
        #then 
        #crs_db_status=$(echo $crs_db_hosts| grep -ic $localnode)
        #if [ $crs_db_status -eq 1 ]
        #then
        #	echo $db_list >>$running_db_list;
        #	echo ":$db_list:$localnode" >>$running_db_host_list;
        #else 	# Not running local node. get remote node
        #if [[ -n $localonly && $localonly -eq "0" ]] ; then
        #crs_db_running_host=$(echo $crs_db_hosts| head -1 | awk '{print $1}')
        #	for crs_db_running_host in $(echo $crs_db_hosts)
        #	do
        #		if [[ -n "$crs_db_running_host" && `grep -ic "$crs_db_running_host" $HOSTLIST` -gt "0" ]]
        #		then
        #			echo $db_list >>$running_db_list;
        #			echo ":$db_list:$crs_db_running_host" >>$running_db_host_list;
        #			break;
        #		else
        #  			echo "$db_list: $crs_db_running_host is not selected"
        #		fi;
        #	done 
        #fi
        #fi;
        #else
        #	crs_db_home=$($CRS/bin/srvctl status database -d $db_list|grep PRKR-1078|awk '{ print $NF }')
        #	if [ -z "$crs_db_home" ];then crs_db_home=$($CRS/bin/srvctl status database -d $db_list|grep PRCD-1229|awk '{ printf "%s",substr($NF,1,length($NF)-1) }');fi
        #	#$READ -p "$db_list and $crs_db_home"
        #	if [ -n "$crs_db_home" ]; then export ORACLE_HOME=$crs_db_home;crs_db_status=$($ORACLE_HOME/bin/srvctl status database -d $db_list|grep -i $localnode | grep -ic "is running");fi;
        #	if [ $crs_db_status -ge 1 ]
        #	then #database instance running in localhost
        #		echo $db_list >>$running_db_list;
        #		echo ":$db_list:$localnode" >>$running_db_host_list;
        #	elif [ -n "$ORACLE_HOME" ] # Not running local node. get remote node
        #	then 
        #		if [[ -n $localonly && $localonly -eq "0" ]] ; then
        #		     	#crs_db_running_host=$($ORACLE_HOME/bin/srvctl status database -d $db_list|grep -i "is running"| head -1 | awk '{print $NF}')
        #		     	crs_db_hosts=$($ORACLE_HOME/bin/srvctl status database -d $db_list|grep -i "is running" | awk '{print $NF}')
        #		     	for crs_db_running_host in $(echo $crs_db_hosts)
        #		     	do
        #				if [[ -n "$crs_db_running_host" && `grep -ic "$crs_db_running_host" $HOSTLIST` -gt "0" ]]
        #				then
        #					echo $db_list >>$running_db_list;
        #					echo ":$db_list:$crs_db_running_host" >>$running_db_host_list;
        #					break;
        #					#else
        #					#echo "$db_list: $crs_db_running_host is not selected"
        #				fi;
        #			done
        #		fi
        #	fi;
        printf ". "
        #fi
        #db_list_lower=$(echo $db_list|tr '[:upper:]' '[:lower:]') 
        #echo "localnode=$localnode"
        #db_status=$($CRS/bin/crsctl status resource ora.${db_list_lower}.db |grep -i state|grep $localnode|grep -ic online)
        #if [[ -z "$db_status" || $db_status -lt 1 ]]; then db_status=$($CRS/bin/crsctl status resource ora.${db_list}.db |grep -i state|grep $localnode|grep -ic online); fi;
        #else
           #db_status=$($CRS/bin/crs_stat ora.${db_list}.db |grep -i state|grep $localnode|grep -ic online)
           #db_status=$($CRS/bin/crs_stat ora.${db_list}.db |grep -i state|grep -ic online)
        #fi 
        #if [[ -n "$db_status" && $db_status -ge 1 ]]; then echo $db_list >>$running_db_list; fi
      done

      no_of_databases=$(cat $running_db_list|wc -l)
  
      if [[ $olsnodes_ssh_disabled -eq 1 ]]; then
      for mapping in ${hostmap[@]}
      do
       	management_host=${mapping%%:*}
       	client_host=${mapping#*:}
  
        tmp_client_host=""
       	if [[ `grep -ic "$client_host" $running_db_host_list` -ge 1 ]]; then
          sed 's/'$client_host'/'$management_host'/p' $running_db_host_list>> $running_db_host_list.new
      	  mv $running_db_host_list.new $running_db_host_list
        else
      	  tmp_client_host=$(echo $client_host|awk -F"." '{print $1}');
      	  if [[ `grep -ic "$tmp_client_host" $running_db_host_list` -ge 1 ]]; then
      	    sed 's/'$tmp_client_host'/'$management_host'/p' $running_db_host_list>> $running_db_host_list.new
      	    mv $running_db_host_list.new $running_db_host_list
      	  fi
       	fi
      done
      fi
  
      #remove duplicate entries....
      if [ -e "$running_db_host_list" ]
      then
      	cat $running_db_host_list|sort|uniq > $running_db_host_list.new
        mv $running_db_host_list.new $running_db_host_list
      fi
  
      if [[ `cat $db_list_fil|sed '/^$/d'|wc -l` -ge 1 && $no_of_databases -lt 1 && `ps -ef |grep ora_pmon|grep -v grep|wc -l` -gt 0 ]]
      then
	if [[ $EM_PROBE_MODE -eq 1 ]]
	then
	  EMSG="$program_name could not determine status of databases registered in clusterware to check best practices. \nSet environment variable RAT_DBNAMES to name of the database and re-run.\neg. like export RAT_DBNAMES=\"TESTDB,PRODDB\""
	  update_probe_xml "ERROR" "GENERIC" "$EMSG"
	fi
        echo -e "\n\n${RED}$program_name could not determine status of databases registered in clusterware to check best practices. Set environment variable RAT_DBNAMES to name of the database and re-run.${NORM}\n\nlike export RAT_DBNAMES=\"TESTDB,PRODDB\"\n" 
        exit 0
      elif [[ `cat $db_list_fil|sed '/^$/d'|wc -l` -lt 1 && `ps -ef |grep ora_pmon|grep -v grep|wc -l` -gt 0 ]]
      then
        if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_db_checks -eq "0" ]] || [[ -n "$exclude_profile" && $exclude_profile -eq "1" && $profile_db_checks -eq "0" ]]; then
          echo
        else
	  if [[ $EM_PROBE_MODE -eq 1 ]]
	  then
	    EMSG="Databases are not registered in Clusteware to check best practices.Set environment variable RAT_DBNAMES to name of the database and re-run.\neg. like export RAT_DBNAMES=\"TESTDB,PRODDB\""
	    update_probe_xml "ERROR" "GENERIC" "$EMSG"
	  fi
          echo -e "\n\n${RED}Databases are not registered in Clusteware to check best practices.Set environment variable RAT_DBNAMES to name of the database and re-run.${NORM}\n\nlike export RAT_DBNAMES=\"TESTDB,PRODDB\"\n" 
          exit 0
        fi
      fi
  
    #else
    #  if [ -z "$RAT_DBHOMES" ];then cat $db_list_fil >$running_db_list;fi
    fi
  
    #cat $db_list_fil
    #cat $running_db_list
    #$READ -p "running db list"
    #if [[ -f $running_db_list && `cat $running_db_list|wc -l` -ge 1 ]]; then cp $running_db_list $db_list_fil;fi;
    no_of_databases=$(cat $running_db_list|wc -l)
    #$READ -p "stop"
    if [[ $single_instance_run -eq "1" ]] ; then
      db_list_from_env=1
      db_counter=1
    fi

    if [[ $no_of_databases -ge 1 && `cat $running_db_list|wc -l` -ge 1 && $db_list_from_env -eq 1 ]]
    then
       if [[ $single_instance_run -eq "0" ]] ; then
         echo -e "\nList of running databases registered in OCR"
         db_print_msg="List of running databases registered in OCR"
         nlsid='n7'
       else
         echo -e "\nList of running databases"
    	 db_print_msg="List of running databases"
	 nlsid='n35'
       fi
       if [[ $EM_PROBE_MODE -eq 1 ]]
       then
         cat >> ${PROBE_XML}.tmp << EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="MULTI_SELECT" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <text nls_id="orhc_exadata_${nlsid}_nlsid">
        $db_print_msg
      </text>
    </context>
    <text nls_id="orhc_exadata_n8_nlsid"> 
      Select databases from list for checking best practices
    </text>
    <options>
EOF
       fi

       for db_list in `cat $running_db_list`
       do 
         if [[ $EM_PROBE_MODE -eq 1 ]]
         then
           cat >> ${PROBE_XML}.tmp << EOF
      <option id="q${PROBE_QUES_CNT}o${db_counter}">
        <text>$db_list</text>
      </option>
EOF
         fi
         echo "${db_counter}. $db_list"
         db_counter=$(expr ${db_counter} + 1)
       done

       if [ $no_of_databases -gt 1 ]; 
       then 
         if [[ $EM_PROBE_MODE -eq 1 ]]
         then
           cat >> ${PROBE_XML}.tmp << EOF
      <option id="q${PROBE_QUES_CNT}o${db_counter}">
        <text nls_id="orhc_exadata_n4_nlsid">All</text>
      </option>
EOF
         fi

         echo -e "${db_counter}. All of above";
         db_counter_none=$(expr $db_counter + 1 );
       else 
         db_counter_none=$db_counter;
         db_counter=$(expr ${db_counter} - 1);
       fi
  
       if [[ -n "$dboption" ]] ; then
         if [[ "$dboption" = "all" ]]; then 
           db_to_check=$db_counter; 
         elif [[ "$dboption" = "none" ]]; then
           db_to_check=$db_counter_none;
         fi
       fi
  
       #db_counter_none=$(expr $db_counter + 1 )
       echo -e "$db_counter_none. None of above\n"  

       if [[ $EM_PROBE_MODE -eq 1 ]]
       then
         cat >> ${PROBE_XML}.tmp << EOF
      <option id="q${PROBE_QUES_CNT}o$db_counter_none">
        <text nls_id="orhc_exadata_n3_nlsid">None</text>
      </option>
    </options>
  </question>
</group>
EOF
	 PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

         if [[ -z "$dboption" ]] ; then db_to_check=$db_counter; fi;
       elif [[ $EM_XMLD_MODE -eq 1 ]]
       then
         echo "Select databases from list for checking best practices. For multiple databases, select ${db_counter} for All or comma separated number like 1,2 etc [1-${db_counter_none}][${db_counter}]."

         read_probe_xml "Select databases from list for checking best practices" 
	 db_to_check=$xml_rvalue
       else
         if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]]
         then
           ask_question2user=1
           if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_db_checks -eq "0" ]] || [[ -n "$exclude_profile" && $exclude_profile -eq "1" && $profile_db_checks -eq "0" ]]; then
             ask_question2user=0; #No need toask user for db if no db checks
             db_to_check=${db_counter_none}
           fi
           if [ $daemon_init_mode -eq 1 ]; then ask_question2user=0;fi
           if [[ $ask_question2user -eq "1" ]] && [[ -z "$dboption" ]] ; then
             exec 3<&2; exec 2<&0 
             $READ -p "Select databases from list for checking best practices. For multiple databases, select ${db_counter} for All or comma separated number like 1,2 etc [1-${db_counter_none}][${db_counter}]." db_to_check
	     read_code=`echo $?`;
             exec 2<&3
	     process_prompt "$read_code" "db_to_check" "$db_counter"
           fi
         else
           if [[ -z "$dboption" ]] ; then db_to_check=$db_counter; fi;
         fi
       fi
  
       db_to_check=$(echo $db_to_check|sed 's/[a-zA-Z]//g')
       comma_ent=`echo $db_to_check |grep "," | wc -l`
       if [  $comma_ent -ge 1 ];then
         case_check=comma_or_single_db
       else
         if [ -z $db_to_check ];then
           case_check=all
         else
           if [ $db_to_check -eq ${db_counter_none} ];then
             case_check=none
           elif [ $db_to_check -eq ${db_counter} ];then
             case_check=all
           elif [ $db_to_check -lt ${db_counter} ];then
             case_check=comma_or_single_db
           else
             case_check=other
           fi
         fi
       fi

       case  $case_check in
         none)
           #for db_list in `cat $running_db_list`
           #do
           #  mb_db_names[$rdbms_counter]=$db_list
           #  #echo "${mb_db_names[$rdbms_counter]}"
           #  rdbms_counter=$(expr ${rdbms_counter} + 1 )
           #done
           #db_name_to_check=${mb_db_names[0]}
           #multiple_db=1  
           #db_name_to_check_none=1
           #rdbms_counter=0
           #mb_set_oracle_homes
           multiple_db=1
           db_name_to_check_none=1
           rdbms_counter=0
           mb_set_oracle_homes
           rm -f $running_db_host_list; touch $running_db_host_list
           rm -f $running_db_list; touch $running_db_list
           no_of_databases=$(cat $running_db_list|wc -l)
	   ;;
         all)
           for db_list in `cat $running_db_list`
           do
             mb_db_names[$rdbms_counter]=$db_list
             rdbms_counter=$(expr ${rdbms_counter} + 1 )
           done
           db_name_to_check=${mb_db_names[0]}
           if [ $rdbms_counter -gt 1 ]
           then
             multiple_db=1
           else
             multiple_db=0
           fi
           rdbms_counter=0
           mb_set_oracle_homes  
           db_name_to_check_all=1
           ;;
         comma_or_single_db)
           if [ `echo $db_to_check|wc -c` -gt 2 ]
           then
             if [ -n "$IFS" ]; then old_ifs=$IFS;IFS=$',';fi;
             for db_to_check_ifs in $db_to_check 
             do
               db_to_check_ifs=$(echo $db_to_check_ifs|sed 's/[a-zA-Z,\*\.;|?/]//g')
               if [[ -n "$db_to_check_ifs" && $db_to_check_ifs -lt $db_counter ]]
               then
      	         db_name_to_check=$(cat $running_db_list|sed -n ''${db_to_check_ifs}'p')  
      	         mb_db_names[$rdbms_counter]=$db_name_to_check
      	         #$READ -p "db_name_to_check=$db_name_to_check"
      	         rdbms_counter=$(expr ${rdbms_counter} + 1 )
               fi
             done
             if [ -n "$old_ifs" ]; then IFS=$old_ifs;else IFS=$'\n';fi;
             db_name_to_check=${mb_db_names[0]}
             multiple_db=1
             rdbms_counter=0
             mb_set_oracle_homes 
             #echo "${mb_db_names[@]}"
           else
      	     db_name_to_check=$(cat $running_db_list|sed -n ''${db_to_check}'p')  
      	     mb_db_names[$rdbms_counter]=$db_name_to_check
      	     mb_set_oracle_homes 
      	     multiple_db=0
           fi
           ;;
         *)
           for db_list in `cat $running_db_list`
           do
             mb_db_names[$rdbms_counter]=$db_list
             #echo "${mb_db_names[$rdbms_counter]}"
             rdbms_counter=$(expr ${rdbms_counter} + 1 )
           done
           db_name_to_check=${mb_db_names[0]}
           multiple_db=1
           rdbms_counter=0
           db_name_to_check_all=1
           mb_set_oracle_homes 
           ;;      
       esac
     elif [[ $no_of_databases -gt 1 && `cat $running_db_list|wc -l` -ge 1 && $db_list_from_env -eq 0 ]]
     then
       for db_list in `cat $running_db_list`
       do
         mb_db_names[$rdbms_counter]=$db_list
         #echo "${mb_db_names[$rdbms_counter]}"
         rdbms_counter=$(expr ${rdbms_counter} + 1 )
         done
       db_name_to_check=${mb_db_names[0]}
       multiple_db=1
       rdbms_counter=0
       mb_set_oracle_homes 
     else
       rdbms_counter=0
       if [[ -n "$no_of_databases" && $no_of_databases -gt 0 ]]
       then
         db_name_to_check=$(cat $running_db_list|sed -n '1p')
         mb_db_names[$rdbms_counter]=$db_name_to_check
       fi
       mb_set_oracle_homes 
       multiple_db=0
     fi
  
     #commented for time being because have plan to support multiple version in upgrade
  
     #$READ -p "DB Name selected =$db_name_to_check"  
     #if [[ $upgrade_mode -gt 1 && -e $OUTPUTDIR/mb_db_homes_versions_distinct_selected.out && `cat $OUTPUTDIR/mb_db_homes_versions_distinct_selected.out|wc -l ` -gt 1 ]]
     #then
     #    echo -e "${RED}you selected multiple version of database which is not supported for upgrade best practice checking. Please select same version databases from list${NORM}\n\n"
     #    echo -e "you selected:-\n\n"
     #    cat $OUTPUTDIR/mb_db_homes_versions_distinct_selected.out
     #    echo -e "\n\n"
     #    #exit 1
     #fi
  
     if [ -n "$db_name_to_check" ]
     then
       #db_name_to_check=$(echo $db_name_to_check|tr '[:upper:]' '[:lower:]')
       if [[ -n "$crs112" && $crs112 -ge 1 ]] 
       then
         db_name_to_check_lower=$(echo $db_name_to_check|tr "[A-Z]" "[a-z]")
         if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
           OLD_OH=$ORACLE_HOME
           ORACLE_HOME=$CRS
           get_dbOwner
           ORACLE_HOME=$OLD_OH
           db_config_fil_write=$(su $dbOwner -c "$CRS/bin/crsctl status resource ora.${db_name_to_check_lower}.db -p")
	   echo -e "$db_config_fil_write" > $db_config_fil
           cd $OLD_DIR
           unset OLD_DIR
           #if [[ -e $db_config_fil && `cat $db_config_fil|grep -ci "Could not find resource"` -ge 1 ]]; then $CRS/bin/crsctl status resource ora.${db_name_to_check}.db -p >$db_config_fil;fi;
           if [[ -e $db_config_fil && `grep -ci "Could not find resource" $db_config_fil` -ge 1 ]]; then  
	     unset db_config_fil_write
	     db_config_fil_write=$(su $dbOwner -c "$CRS/bin/crsctl status resource ora.${db_name_to_check}.db -p")
	     echo -e "$db_config_fil_write" > $db_config_fil;
	   fi;
	 else
           $CRS/bin/crsctl status resource ora.${db_name_to_check_lower}.db -p > $db_config_fil
           #if [[ -e $db_config_fil && `cat $db_config_fil|grep -ci "Could not find resource"` -ge 1 ]]; then $CRS/bin/crsctl status resource ora.${db_name_to_check}.db -p >$db_config_fil;fi;
           if [[ -e $db_config_fil && `grep -ci "Could not find resource" $db_config_fil` -ge 1 ]]; then  $CRS/bin/crsctl status resource ora.${db_name_to_check}.db -p > $db_config_fil;fi;
	 fi
       else
         if [[ $single_instance_run -eq "0" ]] ; then
           if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
             OLD_OH=$ORACLE_HOME
             ORACLE_HOME=$CRS
             get_dbOwner
             ORACLE_HOME=$OLD_OH
             db_config_fil_write=$(su $dbOwner -c "$CRS/bin/srvctl$BAT config database -d $db_name_to_check -a")
	     echo -e "$db_config_fil_write" > $db_config_fil 
             cd $OLD_DIR
             unset OLD_DIR
	   else
             $CRS/bin/srvctl$BAT config database -d $db_name_to_check -a > $db_config_fil 
	   fi
         else
           l_oh="";
           get_ohome_si_oh $db_name_to_check
           echo "ORACLE_HOME=$l_oh" > $db_config_fil
         fi
       fi
     fi

     for rdbms_install in `cat $HOSTLIST`
     do
       unset invntr_OH
       if [ $rdbms_install = $localnode ]
       then
         #if [ -e $db_config_fil ]; then  crs_OH=$(cat $db_config_fil|grep -w ORACLE_HOME|grep ^ORACLE_HOME |cut -d: -f2|sed 's/ //g');fi
         if [ $is_windows -eq "0" ] ; then
           if [ -e $db_config_fil ]; then  crs_OH=$(grep -w ORACLE_HOME $db_config_fil|grep ^ORACLE_HOME |cut -d: -f2|sed 's/ //g');fi
         else
           if [ -e $db_config_fil ]; then  
             crs_OH=$(grep -w ORACLE_HOME $db_config_fil|grep ^ORACLE_HOME |sed 's/ //g'| sed 's|\\|\/|g');
             if [ ! -n "$crs_OH" ] ; then 
               crs_OH=$(grep -w "Oracle home:" $db_config_fil|grep ^Oracle|sed 's/Oracle home: //g' | sed 's/ //g'  | sed 's|\\|\/|g')
             fi
           fi
         fi
         crs_OH=$(echo $crs_OH|cut -d= -f2|sed 's/ //g')
         if [ -z "$crs_OH" ]; then crs_OH=$ORACLE_HOME; fi;
         if [ -n "${invntr_location[$rdbms_counter]}" ]
         then
           if [[ -z "$crs_OH" || ! -d $crs_OH ||  ! -e $crs_OH/bin/oracle ]] && [ -z "$RAT_ORACLE_HOME" ] 
           then
             if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_db_checks -eq "0" ]] || [[ -n "$exclude_profile" && $exclude_profile -eq "1" && $profile_db_checks -eq "0" ]]; then
               echo
             else
	       if [[ $EM_PROBE_MODE -eq 1 ]]
      	       then
	         EMSG="${program_name} did not find the RDBMS binaries on $rdbms_install from environment.\nPlease set RAT_ORACLE_HOME to ORACLE_HOME in current shell to override and re-run it.\neg export RAT_ORACLE_HOME=/u01/app/oracle/product/11.2.0/db_1"
		 update_probe_xml "ERROR" "GENERIC" "$EMSG"
      	       fi
  	       echo -e "${RED}${program_name} did not find the RDBMS binaries on $rdbms_install from environment.\n\nPlease set RAT_ORACLE_HOME to ORACLE_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_ORACLE_HOME=/u01/app/oracle/product/11.2.0/db_1"
               exit 1;
             fi
           fi

           if [[ -d $crs_OH || -n "$RAT_ORACLE_HOME" ]]
           then
             if [[ -f $crs_OH/bin/oracle || -n "$RAT_ORACLE_HOME" ]]
             then
               rdbms_installed[$rdbms_counter]=1
               local_invntr_OH=$crs_OH
             else
               rdbms_installed[$rdbms_counter]=0
             fi
           else
             rdbms_installed[$rdbms_counter]=0
           fi

           if [ ${rdbms_installed[$rdbms_counter]} -eq 1 ]
           then
             echo "$rdbms_install.RDBMS_INSTALLED = 1" >>$MASTERFIL
             rbdmsSoftwareOwner=$(ls -l ${local_invntr_OH}/bin/oracle 2>/dev/null|awk '{print $3}')
             #$READ -p "rbdmsSoftwareOwner=$rbdmsSoftwareOwner usern=$usern crsSoftwareOwner=$crsSoftwareOwner" 
             gridUserAllowed=0
             if [[ "$profiles2run" = "clusterware" || "$profiles2run" = "asm" || "$profiles2run" = "clusterware,asm" || "$profiles2run" = "asm,clusterware" ]]
             then
               gridUserAllowed=1  
             fi
             if [[ -n "$crsSoftwareOwner" && -n "$rbdmsSoftwareOwner" && "$crsSoftwareOwner" != "$rbdmsSoftwareOwner" && "$usern" = "$crsSoftwareOwner" && "$usern" != "$root_user" ]] && [[ "$gridUserAllowed" -eq 0 ]]
             then
	       if [[ $EM_PROBE_MODE -eq 1 ]]
      	       then
		 EMSG="You have run ${program_name} as the clusterware software owner. ${program_name} is intended to be run as an RDBMS software owner (eg. oracle with ownership and group eg.,oracle:oinstall).\nPlease run ${program_name} as an RDBMS software owner and with ownership as described above."
		 update_probe_xml "ERROR" "GENERIC" "$EMSG"
      	       fi
               echo -e "${RED}You have run ${program_name} as the clusterware software owner. ${program_name} is intended to be run as an RDBMS software owner (eg., oracle with ownership and group eg., oracle:oinstall)."
               echo -e "\nPlease run ${program_name} as an RDBMS software owner and with ownership as described above.\n${NORM}"
               exit 1
             fi
           else
             echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL
           fi
         else
           rdbms_installed[$rdbms_counter]=0
           echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL
         fi
       else
         if [ -n "${invntr_location[$rdbms_counter]}" ]
         then
           $SSHELL $rdbms_install ls -l $crs_OH >/dev/null 2>&1
           remote_rdbms_home_status=$(echo $?)
           if [[ $remote_rdbms_home_status -ne 0 && -z "$RAT_ORACLE_HOME" ]] 
           then
             if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_db_checks -eq "0" ]] || [[ -n "$exclude_profile" && $exclude_profile -eq "1" && $profile_db_checks -eq "0" ]]; then
               echo
             else
	       if [[ $EM_PROBE_MODE -eq 1 ]]
      	       then
		 EMSG="${program_name} did not find the RDBMS binaries on $rdbms_install from environment.\nPlease set RAT_ORACLE_HOME to ORACLE_HOME in current shell to override and re-run it.\neg export RAT_ORACLE_HOME=/u01/app/oracle/product/11.2.0/db_1"
		 update_probe_xml "ERROR" "GENERIC" "$EMSG"
      	       fi
               echo -e "${RED}${program_name} did not find the RDBMS binaries on $rdbms_install from environment.\n\nPlease set RAT_ORACLE_HOME to ORACLE_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_ORACLE_HOME=/u01/app/oracle/product/11.2.0/db_1"
               exit 1;
             fi
           fi
           if [[ $remote_rdbms_home_status -eq 0 || -n "$RAT_ORACLE_HOME" ]]
           then 
             $SSHELL $rdbms_install ls -l $crs_OH/bin/oracle >/dev/null 2>&1
             remote_oracle_file_status=$(echo $?)
             if [[ $remote_oracle_file_status -ne 0  && -z "$RAT_ORACLE_HOME" ]] 
             then
               if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_db_checks -eq "0" ]] || [[ -n "$exclude_profile" && $exclude_profile -eq "1" && $profile_db_checks -eq "0" ]]; then
                 echo
               else
	         if [[ $EM_PROBE_MODE -eq 1 ]]
      	         then
		   EMSG="${program_name} did not find the RDBMS binaries on $rdbms_install from environment.\nPlease set RAT_ORACLE_HOME to ORACLE_HOME in current shell to override and re-run it.\neg export RAT_ORACLE_HOME=/u01/app/oracle/product/11.2.0/db_1"
		   update_probe_xml "ERROR" "GENERIC" "$EMSG"
      	         fi
                 echo -e "${RED}${program_name} did not find the RDBMS binaries on $rdbms_install from environment.\n\nPlease set RAT_ORACLE_HOME to ORACLE_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_ORACLE_HOME=/u01/app/oracle/product/11.2.0/db_1"
                 exit 1;
               fi
             fi
             if [[ $remote_oracle_file_status -eq 0  || -n "$RAT_ORACLE_HOME" ]]
             then
               rdbms_installed[$rdbms_counter]=1
             else
               rdbms_installed[$rdbms_counter]=0
             fi
           else
             rdbms_installed[$rdbms_counter]=0
           fi

           if [ ${rdbms_installed[$rdbms_counter]} -eq 1 ]
           then
             echo "$rdbms_install.RDBMS_INSTALLED = 1" >>$MASTERFIL
           else
             echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL
           fi
         else
           rdbms_installed[$rdbms_counter]=0
           echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL   
         fi
       fi # localnode if ends here
       rdbms_counter=`expr $rdbms_counter + 1`
     done 
     rdbms_counter=0  
  else
     is_rdbms_installed
     echo "is_rdbms_installed was called because CRS was down on local node">>$LOGFIL
     multiple_db=0
  fi
  #$READ -p "stop did not find the RDBMS binaries on"
}

# Added to capture the host name where database is running
#remote_database_code
mb_set_running_hosts ()
{
  mb_db_counter=0
  for db_name_to_check in "${mb_db_names[@]}"
  do 
    mb_host_name=$(grep ":$db_name_to_check:" $running_db_host_list | awk -F":" '{print $3}');
    if [ -z "$mb_host_name" ]
    then 
      mb_host_name=$localnode
    fi
    mb_running_host[$mb_db_counter]="$mb_host_name"
    if [[ -n $RAT_DEBUG_V ]]
    then
      echo "Running host for $db_name_to_check:*** $mb_host_name";
    fi
    mb_db_counter=$(expr $mb_db_counter + 1)
  done
}

check_pdb_password()
{
  pdb_check_password_status=1
  return
  pdb_check_password_count=3
  pdb_check_password_status=0
 
  while [[ $pdb_check_password_count -gt 0  && $pdb_check_password_status -eq 0 ]]
  do
    echo ""
    printf "Enter ${RAT_PDB_USER} user password for $pdb_name pluggable database.${pdb_check_password_count} tries remaining:-"
    tty -s && stty -echo
    $READ -r pdb_sys_password
    tty -s && stty echo
    echo ""
    
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      get_dbOwner
      pdb_check_password_message=$(su $dbOwner -c "echo \"select 'LoginSuccessFull' from dual;\"|$ORACLE_HOME/bin/sqlplus ${RAT_PDB_USER}/$pdb_sys_password@\"${mb_pdb_connect_string[$mb_pdb_counter]}\" as sysdba") 
      cd $OLD_DIR
      unset OLD_DIR
    else
      pdb_check_password_message=$(echo "select 'LoginSuccessFull' from dual;"|$ORACLE_HOME/bin/sqlplus ${RAT_PDB_USER}/$pdb_sys_password@"${mb_pdb_connect_string[$mb_pdb_counter]}" as sysdba) 
    fi

    if [ $(echo "$pdb_check_password_message"|grep -wc "LoginSuccessFull") -ge 1 ]
    then
      pdb_check_password_status=1
    else 
      pdb_check_password_status=0
      if [ $pdb_check_password_count -gt 1 ]
      then   
        echo ""
        echo ""
        echo -e "${RED}${RAT_PDB_USER} password is wrong for $pdb_name pluggable database${NORM}" 
      fi
    fi
    pdb_check_password_count=$( expr $pdb_check_password_count - 1)
  done
  if [ $pdb_check_password_status -eq 0 ]
  then
    echo ""
    echo -e "${RED}sys password validation failed for $pdb_name pluggable database. removing from list of databases to check best practices${NORM}"   
  fi
}

mb_set_oracle_homes ()
{
  if [ $no_of_databases -gt 1 ]; then  echo -e "\nSearching out ORACLE_HOME for selected databases.\n";fi
  mb_set_running_hosts; #remote_database_code
  mb_db_counter=0
  mb_db_counter_upgraded=0
  mb_db_counter_need_upgrade=0
  validate_oracle_home_tries=0
  mb_pdb_counter=0

  for db_name_to_check in "${mb_db_names[@]}"
  do 
    printf ". "
    if [[ -n "$crs112" && $crs112 -ge 1 ]]
    then
      db_name_to_check_lower=$(echo $db_name_to_check|tr "[A-Z]" "[a-z]")
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        OLD_OH=$ORACLE_HOME
        ORACLE_HOME=$CRS
        get_dbOwner
        ORACLE_HOME=$OLD_OH
        db_config_fil_write=$(su $dbOwner -c "$CRS/bin/crsctl status resource ora.${db_name_to_check_lower}.db -p")
        echo -e "$db_config_fil_write" > $db_config_fil
	cd $OLD_DIR
        unset OLD_DIR	
        #if [[ -e $db_config_fil && `cat $db_config_fil|grep -ci "Could not find resource"` -ge 1 ]]; then $CRS/bin/crsctl status resource ora.${db_name_to_check}.db -p >$db_config_fil;fi;
        if [[ -e $db_config_fil && `grep -ci "Could not find resource" $db_config_fil` -ge 1 ]]; then  
          unset db_config_fil_write
          db_config_fil_write=$(su $dbOwner -c "$CRS/bin/crsctl status resource ora.${db_name_to_check}.db -p")
          echo -e "$db_config_fil_write" > $db_config_fil;
        fi;
      else
        $CRS/bin/crsctl status resource ora.${db_name_to_check_lower}.db -p > $db_config_fil
        #if [[ -e $db_config_fil && `cat $db_config_fil|grep -ci "Could not find resource"` -ge 1 ]]; then $CRS/bin/crsctl status resource ora.${db_name_to_check}.db -p >$db_config_fil;fi;
        if [[ -e $db_config_fil && `grep -ci "Could not find resource" $db_config_fil` -ge 1 ]]; then  $CRS/bin/crsctl status resource ora.${db_name_to_check}.db -p > $db_config_fil;fi;
      fi
    else
      if [[ $single_instance_run -eq "0" ]] ; then
        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
          OLD_OH=$ORACLE_HOME
          ORACLE_HOME=$CRS
          get_dbOwner
          ORACLE_HOME=$OLD_OH
          db_config_fil_write=$(su $dbOwner -c "$CRS/bin/srvctl$BAT config database -d $db_name_to_check -a")
          echo -e "$db_config_fil_write" > $db_config_fil 
          cd $OLD_DIR
          unset OLD_DIR
        else
          $CRS/bin/srvctl$BAT config database -d $db_name_to_check -a > $db_config_fil 
        fi
      else 
        l_oh="";
        get_ohome_si_oh $db_name_to_check
        echo "ORACLE_HOME=$l_oh" > $db_config_fil
      fi
    fi

    if [[ $olsnodes_ssh_disabled -eq 1 ]]; then
      for mapping in ${hostmap[@]}
      do
        management_host=${mapping%%:*}
        client_host=${mapping#*:}
      
        if [[ `grep -ic "$client_host" $db_config_fil` -ge 1 ]]; then
          sed 's/'$client_host'/'$management_host'/p' $db_config_fil>> $db_config_fil.new
       	  mv $db_config_fil.new $db_config_fil
        else
          tmp_client_host=$(echo $client_host|awk -F"." '{print $1}');
          if [[ `grep -ic "$tmp_client_host" $db_config_fil` -ge 1 ]]; then
            sed 's/'$tmp_client_host'/'$management_host'/p' $db_config_fil>> $db_config_fil.new
            mv $db_config_fil.new $db_config_fil
          fi
        fi
      done
    fi

    #following code to fix the issue raised by DHS
    if [[ -n "$RAT_ORACLE_HOME" && $no_of_databases -eq 1 ]]
    then
      mb_oracle_homes[$mb_db_counter]=$RAT_ORACLE_HOME
    else
      #mb_oracle_homes[$mb_db_counter]=$(cat $db_config_fil|grep -w ORACLE_HOME|grep ^ORACLE_HOME|cut -d: -f2|cut -d= -f2|sed 's/ //g')
      if [ $is_windows -eq "0" ] ; then
        mb_oracle_homes[$mb_db_counter]=$(grep -w ORACLE_HOME $db_config_fil|grep ^ORACLE_HOME|cut -d: -f2|cut -d= -f2|sed 's/ //g')
      else
        mb_oracle_homes[$mb_db_counter]=$(grep -w ORACLE_HOME $db_config_fil|grep ^ORACLE_HOME|cut -d= -f2|sed 's/ //g' | sed 's|\\|\/|g')
        if [ ! -n "${mb_oracle_homes[$mb_db_counter]}" ] ; then 
           mb_oracle_homes[$mb_db_counter]=$(grep -w "Oracle home:" $db_config_fil|grep ^Oracle|sed 's/Oracle home: //g' | sed 's/ //g'  | sed 's|\\|\/|g')
        fi
      fi
      #mb_oracle_homes[$mb_db_counter]=$(cat $db_config_fil|grep ORACLE_HOME|grep -vw "ORACLE_HOME_OLD"|cut -d: -f2|cut -d= -f2|sed 's/ //g')
    fi
    ####

    #below if condition to find $ORACLE_HOME using config database -v option
    if [[ -z "${mb_oracle_homes[$mb_db_counter]}" && -e $db_list_fil_verbose ]]
    then
      mb_oracle_homes[$mb_db_counter]=$(grep -w ${db_name_to_check} $db_list_fil_verbose|awk '{print $2}')
    fi
    if [ -z "${mb_oracle_homes[$mb_db_counter]}" ]
    then
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        OLD_OH=$ORACLE_HOME
        ORACLE_HOME=$CRS
        get_dbOwner
        ORACLE_HOME=$OLD_OH
        mb_oracle_homes[$mb_db_counter]=$(su $dbOwner -c "$CRS/bin/srvctl$BAT status database -d ${db_name_to_check}|grep PRKR-1078|awk '{ print \$NF }'")   
        cd $OLD_DIR
        unset OLD_DIR
      else
        mb_oracle_homes[$mb_db_counter]=$($CRS/bin/srvctl$BAT status database -d ${db_name_to_check}|grep PRKR-1078|awk '{ print $NF }')   
      fi
    fi

    mb_read_oracle_home "${mb_oracle_homes[$mb_db_counter]}" "$db_name_to_check"

    if [[ -n "$mb_read_oracle_home_called" && $mb_read_oracle_home_called -eq 0 ]] 
    then
      mb_oracle_homes[$mb_db_counter]=${mb_oracle_homes[$mb_db_counter]}
    else
      mb_validate_oracle_home "$mb_ask_oracle_home"
      mb_oracle_homes[$mb_db_counter]=$mb_ask_oracle_home
    fi

    #echo " ${mb_oracle_homes[$mb_db_counter]}  and mb_db_counter=$mb_db_counter"
    while [[ -n "$mb_read_oracle_home_called" && $mb_read_oracle_home_called -eq 1 ]] && [ $validate_oracle_home_tries -lt 3 ] && [ $validate_oracle_home_status -eq 0 ]
    do
      validate_oracle_home_tries=$(expr $validate_oracle_home_tries + 1 )
      mb_oracle_homes[$mb_db_counter]=""
      mb_read_oracle_home "${mb_oracle_homes[$mb_db_counter]}" "$db_name_to_check"
      mb_validate_oracle_home "$mb_ask_oracle_home"
      mb_oracle_homes[$mb_db_counter]=$mb_ask_oracle_home
      printf ". "
      #$READ -p "validate_oracle_home_tries=$validate_oracle_home_tries"
    done

    export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      get_dbOwner
      what_db=$(su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -v 2>/dev/null|awk '{print \$3}'|sed 's/\.//g'|sed '/^$/d'")
      cd $OLD_DIR
      unset OLD_DIR
    else
      what_db=$($ORACLE_HOME/bin/sqlplus -v 2>/dev/null|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
    fi
    if [ -z $what_db ]; then
      t_flag="-T";
      for hosts in `cat $HOSTLIST`
      do
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  get_dbOwner "" "1"
          what_db=`$SSHELL $t_flag $hosts<<EOF
	  cd $dbhome_dir 2>/dev/null;
          export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
          su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -v 2>/dev/null"
EOF`		
	else	
          what_db=`$SSHELL $t_flag $hosts<<EOF
          export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
          $ORACLE_HOME/bin/sqlplus -v 2>/dev/null
EOF`		
	fi
	what_db=$(echo "$what_db"|grep -i 'SQL\*Plus: Release'|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
	if [[ -n $what_db ]]; then break; fi
      done
    fi

    export PATH=$ORACLE_HOME/bin:$PATH
    #if [ -n "$RAT_DB" ]; then what_db=$RAT_DB;fi
    check_oh_last_character=$ORACLE_HOME
    if [ -n "$check_oh_last_character" ]
    then 
      if [ `uname -s` = "Linux" ]
      then
        oh_last_character=$(expr substr $check_oh_last_character ${#check_oh_last_character} 1) 
      else
        oh_last_character=""
      fi
      if [[ -n "$oh_last_character" && "$oh_last_character" = "/" && $what_db -lt 111070 ]]; then  mb_oracle_homes[$mb_db_counter]=$(echo ${mb_oracle_homes[$mb_db_counter]}|sed 's/.$//');fi;
    fi
    #ports_find_sid
    #$READ -p "ORACLE_HOME=$ORACLE_HOME"
    mb_database_type[$mb_db_counter]="NORMAL"
    if [ $single_instance_run -eq "1" ] ; then
      mb_oracle_sids[$mb_db_counter]=${mb_db_names[$mb_db_counter]}
    else
      local_mb_running_host="${mb_running_host[$mb_db_counter]}";
      if [[ $olsnodes_ssh_disabled -eq 1 ]]; then
        for mapping in ${hostmap[@]}
        do
       	  tmp_client_host=""
          management_host=${mapping%%:*}
          client_host=${mapping#*:}
         
          if [[ `echo "$management_host" |grep -ic "$local_mb_running_host"` -ge 1 ]]; then
            tmp_client_host=$(echo $client_host|awk -F"." '{print $1}');
            local_mb_running_host=$tmp_client_host;
          fi 
        done
      fi
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        OLD_OH=$ORACLE_HOME
        ORACLE_HOME=$CRS
        get_dbOwner
        ORACLE_HOME=$OLD_OH
        mb_oracle_sids[$mb_db_counter]=$(su $dbOwner -c "${ORACLE_HOME}/bin/srvctl$BAT status database -d $db_name_to_check 2>/dev/null|grep -i "$local_mb_running_host"|head -1|awk '{print \$2}'") 
        cd $OLD_DIR
        unset OLD_DIR
      else
        mb_oracle_sids[$mb_db_counter]=$(${ORACLE_HOME}/bin/srvctl$BAT status database -d $db_name_to_check 2>/dev/null|grep -i "$local_mb_running_host"|head -1|awk '{print $2}') 
      fi
      #remote_database_code
      if [ -z ${mb_oracle_sids[$mb_db_counter]} ]; then
        t_flag="-T";
        for hosts in `cat $HOSTLIST`
        do
          if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
            OLD_OH=$ORACLE_HOME
            ORACLE_HOME=$CRS
            get_dbOwner
            ORACLE_HOME=$OLD_OH
            mb_oracle_sids[$mb_db_counter]=`$SSHELL $t_flag $hosts<<EOF
	    cd $dbhome_dir 2>/dev/null;
	    export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
	    su $dbOwner -c "${ORACLE_HOME}/bin/srvctl$BAT status database -d $db_name_to_check 2>/dev/null"
EOF`      	
            cd $OLD_DIR
            unset OLD_DIR
          else
            mb_oracle_sids[$mb_db_counter]=`$SSHELL $t_flag $hosts<<EOF
	    export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
	    ${ORACLE_HOME}/bin/srvctl$BAT status database -d $db_name_to_check 2>/dev/null
EOF`      	
          fi
	  mb_oracle_sids[$mb_db_counter]=$(echo "${mb_oracle_sids[$mb_db_counter]}"|grep -i "$local_mb_running_host"|head -1|awk '{print $2}')
          if [[ -n ${mb_oracle_sids[$mb_db_counter]} ]]; then break; fi
        done
      fi
    fi

    export ORACLE_SID=${mb_oracle_sids[$mb_db_counter]}

    if [[ $what_db -gt 121000 ]]
    then
      checksysdba     
      mb_checksysdba[$mb_db_counter]=$IS_SYSDBA
      if [[ ${mb_checksysdba[$mb_db_counter]} -eq 1 ]]
      then  
        multipleSqlValue "select value from v\$parameter where name='local_listener'"
        local_listener=$(echo $sqlValue|awk 'BEGIN { FS = "=" }{ print $NF }'|sed 's/[^0-9]*//g'|tr "\013" " ")
        #local_listener=$(echo $sqlValue|awk -F "PORT=" '{print $2}'|sed 's/)//g'|tr "\013" " ")
        #To remove new line and blank space charactor  
        local_listener=$(echo $local_listener|sed 's/ //g')
        multipleSqlValue "select upper(cdb) from v\$database"  
      	
        if [ "$sqlValue" = "YES" ]
        then
      	  mb_database_type[$mb_db_counter]="CDB"
      	  multipleSqlValue "select name from v\$pdbs where open_mode='READ WRITE'"  
      	  sqlValue=$(echo $sqlValue|tr "\013" " ")

          if [[ -n "$RAT_PDBNAMES" && "$RAT_PDBNAMES" = "none" ]]
          then
            sqlValue="" 
          elif  [ -n "$RAT_PDBNAMES" ]
          then 
            sqlValue=$RAT_PDBNAMES
          fi

      	  if [ -z "$RAT_PDB_USER" ]; then RAT_PDB_USER=sys;fi     

      	  for pdb_name in $sqlValue
      	  do  
      	    #if [ "$NOQUESTION" -eq 0 ]
      	    #then    
      	    if [ -z "$db_name_to_check_none" ]
      	    then 
	      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		get_dbOwner
		l_service_name=$(su $dbOwner -c "$ORACLE_HOME/bin/lsnrctl services |grep -iw ${pdb_name}|cut -d'\"' -f2")
		cd $OLD_DIR
		unset OLD_DIR
	      else
      	        l_service_name=$($ORACLE_HOME/bin/lsnrctl services |grep -iw ${pdb_name}|cut -d'"' -f2)
	      fi
      	      if [ -z "$l_service_name" ] ; then l_service_name=${pdb_name}; fi
      	      mb_pdb_connect_string[$mb_pdb_counter]="(DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = ${mb_running_host[$mb_db_counter]})(PORT = ${local_listener})) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = ${l_service_name})))"
      	      check_pdb_password
      	    
	      if [ $pdb_check_password_status -eq 1 ]
      	      then 
      	        mb_pdb_names[$mb_pdb_counter]=$pdb_name 
      	        mb_pdb_homes[$mb_pdb_counter]=${mb_oracle_homes[$mb_db_counter]}
      	        mb_pdb_running_host[$mb_pdb_counter]=${mb_running_host[$mb_db_counter]}
      	        mb_pdb_running_sid[$mb_pdb_counter]=$ORACLE_SID
                          
                #commenting this because not asking password for pdbs
      	        #mb_pdb_sys_password[$mb_pdb_counter]=$pdb_sys_password 
      	        mb_pdb_counter=$(expr $mb_pdb_counter + 1)
      	      fi
      	    fi
      	    #else 
      	    #    echo -e "\n${RED}Pluggable database $pdb_name can not checked in silent mode because user needs to key in database password${NORM}\n\n"|tee -a $LOGFIL
      	    #fi
      	  done 
      	  #If there are PDBS for a CDB then set multiple_db=1  
      	  if [[ $multiple_db -eq 0 && $mb_pdb_counter -gt 0 ]]; then multiple_db=1;fi 
      	  #echo "$db_name_to_check.pluggable_databases = $sqlValue" >>$MASTERFIL
        fi
      else
        echo -e "\n${RED} OS authentication to login as sysdba is not enabled so skipping $db_name_to_check for pdb discovery${NORM}\n\n"|tee -a $LOGFIL 
      fi    
    fi  

    #func_what_db
    if [[ $upgrade_mode -eq 2 ]]
    then
      if [[ -n "$what_db" &&  $what_db -eq $targetversion ]]
      then 
        mb_db_names_upgraded[$mb_db_counter_upgraded]=$db_name_to_check
        mb_db_counter_upgraded=$(expr $mb_db_counter_upgraded + 1)
      else
        mb_db_names_need_upgrade[$mb_db_counter_need_upgrade]=$db_name_to_check
        mb_db_counter_need_upgrade=$(expr $mb_db_counter_need_upgrade + 1)
      fi
    elif [ $upgrade_mode -eq 3 ]
    then
      if [[ -n "$what_db" &&  `echo $supportedTargetVersion|grep -icw $what_db` -ge 1 ]]
      then 
        mb_db_names_upgraded[$mb_db_counter_upgraded]=$db_name_to_check
        mb_db_counter_upgraded=$(expr $mb_db_counter_upgraded + 1)
      else
        mb_db_names_need_upgrade[$mb_db_counter_need_upgrade]=$db_name_to_check
        mb_db_counter_need_upgrade=$(expr $mb_db_counter_need_upgrade + 1)
      fi
    fi

    if [  -e $OUTPUTDIR/mb_db_homes_versions_distinct.out ]
    then 
      if [ `grep -c "$what_db" $OUTPUTDIR/mb_db_homes_versions_distinct.out` -lt 1 ]
      then  
        echo "$ORACLE_HOME|$what_db">>$OUTPUTDIR/mb_db_homes_versions_distinct.out
      fi
    else
      echo "$ORACLE_HOME|$what_db">>$OUTPUTDIR/mb_db_homes_versions_distinct.out
    fi

    if [ -z "$db_name_to_check_none"  ]
    then
      if [  -e $OUTPUTDIR/mb_db_homes_versions_distinct_selected.out ]
      then 
        if [ `grep -c "$what_db" $OUTPUTDIR/mb_db_homes_versions_distinct_selected.out` -lt 1 ]
        then  
          echo "$ORACLE_HOME|$what_db|$db_name_to_check">>$OUTPUTDIR/mb_db_homes_versions_distinct_selected.out
        fi
      else
        echo "$ORACLE_HOME|$what_db|$db_name_to_check">>$OUTPUTDIR/mb_db_homes_versions_distinct_selected.out
      fi
    fi
    #$READ -p " ${mb_oracle_homes[$mb_db_counter]} ${mb_oracle_sids[$mb_db_counter]}"
    mb_db_counter=$(expr $mb_db_counter + 1)
  done
  #$READ -p  "${mb_oracle_sids[@]} ${mb_oracle_homes[@]} ${mb_db_names[@]}"
  #code to add PDBs to to the end of the list of databases

  mb_pdb_counter=0
  for pdb_name in "${mb_pdb_names[@]}" 
  do
    mb_db_names[$mb_db_counter]=$pdb_name
    mb_oracle_homes[$mb_db_counter]=${mb_pdb_homes[$mb_pdb_counter]}
    mb_database_type[$mb_db_counter]="PDB"
    mb_running_host[$mb_db_counter]=${mb_pdb_running_host[$mb_pdb_counter]}
    #commenting this because not asking password for pdbs
    #mb_db_sys_password[$mb_db_counter]=${mb_pdb_sys_password[$mb_pdb_counter]}
    mb_db_connect_string[$mb_db_counter]=${mb_pdb_connect_string[$mb_pdb_counter]}
    mb_database_role[$mb_db_counter]="PRIMARY"
    mb_oracle_sids[$mb_db_counter]=${mb_pdb_running_sid[$mb_pdb_counter]}
    mb_checksysdba[$mb_db_counter]=1
    mb_db_counter=$(expr $mb_db_counter + 1)
    mb_pdb_counter=$(expr $mb_pdb_counter + 1)
  done

  mb_db_counter=0
  mb_db_counter_upgraded=0
  mb_db_counter_need_upgrade=0
  mb_pdb_counter=0
  #$READ -p "${mb_db_names[@]} ${mb_oracle_homes[@]} ${mb_database_type[@]} ${mb_running_host[$mb_db_counter]} ${mb_database_role[@]}"
  #$READ -p "${mb_database_type[@]}"

  for db_name_to_check_oh in `if [ -r $db_list_fil ]; then cat $db_list_fil;fi`
  do
    if [[ $upgrade_mode -gt 0 && ` echo ${mb_db_names[@]}|grep -icw $db_name_to_check_oh` -lt 1 ]]
    then
      echo "skipping $db_name_to_check_oh database for checking patches because not selected from list">>$LOGFIL
    else
      printf ". "
      if [[ -n "$crs112" && $crs112 -ge 1 ]]
      then
        db_name_to_check_lower=$(echo $db_name_to_check_oh|tr "[A-Z]" "[a-z]")
        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
          OLD_OH=$ORACLE_HOME
          ORACLE_HOME=$CRS
          get_dbOwner
          ORACLE_HOME=$OLD_OH
          db_config_fil_write=$(su $dbOwner -c "$CRS/bin/crsctl status resource ora.${db_name_to_check_lower}.db -p")
          echo -e "$db_config_fil_write" > $db_config_fil
          cd $OLD_DIR
          unset OLD_DIR
          #if [[ -e $db_config_fil && `cat $db_config_fil|grep -ci "Could not find resource"` -ge 1 ]]; then $CRS/bin/crsctl status resource ora.${db_name_to_check}.db -p >$db_config_fil;fi;
          if [[ -e $db_config_fil && `grep -ci "Could not find resource" $db_config_fil` -ge 1 ]]; then  
            unset db_config_fil_write
            db_config_fil_write=$(su $dbOwner -c "$CRS/bin/crsctl status resource ora.${db_name_to_check_oh}.db -p")
            echo -e "$db_config_fil_write" > $db_config_fil;
          fi;
        else
          $CRS/bin/crsctl status resource ora.${db_name_to_check_lower}.db -p > $db_config_fil
          #if [[ -e $db_config_fil && `cat $db_config_fil|grep -ci "Could not find resource"` -ge 1 ]]; then $CRS/bin/crsctl status resource ora.${db_name_to_check}.db -p >$db_config_fil;fi;
          if [[ -e $db_config_fil && `grep -ci "Could not find resource" $db_config_fil` -ge 1 ]]; then $CRS/bin/crsctl status resource ora.${db_name_to_check_oh}.db -p > $db_config_fil;fi;
        fi
      else
        if [[ $single_instance_run -eq "0" ]] ; then
          if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
            OLD_OH=$ORACLE_HOME
            ORACLE_HOME=$CRS
            get_dbOwner
            ORACLE_HOME=$OLD_OH
            db_config_fil_write=$(su $dbOwner -c "$CRS/bin/srvctl$BAT config database -d $db_name_to_check_oh -a")
            echo -e "$db_config_fil_write" > $db_config_fil 
            cd $OLD_DIR
            unset OLD_DIR
          else
            $CRS/bin/srvctl$BAT config database -d $db_name_to_check_oh -a > $db_config_fil 
          fi
        else 
          l_oh="";
          get_ohome_si_oh $db_name_to_check_oh
          echo "ORACLE_HOME=$l_oh" > $db_config_fil
        fi
      fi

      #mb_oracle_homes[$mb_db_counter]=$(cat $db_config_fil|grep ORACLE_HOME|cut -d: -f2|cut -d= -f2|sed 's/ //g')
      #following code to fix the issue raised by DHS
      if [[ -n "$RAT_ORACLE_HOME" && `cat $db_list_fil|wc -l` -eq 1 ]]
      then
        export ORACLE_HOME=$RAT_ORACLE_HOME
      else
        #export ORACLE_HOME=$(cat $db_config_fil|grep -w ORACLE_HOME|grep ^ORACLE_HOME|cut -d: -f2|cut -d= -f2|sed 's/ //g')
        if [ $is_windows -eq "0" ] ; then
          export ORACLE_HOME=$(grep -w ORACLE_HOME $db_config_fil|grep ^ORACLE_HOME|cut -d: -f2|cut -d= -f2|sed 's/ //g')
        else
          export ORACLE_HOME=$(grep -w ORACLE_HOME $db_config_fil|grep ^ORACLE_HOME|cut -d= -f2|sed 's/ //g' | sed 's|\\|\/|g')
          if [ ! -n "$ORACLE_HOME" ] ; then 
            ORACLE_HOME=$(grep -w "Oracle home:" $db_config_fil|grep ^Oracle|sed 's/Oracle home: //g' | sed 's/ //g'  | sed 's|\\|\/|g')
          fi
        fi
        #export ORACLE_HOME=$(cat $db_config_fil|grep ORACLE_HOME|grep -vw "ORACLE_HOME_OLD"|cut -d: -f2|cut -d= -f2|sed 's/ //g')
      fi
      #####
      #below if condition to find $ORACLE_HOME using config database -v option
      if [[ -z "${ORACLE_HOME}" && -e $db_list_fil_verbose ]]
      then
        export ORACLE_HOME=$(grep -w ${db_name_to_check_oh} $db_list_fil_verbose|awk '{print $2}')
      fi

      if [ -z "${ORACLE_HOME}" ]
      then
        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
          OLD_OH=$ORACLE_HOME
          ORACLE_HOME=$CRS
          get_dbOwner
          ORACLE_HOME=$OLD_OH
          export ORACLE_HOME=$(su $dbOwner -c "$CRS/bin/srvctl$BAT status database -d ${db_name_to_check_oh}|grep PRKR-1078|awk '{ print \$NF }'")   
	  cd $OLD_DIR
	  unset OLD_DIR
	else
          export ORACLE_HOME=$($CRS/bin/srvctl$BAT status database -d ${db_name_to_check_oh}|grep PRKR-1078|awk '{ print $NF }')   
	fi
      fi

      mb_read_oracle_home "$ORACLE_HOME" "$db_name_to_check_oh"

      if [[ -n "$mb_read_oracle_home_called" && $mb_read_oracle_home_called -eq 0 ]] 
      then
        echo "Do nothing" >/dev/null 2>&1
      else
        mb_validate_oracle_home "$mb_ask_oracle_home"
        export ORACLE_HOME=$mb_ask_oracle_home
      fi
      while [[ -n "$mb_read_oracle_home_called" && $mb_read_oracle_home_called -eq 1 ]] && [ $validate_oracle_home_tries -lt 3 ] && [ $validate_oracle_home_status -eq 0 ]
      do
        validate_oracle_home_tries=$(expr $validate_oracle_home_tries + 1 )
        ORACLE_HOME=""
        mb_read_oracle_home "$ORACLE_HOME" "$db_name_to_check_oh"
        mb_validate_oracle_home "$mb_ask_oracle_home"
        export ORACLE_HOME=$mb_ask_oracle_home
        printf ". "
      done
      validate_oracle_home_tries=0
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        get_dbOwner
        what_db=$(su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -v 2>/dev/null|awk '{print \$3}'|sed 's/\.//g'|sed '/^$/d'")
        cd $OLD_DIR
        unset OLD_DIR
      else
        what_db=$($ORACLE_HOME/bin/sqlplus -v 2>/dev/null|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
      fi
      if [ -z $what_db ]; then
        t_flag="-T";
        for hosts in `cat $HOSTLIST`
        do
          if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
            get_dbOwner "" "1"
            what_db=`$SSHELL $t_flag $hosts<<EOF
	    cd $dbhome_dir 2>/dev/null;
            export ORACLE_HOME=$ORACLE_HOME
            su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -v 2>/dev/null"
EOF`  		
	  else
            what_db=`$SSHELL $t_flag $hosts<<EOF
            export ORACLE_HOME=$ORACLE_HOME
            $ORACLE_HOME/bin/sqlplus -v 2>/dev/null
EOF`  		
	  fi
          what_db=$(echo "$what_db"|grep -i 'SQL\*Plus: Release'|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
          if [[ -n $what_db ]]; then break; fi
        done
      fi
      if [ -n "$what_db" ]; then echo "$ORACLE_HOME|$what_db">>$OUTPUTDIR/mb_db_homes_distinct.out;fi
      echo "$what_db">>$OUTPUTDIR/mb_db_versions_distinct.out
      mb_db_counter=$(expr $mb_db_counter + 1)
    fi
  done
  mb_db_counter=0
  echo -e "\n"
  #cat $OUTPUTDIR/mb_db_homes_distinct.out
  #$READ -p "stop"
  #cat $OUTPUTDIR/mb_db_homes_distinct.out
  mb_set_oracle_home_version_distinct 
  #$READ -p  "${mb_oracle_homes_distinct[@]} ${mb_oracle_versions_distinct[@]} ${mb_oracle_homes_version_distinct[@]}"
}

mb_set_oracle_home_version_distinct ()
{
  mb_db_counter=0
  for mb_db_version in `if [ -e $OUTPUTDIR/mb_db_versions_distinct.out ]; then cat $OUTPUTDIR/mb_db_versions_distinct.out|sort -u;fi;`
  do
    mb_oracle_versions_distinct[$mb_db_counter]=$mb_db_version
    mb_db_counter=$(expr $mb_db_counter + 1)
  done
  mb_db_counter=0
  for mb_db_home in `if [ -e $OUTPUTDIR/mb_db_homes_distinct.out ]; then cat $OUTPUTDIR/mb_db_homes_distinct.out|cut -d'|' -f1|sort -u;fi;`
  do
    unset dbOwner 
    unset oh_available_on_host
    mb_oracle_homes_distinct[$mb_db_counter]=$mb_db_home
    if [ $OFFLINE -eq 0 ]
    then
      export ORACLE_HOME=$mb_db_home
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        get_dbOwner
        what_db=$(su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -v 2>/dev/null|awk '{print \$3}'|sed 's/\.//g'|sed '/^$/d'")
        cd $OLD_DIR
        unset OLD_DIR
      else
        what_db=$($ORACLE_HOME/bin/sqlplus -v 2>/dev/null|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
      fi
      if [[ -n $what_db ]]; then
	oh_available_on_host=$localnode;
      fi

      t_flag="-T";
      for hosts in `cat $HOSTLIST`
      do
        if [[ $localnode != $hosts ]]; then
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    get_dbOwner "" "1"
            t_what_db=$($SSHELL $t_flag $hosts $bash_scr <<EOF
	    cd $dbhome_dir 2>/dev/null; \
            export ORACLE_HOME=$ORACLE_HOME; \
            su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -v 2>/dev/null"
EOF
)
	  else 
            t_what_db=$($SSHELL $t_flag $hosts $bash_scr <<EOF
            export ORACLE_HOME=$ORACLE_HOME;\
            $ORACLE_HOME/bin/sqlplus -v 2>/dev/null
EOF
)
	  fi
          t_what_db=$(echo "$t_what_db"|grep -i 'SQL\*Plus: Release'|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
          if [[ -n $t_what_db ]]; then
	    what_db=$t_what_db
            get_dbOwner "$hosts" "1";
            oh_available_on_host=${oh_available_on_host},${hosts};
          fi
        fi
      done

      oh_available_on_host=$(echo "$oh_available_on_host"|sed 's/^,//g'|sed 's/,$//g')

      if [[ -z $dbOwner ]]; then get_dbOwner "" "1"; oh_available_on_host=$localnode; fi;  oracle_home_owner[$mb_db_counter]=$dbOwner;
      #if [ `uname -s` = "Linux" ]
      #then
      #  oracle_home_owner[$mb_db_counter]=$(stat -L -c "%U" $ORACLE_HOME/bin/oracle 2>/dev/null >&1)
      #else
      #  oracle_home_owner[$mb_db_counter]=$(ls -l $ORACLE_HOME/bin/oracle 2>/dev/null >&1|awk '{print $3}')
      #fi
      echo "RDBMS_ORACLE_HOME = $mb_db_home|${what_db}|${oracle_home_owner[$mb_db_counter]}|${oh_available_on_host}">>$MASTERFIL
    fi
    mb_db_counter=$(expr $mb_db_counter + 1)
  done

  multiple_oracle_homes=$mb_db_counter
  mb_db_counter=0
  for mb_db_version in `if [ -e $OUTPUTDIR/mb_db_homes_distinct.out ]; then cat $OUTPUTDIR/mb_db_homes_distinct.out|cut -d'|' -f2;fi`
  do
    mb_db_versions_all[$mb_db_counter]=$mb_db_version
    mb_db_counter=$(expr $mb_db_counter + 1)
  done

  mb_db_counter=0 
  for mb_db_home_version in `if [ -e $OUTPUTDIR/mb_db_homes_versions_distinct.out ]; then cat $OUTPUTDIR/mb_db_homes_versions_distinct.out|cut -d'|' -f1|sort -u;fi;`
  do
    mb_oracle_homes_version_distinct[$mb_db_counter]=$(grep $mb_db_home_version "$OUTPUTDIR/mb_db_homes_versions_distinct.out"|cut -d'|' -f2)
    mb_db_counter=$(expr $mb_db_counter + 1)
  done
  mb_db_counter=0
}

mb_rdbms_stack_status ()
{
  mb_db_counter=0
  for db_name_to_check in "${mb_db_names[@]}"
  do
    printf ". "
    #reinitializing database password check counter for each database
    WRNDBPWD=0
    mb_skip[$mb_db_counter]=0;

    stack_status=$INPUTDIR/stack_status_${db_name_to_check}.out
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then new_stack_status=$TMP_OUTPUT/stack_status_${db_name_to_check}.out; fi
    if [ $upgrade_mode -eq 2 ]
    then
      if [[ -n "${mb_db_names_upgraded[@]}" && ` echo ${mb_db_names_upgraded[@]}|grep -icw $db_name_to_check` -ge 1 ]]
      then
        its_upgraded=0
        mb_skip[$mb_db_counter]=1;
      else
        its_upgraded=0
      fi
    elif [ $upgrade_mode -eq 3 ]
    then 
      if [[ -n "${mb_db_names_upgraded[@]}" && ` echo ${mb_db_names_upgraded[@]}|grep -icw $db_name_to_check` -ge 1 ]]
      then
        its_upgraded=0
      else
        its_upgraded=0
        mb_skip[$mb_db_counter]=1;
      fi
    else
      its_upgraded=0
    fi
    #$READ -p "IS_SYSDBA=$IS_SYSDBA $its_upgraded" 
    #if [[ -n "$crs112" && $crs112 -ge 1 ]]
    #then
    #    db_name_to_check_lower=$(echo $db_name_to_check|tr '[:upper:]' '[:lower:]')
    #    mb_rdbms_inst_stat=$($CRS/bin/crsctl status resource ora.${db_name_to_check_lower}.db |grep -i state|grep $localnode|grep -ic online)
    #    if [[ -z "$mb_rdbms_inst_stat" || $mb_rdbms_inst_stat -lt 1 ]]; then mb_rdbms_inst_stat=$($CRS/bin/crsctl status resource ora.${db_name_to_check}.db |grep -i state|grep $localnode|grep -ic online); fi;
    #else
    #    mb_rdbms_inst_stat=$($CRS/bin/crs_stat ora.${db_name_to_check}.db |grep -i state|grep $localnode|grep -ic online)
    #fi
    #if [[ -n "$mb_rdbms_inst_stat" &&  $mb_rdbms_inst_stat -ge 1 ]] 
    #then

    if [[ -z "$db_name_to_check_none" && $its_upgraded -eq 0 ]]
    then
      if [ -z "$RAT_ORACLE_HOME" ]
      then  
        export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
      else
        export ORACLE_HOME=$RAT_ORACLE_HOME
      fi
      #Following if block is to set ORACLE_SID even database is not registered in OCR.
      if [ -n "${mb_oracle_sids[$mb_db_counter]}" ]
      then
        export ORACLE_SID=${mb_oracle_sids[$mb_db_counter]}
      else
        mb_oracle_sids[$mb_db_counter]=$ORACLE_SID
        export ORACLE_SID
      fi
      export PATH=$PATH:$ORACLE_HOME/bin
      checksysdba
      mb_checksysdba[$mb_db_counter]=$IS_SYSDBA 
      #$READ -p "IS_SYSDBA=${mb_checksysdba[$mb_db_counter]}"
      if [[ ${mb_checksysdba[$mb_db_counter]} -eq 0 ]]
      then 
        if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]] && [[ -n "$daemon_init_mode" && $daemon_init_mode -eq 0 ]]
        then
          nosysdba
          mb_sysdba_user[$mb_db_counter]=$DBUSR
          mb_sysdba_pswd[$mb_db_counter]=$DBPWD

          if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
          then
	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	      get_dbOwner
    	      su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
    	      set head off
    	      set lines 80
    	      set feedback off
              set timing off    
	      set serveroutput on
	      spool $new_stack_status
	      select instance_name||'|'||decode(status,'OPEN',3,'MOUNTED',2,'NOMOUNT',1,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\$instance;
	      spool off
	      exit
EOF
"
	      move_files "$new_stack_status" "$stack_status"
	      cd $OLD_DIR
	      unset OLD_DIR
	    else 
    	      $ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
    	      set head off
    	      set lines 80
    	      set feedback off
              set timing off    
	      set serveroutput on
	      spool $stack_status
	      select instance_name||'|'||decode(status,'OPEN',3,'MOUNTED',2,'NOMOUNT',1,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\$instance;
	      spool off
	      exit
EOF
	    fi
          else #remote_database_code
	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	      TMP_SSFIL=$TMP_OUTPUT/stack_status_${db_name_to_check}.log
	      get_dbOwner "${mb_running_host[$mb_db_counter]}" "1"

              $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
	      cd "$dbhome_dir"; \
              export ORACLE_HOME=$ORACLE_HOME
              export ORACLE_SID=$ORACLE_SID; \
	      su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
	      set head off
	      set lines 80
	      set feedback off
              set timing off 
	      set serveroutput on
	      spool $TMP_SSFIL
	      select instance_name||'|'||decode(status,'OPEN',3,'MOUNTED',2,'NOMOUNT',1,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\\\\\$instance;
	      spool off
	      exit
EOF
"
EOF2
	    else 
	      TMP_SSFIL=$RTEMPDIR/stack_status_${db_name_to_check}.log
              $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
              export ORACLE_HOME=$ORACLE_HOME
              export ORACLE_SID=$ORACLE_SID; \
	      $ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
	      set head off
	      set lines 80
	      set feedback off
              set timing off 
	      set serveroutput on
	      spool $TMP_SSFIL
	      select instance_name||'|'||decode(status,'OPEN',3,'MOUNTED',2,'NOMOUNT',1,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\$instance;
	      spool off
	      exit
EOF
EOF2
	    fi
            #$SCOPY ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/stack_status_${db_name_to_check}.log $stack_status >/dev/null 2>&1
            $SCOPY ${mb_running_host[$mb_db_counter]}:$TMP_SSFIL $stack_status >/dev/null 2>&1
          fi #end of localnode if

          printf ". . . . "
        else
          unset mb_db_names[$mb_db_counter]
          echo -e "\nOS authentication not enabled and asking database password not possible in silent mode so dropping $db_name_to_check from list to check best practices\n">>$LOGFIL  
        fi #end of NOQUESTION if

      else
        mb_sysdba_user[$mb_db_counter]=1
        mb_sysdba_pswd[$mb_db_counter]=1
        if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
        then
  	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    get_dbOwner

	    su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	    set head off
	    set lines 80
	    set feedback off
            set timing off 
	    set serveroutput on
	    spool $new_stack_status
	    select instance_name||'|'||decode(status,'OPEN',3,'MOUNTED',2,'NOMOUNT',1,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\$instance;
	    spool off
	    exit
EOF
"
	    move_files "$new_stack_status" "$stack_status"
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
	    $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	    set head off
	    set lines 80
	    set feedback off
            set timing off 
	    set serveroutput on
	    spool $stack_status
	    select instance_name||'|'||decode(status,'OPEN',3,'MOUNTED',2,'NOMOUNT',1,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\$instance;
	    spool off
	    exit
EOF
	  fi
        else #remote_database_code
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    TMP_SSFIL=$TMP_OUTPUT/stack_status_${db_name_to_check}.log
	    get_dbOwner "${mb_running_host[$mb_db_counter]}"

            $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
            export ORACLE_HOME=$ORACLE_HOME
            export ORACLE_SID=$ORACLE_SID; \
	    cd "$dbhome_dir"; \
	    su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	    set head off
	    set lines 80
	    set feedback off
            set timing off
	    set serveroutput on
	    spool $TMP_SSFIL
	    select instance_name||'|'||decode(status,'OPEN',3,'MOUNTED',2,'NOMOUNT',1,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\\\\\$instance;
	    spool off
	    exit
EOF
"
EOF2
	    cd $OLD_DIR
  	    unset OLD_DIR
	  else
	    TMP_SSFIL=$RTEMPDIR/stack_status_${db_name_to_check}.log
            $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
            export ORACLE_HOME=$ORACLE_HOME
            export ORACLE_SID=$ORACLE_SID; \
	    $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	    set head off
	    set lines 80
	    set feedback off
            set timing off
	    set serveroutput on
	    spool $TMP_SSFIL
	    select instance_name||'|'||decode(status,'OPEN',3,'MOUNTED',2,'NOMOUNT',1,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\$instance;
	    spool off
	    exit
EOF
EOF2
	  fi
          #$SCOPY ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/stack_status_${db_name_to_check}.log $stack_status >/dev/null 2>&1
          $SCOPY ${mb_running_host[$mb_db_counter]}:$TMP_SSFIL $stack_status >/dev/null 2>&1
	fi
	printf ". . . . "
      fi
    elif [[ -n "$db_name_to_check_none" && $db_name_to_check_none -eq 1 ]] || [ $its_upgraded -eq 1 ]
    then
      if [ -z "$RAT_ORACLE_HOME" ]
      then  
        export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
      else
        export ORACLE_HOME=$RAT_ORACLE_HOME
      fi
      export ORACLE_SID=${mb_oracle_sids[$mb_db_counter]}
      checksysdba
      mb_checksysdba[$mb_db_counter]=$IS_SYSDBA 
      if [[ ${mb_checksysdba[$mb_db_counter]} -eq 0 ]]
      then 
        if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]] && [[ -n "$daemon_init_mode" && $daemon_init_mode -eq 0 ]]
        then     
          nosysdba
          mb_sysdba_user[$mb_db_counter]=$DBUSR
          mb_sysdba_pswd[$mb_db_counter]=$DBPWD
          if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
          then
	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	      get_dbOwner
	      su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
	      set head off
	      set lines 80
	      set feedback off
              set timing off
	      set serveroutput on
	      spool $new_stack_status
	      select instance_name||'|'||decode(status,'OPEN',0,'MOUNTED',0,'NOMOUNT',0,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\$instance;
	      spool off
	      exit
EOF
"
	      move_files "$new_stack_status" "$stack_status"
	      cd $OLD_DIR
	      unset OLD_DIR
	    else
	      $ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
	      set head off
	      set lines 80
	      set feedback off
              set timing off
	      set serveroutput on
	      spool $stack_status
	      select instance_name||'|'||decode(status,'OPEN',0,'MOUNTED',0,'NOMOUNT',0,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\$instance;
	      spool off
	      exit
EOF
	    fi
          else #remote_database_code
	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	      TMP_SSFIL=$TMP_OUTPUT/stack_status_${db_name_to_check}.log
              $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
	      cd "$dbhome_dir";
              export ORACLE_HOME=$ORACLE_HOME
              export ORACLE_SID=$ORACLE_SID; \
	      su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
	      set head off
	      set lines 80
	      set feedback off
              set timing off
	      set serveroutput on
	      spool $TMP_SSFIL
	      select instance_name||'|'||decode(status,'OPEN',0,'MOUNTED',0,'NOMOUNT',0,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\\\\\$instance;
	      spool off
	      exit
EOF
"
EOF2
	      cd $OLD_DIR
	      unset OLD_DIR
	    else
	      TMP_SSFIL=$RTEMPDIR/stack_status_${db_name_to_check}.log
              $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
              export ORACLE_HOME=$ORACLE_HOME
              export ORACLE_SID=$ORACLE_SID; \
	      $ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
	      set head off
	      set lines 80
	      set feedback off
              set timing off
	      set serveroutput on
	      spool $TMP_SSFIL
	      select instance_name||'|'||decode(status,'OPEN',0,'MOUNTED',0,'NOMOUNT',0,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\$instance;
	      spool off
	      exit
EOF
EOF2
	    fi
            #$SCOPY ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/stack_status_${db_name_to_check}.log $stack_status >/dev/null 2>&1
            $SCOPY ${mb_running_host[$mb_db_counter]}:$TMP_SSFIL $stack_status >/dev/null 2>&1
          fi #end of localnode if
          printf ". . . . "
        else
          unset mb_db_names[$mb_db_counter]
          echo -e "\nOS authentication not enabled and asking database password not possible in silent mode so dropping $db_name_to_check from list to check best practices\n">>$LOGFIL  
        fi  #end of NOQUESTION if 
      else
        mb_sysdba_user[$mb_db_counter]=1
        mb_sysdba_pswd[$mb_db_counter]=1
        if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
        then
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    get_dbOwner

	    su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	    set head off
	    set lines 80
	    set feedback off
            set timing off 
	    set serveroutput on
	    spool $new_stack_status
	    select instance_name||'|'||decode(status,'OPEN',0,'MOUNTED',0,'NOMOUNT',0,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\$instance;
	    spool off
	    exit
EOF
"
	    move_files "$new_stack_status" "$stack_status"
	    cd $OLD_DIR
	    unset OLD_DIR
	  else 
	    $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	    set head off
	    set lines 80
	    set feedback off
            set timing off 
	    set serveroutput on
	    spool $stack_status
	    select instance_name||'|'||decode(status,'OPEN',0,'MOUNTED',0,'NOMOUNT',0,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\$instance;
	    spool off
	    exit
EOF
	  fi
        else #remote_database_code
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    TMP_SSFIL=$TMP_OUTPUT/stack_status_${db_name_to_check}.log
	    get_dbOwner

            $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
            export ORACLE_HOME=$ORACLE_HOME
            export ORACLE_SID=$ORACLE_SID; \
	    cd "$dbhome_dir"; \
	    su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	    set head off
	    set lines 80
	    set feedback off
            set timing off
	    set serveroutput on
	    spool $TMP_SSFIL
	    select instance_name||'|'||decode(status,'OPEN',0,'MOUNTED',0,'NOMOUNT',0,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\\\\\$instance;
	    spool off
	    exit
EOF
"
EOF2
	    cd $OLD_DIR
	    unset OLD_DIR
	  else 
	    TMP_SSFIL=$RTEMPDIR/stack_status_${db_name_to_check}.log
            $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
            export ORACLE_HOME=$ORACLE_HOME
            export ORACLE_SID=$ORACLE_SID; \
	    $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
	    set head off
	    set lines 80
	    set feedback off
            set timing off
	    set serveroutput on
	    spool $TMP_SSFIL
	    select instance_name||'|'||decode(status,'OPEN',0,'MOUNTED',0,'NOMOUNT',0,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\$instance;
	    spool off
	    exit
EOF
EOF2
	  fi
          #$SCOPY ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/stack_status_${db_name_to_check}.log $stack_status >/dev/null 2>&1
          $SCOPY ${mb_running_host[$mb_db_counter]}:$TMP_SSFIL $stack_status >/dev/null 2>&1
        fi
	printf ". . . . "
      fi #end os IS_SYSDBA if
    fi #end of first if in this for loop
    #fi
    #echo "stack_status: ${mb_running_host[$mb_db_counter]}"
    #cat $stack_status
    mb_db_counter=$(expr $mb_db_counter + 1)
    #$READ -p "stop here"

    if [[ $olsnodes_ssh_disabled -eq 1 ]];
    then
      TMP_STKFILE=$(dirname $stack_status)/.$(basename $stack_status);
      replacement=0
      for mapping in ${hostmap[@]}
      do
        management_host=${mapping%%:*};
        client_host=${mapping#*:};
        tag=`grep -ic "$client_host" $stack_status`;
        if [[ $tag -eq 1 ]]; then
          str=`grep "$client_host" $stack_status`;
          echo $str | sed 's/'$client_host'/'$management_host'/g' >> $TMP_STKFILE
          replacement=1
        fi
      done
      if [[ $replacement -eq 1 ]]
      then
        rm -rf $stack_status;
        mv $TMP_STKFILE $stack_status;
        rm -rf $TMP_STKFILE;
      fi
    fi
  done
  mb_db_counter=0
  printf ""
}

#db_name_to_check=$(echo $db_name_to_check|tr '[:upper:]' '[:lower:]')
is_asm_installed_crs ()
{
  #search_invntr_platform
  asm_counter=0
  asm_config_fil=$INPUTDIR/asm_config.out
  if [[ ${crs_up} = 1 && $check_crs_stat -eq 0 ]]
  then
    if [[ -n "$crs112" && $crs112 -ge 1 ]]
    then
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        OLD_OH=$ORACLE_HOME
	ORACLE_HOME=$CRS
	get_dbOwner
	ORACLE_HOME=$OLD_OH
	crs_AH=$(su $dbOwner -c "$CRS/bin/srvctl$BAT config asm |grep -i home |awk '{print \$3}'")
	cd $OLD_DIR
	unset OLD_DIR
      else
        crs_AH=$($CRS/bin/srvctl$BAT config asm |grep -i home |awk '{print $3}')
      fi
      #in 12102,above command output format chagned so making CRS_HOME to ASM_HOME 
      if [[ -n "$crs_AH" && "$crs_AH" = "<CRS" ]]; then crs_AH=$CRS;fi  
    fi
    for asm_install in `cat $HOSTLIST`
    do
      unset invntr_AH
      if [ $asm_install = $localnode ]
      then
	if [[ -n "$crs112" && $crs112 -eq 0 ]]; then 
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    OLD_OH=$ORACLE_HOME
	    ORACLE_HOME=$CRS	 
	    get_dbOwner
	    ORACLE_HOME=$OLD_OH
	    crs_AH=$(su $dbOwner -c "$CRS/bin/srvctl$BAT config asm -n $asm_install|awk '{print \$2}'")
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
	    crs_AH=$($CRS/bin/srvctl$BAT config asm -n $asm_install|awk '{print $2}')
	  fi
	  #if [[ -n "${invntr_location[$asm_counter]}" && -n "$crs_AH" ]]
	  #then
	  #  invntr_AH=$(cat ${invntr_location[$asm_counter]}/ContentsXML/inventory.xml |grep $crs_AH|awk '{print $3}'|cut -d= -f2|sed 's/\"//g' )
	  #  if [[ $invntr_AH = $crs_AH  && $crs112 -eq 0 ]] 
	  #  then
        fi
	if [[ -d $crs_AH || -n "$RAT_ASM_HOME" ]]
	then
	  if [[ -f $crs_AH/bin/oracle || -n "$RAT_ASM_HOME" ]]
	  then
	    asm_installed[$asm_counter]=1
	    local_invntr_AH=$crs_AH
	  else
	    asm_installed[$asm_counter]=0
	  fi
	else
	  asm_installed[$asm_counter]=0
	fi
	# else
	#   asm_installed[$asm_counter]=0
	# fi
	if [ ${asm_installed[$asm_counter]} -eq 1 ]
	then
	  echo "$asm_install.ASM_INSTALLED = 1" >>$MASTERFIL
	else
	  echo "$asm_install.ASM_INSTALLED = 0" >>$MASTERFIL
	fi
	#else
	#    asm_installed[$asm_counter]=0
	#    echo "$asm_install.ASM_INSTALLED = 0" >>$MASTERFIL
	#fi
      else
	if [[ -n "$crs112" &&  $crs112 -eq 0 ]]; then 
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    OLD_OH=$ORACLE_HOME
	    ORACLE_HOME=$CRS	 
	    get_dbOwner
	    ORACLE_HOME=$OLD_OH
	    crs_AH=$(su $dbOwner -c "$CRS/bin/srvctl$BAT config asm -n $asm_install|awk '{print \$2}'");
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
	    crs_AH=$($CRS/bin/srvctl$BAT config asm -n $asm_install|awk '{print $2}');
	  fi
        fi
	#if [[ -n "${invntr_location[$asm_counter]}" && -n "$crs_AH" ]]
	#then
	#  invntr_AH=$(ssh $asm_install cat ${invntr_location[$asm_counter]}/ContentsXML/inventory.xml |grep $crs_AH|awk '{print $3}'|cut -d= -f2|sed 's/\"//g' )
	#  if [[ $invntr_AH = $crs_AH && $crs112 -eq  0 ]]
	#  then
        $SSHELL $asm_install ls -l $crs_AH >/dev/null 2>&1
        if [[ $? -eq 0  || -n "$RAT_ASM_HOME" ]]
        then 
          $SSHELL $asm_install ls -l $crs_AH/bin/oracle >/dev/null 2>&1
          if [[ $? -eq 0 || -n "$RAT_ASM_HOME" ]]
          then
       	    asm_installed[$asm_counter]=1
          else
       	    asm_installed[$asm_counter]=0
          fi
        else
          asm_installed[$asm_counter]=0
        fi
	#else
	#  asm_installed[$asm_counter]=0
	#fi
	if [ ${asm_installed[$asm_counter]} -eq 1 ]
	then
	  echo "$asm_install.ASM_INSTALLED = 1" >>$MASTERFIL
	else
	  echo "$asm_install.ASM_INSTALLED = 0" >>$MASTERFIL
	fi
	#else
	#  asm_installed[$asm_counter]=0
	#  echo "$asm_install.ASM_INSTALLED = 0" >>$MASTERFIL   
	#fi
      fi #localnode if ends here
      asm_counter=`expr $asm_counter + 1`
    done 
    asm_counter=0  
  else
    is_asm_installed
    echo "is_asm_installed was called because CRS was down on local node">>$LOGFIL
  fi
}

#is_exalogic_machine
#In exalogic we dont check statck status. This function initializes all varia bles
func_init_arrays ()
{
  if [ $OFFLINE -eq "0" ] ; then touch $ORCLENVFIL; fi;
  crs_installed=0
  stack_counter=0 
  for stack in `cat $HOSTLIST`
  do
    stack_crs_up[$stack_counter]=0
    stack_dbinst_up[$stack_counter]=0
    stack_asm_up[$stack_counter]=0
    if [[ -n "$is_exalytics_machine" &&  "$is_exalytics_machine" -eq 0 ]];then rdbms_installed[$stack_counter]=0;fi
    crs_installed[$stack_counter]=0
    stack_counter=$(expr $stack_counter + 1)
  done
  stack_counter=0
}

#this function is to check the CRS and RDBMS instance status in entire cluster.
#CRS check swill executed if CRS is and Database checks will be executed if 
#rDBMS instance is up and that too on individual node
func_stack_status ()
{
  echo -e "\nChecking Status of Oracle Software Stack - Clusterware, ASM, RDBMS\n"
  printf ". "

  mb_rdbms_stack_status

  #$READ -p "IS_SYSDBA=$IS_SYSDBA"
  echo "MULTIPLE_DATABASE = $multiple_db" >>$MASTERFIL
  stack_counter=0
  for stack in `cat $HOSTLIST`
  do
    qstack=$stack
    if [[ $olsnodes_ssh_disabled -eq 1 ]];
    then
      for mapping in ${hostmap[@]}
      do
        management_host=${mapping%%:*};
        client_host=${mapping#*:};
        if [ $stack = $management_host ]; then qstack=$client_host; qstack=${qstack%%.*}; fi
      done	
    fi

    printf ". "

    if [ $stack = $localnode ]
    then
      if [[ -e $EMHOMEVERSIONFIL && `grep -wic "agent_inst$" $EMHOMEVERSIONFIL` -gt 0 ]];then
      	filefirst=1;
        is_emagent_installed=1;
      	echo "${stack}.EMAGENT_INSTALLED = 1" >>$MASTERFIL
      	#emhome=`cat  $EMHOMEVERSIONFIL|grep -wi "agent_inst$"|cut -d':' -f2`
	if [ -n "$RAT_EMAGENT_HOME" ]
	then
		 emhome=$RAT_EMAGENT_HOME
	else
		 emhome=`cat $EMHOMEVERSIONFIL|grep -wi "agent_inst$"|cut -d ':' -f1|head -1`
	fi
	if [ -n "$RAT_EMAGENT_INST" ]
        then
                 EMAGENT_INST=$RAT_EMAGENT_INST
        else
                 EMAGENT_INST=`cat $EMHOMEVERSIONFIL|grep -wi "agent_inst$"|cut -d ':' -f2|head -1`
        fi
        echo "${stack}.EMAGENT_HOME = $emhome" >> $MASTERFIL
        echo "${stack}.EMAGENT_INST = $EMAGENT_INST" >> $MASTERFIL
      else
        is_emagent_installed=0;
      	filefirst=0
      fi

      if [ $filefirst -eq 0 ]
      then
        if [[ -e $EMHOMEVERSIONFIL2 && `grep -wic "agent_inst$" $EMHOMEVERSIONFIL2` -gt 0 ]];then
          is_emagent_installed=1;
          EMHOMEVERSIONFIL="$EMHOMEVERSIONFIL2";
      	  echo "${stack}.EMAGENT_INSTALLED = 1" >>$MASTERFIL
      	  #emhome=`cat  $EMHOMEVERSIONFIL|grep -wi "agent_inst$"|cut -d':' -f2`
        if [ -n "$RAT_EMAGENT_HOME" ]
        then
                 emhome=$RAT_EMAGENT_HOME
        else
                 emhome=`cat $EMHOMEVERSIONFIL|grep -wi "agent_inst$"|cut -d ':' -f1|head -1`
        fi
        if [ -n "$RAT_EMAGENT_INST" ]
        then
                 EMAGENT_INST=$RAT_EMAGENT_INST
        else
                 EMAGENT_INST=`cat $EMHOMEVERSIONFIL|grep -wi "agent_inst$"|cut -d ':' -f2|head -1`
        fi

          echo "${stack}.EMAGENT_HOME = $emhome" >> $MASTERFIL
          echo "${stack}.EMAGENT_INST = $EMAGENT_INST" >> $MASTERFIL
        else
          is_emagent_installed=0;
      	  echo "${stack}.EMAGENT_INSTALLED = 0" >>$MASTERFIL
      	  emhome="";
          EMAGENT_INST="";
          echo "${stack}.EMAGENT_HOME = $emhome" >> $MASTERFIL
          echo "${stack}.EMAGENT_INST = $EMAGENT_INST" >> $MASTERFIL
        fi
      fi

      if [ $is_windows -eq "1" ] ; then
        stack_check_crs=`grep -c OracleOHService $win_services`;
        stack_check_crsd=`grep -c OracleOHService $win_services`;
        if [ $stack_check_crs -gt "0" ] ; then stack_check_crs=3; fi
  	if [ $stack_check_crsd -gt "0" ] ; then stack_check_crsd=1; fi
      else
        stack_check_crs=`ps -ef|grep -ic "d.bin"`
	stack_check_crsd=`ps -ef |grep -ic "crsd\.bin"`
      fi

      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	OLD_OH=$ORACLE_HOME
	ORACLE_HOME=$CRS
	get_dbOwner
	ORACLE_HOME=$OLD_OH
        if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
          stack_check_crs_run=`su $dbOwner -c "$CRS/bin/crsctl status resource -t >/dev/null 2>&1";echo $?`
        else
          stack_check_crs_run=`su $dbOwner -c "$CRS/bin/crs_stat -t >/dev/null 2>&1";echo $?`
        fi
	cd $OLD_DIR
	unset OLD_DIR
      else
        if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
          stack_check_crs_run=`$CRS/bin/crsctl status resource -t >/dev/null 2>&1;echo $?`
        else
          stack_check_crs_run=`$CRS/bin/crs_stat -t  >/dev/null 2>&1;echo $?`
        fi
      fi

      #$READ -p "$stack_check_crs $stack_check_crs_run $CRS"
      printf ". "
      if [[ ${stack_check_crs} -ge 3 && $stack_check_crs_run -eq 0 ]]
      then
	if [[ -n "$crs112" && $crs112 -ge 1 ]]
	then
	  if [[ `uname -s` = "AIX"  || `uname -s` = "SunOS" ||  `uname -s` = "HP-UX" ]] 
	  then
	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	      OLD_OH=$ORACLE_HOME
	      ORACLE_HOME=$CRS
	      get_dbOwner
	      ORACLE_HOME=$OLD_OH
	      asm_inst_name_single=$(su $dbOwner -c "$CRS/bin/crs_stat|grep -iw asm|grep $qstack|cut -d. -f3")
	      cd $OLD_DIR
	      unset OLD_DIR
	    else
	      asm_inst_name_single=$($CRS/bin/crs_stat|grep -iw asm|grep $qstack|cut -d. -f3)
	    fi
	    stack_asm_sid[$stack_counter]=$(echo "+${asm_inst_name_single}")
	  else
	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	      OLD_OH=$ORACLE_HOME
	      ORACLE_HOME=$CRS
	      get_dbOwner
	      ORACLE_HOME=$OLD_OH
	      stack_asm_sid[$stack_counter]="+"`su $dbOwner -c "$CRS/bin/crs_stat|grep -wi -A 2 asm|grep $qstack|cut -d. -f3|grep -v $qstack"`
	      cd $OLD_DIR
	      unset OLD_DIR
	    else
	      stack_asm_sid[$stack_counter]="+"`$CRS/bin/crs_stat|grep -wi -A 2 asm|grep $qstack|cut -d. -f3|grep -v $qstack`
	    fi
	    if [ $is_windows -eq "0" ] ; then
	      stack_acfs_modules=$(/sbin/lsmod|grep -i -E 'oracleacfs|oracleoks|oracleadvm'|wc -l)
	    fi
	  fi
          if [[ $is_windows -eq "0" && "${stack_asm_sid[$stack_counter]}" != "$(ps -ef |grep asm_pmon|grep -v grep|$AWK 'BEGIN { FS = "_" } {print $NF}')" ]]
          then 
            stack_asm_sid[$stack_counter]=$(ps -ef |grep asm_pmon|grep -v grep|$AWK 'BEGIN { FS = "_" } {print $NF}')
          fi      
	  printf ". . . . "
	else
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    OLD_OH=$ORACLE_HOME
	    ORACLE_HOME=$CRS
	    get_dbOwner
	    ORACLE_HOME=$OLD_OH
            if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
	      stack_asm_home[$stack_counter]=`su $dbOwner -c "$CRS/bin/srvctl$BAT config asm |grep "ASM home:"|sed 's/ //g'|sed 's/ASMhome://g'"`
	      asm_home_path="${stack_asm_home[$stack_counter]}";
	      ASM_HOME="${stack_asm_home[$stack_counter]}";
	      stack_asm_sid[$stack_counter]="+ASM";
            else  
	      stack_asm_sid[$stack_counter]=`su $dbOwner -c "$CRS/bin/srvctl$BAT config asm -n $qstack |awk '{print \$1}'"`
	      stack_asm_home[$stack_counter]=`su $dbOwner -c "$CRS/bin/srvctl$BAT config asm -n $qstack |awk '{print \$2}'"`
            fi
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
            if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
	      stack_asm_home[$stack_counter]=`$CRS/bin/srvctl$BAT config asm |grep "ASM home:"|sed 's/ //g'|sed 's/ASMhome://g'`
	      asm_home_path="${stack_asm_home[$stack_counter]}";
	      ASM_HOME="${stack_asm_home[$stack_counter]}";
	      stack_asm_sid[$stack_counter]="+ASM";
            else  
	      stack_asm_sid[$stack_counter]=`$CRS/bin/srvctl$BAT config asm -n $qstack |awk '{print $1}'`
	      stack_asm_home[$stack_counter]=`$CRS/bin/srvctl$BAT config asm -n $qstack |awk '{print $2}'`
            fi
	  fi
	  printf ". . . . "
	fi
	save_crs
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  OLD_OH=$ORACLE_HOME
	  ORACLE_HOME=$CRS
	  get_dbOwner
	  ORACLE_HOME=$OLD_OH
	  stack_crs_version[$stack_counter]=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch|sed -n 's/.*\[//p'|sed 's/\]//g'"`
          if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
            stack_crs_version[$stack_counter]=`su $dbOwner -c "$CRS/bin/crsctl query has softwareversion|sed -n 's/.*\[//p'|sed 's/\]//g'"`
          fi 
	  cd $OLD_DIR
	  unset OLD_DIR
	else
	  stack_crs_version[$stack_counter]=`$CRS/bin/crsctl query $crs_version_switch|sed -n 's/.*\[//p'|sed 's/\]//g'`
          if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
            stack_crs_version[$stack_counter]=`$CRS/bin/crsctl query has softwareversion|sed -n 's/.*\[//p'|sed 's/\]//g'`
          fi 
	fi
	ret_crs
	
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  OLD_OH=$ORACLE_HOME
	  ORACLE_HOME=$CRS
	  get_dbOwner
	  ORACLE_HOME=$OLD_OH
	  if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
            stack_asm=`su $dbOwner -c "$CRS/bin/srvctl$BAT status asm |grep -ic \"is running on $qstack\""`
          else
            stack_asm=`su $dbOwner -c "$CRS/bin/srvctl$BAT status asm -n $qstack|grep -ic 'is running'"`
          fi
	  if [ $stack_asm -ge 1 ]
	  then
	    stack_asm_up[$stack_counter]=1
	    printf ". "
	    stack_acfs_drivers=$(su $dbOwner -c "$CRS/bin/crsctl stat res ora.registry.acfs -t|grep $qstack")
	    if [ $? -eq 0 ]; then stack_acfs_drivers_status=1;else stack_acfs_drivers_status=0;fi;
	    printf ". "
	    stack_acfs_registry=$(su $dbOwner -c "$CRS/bin/crsctl stat res ora.drivers.acfs -init -t|grep $qstack")
	    if [  $? -eq 0 ]; then stack_acfs_registry_status=1;else stack_registry_drivers_status=0;fi;
	    if [[ $stack_acfs_modules -ge 3 && $stack_acfs_drivers_status -eq 1 && $stack_acfs_registry_status -eq 1 ]]
	    then 
	      stack_acfs_up[$stack_counter]=1
	    else 
	      stack_acfs_up[$stack_counter]=0
	    fi
	    printf ". "
	  else
	    stack_asm_up[$stack_counter]=0
	    printf ". "
	  fi
	  cd $OLD_DIR
	  unset OLD_DIR
	else
	  if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
            stack_asm=`$CRS/bin/srvctl$BAT status asm |grep -ic "is running on $qstack"`
          else
            stack_asm=`$CRS/bin/srvctl$BAT status asm -n $qstack|grep -ic "is running"`
          fi
     	  #stack_asm=0
	  if [ $stack_asm -ge 1 ]
	  then
	    stack_asm_up[$stack_counter]=1
	    printf ". "
	    stack_acfs_drivers=$($CRS/bin/crsctl  stat res ora.registry.acfs -t|grep $qstack)
	    if [ $? -eq 0 ]; then stack_acfs_drivers_status=1;else stack_acfs_drivers_status=0;fi;
	    printf ". "
	    stack_acfs_registry=$($CRS/bin/crsctl  stat res ora.drivers.acfs -init -t|grep $qstack)
	    if [  $? -eq 0 ]; then stack_acfs_registry_status=1;else stack_registry_drivers_status=0;fi;
	    if [[ $stack_acfs_modules -ge 3 && $stack_acfs_drivers_status -eq 1 && $stack_acfs_registry_status -eq 1 ]]
	    then 
	      stack_acfs_up[$stack_counter]=1
	    else 
	      stack_acfs_up[$stack_counter]=0
	    fi
	    printf ". "
	  else
	    stack_asm_up[$stack_counter]=0
	    printf ". "
	  fi
	fi

        if [ ${stack_check_crsd} -eq 1 ] ; then 
 	  stack_crs_up[$stack_counter]=1
          crs_up=1
	else
	  stack_crs_up[$stack_counter]=0
	  crs_up=0
        fi 
	#if [ ${crs_installed[$stack_counter]} -eq 0 ]; then crs_installed[$stack_counter]=1;fi;
	printf ". "
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  OLD_OH=$ORACLE_HOME
	  ORACLE_HOME=$CRS
	  get_dbOwner
	  ORACLE_HOME=$OLD_OH
	  cluster_name=`su $dbOwner -c "$CRS/bin/cemutlo -n"`
	  cd $OLD_DIR
	  unset OLD_DIR
	else
	  cluster_name=`$CRS/bin/cemutlo -n`
	fi
      else
	stack_crs_up[$stack_counter]=0
	stack_asm_up[$stack_counter]=0
	printf ". "
	crs_up=0
      fi
      echo "${stack}.CRS_STATUS = ${stack_crs_up[$stack_counter]}" >>$MASTERFIL
      echo "${stack}.CRS_ACTIVE_VERSION = ${stack_crs_version[$stack_counter]}" >>$MASTERFIL
      echo "${stack}.ASM_STATUS = ${stack_asm_up[$stack_counter]}" >>$MASTERFIL
      echo "${stack}.ASM_INSTANCE = ${stack_asm_sid[$stack_counter]}" >>$MASTERFIL
      echo "${stack}.ASM_HOME = ${stack_asm_home[$stack_counter]}" >>$MASTERFIL
      echo "${stack}.ACFS_STATUS = ${stack_acfs_up[$stack_counter]}" >>$MASTERFIL
      if [[ -n "$multiple_db" &&  $multiple_db -eq 1 ]]
      then
	for db_name_to_check in "${mb_db_names[@]}"
	do
          stack_dbinst_up[$stack_counter]=""
          stack_dbinst_name[$stack_counter]=""
          stack_dbinst_version[$stack_counter]="" 
	  stack_status=$INPUTDIR/stack_status_${db_name_to_check}.out
	  if [ -f $stack_status ]
	  then  
	    stack_dbinst_up[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f2`
	    stack_dbinst_name[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f1`
	    stack_dbinst_version[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f3`
	    db_version=stack_dbinst_version[$stack_counter]
	    printf ". "
	  fi
	  if [ -z ${stack_dbinst_up[$stack_counter]} ]
	  then
	    stack_dbinst_up[$stack_counter]=0
	    db_up=0 
	    printf ". "
	  else
	    db_up=1
	    printf ". "
	  fi
	  stack_host[stack_counter]=$stack
	  printf ". "
	  echo "${stack}.${db_name_to_check}.INSTANCE_NAME = ${stack_dbinst_name[$stack_counter]}" >>$MASTERFIL
	  echo "${stack}.${db_name_to_check}.INSTANCE_MODE = ${stack_dbinst_up[$stack_counter]}" >>$MASTERFIL
	  echo "${stack}.${db_name_to_check}.INSTANCE_VERSION = ${stack_dbinst_version[$stack_counter]}" >>$MASTERFIL
	  printf ". "
	done
      else
	for db_name_to_check in "${mb_db_names[@]}"
	do
	  stack_status=$INPUTDIR/stack_status_${db_name_to_check}.out
	  if [ -f $stack_status ]
	  then
	    stack_dbinst_up[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f2`
	    stack_dbinst_name[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f1`
	    stack_dbinst_version[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f3`
	    db_version=stack_dbinst_version[$stack_counter]
	    printf ". "
	  fi  
	done 

	if [ -z ${stack_dbinst_up[$stack_counter]} ]
	then
	  stack_dbinst_up[$stack_counter]=0
	  db_up=0
	  printf ". "
	else
	  db_up=1
	  printf ". "
	fi 

	stack_host[stack_counter]=$stack
	printf ". "
	echo "${stack}.${db_name_to_check}.INSTANCE_NAME = ${stack_dbinst_name[$stack_counter]}" >>$MASTERFIL
	echo "${stack}.${db_name_to_check}.INSTANCE_MODE = ${stack_dbinst_up[$stack_counter]}" >>$MASTERFIL
	echo "${stack}.${db_name_to_check}.INSTANCE_VERSION = ${stack_dbinst_version[$stack_counter]}" >>$MASTERFIL
	printf ". "
      fi
   else
      if [ $is_windows -eq "0" ] ; then
        stack_check_crs=`$SSHELL $stack ps -ef|grep -ic "d.bin"`
        stack_check_crsd=`$SSHELL $stack ps -ef |grep -ic "crsd\.bin"`
      else
        stack_check_crs=`$SSHELL $stack "grep -c OracleOHService $RTEMPDIR/win_services.out"`;
        stack_check_crsd=`$SSHELL $stack "grep -c OracleOHService $RTEMPDIR/win_services.out"`;
        if [ $stack_check_crs -gt "0" ] ; then stack_check_crs=3; fi
  	if [ $stack_check_crsd -gt "0" ] ; then stack_check_crsd=1; fi
      fi

      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	OLD_OH=$ORACLE_HOME
	ORACLE_HOME=$CRS
	get_dbOwner
	ORACLE_HOME=$OLD_OH
        if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
          stack_check_crs_run=`$SSHELL $stack "cd \"$dbhome_dir\" 2>/dev/null; su $dbOwner -c \"$CRS/bin/crsctl status resource -t >/dev/null 2>&1\"";echo $?`
        else
          stack_check_crs_run=`$SSHELL $stack "cd \"$dbhome_dir\" 2>/dev/null; su $dbOwner -c \"$CRS/bin/crs_stat -t >/dev/null 2>&1\"";echo $?`
        fi
	cd $OLD_DIR
	unset OLD_DIR
      else
        if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
          stack_check_crs_run=`$SSHELL $stack $CRS/bin/crsctl status resource -t >/dev/null 2>&1;echo $?`
        else
          stack_check_crs_run=`$SSHELL $stack $CRS/bin/crs_stat -t  >/dev/null 2>&1;echo $?`
        fi
      fi
      #$READ -p "stack_check_crs_run=$stack_check_crs_run and stack_check_crs=$stack_check_crs"
      printf ". "
      stack_check_emagent=0;
      stack_check_emagent=`$SSHELL $stack " $bash_scr -c \"if [ -e $EMHOMEVERSIONFIL ]; then grep -wic \"agent_inst$\" $EMHOMEVERSIONFIL ;fi\""`;

      if [[ $stack_check_emagent -gt 0 ]];then
        filefirst=1;
        is_emagent_installed=1;
        echo "${stack}.EMAGENT_INSTALLED = 1" >>$MASTERFIL
        #emhome=`cat  $EMHOMEVERSIONFIL|grep -wi "agent_inst$"|cut -d':' -f2`
	if [ -n "$RAT_EMAGENT_HOME" ]
	then
		 emhome=$RAT_EMAGENT_HOME
	else
	 	#emhome=`cat $EMHOMEVERSIONFIL|grep -wi "agent_inst$"|cut - d':' -f1|head -1`
		emhome=`$SSHELL $stack "cat $EMHOMEVERSIONFIL|grep -wi "agent_inst$"|cut -d ':' -f1|head -1"`;
	fi
       if [ -n "$RAT_EMAGENT_INST" ]
        then
                 EMAGENT_INST=$RAT_EMAGENT_INST
        else
                 #EMAGENT_INST=`cat $EMHOMEVERSIONFIL|grep -wi "agent_inst$"|cut -d ':' -f2|head -1`
		EMAGENT_INST=`$SSHELL $stack "cat $EMHOMEVERSIONFIL|grep -wi "agent_inst$"|cut -d ':' -f2|head -1"`;
        fi
        echo "${stack}.EMAGENT_HOME = $emhome" >> $MASTERFIL
        echo "${stack}.EMAGENT_INST = $EMAGENT_INST" >> $MASTERFIL
      else
        is_emagent_installed=0;
        filefirst=0
      fi
      
      if [ $filefirst -eq 0 ]
      then
        stack_check_emagent=`$SSHELL $stack " $bash_scr -c \"if [ -e $EMHOMEVERSIONFIL2 ]; then grep -wic \"agent_inst$\" $EMHOMEVERSIONFIL2 ;fi\""`;
        if [[ $stack_check_emagent -gt 0 ]];then
          is_emagent_installed=1;
          EMHOMEVERSIONFIL="$EMHOMEVERSIONFIL2";
          echo "${stack}.EMAGENT_INSTALLED = 1" >>$MASTERFIL
          #emhome=`cat  $EMHOMEVERSIONFIL|grep -wi "agent_inst$"|cut -d':' -f2`
	  if [ -n "$RAT_EMAGENT_HOME" ]
	  then
		 emhome=$RAT_EMAGENT_HOME
	  else
		 #emhome=`cat $EMHOMEVERSIONFIL|grep -wi "agent_inst$"|cut -d ':' -f1|head -1`
		 emhome=`$SSHELL $stack "cat $EMHOMEVERSIONFIL|grep -wi "agent_inst$"|cut -d ':' -f1|head -1"`;
	  fi
        if [ -n "$RAT_EMAGENT_INST" ]
        then
                 EMAGENT_INST=$RAT_EMAGENT_INST
        else
#                 EMAGENT_INST=`cat $EMHOMEVERSIONFIL|grep -wi "agent_inst$"|cut -d ':' -f2|head -1`
 		 EMAGENT_INST=`$SSHELL $stack "cat $EMHOMEVERSIONFIL|grep -wi "agent_inst$"|cut -d ':' -f2|head -1"`;
        fi

          echo "${stack}.EMAGENT_HOME = $emhome" >> $MASTERFIL
          echo "${stack}.EMAGENT_INST = $EMAGENT_INST" >> $MASTERFIL
        else
          is_emagent_installed=0;
          echo "${stack}.EMAGENT_INSTALLED = 0" >>$MASTERFIL
          emhome="";
          EMAGENT_INST=""; 
          echo "${stack}.EMAGENT_HOME = $emhome" >> $MASTERFIL
          echo "${stack}.EMAGENT_INST = $EMAGENT_INST" >> $MASTERFIL
        fi
      fi

      if [[ ${stack_check_crs} -ge 3 && $stack_check_crs_run -eq 0 ]]
      then
	if [[ -n "$crs112" && $crs112 -ge 1 ]]
	then
	  if [[ `uname -s` = "AIX"  || `uname -s` = "SunOS" || `uname -s` = "HP-UX" ]] 
	  then
	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	      OLD_OH=$ORACLE_HOME
	      ORACLE_HOME=$CRS
	      get_dbOwner
	      ORACLE_HOME=$OLD_OH
	      asm_inst_name_single=$(su $dbOwner -c "$CRS/bin/crs_stat|grep -wi asm|grep $qstack|cut -d. -f3")		
	      cd $OLD_DIR
	      unset OLD_DIR	
	    else
	      asm_inst_name_single=$($CRS/bin/crs_stat|grep -wi asm|grep $qstack|cut -d. -f3)		
	      stack_asm_sid[$stack_counter]=$(echo "+${asm_inst_name_single}")
	    fi
	  else
	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	      OLD_OH=$ORACLE_HOME
	      ORACLE_HOME=$CRS
	      get_dbOwner
	      ORACLE_HOME=$OLD_OH
	      stack_asm_sid[$stack_counter]="+"`su $dbOwner -c "$CRS/bin/crs_stat|grep -wi -A 2 asm|grep $qstack|cut -d. -f3|tail -1"`
	      cd $OLD_DIR
	      unset OLD_DIR	
	    else
	      stack_asm_sid[$stack_counter]="+"`$CRS/bin/crs_stat|grep -wi -A 2 asm|grep $qstack|cut -d. -f3|tail -1`
	    fi
	    if [ $is_windows -eq "0" ] ; then
	      stack_acfs_modules=$($SSHELL $stack /sbin/lsmod|grep -i -E 'oracleacfs|oracleoks|oracleadvm'|wc -l)
	    fi
	  fi
          if [ $is_windows -eq "0" ] ; then
            ps_asm_sid=$($SSHELL $stack ps -ef |grep asm_pmon|grep -v grep|$AWK 'BEGIN { FS = "_" } {print $NF}')    
            if [ "${stack_asm_sid[$stack_counter]}" != "$ps_asm_sid" ]
            then 
              stack_asm_sid[$stack_counter]=$($SSHELL $qstack ps -ef |grep asm_pmon|grep -v grep|$AWK 'BEGIN { FS = "_" } {print $NF}')
            fi              
          fi              
	  printf ". . . "
	else
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    OLD_OH=$ORACLE_HOME
	    ORACLE_HOME=$CRS
	    get_dbOwner
	    ORACLE_HOME=$OLD_OH
	    if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
              stack_asm_home[$stack_counter]=`su $dbOwner -c "$CRS/bin/srvctl$BAT config asm |grep 'ASM home:'|sed 's/ //g'|sed 's/ASMhome://g'"`
	      ASM_HOME=${stack_asm_home[$stack_counter]};
              stack_asm_sid[$stack_counter]="+ASM";
            else
              stack_asm_sid[$stack_counter]=`su $dbOwner -c "$CRS/bin/srvctl$BAT config asm -n $qstack |awk '{print \$1}'"`
              stack_asm_home[$stack_counter]=`su $dbOwner -c "$CRS/bin/srvctl$BAT config asm -n $qstack |awk '{print \$2}'"`
            fi
	    cd $OLD_DIR
	    unset OLD_DIR	
	  else
	    if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
              stack_asm_home[$stack_counter]=`$CRS/bin/srvctl$BAT config asm |grep "ASM home:"|sed 's/ //g'|sed 's/ASMhome://g'`
	      ASM_HOME=${stack_asm_home[$stack_counter]};
              stack_asm_sid[$stack_counter]="+ASM";
            else
              stack_asm_sid[$stack_counter]=`$CRS/bin/srvctl$BAT config asm -n $qstack |awk '{print $1}'`
              stack_asm_home[$stack_counter]=`$CRS/bin/srvctl$BAT config asm -n $qstack |awk '{print $2}'`
            fi
	  fi

	  printf ". . . . "
	fi
	save_crs
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  OLD_OH=$ORACLE_HOME
	  ORACLE_HOME=$CRS
	  get_dbOwner
	  ORACLE_HOME=$OLD_OH
	  stack_crs_version[$stack_counter]=`$SSHELL $stack "cd \"$dbhome_dir\" 2>/dev/null; su $dbOwner -c \"$CRS/bin/crsctl query $crs_version_switch 2>/dev/null|sed -n 's/.*\[//p'|sed 's/\]//g'\""`
	  cd $OLD_DIR
	  unset OLD_DIR
	else
	  stack_crs_version[$stack_counter]=`$SSHELL $stack $CRS/bin/crsctl query $crs_version_switch|sed -n 's/.*\[//p'|sed 's/\]//g'`
	fi
	ret_crs

	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  OLD_OH=$ORACLE_HOME
	  ORACLE_HOME=$CRS
	  get_dbOwner
	  ORACLE_HOME=$OLD_OH
	  if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
            stack_asm=`su $dbOwner -c "$CRS/bin/srvctl$BAT status asm |grep -ic \"is running on $qstack\""`
	  else
	    stack_asm=`su $dbOwner -c "$CRS/bin/srvctl$BAT status asm -n $qstack|grep -ic 'is running'"`
	  fi
	   
	  printf ". "
	  if [ $stack_asm -ge 1 ]
	  then
	    stack_asm_up[$stack_counter]=1
	    printf ". "
	    stack_acfs_drivers=$($SSHELL $stack "cd \"$dbhome_dir\" 2>/dev/null; su $dbOwner -c \"$CRS/bin/crsctl stat res ora.registry.acfs -t 2>/dev/null|grep $qstack\"")
	    if [ `echo $?` -eq 0 ]; then stack_acfs_drivers_status=1;else stack_acfs_drivers_status=0;fi;
	    printf ". "
	    stack_acfs_registry=$(su $dbOwner -c "$CRS/bin/crsctl stat res ora.drivers.acfs -init -t|grep $qstack")
	    if [ `echo $?` -eq 0 ]; then stack_acfs_registry_status=1;else stack_registry_drivers_status=0;fi;
	    if [[ $stack_acfs_modules -ge 3 && $stack_acfs_drivers_status -eq 1 && $stack_acfs_registry_status -eq 1 ]]
	    then 
	      stack_acfs_up[$stack_counter]=1
	    else 
	      stack_acfs_up[$stack_counter]=0
	    fi
	    printf ". "
	  else
	    stack_asm_up[$stack_counter]=0
	    printf ". "
	  fi
	  
	  cd $OLD_DIR
	  unset OLD_DIR
	else
	  if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
            stack_asm=`$CRS/bin/srvctl$BAT status asm |grep -ic "is running on $qstack"`
	  else
	    stack_asm=`$CRS/bin/srvctl$BAT status asm -n $qstack|grep -ic "is running"`
	  fi
	   
	  printf ". "
	  if [ $stack_asm -ge 1 ]
	  then
	    stack_asm_up[$stack_counter]=1
	    printf ". "
	    stack_acfs_drivers=$($SSHELL $stack $CRS/bin/crsctl  stat res ora.registry.acfs -t|grep $qstack)
	    if [ `echo $?` -eq 0 ]; then stack_acfs_drivers_status=1;else stack_acfs_drivers_status=0;fi;
	    printf ". "
	    stack_acfs_registry=$($CRS/bin/crsctl  stat res ora.drivers.acfs -init -t|grep $qstack)
	    if [ `echo $?` -eq 0 ]; then stack_acfs_registry_status=1;else stack_registry_drivers_status=0;fi;
	    if [[ $stack_acfs_modules -ge 3 && $stack_acfs_drivers_status -eq 1 && $stack_acfs_registry_status -eq 1 ]]
	    then 
	      stack_acfs_up[$stack_counter]=1
	    else 
	      stack_acfs_up[$stack_counter]=0
	    fi
	    printf ". "
	  else
	    stack_asm_up[$stack_counter]=0
	    printf ". "
	  fi
	fi

	if [ ${stack_check_crsd} -eq 1 ] ; then
	  stack_crs_up[$stack_counter]=1
	else
	  stack_crs_up[$stack_counter]=0
	fi
	#if [ ${crs_installed[$stack_counter]} -eq 0 ]; then crs_installed[$stack_counter]=1;fi;
	printf ". "
      else
	stack_crs_up[$stack_counter]=0
	stack_asm_up[$stack_counter]=0
	printf ". "
      fi
      echo "${stack}.CRS_STATUS = ${stack_crs_up[$stack_counter]}" >>$MASTERFIL
      echo "${stack}.CRS_ACTIVE_VERSION = ${stack_crs_version[$stack_counter]}" >>$MASTERFIL
      echo "${stack}.ASM_STATUS = ${stack_asm_up[$stack_counter]}" >>$MASTERFIL
      echo "${stack}.ASM_INSTANCE = ${stack_asm_sid[$stack_counter]}" >>$MASTERFIL
      echo "${stack}.ASM_HOME = ${stack_asm_home[$stack_counter]}" >>$MASTERFIL
      echo "${stack}.ACFS_STATUS = ${stack_acfs_up[$stack_counter]}" >>$MASTERFIL

      if [[ -n "$multiple_db" && $multiple_db -eq 1 ]]
      then
	for db_name_to_check in "${mb_db_names[@]}"
	do
	  stack_status=$INPUTDIR/stack_status_${db_name_to_check}.out
          stack_dbinst_up[$stack_counter]=""
          stack_dbinst_name[$stack_counter]=""
          stack_dbinst_version[$stack_counter]="" 
	  if [  -f $stack_status ]
	  then
	    stack_dbinst_up[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f2`
	    local_db_inst=`grep -w $stack $stack_status|cut -d. -f2`
	    stack_dbinst_name[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f1`
	    stack_dbinst_version[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f3`
	    db_version=stack_dbinst_version[$stack_counter]
	    printf ". "
	  fi
	  if [ -z ${stack_dbinst_up[$stack_counter]} ]
	  then
	    stack_dbinst_up[$stack_counter]=0
	    printf ". "
	    db_up=0
	  else
	    db_up=1
	  fi
	  printf ". "
	  stack_host[stack_counter]=$stack
	  echo "${stack}.${db_name_to_check}.INSTANCE_NAME = ${stack_dbinst_name[$stack_counter]}" >>$MASTERFIL
	  echo "${stack}.${db_name_to_check}.INSTANCE_MODE = ${stack_dbinst_up[$stack_counter]}" >>$MASTERFIL
	  echo "${stack}.${db_name_to_check}.INSTANCE_VERSION = ${stack_dbinst_version[$stack_counter]}" >>$MASTERFIL
	  printf ". "
	done
      else
	for db_name_to_check in "${mb_db_names[@]}"
	do
	  stack_status=$INPUTDIR/stack_status_${db_name_to_check}.out
	  if [ -f $stack_status ]
	  then
	    stack_dbinst_up[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f2`
	    stack_dbinst_name[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f1`
	    stack_dbinst_version[$stack_counter]=`grep -w $stack $stack_status|cut -d'|' -f3`
	    db_version=stack_dbinst_version[$stack_counter]
	    printf ". "
	  fi
	done

	if [ -z ${stack_dbinst_up[$stack_counter]} ]
	then
	  stack_dbinst_up[$stack_counter]=0
	  db_up=0
	  printf ". "
	else
	  db_up=1
	  printf ". "
	fi
	printf ". "
	stack_host[stack_counter]=$stack
	echo "${stack}.${db_name_to_check}.INSTANCE_NAME = ${stack_dbinst_name[$stack_counter]}" >>$MASTERFIL
	echo "${stack}.${db_name_to_check}.INSTANCE_MODE = ${stack_dbinst_up[$stack_counter]}" >>$MASTERFIL
	echo "${stack}.${db_name_to_check}.INSTANCE_VERSION = ${stack_dbinst_version[$stack_counter]}" >>$MASTERFIL
	printf ". "
      fi
    fi 
    stack_counter=`expr $stack_counter + 1 `
    printf ". "
  done
 
  mb_db_counter_local=0
  for db_name_to_check in "${mb_db_names[@]}"
  do 
    echo "$db_name_to_check.CHECKED_NODE = ${mb_running_host[$mb_db_counter_local]}" >>$MASTERFIL
    mb_db_counter_local=$(expr $mb_db_counter_local + 1)
  done

  printf ". \n"
  #when this fuction is over, reinitialize stack_counter to use in Main for loop to trace each host.
  stack_counter=0
  #following function will add asm version to master file

  GetMachineRole
  is_this_db_machine "$localnode" "0"
  #if [ $db_machine_compute -eq 1 ];then func_cells_stack_status;fi;
  is_this_oda
  check_maa_scorecard
  check_hacheck
 
  #Following code is to override components found from environment and use passed from command line option"
  if [ -n "$options_components" ]
  then
    components=$options_components
  fi
  #this condition not to execute old code
  if [ 1 -eq 2 ]
  then
  #To execute only hacheck depending upon type of the database either RAC or SI
    if [[ "$components" = "HACHECK" || "$components" = "MAA" || "$components" = "MAA:HACHECK" || "$components" = "HACHECK:MAA" ]]; then only_hacheck_run=1;else only_hacheck_run=0;fi
    if [ `echo $options_components|grep -icw hacheck` -ge 1 ] 
    then
      if [ $single_instance_run -eq 0 ]
      then
        components=$(echo ${components}|sed 's/HACHECK//')
        components=$(echo ${components}:HACHECK)
      else
        components=$(echo ${components}|sed 's/HACHECK//')
        components=$(echo ${components}|sed 's/SIDBHACHECK//')
        components=$(echo ${components}:SIDBHACHECK)    
      fi
    fi
    if [ `echo $options_components|grep -icw hacheck` -ge 0 ]
    then
      if [[ "$TYP" = "-r" && $db_machine_compute -eq 0 ]]
      then 
        if [ $single_instance_run -eq 0 ]
        then
    	  components=$(echo ${components}:HACHECK)
	elif [[ $single_instance_run -eq 1 ]]
	then
	  components=$(echo ${components}:SIDBHACHECK)
	else
	  components=$(echo ${components}|sed 's/:HACHECK//')
	  components=$(echo ${components}|sed 's/:SIDBHACHECK//')
	fi
      fi
      if [ $upgrade_mode -eq 0 ]; then TYP=-a;fi
    fi

    if [ $only_hacheck_run -eq 1 ]; then TYP=-b;fi

    if [[ -n "$include_hacheck" && $include_hacheck -eq 0 ]]
    then
      components=$(echo ${components}|sed 's/:HACHECK//')
      components=$(echo ${components}|sed 's/:SIDBHACHECK//')
    fi
  fi

  #this is to change HACHECK to SIDBHACHECK for single instance run
  if [[ `echo $options_components|grep -icw hacheck` -ge 1 && $single_instance_run -eq 1 ]]
  then
    components=$(echo ${components}|sed 's/HACHECK//')
    components=$(echo ${components}|sed 's/SIDBHACHECK//')
    components=$(echo ${components}:SIDBHACHECK)
  fi             
  if [ -z "$components" ]
  then
    echo -e "\n\n${RED}Component is empty.\n\n${program_name} is exiting...${NORM}"
    exit 1
  fi
  final_components=$components
  #$READ -p "final_components=$final_components"
  #if [ -n "$options_components" ]; then echo "${localnode}.COMPONENTS = $components" >>$MASTERFIL;fi
  #commented following function here and will call after asking root password because is_this_db_machine will be called once again
  #write_db_machine_info_to_envfile $localnode
  if [ $upgrade_mode -gt 0 ]; then echo "UPGRADE_MODE = $upgrade_mode" >>$MASTERFIL;fi
  #$READ -p "COMPONENTS = $components TYPE=$TYP"
}

# Format value in $l_version from 112030 to 11.2.0.3.0
format_l_version()
{
  if [ -z "$1" ]
  then
    l_version=$(echo $l_version | sed 's/[0-9]/&./g' | sed 's/\.//' | sed 's/.$//')
  else # For exalogic version is like 1.0.0.2
    l_version=$(echo $l_version | sed 's/[0-9]/&./g' | sed 's/.$//')
  fi
}

func_print_homes()
{
  stk_line_header_h="${stk_line_header}--------------------------"
  echo -e "\n\n${stk_line_header_h}" | tee -a $OUTPUTDIR/installed_components.out
  echo -e "                                       Installed components summary   $NORM                          "| tee -a $OUTPUTDIR/installed_components.out
  echo $stk_line_header_h | tee -a $OUTPUTDIR/installed_components.out
  #printf "%-11s " "$stk_host_header" | tee -a $OUTPUTDIR/installed_components.out
  printf "%-40s " "GI_HOME" | tee -a $OUTPUTDIR/installed_components.out
  printf "%-60s " "ORACLE_HOME" | tee -a $OUTPUTDIR/installed_components.out
  printf "%-30s\n" "Database Names" | tee -a $OUTPUTDIR/installed_components.out
  echo $stk_line_header_h | tee -a $OUTPUTDIR/installed_components.out
  #for node in `cat $HOSTLIST`
  #do
  node=$localnode
  crs_active_version=`grep "$node.CRS_ACTIVE_VERSION" $MASTERFIL |awk '{print $3}'`
  rm -f $OUTPUTDIR/mb_db_tmp.out
  mb_db_counter=0
  for db_name_to_check in "${mb_db_names[@]}"
  do
    #l_version=$(grep "${mb_oracle_homes[$mb_db_counter]}" $OUTPUTDIR/mb_db_homes_versions_distinct.out|cut -d'|' -f2)
    l_version=$(grep "${mb_oracle_homes[$mb_db_counter]}" $OUTPUTDIR/mb_db_homes_distinct.out|cut -d'|' -f2 |sort -u | head -1)
    format_l_version
    oh_version=$l_version
    running_instance=`grep "$node.$db_name_to_check.INSTANCE_NAME" $MASTERFIL |awk '{print $3}'`
    echo "${mb_oracle_homes[$mb_db_counter]}|${oh_version}|$db_name_to_check|$running_instance" >> $OUTPUTDIR/mb_db_tmp.out
    mb_db_counter=$(expr $mb_db_counter + 1)
  done

  #printf "%-11s " $node;
  #printf "%-40s " "$CRS - $crs_active_version";
  first_time_print=0
  mb_db_counter=0
  if  [ -e $OUTPUTDIR/mb_db_tmp.out ]
  then
    for mb_oh_name in `cut -d'|' -f1  $OUTPUTDIR/mb_db_tmp.out |sort -u`
    do
      oh_version=$(grep "$mb_oh_name" $OUTPUTDIR/mb_db_tmp.out |cut -d'|' -f2|sort -u)
      if [ $first_time_print -eq 0 ]
      then
        #printf "%-11s " $node| tee -a $OUTPUTDIR/installed_components.out
        printf "%-40s " "$CRS - $crs_active_version" | tee -a $OUTPUTDIR/installed_components.out
        #printf "%-11s " "";
        #printf "%-40s " "";
      else
        first_time_print=0
      fi
      printf "%-60s " "${mb_oh_name} - ${oh_version}" | tee -a $OUTPUTDIR/installed_components.out
      running_db_line=""
      for running_db in `grep "$mb_oh_name" $OUTPUTDIR/mb_db_tmp.out |cut -d'|' -f3|sort -u`
      do
        running_db_line="$running_db $running_db_line"
      done # Finished printing db info for a OH
      mb_db_counter=$(expr $mb_db_counter + 1)
      printf "%-30s\n" "$running_db_line" | tee -a $OUTPUTDIR/installed_components.out
    done # Finished printing all homes
    echo $stk_line_header_h | tee -a $OUTPUTDIR/installed_components.out
  fi
  mb_db_counter=0
}

func_print_homes_tree()
{
  echo -e "\n\n${stk_line_header}"
  echo -e "                                       Installed components summary   $NORM                          "
  echo $stk_line_header
  for node in `cat $HOSTLIST`
  do
    crs_active_version=`grep "$node.CRS_ACTIVE_VERSION" $MASTERFIL |awk '{print $3}'`
    echo -e "Host : $node\n" | tee -a $OUTPUTDIR/installed_components.out
    echo -e "  |-- GI_HOME - Version : $CRS - $crs_active_version\n" | tee -a $OUTPUTDIR/installed_components.out
    rm -f $OUTPUTDIR/mb_db_tmp.out
    mb_db_counter=0
    for db_name_to_check in "${mb_db_names[@]}"
    do
      l_version=$(grep "${mb_oracle_homes[$mb_db_counter]}" $OUTPUTDIR/mb_db_homes_versions_distinct.out|cut -d'|' -f2)
      format_l_version
      oh_version=$l_version
      running_instance=`grep "$node.$db_name_to_check.INSTANCE_NAME" $MASTERFIL |awk '{print $3}'`
      echo "${mb_oracle_homes[$mb_db_counter]}|${oh_version}|$db_name_to_check|$running_instance" >> $OUTPUTDIR/mb_db_tmp.out
      mb_db_counter=$(expr $mb_db_counter + 1)
    done

    mb_db_counter=0
    if  [ -e $OUTPUTDIR/mb_db_tmp.out ]
    then
      for mb_oh_name in `cut -d'|' -f1  $OUTPUTDIR/mb_db_tmp.out |sort -u`
      do
        oh_version=$(grep "$mb_oh_name" $OUTPUTDIR/mb_db_tmp.out |cut -d'|' -f2|sort -u)
        echo -e "    |-- ORACLE_HOME - Version : ${mb_oh_name} - ${oh_version}\n" | tee -a $OUTPUTDIR/installed_components.out 
        for running_db in `grep "$mb_oh_name" $OUTPUTDIR/mb_db_tmp.out |cut -d'|' -f3|sort -u`
        do
          echo -e "      |-- Database Name : $running_db" | tee -a $OUTPUTDIR/installed_components.out
          running_instance=$(grep "$mb_oh_name|$oh_version|$running_db|" $OUTPUTDIR/mb_db_tmp.out |cut -d'|' -f4)
          if [ -n "$running_instance" ]
          then
            echo "        |-- Instance Name: $running_instance" | tee -a $OUTPUTDIR/installed_components.out
          fi
          echo -e ""| tee -a $OUTPUTDIR/installed_components.out
        done # Finished printing db info for a OH
        mb_db_counter=$(expr $mb_db_counter + 1)
      done # Finished printing all homes
    fi
    echo -e "\n"| tee -a $OUTPUTDIR/installed_components.out
  done # Finished all nodes
  echo $stk_line_header
  mb_db_counter=0
}

func_stack_print ()
{
  offline_counter=0
  for node in `cat $HOSTLIST`
  do
    crs_installed[$offline_counter]=`grep -i "$node.CRS_INSTALLED" $MASTERFIL |awk '{print $3}'`
    rdbms_installed[$offline_counter]=`grep -i "$node.RDBMS_INSTALLED" $MASTERFIL |awk '{print $3}'`
    asm_installed[$offline_counter]=`grep -i "$node.ASM_INSTALLED" $MASTERFIL |awk '{print $3}'`
    stack_crs_up[$offline_counter]=`grep -i "$node.CRS_STATUS" $MASTERFIL|awk '{print $3}'`
    stack_asm_up[$offline_counter]=`grep -i "$node.ASM_STATUS" $MASTERFIL|awk '{print $3}'`
    stack_asm_sid[$offline_counter]=`grep -i "$node.ASM_INSTANCE" $MASTERFIL|awk '{print $3}'`
    stack_asm_home[$offline_counter]=`grep -i "$node.ASM_HOME" $MASTERFIL|awk '{print $3}'`
    stack_acfs_up[$offline_counter]=`grep -i "$node.ACFS_STATUS" $MASTERFIL|awk '{print $3}'`
    if [[ -n "$multiple_db" && $multiple_db -eq 1 ]] 
    then
      db_status_counter=0
      mb_db_counter_local=0
      #added uniq not to display same instance names of container instance in case of pdbs are found 
      stack_db_instances[$offline_counter]=`grep -i "$node" $MASTERFIL|grep INSTANCE_NAME|awk '{print $3}'|sort|uniq`
      #echo "instances on $node ${stack_db_instances[$offline_counter]}"

      for db_name_to_check in "${mb_db_names[@]}"
      do
        if [[ $node = ${mb_running_host[$mb_db_counter_local]} ]] # && ! -z "`grep -i $node.${db_name_to_check}.INSTANCE_MODE  $MASTERFIL |awk '{print $3}'`" ]] 
        then #remote_database_code
    	  stack_db_status[$mb_db_counter_local]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
    	  stack_local_db_inst[$mb_db_counter_local]=`grep -i "$node.${db_name_to_check}.INSTANCE_NAME" $MASTERFIL|awk '{print $3}'` 
    	  #stack_db_name[$db_status_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
          #echo "$db_name_to_check instance is  ${stack_local_db_inst[$db_status_counter]}"
	  db_status_counter=$(expr $db_status_counter + 1)
	fi 
        mb_db_counter_local=$(expr $mb_db_counter_local + 1)
      done
      db_status_counter=0
      mb_db_counter_local=0
    else
      stack_dbinst_name[$offline_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_NAME" $MASTERFIL|awk '{print $3}'`
      #if [ $node = $localnode ]
      #if [ ! -z "${stack_dbinst_name[$offline_counter]}" && `grep -ic "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL` -gt 0 ]]
      if [[ -n "${mb_running_host[0]}" && $node = ${mb_running_host[0]} ]]
      then 
        stack_db_status[$db_status_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
      else
        #added this else part to avoid below error when no database is running on local node and asm is up
        #./exachk: line 13666: [: too many arguments
        stack_db_status[$db_status_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
        #$READ -p " stack_db_status=${stack_db_status[$db_status_counter]}"
      fi;
      stack_dbinst_up[$offline_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
    fi
    offline_counter=`expr $offline_counter + 1`  
  done

  offline_counter=0
  stk_line_header="-------------------------------------------------------------------------------------------------------"
  r="-----------------------------------------------------------------------------------"
  stk_host_header="Host Name"
  stk_crs_installed_header="CRS Installed"
  stk_asm_installed_header="ASM HOME"
  stk_rdbms_installed_header="RDBMS Installed"
  stk_crs_header="CRS UP"
  stk_asm_header="ASM UP"
  stk_rdbms_header="RDBMS UP"
  stck_dbinst_name="DB Instance Name"
  stk_status_no="No"
  stk_status_yes="Yes"
  stk_status_na="N/A"

  echo $stk_line_header
  #echo -e "                                   $BLINK $BOLD Oracle Stack Status  $NORM                          "
  echo -e "                                                 Oracle Stack Status  $NORM                          "
  echo $stk_line_header
  echo $stk_host_header|awk '{printf "%-11s",$stk_host_header}'
  echo $stk_crs_installed_header|awk '{printf "%-15s",$stk_crs_installed_header}'

  if [ $gi112 -eq 0 ] ; then echo $stk_asm_installed_header|awk '{printf "%-15s",$stk_asm_installed_header}'; fi

  echo $stk_rdbms_installed_header|awk '{printf "%-17s",$stk_rdbms_installed_header}'
  echo $stk_crs_header|awk '{printf "%-10s",$stk_crs_header}'
  echo $stk_asm_header|awk '{printf "%-10s",$stk_asm_header}'
  echo $stk_rdbms_header|awk '{printf "%-10s",$stk_rdbms_header}'
  echo $stck_dbinst_name|awk '{printf "%-15s\n",$stk_rdbms_header}'
  echo $stk_line_header

  for stk in `cat $HOSTLIST`
  do
    echo $stk|awk '{printf "%-11s",$stk}'
    if [[ -n "${crs_installed[$offline_counter]}" && ${crs_installed[$offline_counter]} -eq 1 ]]
    then
      echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-30s",$stk_status_yes}'
    else
      echo -e $RED $stk_status_no $NORM|awk '{printf "%-30s",$stk_status_no}'
    fi
    if [ $gi112 -eq 0 ]
    then
      if [[ -n "${asm_installed[$offline_counter]}" && ${asm_installed[$offline_counter]} -eq 1 ]]
      then
        echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-30s",$stk_status_yes}'
      else
        echo -e $RED $stk_status_no $NORM|awk '{printf "%-30s",$stk_status_no}'
      fi
    #else
    #  echo -e $BLUE "N/A" $NORM|awk '{printf "%-30s",$stk_status_no}'
    fi

    if [ ${rdbms_installed[$offline_counter]} -eq 0 ]
    then
      echo -e $RED $stk_status_no $NORM|awk '{printf "%-30s",$stk_status_no}'
    else
      echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-30s",$stk_status_yes}'
    fi
    if [ ${stack_crs_up[$offline_counter]} -eq 0 ]
    then
      echo -e $RED $stk_status_no $NORM|awk '{printf "%-25s",$stk_status_no}'
    else
      echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-25s",$stk_status_yes}'
    fi
    if [ ${stack_asm_up[$offline_counter]} -eq 0 ]
    then
      echo -e $RED $stk_status_no $NORM|awk '{printf "%-23s",$stk_status_no}'
    else
      echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-23s",$stk_status_yes}'
    fi
    if [[ ${stack_dbinst_up[$offline_counter]} -eq 0 && $multiple_db -eq 0 ]]
    then
      echo -e $RED $stk_status_no $NORM|awk '{printf "%-23s",$stk_status_no}'
    else
      echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-23s",$stk_status_yes}'
    fi
    if [[ -n "$multiple_db" && $multiple_db -eq 0 ]]
    then
      if [ ${stack_dbinst_up[$offline_counter]} -eq 1 ]
      then
        stk_inst_name=${stack_dbinst_name[$offline_counter]}
        echo -e $GREEN ${stack_dbinst_name[$offline_counter]} $NORM|awk '{printf "%-25s\n",$stk_inst_name}'
      else
        stk_inst_name=${stack_dbinst_name[$offline_counter]}
   	echo -e $GREEN ${stack_dbinst_name[$offline_counter]} $NORM|awk '{printf "%-25s\n",$stk_inst_name}'
      fi
    else
      #if [ ${stack_db_status[$offline_counter]} -ne 0 ]
      if [[ -n "${stack_db_status[$offline_counter]}" && ${stack_db_status[$offline_counter]} -ne -1 ]]
      then
        stk_inst_name=${stack_db_instances[$offline_counter]}
   	echo -e $GREEN ${stack_db_instances[$offline_counter]} $NORM|awk '{printf "%-25s\n",$stk_inst_name}'
      else
        stk_inst_name=${stack_db_instances[$offline_counter]}
   	echo -e $GREEN ${stack_db_instances[$offline_counter]} $NORM|awk '{printf "%-25s\n",$stk_inst_name}'
      fi
      #echo -e "\n"
    fi
    offline_counter=`expr $offline_counter + 1`
  done
  offline_counter=0
  echo $stk_line_header
}

func_stack_print_aix ()
{
  offline_counter=0
  for node in `cat $HOSTLIST`
  do
    crs_installed[$offline_counter]=`grep -i "$node.CRS_INSTALLED" $MASTERFIL |awk '{print $3}'`
    rdbms_installed[$offline_counter]=`grep -i "$node.RDBMS_INSTALLED" $MASTERFIL |awk '{print $3}'`
    asm_installed[$offline_counter]=`grep -i "$node.ASM_INSTALLED" $MASTERFIL |awk '{print $3}'`
    stack_crs_up[$offline_counter]=`grep -i "$node.CRS_STATUS" $MASTERFIL|awk '{print $3}'`
    stack_asm_up[$offline_counter]=`grep -i "$node.ASM_STATUS" $MASTERFIL|awk '{print $3}'`
    stack_asm_sid[$offline_counter]=`grep -i "$node.ASM_INSTANCE" $MASTERFIL|awk '{print $3}'`
    stack_asm_home[$offline_counter]=`grep -i "$node.ASM_HOME" $MASTERFIL|awk '{print $3}'`
    stack_acfs_up[$offline_counter]=`grep -i "$node.ACFS_STATUS" $MASTERFIL|awk '{print $3}'`

    if [ $multiple_db -eq 1 ]
    then
      db_status_counter=0
      mb_db_counter_local=0
      #added uniq not to display same instance names of container instance in case of pdbs are found 
      stack_db_instances[$offline_counter]=`grep -i "$node" $MASTERFIL|grep INSTANCE_NAME|awk '{print $3}'|sort|uniq`
      #echo "instances on $node ${stack_db_instances[$offline_counter]}"
      for db_name_to_check in "${mb_db_names[@]}"
      do
        if [ $node = ${mb_running_host[$mb_db_counter_local]} ]
        then
          stack_db_status[$mb_db_counter_local]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
          stack_local_db_inst[$mb_db_counter_local]=`grep -i "$node.${db_name_to_check}.INSTANCE_NAME" $MASTERFIL|awk '{print $3}'`
          #stack_db_name[$db_status_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
          #echo "$db_name_to_check instance is  ${stack_local_db_inst[$db_status_counter]}"
          db_status_counter=$(expr $db_status_counter + 1)
        fi
        mb_db_counter_local=$(expr $mb_db_counter_local + 1)
      done
      db_status_counter=0
      mb_db_counter_local=0
    else
      stack_dbinst_name[$offline_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_NAME" $MASTERFIL|awk '{print $3}'`
      if [ "$node" = "${mb_running_host[0]}" ]
      then
        stack_db_status[$db_status_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
        #$READ -p " stack_db_status=${stack_db_status[$db_status_counter]}"
      fi;
      stack_dbinst_up[$offline_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
    fi
    #stack_dbinst_up[$offline_counter]=`grep -i "$node.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
    #stack_dbinst_name[$offline_counter]=`grep -i "$node.INSTANCE_NAME" $MASTERFIL|awk '{print $3}'`
    offline_counter=`expr $offline_counter + 1`
  done

  offline_counter=0
  stk_line_header="-------------------------------------------------------------------------------------------------------"
  r="-----------------------------------------------------------------------------------"
  stk_host_header="Host Name"
  stk_crs_installed_header="CRS Installed"
  stk_asm_installed_header="ASM HOME"
  stk_rdbms_installed_header="RDBMS Installed"
  stk_crs_header="CRS UP"
  stk_asm_header="ASM UP"
  stk_rdbms_header="RDBMS UP"
  stck_dbinst_name="DB Instance Name"
  stk_status_no="No"
  stk_status_yes="Yes"
  stk_status_na="N/A"

  echo $stk_line_header
  #echo -e "                                   $BLINK $BOLD Oracle Stack Status  $NORM                          "
  echo -e "                                                 Oracle Stack Status  $NORM                          "
  echo $stk_line_header
  echo $stk_host_header|awk 'BEGIN { FS = "," } ;{printf "%-11s",$1}'
  echo $stk_crs_installed_header|awk 'BEGIN { FS = "," } ;{printf "%-15s",$1}'

  if [ $gi112 -eq 0 ]; then echo $stk_asm_installed_header|awk 'BEGIN { FS = "," } ;{printf "%-15s",$1}'; fi

  echo $stk_rdbms_installed_header|awk 'BEGIN { FS = "," } ;{printf "%-17s",$1}'
  echo $stk_crs_header|awk 'BEGIN { FS = "," } ;{printf "%-10s",$1}'
  echo $stk_asm_header|awk 'BEGIN { FS = "," } ;{printf "%-10s",$1}'
  echo $stk_rdbms_header|awk 'BEGIN { FS = "," } ;{printf "%-10s",$1}'
  echo $stck_dbinst_name|awk 'BEGIN { FS = "," } ;{printf "%-15s\n",$1}'
  echo $stk_line_header

  for stk in `cat $HOSTLIST`
  do
    echo $stk|awk 'BEGIN { FS = "," } ;{printf "%-11s",$1}'
    if [ ${crs_installed[$offline_counter]} -eq 0 ]
    then
      echo -e $RED $stk_status_no $NORM|awk '{printf "%-15s",$2}'
    else
      echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-15s",$2}'
    fi
    if [ $gi112 -eq 0 ]
    then
      if [[ -n "${asm_installed[$offline_counter]}" && ${asm_installed[$offline_counter]} -eq 1 ]]
      then
        echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-15s",$2}'
      else
        echo -e $RED $stk_status_no $NORM|awk '{printf "%-15s",$2}'
      fi
    #else
    #  echo -e $BLUE "N/A" $NORM|awk '{printf "%-15s",$2}'
    fi

    if [ ${rdbms_installed[$offline_counter]} -eq 0 ]
    then
      echo -e $RED $stk_status_no $NORM|awk '{printf "%-17s",$2}'
    else
      echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-17s",$2}'
    fi
    if [ ${stack_crs_up[$offline_counter]} -eq 0 ]
    then
      echo -e $RED $stk_status_no $NORM|awk '{printf "%-10s",$2}'
    else
      echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-10s",$2}'
    fi
    if [ ${stack_asm_up[$offline_counter]} -eq 0 ]
    then
      echo -e $RED $stk_status_no $NORM|awk '{printf "%-10s",$2}'
    else
      echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-10s",$2}'
    fi
    if [[ ${stack_dbinst_up[$offline_counter]} -eq 0 && $multiple_db -eq 0 ]]
    then
      echo -e $RED $stk_status_no $NORM|awk '{printf "%-10s",$2}'
    else
      echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-10s",$2}'
    fi
    if [ $multiple_db -eq 0 ]
    then
      if [ ${stack_dbinst_up[$offline_counter]} -eq 1 ]
      then
        stk_inst_name=${stack_dbinst_name[$offline_counter]}
        echo -e  ${stk_inst_name}|awk 'BEGIN { FS = "\n" } ;{printf "%-25s\n",$1}'
      else
        stk_inst_name=${stack_dbinst_name[$offline_counter]}
        echo -e ${stk_inst_name}|awk 'BEGIN { FS = "\n" } ;{printf "%-25s\n",$1}'
      fi
    else
      if [[ -n "$${stack_db_status[$offline_counter]}" && ${stack_db_status[$offline_counter]} -ne 0 ]]
      then
        stk_inst_name=${stack_db_instances[$offline_counter]}
        echo -e ${stk_inst_name}|awk 'BEGIN { FS = "\n" } ;{printf "%-25s\n",$1}'
      else
        stk_inst_name=${stack_db_instances[$offline_counter]}
        echo -e ${stk_inst_name}|awk 'BEGIN { FS = "\n" } ;{printf "%-25s\n",$1}'
      fi
    fi
    offline_counter=`expr $offline_counter + 1`
  done
  offline_counter=0
  echo $stk_line_header
}

func_cells_stack_status ()
{
  cell_counter=0
  for cell_ip in `cat /etc/oracle/cell/network-config/cellip.ora |cut -d\" -f2`
  do
    cell_host[$cell_counter]=$(ssh $cell_ip hostname -s)
    cell_cellsrv[$cell_counter]=$(ssh $cellip su - celladmin "cellcli -e \"list cell attributes cellsrvStatus\"|grep -wc \"running\"")
    cell_msstatus[$cell_counter]=$(ssh $cellip su - celladmin "cellcli -e \"list cell attributes msStatus\"|grep -wc \"running\"")
    cell_rsstatus[$cell_counter]=$(ssh $cellip su - celladmin "cellcli -e \"list cell attributes rsStatus\"|grep -wc \"running\"")
    echo $cell_host $cell_cellsrv $cell_msstatus $cell_rsstatus
  done  
}

#this function will check space for two locations
#1.Current location from where tool will run
#2. $TMPDIR because this tool uses tmp to for temporary files movement among cluster nodes
func_check_space()
{
  min_curr_space=102400
  #min_curr_space=137758049
  min_tmp_space=20480
  #min_tmp_space=1377678890000
  curr_location=$CHECKHOME
  tmp_location=$TMPDIR
  space_status=0
  space_pass_msg=""
  space_fail_msg=""

  local_tmp_out_space_status=0    
  remote_tmp_out_space_status=0    
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then tmp_out_location=$RAT_TMP_OUTPUT; fi

  for space in `cat $HOSTLIST`
  do
    if [ $space = $localnode ]
    then
      if [ `uname -s` = "HP-UX" ] ; then
        space_curr_location=`df -k $curr_location| grep free |awk '{print $1}'`
        space_tmp_location=`df -k $tmp_location| grep free |awk '{print $1}'`
        if [[ -n "$tmp_out_location" ]]; then space_tmp_out_location=`df -k $tmp_out_location| grep free |awk '{print $1}'`; fi
      else
        awk_col=`df -k  $curr_location|grep -iv "avail" | awk '{ print $4}'|grep -c "%"`
        awk_col_tmp=`df -k  $tmp_location|grep -iv "avail" | awk '{ print $4}'|grep -c "%"`
        if [[ -n "$tmp_out_location" ]]; then awk_col_tmp_out=`df -k  $tmp_out_location|grep -iv "avail" | awk '{ print $4}'|grep -c "%"`; fi
        if [ $awk_col  -gt 0 ]
        then
 	  space_curr_location=`df -k $curr_location| grep -iv "avail" | awk '{ print $3}'|tail -1`  
        else
 	  space_curr_location=`df -k $curr_location| grep -iv "avail" | awk '{ print $4}'`
        fi 
        if [ $awk_col_tmp  -gt 0 ]
        then
 	  space_tmp_location=`df -k $tmp_location |grep -iv "avail" | awk '{ print $3}'|tail -1 `  
        else
 	  space_tmp_location=`df -k $tmp_location |grep -iv "avail" | awk '{ print $4}'`
        fi 
        if [[ -n "$tmp_out_location" ]]; then
          if [ $awk_col_tmp_out  -gt 0 ]
          then
 	    space_tmp_out_location=`df -k $tmp_out_location |grep -iv "avail" | awk '{ print $3}'|tail -1 `  
          else
 	    space_tmp_out_location=`df -k $tmp_out_location |grep -iv "avail" | awk '{ print $4}'`
          fi 
	fi
      fi

      if [ $min_curr_space -lt $space_curr_location ]
      then
        space_pass_msg="Space available on $space at $curr_location is $space_curr_location KB"
        curr_loc_space_status=0
      else
        space_fail_msg="${RED}Space available on $space at $curr_location is $space_curr_location KB and required space is $min_curr_space KB $NORM"
        curr_loc_space_status=1
      fi
      #$READ -p "space_pass_msg =$space_pass_msg and space_fail_msg =$space_fail_msg"
      if [ $min_tmp_space -lt $space_tmp_location ]
      then
        space_pass_msg="$space_pass_msg \nSpace available on $space at $tmp_location is $space_tmp_location KB"
        local_tmp_space_status=0
      else
        space_fail_msg="$space_fail_msg $RED \nSpace available on $space at $tmp_location is $space_tmp_location KB and required space is $min_tmp_space KB $NORM "
        local_tmp_space_status=1
      fi
      if [[ -n "$tmp_out_location" ]]; then
        if [ $min_tmp_space -lt $space_tmp_out_location ]
        then
          space_pass_msg="$space_pass_msg \nSpace available on $space at $tmp_out_location is $space_tmp_out_location KB"
          local_tmp_out_space_status=0
        else
          space_fail_msg="$space_fail_msg $RED \nSpace available on $space at $tmp_out_location is $space_tmp_out_location KB and required space is $min_tmp_space KB $NORM "
          local_tmp_out_space_status=1
        fi
      fi
      #$READ -p "space_curr_location=$space_curr_location space_tmp_location=$space_tmp_location min_curr_space=$min_curr_space and min_tmp_space=$min_tmp_space"
    else
      if [ `uname -s` = "HP-UX" ] ; then
        space_tmp_location=`$SSHELL $space df -k $tmp_location| grep free |awk '{print $1}'`
	if [[ -n "$tmp_out_location" ]]; then space_tmp_out_location=`$SSHELL $space df -k $tmp_out_location 2>/dev/null| grep free |awk '{print $1}'`; fi
      else
        awk_col_tmp=`$SSHELL $space df -k  $tmp_location 2>/dev/null|grep -iv "avail" | awk '{ print $4}'|grep -c "%"`
	if [[ -n "$tmp_out_location" ]]; then awk_col_tmp_out=`$SSHELL $space df -k  $tmp_out_location 2>/dev/null|grep -iv "avail" | awk '{ print $4}'|grep -c "%"`; fi
        if [ $awk_col_tmp  -gt 0 ]
        then
 	  space_tmp_location=`$SSHELL $space df -k $tmp_location 2>/dev/null |grep -iv "avail" | awk '{ print $3}'|tail -1`  
        else
 	  space_tmp_location=`$SSHELL $space df -k $tmp_location 2>/dev/null|grep -iv "avail" | awk '{ print $4}'`
        fi 
	if [[ -n "$tmp_out_location" ]]; then
	  if [ $awk_col_tmp_out -gt 0 ]
	  then
 	    space_tmp_out_location=`$SSHELL $space df -k $tmp_out_location 2>/dev/null|grep -iv "avail" | awk '{ print $3}'|tail -1`  
	  else
 	    space_tmp_out_location=`$SSHELL $space df -k $tmp_out_location 2>/dev/null|grep -iv "avail" | awk '{ print $4}'`
	  fi
	fi
      fi 
      if  [[ -n "$min_tmp_space" && $min_tmp_space -lt $space_tmp_location ]]
      then
        space_pass_msg="$space_pass_msg \nSpace available on $space at $tmp_location is $space_tmp_location KB"
        remote_tmp_space_status=0
      else
        space_fail_msg="$space_fail_msg $RED \nSpace available on $space at $tmp_location is $space_tmp_location KB and required space is $min_tmp_space KB $NORM"
        remote_tmp_space_status=1
      fi
      if [[ -n "$tmp_out_location" ]]; then
        if [[ -n "$min_tmp_space" &&  $min_tmp_space -lt $space_tmp_out_location ]]
        then
          space_pass_msg="$space_pass_msg \nSpace available on $space at $tmp_out_location is $space_tmp_out_location KB"
          remote_tmp_out_space_status=0
        else
          space_fail_msg="$space_fail_msg $RED \nSpace available on $space at $tmp_out_location is $space_tmp_out_location KB and required space is $min_tmp_space KB $NORM "
          remote_tmp_out_space_status=1
        fi
      fi
    fi
    if [[ $curr_loc_space_status -eq 1 || $local_tmp_space_status -eq 1 || $remote_tmp_space_status -eq 1 || $local_tmp_out_space_status -eq 1 || $remote_tmp_out_space_status -eq 1 ]]; then space_status=1; break; else space_status=0;fi;
  done
}

#Function to compare rpm versions
function compare_rpmversion()
{
  unset rpm_dot1
  unset rpm_dot2
  local IFS=$'.'
  vd_counter1=0
  digits1=0
  for vd in $1
  do
    if [ `echo $vd|grep -c "_" ` -ge 1 ]
    then
      vd=$(echo $vd|cut -d_ -f1)
    fi  
    rpm_dot1[$vd_counter1]=$vd
    vd_counter1=$(expr $vd_counter1 + 1)
  done
  vd_counter2=0
  digits2=0
  for vd in $2
  do
    if [ `echo $vd|grep -c "_" ` -ge 1 ]
    then
      vd=$(echo $vd|cut -d_ -f1)
    fi  
    rpm_dot2[$vd_counter2]=$vd
    vd_counter2=$(expr $vd_counter2 + 1)
  done
  loop_digits=0
  while [ "$loop_digits" -lt "$vd_counter1" ]
  do
    isdigit=$(echo ${rpm_dot1[$loop_digits]}|grep -E '^[0-9]+$')
    if [ -n "$isdigit" ]
    then
      #echo "went to numeric comparision"
      if [[ -n "${rpm_dot1[$loop_digits]}" && "${rpm_dot2[$loop_digits]}" -eq "${rpm_dot1[$loop_digits]}" ]]
      then
        func_rpm_status=0
        #$READ -p "reco=${rpm_dot1[$loop_digits]} actual=${rpm_dot2[$loop_digits]} and func_rpm_status=$func_rpm_status"
      elif [[ -n "${rpm_dot1[$loop_digits]}" && "${rpm_dot2[$loop_digits]}" -gt "${rpm_dot1[$loop_digits]}" ]]
      then
        func_rpm_status=1
        #$READ -p "reco=${rpm_dot1[$loop_digits]} actual=${rpm_dot2[$loop_digits]} and func_rpm_status=$func_rpm_status"
        return
      elif [[ -n "${rpm_dot1[$loop_digits]}" && "${rpm_dot2[$loop_digits]}" -lt "${rpm_dot1[$loop_digits]}" ]]
      then
        func_rpm_status=2
        #$READ -p "reco=${rpm_dot1[$loop_digits]} actual=${rpm_dot2[$loop_digits]} and func_rpm_status=$func_rpm_status"
        return
      fi
    else
      isdigit=$(echo ${rpm_dot2[$loop_digits]}|grep -E '^[0-9]+$')
      if [ -n "$isdigit" ]; then
        func_rpm_status=1
        return
      else
        #echo "went to string comparision"
        if [[ -n "${rpm_dot1[$loop_digits]}" && "${rpm_dot2[$loop_digits]}" = "${rpm_dot1[$loop_digits]}" ]]
        then
          func_rpm_status=0
          #$READ -p "reco=${rpm_dot1[$loop_digits]} actual=${rpm_dot2[$loop_digits]} and func_rpm_status=$func_rpm_status"
        elif [[ -n "${rpm_dot1[$loop_digits]}" && "${rpm_dot2[$loop_digits]}" > "${rpm_dot1[$loop_digits]}" ]]
        then
          func_rpm_status=1
          #$READ -p "reco=${rpm_dot1[$loop_digits]} actual=${rpm_dot2[$loop_digits]} and func_rpm_status=$func_rpm_status"
          return
        elif [[ -n "${rpm_dot1[$loop_digits]}" && "${rpm_dot2[$loop_digits]}" < "${rpm_dot1[$loop_digits]}" ]]
        then
          func_rpm_status=2
          #$READ -p "reco=${rpm_dot1[$loop_digits]} actual=${rpm_dot2[$loop_digits]} and func_rpm_status=$func_rpm_status"
          return
        fi
      fi
    fi
    loop_digits=$(expr $loop_digits + 1)
  done
}

function nodelist_without_olsnodes ()
{
  if [[ -n "$setup_inittab" ]] && [[ $setup_inittab -eq "3" || $setup_inittab -eq "10" ]] ; then touch $HOSTLIST; return; fi
 
  if [[ $EM_PROBE_MODE -eq 1 ]]
  then
    cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <text nls_id="orhc_exadata_n26_nlsid">
        Unable to determine nodes in cluster  
      </text>
    </context>
    <text nls_id="orhc_exadata_n9_nlsid">
      Do you want to enter manually
    </text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o1q1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1" questionType="TEXT" outcome="No">
    <text nls_id="orhc_exadata_n10_nlsid">
      Enter cluster node names delimited by comma.(eg. node2,node3,node4) 
    </text>
  </question>
</group>
EOF
    PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

    readNodeNames="Yes"
    echo `hostname|cut -d. -f1`>$HOSTLIST   

    printf  $RED"Unable to determine nodes in cluster.  Do you want to enter manually.[y/n][y]"$NORM
    echo "Enter cluster node names delimited by comma.by defalut localhost will be printed. (eg. node2,node3,node4)"
  else
    printf  $RED"Unable to determine nodes in cluster.  Do you want to enter manually.[y/n][y]"$NORM
    if [[ $EM_XMLD_MODE -eq 1 ]]
    then
      read_probe_xml "Unable to determine nodes in cluster"
      readNodeNames=$xml_rvalue
    else
      $READ readNodeNames
    fi

    case $readNodeNames in
      y|Y|yes|YES|Yes)
        echo `hostname|cut -d. -f1`>$HOSTLIST
        echo "Enter cluster node names delimited by comma.by defalut localhost will be printed. (eg. node2,node3,node4)"
        printf "`hostname|cut -d. -f1`,"
	
	if [[ $EM_XMLD_MODE -eq 1 ]]
	then
	  read_probe_xml " Enter cluster node names delimited by comma"
	  nodeList=$xml_rvalue
	else
          $READ nodeList
	fi
        echo $nodeList|awk 'BEGIN {RS=","} {print}'|sed '/^$/d'>>$HOSTLIST   
        ;;
      n|N|No|NO) 
        echo ""
        echo `hostname|cut -d. -f1`>$HOSTLIST
        echo -e $RED"Since you did not enter any node names, this script will execute only on the local node.\n"$NORM
        echo "Since you did not enter any node names, this script will execute only on the local node\n" >>$LOGFIL
        echo "">>$LOGFIL
        ;;
      *)
        echo `hostname|cut -d. -f1`>$HOSTLIST
        echo "Enter cluster node names delimited by comma.by default localhost will be printed (eg. node2,node3,node4)"
        printf "`hostname|cut -d. -f1`,"
        $READ nodeList
        #echo $nodeList|sed 's/,/\n/g'>>$HOSTLIST
        echo $nodeList|tr "," "\n">>$HOSTLIST
        ;;
    esac
  fi
}

function func_what_platform ()
{
  os_name=$(uname -s)
  case  ${os_name} in
  Linux)
    #os_bit=$( file /sbin/modinfo |awk '{print $3}'|cut -d- -f1 )
     os_bit=$(getconf LONG_BIT)  
    if [ $os_bit -eq 64 ]
    then
      os_arch="X8664"
      os_arch_env_file="X86-64"
    elif [ $os_bit -eq 32 ]
    then
      os_arch="X86"
      os_arch_env_file="X86"
    fi
    if [ -f /etc/redhat-release ] 
    then
      os_type_full="OELRHEL"
      #os_version=$(cat /etc/redhat-release|grep -v ^#|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      os_version=$(grep -v ^# /etc/redhat-release|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 && `grep -icw "vm server" /etc/redhat-release` -ge 1 && $os_version -eq 3 ]];then os_version=5;fi
      if [[ $is_exadata_dom0_machine -eq 1 && `grep -icw "vm server" /etc/redhat-release` -ge 1 && $os_version -eq 3 ]];then os_version=6;fi
    elif [ -f /etc/SuSE-release ] 
    then
      os_type_full="Suse" 
      #os_version=$(cat /etc/SuSE-release|grep -v ^#|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      os_version=$(grep -v ^# /etc/SuSE-release|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      #if [ -z "$os_version" ]; then os_version=$(cat /etc/SuSE-release|grep -i version|awk '{print $3}');fi 
      if [ -z "$os_version" ]; then os_version=$(grep -i version /etc/SuSE-release|awk '{print $3}');fi 
    else
      os_type_full="Unsupported OS"
    fi
    if [ $(uname -p) = "s390x" ];then os_name="LINUXZ";fi
    what_os=$(echo ${os_name}${os_arch}${os_type_full}${os_version}|tr "[a-z]" "[A-Z]")
  ;;
  SunOS)
    os_bit=$(/usr/bin/isainfo -b)     
    os_version=$(uname -r |cut -d. -f2)
    os_arch=$(uname -p|tr "[a-z]" "[A-Z]")
    if [ "$os_arch" = "I386" ]; then os_arch="X86";os_arch_env_file="X86";fi
    os_arch_env_file=$(echo "(${os_arch}${os_bit}-BIT)")
    os_name="SOLARIS"
    #$READ -p "${os_name}${os_arch_env_file}"
    what_os=$(echo ${os_name}${os_arch}${os_bit}${os_version})
    #$READ -p "what os $what_os"
  ;;
  AIX)
    os_bit=$(getconf -a | grep KERN|cut -d: -f2|awk '{print $1}')
    os_version=$(oslevel|awk 'BEGIN { FS = "." } ;{print $1$2}')
    os_name=$(uname -s)
    os_arch=$(uname -p)
    if [ $os_arch = "powerpc" ]; then os_arch="PPC"; fi
    what_os=$(echo ${os_name}${os_arch}${os_bit}${os_version}|sed 's/ //g')
    os_version_env_file=$(oslevel|cut -d. -f1)
    os_name=$(echo ${os_name}${os_version_env_file})
    if [ $os_version_env_file -eq 5 ]; then os_name=$(echo "${os_name}L");fi
    os_arch_env_file=$(echo "(${os_bit}-BIT)")
  ;;
  HP-UX)
    os_name="HPUX"
    os_arch=$(uname -m)
    if [ $os_arch = "ia64" ]; then os_arch="Itanium" ; else os_arch="PARISC"; fi;
    os_version=$(uname -r |  sed 's/[^0-9]*\([0-9][0-9]*\)[^0-9]*/\1/g')
    what_os=$(echo ${os_name}${os_arch}${os_version})
    os_bit=$(getconf KERNEL_BITS);
    if [ "$(uname -m)" = "ia64" ]
    then
      os_arch_env_file=$(echo $(uname -s) $os_arch|tr "[a-z]" "[A-Z]")
    else
      os_bit=$(getconf KERNEL_BITS);
      os_arch_env_file=$(echo $(uname -s) PA-RISC "(${os_bit}-BIT)")
    fi
  ;;
  CYGWIN_NT-[0-9].[0-9])
    os_name="MSWINDOWS"
    os_arch="X86";
    os_bit=64
    os_version=`uname -s | sed 's/CYGWIN_NT-//'| sed 's/\r//'`
    what_os="MSWINDOWS64";
  ;;
  *)
    os_arch="Not supported OS"
    exit 1;
  ;;
  esac
}

function func_what_db()
{
  if [ ${rdbms_installed[0]} -eq 1 ]
  then
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      get_dbOwner  
      what_db=$(su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -v|awk '{print \$3}'|sed 's/\.//g'|sed '/^$/d'")
      cd $OLD_DIR
      unset OLD_DIR	
    else
      what_db=$($ORACLE_HOME/bin/sqlplus -v|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
    fi

    if [ -z $what_db ]; then
      t_flag="-T";
      for hosts in `cat $HOSTLIST`
      do
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  get_dbOwner "" "1"
          what_db=$($SSHELL $t_flag $hosts $bash_scr <<EOF
	  cd $dbhome_dir 2>/dev/null; \
          export ORACLE_HOME=$ORACLE_HOME; \
          su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -v 2>/dev/null"
EOF
)		
	else
          what_db=$($SSHELL $t_flag $hosts $bash_scr <<EOF
          export ORACLE_HOME=$ORACLE_HOME; \
          $ORACLE_HOME/bin/sqlplus -v 2>/dev/null
EOF
)	
	fi
        what_db=$(echo "$what_db"|grep -i 'SQL\*Plus: Release'|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
        if [[ -n $what_db ]]; then break; fi
      done
    fi

    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      get_dbOwner
      DBVERSION=$(su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -v|awk '{print \$3}'|sed '/^$/d'")
      cd $OLD_DIR
      unset OLD_DIR
    else
      DBVERSION=$($ORACLE_HOME/bin/sqlplus -v|awk '{print $3}'|sed '/^$/d')
    fi

    if [ -z $DBVERSION ]; then
      t_flag="-T";
      for hosts in `cat $HOSTLIST`
      do
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  get_dbOwner "" "1"
          DBVERSION=`$SSHELL $t_flag $hosts<<EOF
	  cd $dbhome_dir 2>/dev/null;
          export ORACLE_HOME=$ORACLE_HOME
          su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -v 2>/dev/null"
EOF`		
	else
          DBVERSION=`$SSHELL $t_flag $hosts<<EOF
          export ORACLE_HOME=$ORACLE_HOME
          $ORACLE_HOME/bin/sqlplus -v 2>/dev/null
EOF`		
	fi
        DBVERSION=$(echo "$DBVERSION"|grep -i 'SQL\*Plus: Release'|awk '{print $3}'|sed '/^$/d')
        if [[ -n $DBVERSION ]]; then break; fi
      done
    fi
  else
    what_db="NODATABASE"
    DBVERSION="NODATABASE"  
    #RAT_DB="NODATABASE"
  fi
}

# Create small file with only checks from profile
function select_collections4profile
{
  #echo Started selecting profile checks : `date`
  bs_reffil=$INPUTDIR/collections.dat.beforeselect
  targetVesionCheckFil=$INPUTDIR/collections.dat.tvc
  cp -f $INPUTDIR/collections.dat $bs_reffil
  grep ".-CHECK_ID" $INPUTDIR/collections.dat > $INPUTDIR/cm.dat
  echo > $INPUTDIR/collections.dat
  #create checks with targetversion values from collections.dat
  if [[ -n "$upgrade_mode" && $upgrade_mode -eq 2 ]]
  then
    grep -w "TARGET_VERSION" $bs_reffil|sed 's/\.//g'|grep $targetversion|cut -d- -f1|sed 's/_//g'>$targetVesionCheckFil
  elif [[ -n "$upgrade_mode" && $upgrade_mode -eq 3 ]]
  then
    grep -w "COMPONENTS" $bs_reffil|grep POSTUPGR|cut -d- -f1|sed 's/_//g'>$targetVesionCheckFil
  fi
  #####################
  cur_check_index=1
  selected_collect_count=0
  selected_root_count=0
  
  cindex_collect=$(grep "OS_COLLECT_COUNT" $bs_reffil|cut -d. -f1|sed 's/_//g')
  cindex_root=$(grep "REQUIRES_ROOT_COUNT" $bs_reffil|cut -d. -f1|sed 's/_//g')

  if [[ $OFFLINE -eq "0" && -n "$run_profile" && $run_profile -eq "1" ]] ; then
    echo "PROFILE_RUN = 1">>$MASTERFIL
    echo "PROFILES = $profileids2run">>$MASTERFIL
    echo "PROFILE_NAMES = $profiles2run">>$MASTERFIL
  fi
  if [[ $OFFLINE -eq "0" && -n "$exclude_profile" && $exclude_profile -eq "1" ]] ; then
    echo "EXCLUDE_PROFILE_RUN = 1">>$MASTERFIL
    echo "EXCLUDE_PROFILES = $profileids2exclude">>$MASTERFIL
    echo "EXCLUDE_PROFILE_NAMES = $profiles2exclude">>$MASTERFIL
  fi

  previous_index="";

  while read cline
  do
    CHECK_ID=$(echo "$cline" | awk '{print $3}');
    cindex=$(echo "$cline" | sed 's/\..*//' |sed 's/_//')

    in_profile=0
    ex_profile=1
    if [[ -n "$run_profile" && $run_profile -eq "1" ]] || [[ -n "$exclude_profile" && $exclude_profile -eq 1 ]]
    then
      check_in_profiles
    elif [ $upgrade_mode -ge 2 ]
    then
      check_in_targetversion
    fi
   
    if [[ -n "$run_profile" && $run_profile -eq "1" && $in_profile -eq "1" ]] || [[ $ex_profile -eq "1" && -n "$exclude_profile" && $exclude_profile -eq 1 ]] || [[ -n "$upgrade_mode" && $upgrade_mode -ge 2 && $in_profile -eq "1" ]]
    then
      if [[ `grep -c ".-CHECK_ID $CHECK_ID" $INPUTDIR/collections.dat` -eq 0 ]]
      then # Add only if it does not exists already
        #if [ -z "$previous_index" ] ; then previous_index=$cindex; fi
        #if [ $cindex -ne $previous_index ] ; then
        #  index_to_print=$(expr $cur_check_index + 1)
        #  increment_index=1
        #  previous_index=$cindex
        #else
        #  index_to_print=$cur_check_index
        #  increment_index=0
        #fi
        grep "^_$cindex\." $bs_reffil | grep -v "OS_COLLECT_COUNT" | grep -v "REQUIRES_ROOT_COUNT" | sed 's/_'$cindex'\./_'${cur_check_index}'./' >> $INPUTDIR/collections.dat
        #echo $cline | grep -v "OS_COLLECT_COUNT" | grep -v "REQUIRES_ROOT_COUNT" | sed 's/_'$cindex'\./_'${index_to_print}'./' >> $INPUTDIR/collections.dat
        check_type=$(grep "_${CHECK_ID}-TYPE" $bs_reffil | awk '{print $2}');
        require_root=$(grep "_${CHECK_ID}-REQUIRES_ROOT" $bs_reffil | awk '{print $2}');
        if [[ -n "$check_type" && $check_type = "OS_COLLECT" ]] ; then
          selected_collect_count=$(expr $selected_collect_count + 1)
        fi
        if [[ -n "$require_root" && $require_root -eq "1" ]] ; then
          selected_root_count=$(expr $selected_root_count + 1)
        fi
        #if [[ $increment_index -eq "1" ]] ; then
        cur_check_index=$(expr $cur_check_index + 1)
        #fi
      fi
    fi
    if [[ $cindex_collect -eq $cindex ]] ; then
      echo "_$cur_check_index.0.0.0.0.0.0.0.0.0-OS_COLLECT_COUNT $selected_collect_count" >> $INPUTDIR/collections.dat
      osCheckIndexNo=$cur_check_index
      cindex_collect=0
    fi
    if [[ $cindex_root -eq $cindex ]] ; then
      echo "_$cur_check_index.0.0.0.0.0.0.0.0.0-REQUIRES_ROOT_COUNT $selected_root_count" >> $INPUTDIR/collections.dat
      cindex_root=0
    fi

  done < $INPUTDIR/cm.dat 
  rm -f $INPUTDIR/cm.dat
  sed -n /COLLECTIONS_START/,/COLLECTIONS_END/p $bs_reffil >> $INPUTDIR/collections.dat
  #echo Done selecting profile checks : `date`
  #cp $bs_reffil $OUTPUTDIR/collections_org.dat
  rm -f $bs_reffil $targetVesionCheckFil >/dev/null 2>&1
  #cp $INPUTDIR/collections.dat $OUTPUTDIR/collections_saved.dat
  ##$READ -p "stop"
}
#multiple version support
# create collection.dat file for clusterware. it will be base version. 
# say we have 11202 clusterware & 11107 and 10204 databases
# we loop through check-ids. if for any checkid needs_running=RDBMS or 
# PARAM_PATH=RDBMS then we write the database next to same checkid if 
# its there in basefile
# if not then we add at the end

function append_version_checks ()
{
  #if [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]] ; return; fi;
   
  cur_check_index=$(grep ".-CHECK_ID" $INPUTDIR/collections.dat |tail -1 | sed 's/\..*//' |sed 's/_//')
  rm -f $INPUTDIR/insert.dat
  cp -f $INPUTDIR/collections.dat $INPUTDIR/collections.dat.beforemerge
  if [ -z "$stk_line_header" ]; then stk_line_header=$fmt_line_header;fi
  echo -e "\n$stk_line_header" 
  printf "Found multiple combinations of Clusterware and/or RDBMS versions. Preparing necessary checks.This will take some time.  Be Patient\n"
  echo -e "$stk_line_header\n"

  if [[ -n "$RAT_SKIP_MERGE_INTERNAL" && $RAT_SKIP_MERGE_INTERNAL -eq "1" ]] ; then 
    echo 
    echo "Skipping version checks merge as RAT_SKIP_MERGE_INTERNAL is set";
    echo
    return;
  fi
  # If there is no database with $CRSVERSION, then we need to add it
  crs_version_in_loop="";
  if [[ -n "${mb_oracle_versions_distinct[@]}" && ` echo ${mb_oracle_versions_distinct[@]}|grep -icw "$CRSVERSION"` -eq 0 ]]
  then
    crs_version_in_loop="$CRSVERSION";
  fi

  for mb_db_version in ${mb_oracle_versions_distinct[@]} $crs_version_in_loop
  do
    #if [ "xxx${CRSVERSION}" != "${mb_db_version}" ]
    #then # Already exists in collection.dat.. commented as we need to update 
      if [ $OFFLINE -eq 0 ]
      then
        grp_str=$(echo ${what_os}"_"${mb_db_version})
      else
        what_os_offline=$(grep "grp_str" $DUMPDIR/$CHKFIL |awk '{print $3}'|cut -d_ -f1)
        grp_str=$(echo ${what_os_offline}"_"${mb_db_version})
      fi
      grp_str=$(echo ${grp_str}"-")
      get_winpath "reffil_old"
      $GREP $grp_str $reffil_old >$INPUTDIR/collections_new_${mb_db_version}.dat
      restore_winpath "reffil_old"
      sed 's/'$grp_str'//g' $INPUTDIR/collections_new_${mb_db_version}.dat > $INPUTDIR/collections_${mb_db_version}.dat

      ##CONTROLM  sed 's///g' $INPUTDIR/collections_${mb_db_version}.dat >$INPUTDIR/collections_new_${mb_db_version}.dat
      cat $INPUTDIR/collections_${mb_db_version}.dat |tr -d '\r' >$INPUTDIR/collections_new_${mb_db_version}.dat

      cp $INPUTDIR/collections_new_${mb_db_version}.dat $INPUTDIR/collections_${mb_db_version}.dat
      rm $INPUTDIR/collections_new_${mb_db_version}.dat
  
      # Go through all collections_new_${mb_db_version}.dat and update collections.dat
      merge_version_dat;
      if [ -f "$INPUTDIR/insert_${mb_db_version}.dat" ]
      then
        cat $INPUTDIR/insert_${mb_db_version}.dat >> $INPUTDIR/insert.dat #fordebug
        cp -f $INPUTDIR/collections.dat $INPUTDIR/collections.dat.saved
        sed -n /_1.0.0.0.0.0.0.0.0.0-LEVEL.1-/,/COLLECTIONS_START/p $INPUTDIR/collections.dat.saved |grep -v COLLECTIONS_START > $INPUTDIR/collections.dat
        cat $INPUTDIR/insert_${mb_db_version}.dat >> $INPUTDIR/collections.dat
        sed -n /COLLECTIONS_START/,/COLLECTIONS_END/p $INPUTDIR/collections.dat.saved >> $INPUTDIR/collections.dat
        rm -f $INPUTDIR/insert_${mb_db_version}.dat
        rm -f $INPUTDIR/insert_${mb_db_version}.log
      fi
      rm -f $INPUTDIR/update_${mb_db_version}.dat
      rm -f $INPUTDIR/collections_${mb_db_version}.dat
    #fi
  done
  echo ""
  rm -f $INPUTDIR/insert.dat 
  rm -f $INPUTDIR/collections.dat.beforemerge
  rm -f $INPUTDIR/collections.dat.saved
}

function merge_version_dat ()
{
  #printf "\nSearching for new checks to run for version ${mb_db_version}..."
  #$READ -p "merging $INPUTDIR/collections_${mb_db_version}.dat to $INPUTDIR/collections.dat"
  grep ".-CHECK_ID" $INPUTDIR/collections_${mb_db_version}.dat > $INPUTDIR/cm.dat
  if [[ -n $RAT_DEBUG_V ]] ; then date; fi;
  while read cline
  do
    check_id=$(echo "$cline" | awk '{print $3}');
    merge_this_check=0

    if [[ `grep -c "$check_id-PARAM_PATH RDBMS" $INPUTDIR/collections.dat` -gt 0 || `grep -c "$check_id-NEEDS_RUNNING RDBMS" $INPUTDIR/collections.dat` -gt 0  || `grep -c "$check_id-HOME_PATH RDBMS" $INPUTDIR/collections.dat` -gt 0  || `grep -c "$check_id-TYPE SQL" $INPUTDIR/collections.dat` -gt 0 ]]
    then  # check need tobe merged
      merge_this_check=1
    fi;

    if [[ `grep -c "$check_id-PARAM_PATH ASM" $INPUTDIR/collections.dat` -gt 0 || `grep -c "$check_id-NEEDS_RUNNING ASM" $INPUTDIR/collections.dat` -gt 0  || `grep -c "$check_id-HOME_PATH ASM" $INPUTDIR/collections.dat` -gt 0  || `grep -c "$check_id-SOURCE_FILE v_parameter_asm" $INPUTDIR/collections.dat` -gt 0 ]]
    then  # ignore ASM
      merge_this_check=0
    fi;

    if [[ $merge_this_check -eq "1" ]]
    then
      if [[ `grep -c ".-CHECK_ID $check_id" $INPUTDIR/collections.dat` -gt 0 ]]
      then # Exists in base file, just update version
        echo "Update: $cline" >> $INPUTDIR/update_${mb_db_version}.dat #fordebug
        cp -f $INPUTDIR/collections.dat $INPUTDIR/collections.dat.saved
        sed 's/CHECK_ID '$check_id'/CHECK_ID '$check_id' '${mb_db_version}'/' $INPUTDIR/collections.dat.saved > $INPUTDIR/collections.dat
      else # add a new row
        printf ". "
        if [[ -f "$INPUTDIR/insert_${mb_db_version}.dat" && `grep -c ".-CHECK_ID $check_id" $INPUTDIR/insert_${mb_db_version}.dat` -gt 0 ]]
        then #inserted already
	  if [[ `grep ".-CHECK_ID $check_id" $INPUTDIR/insert_${mb_db_version}.dat | grep -c "no-release"` -gt 0 && `grep ".-CHECK_ID $check_id" $INPUTDIR/insert_${mb_db_version}.dat | grep -c "${mb_db_version}"` -eq "0" ]] ; then
            cp -f $INPUTDIR/insert_${mb_db_version}.dat $INPUTDIR/insert_${mb_db_version}.dat.saved
            sed 's/CHECK_ID '$check_id'/CHECK_ID '$check_id' '${mb_db_version}'/' $INPUTDIR/insert_${mb_db_version}.dat.saved > $INPUTDIR/insert_${mb_db_version}.dat
          else
            echo "Already inserted : $cline" >> $INPUTDIR/insert_${mb_db_version}.log
          fi
        else
          echo "Insert: $cline" >> $INPUTDIR/insert_${mb_db_version}.log
          cur_check_index=$(expr $cur_check_index + 1)
          cindex=$(echo "$cline" | sed 's/\..*//' |sed 's/_//')
          echo "Old: " >> $INPUTDIR/insert_${mb_db_version}.log
          grep "^_$cindex\." $INPUTDIR/collections_${mb_db_version}.dat >> $INPUTDIR/insert_${mb_db_version}.log
          echo "New: " >> $INPUTDIR/insert_${mb_db_version}.log
          grep "^_$cindex\." $INPUTDIR/collections_${mb_db_version}.dat | sed 's/_'$cindex'\./_'${cur_check_index}'./' | awk '{print $0" "'${mb_db_version}' }'>> $INPUTDIR/insert_${mb_db_version}.log
	  insert_version_dat "$cindex" "${cur_check_index}" "${mb_db_version}" "$cline"
          #grep "_$cindex\." $INPUTDIR/collections_${mb_db_version}.dat | sed 's/_'$cindex'\./_'${cur_check_index}'./' | awk '{print $0" "'${mb_db_version}' }'>> $INPUTDIR/insert_${mb_db_version}.dat
        fi
      fi
    fi
  done < $INPUTDIR/cm.dat
  rm -f $INPUTDIR/cm.dat
}

function insert_version_dat ()
{
  index="$1"
  cur_index="$2"
  db_version="$3"
  line="$4"

  level=$(echo "$line" | awk -F"-" '{print $2}' | awk '{print $2}' | sed 's/^\s*|\s*$//g')
  m_check_id=$(echo "$line" | awk -F"-" '{print $1}');

  counter=0;
  declare -a parent_check_ids=()
  unset tmp
  for (( i=$level; i>1; i-- ))
  do
    if [[ -z "$tmp" ]]
    then
      tmp=$m_check_id
    fi
    tmp=$(echo "$tmp" | sed "s/[0-9]\./0\./$i")
    parent_check_ids[$counter]=$tmp
    counter=$(expr $counter + 1)
  done
  parent_check_ids[$counter]=$m_check_id

  OIFS=$IFS
  IFS=$'\n'
  for iline in `grep "^_$cindex\." $INPUTDIR/collections_${db_version}.dat`
  do
    icheck_id=$(echo "$iline" | awk -F"-" '{print $1}');
    mark=0
    for pchkid in ${parent_check_ids[@]}
    do
      if [[ "$pchkid" = "$icheck_id" ]]
      then
        mark=1
        break
      fi
    done
    
    if [[ "$mark" -eq "1" ]]
    then
      iline=$(echo $iline |sed 's/_'$index'\./_'${cur_index}'./' | awk '{print $0" "'${db_version}'}')
      echo $iline >> $INPUTDIR/insert_${db_version}.dat
    else
      iline=$(echo $iline |sed 's/_'$index'\./_'${cur_index}'./')
      echo $iline 'no-release' >> $INPUTDIR/insert_${db_version}.dat
    fi
  done
  IFS=$OIFS
}

function set_skip_this_version()
{
  l_mb_db_homes="$1"
  skip_this_version=0
  l_mb_db_home_dname="all"
  if [[ $l_mb_db_homes = "-" ]]
  then
    if [ $OFFLINE -eq 0  ]
    then
      l_mb_db_homes="${mb_oracle_homes[$mb_db_counter]}"
    else
      l_mb_db_homes=$(grep -w "DB_NAME = $db_name_to_check" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f3)
    fi
    l_mb_db_home_dname="$db_name_to_check"
  fi

  if [[ $RAT_RUNMODE_INTERNAL = "slave" ]] && [[ $COMTYPE = "SQL_COLLECT" || $COMTYPE = "SQL" || $COMTYPE = "SQL_OUT_CHECK" ]] ; then
    skip_this_version=1
    call_get_log_result=0
  fi

  #if [[ $crsdb_mixed_version=1 && -z $versions_to_run && $COMTYPE = "ORACLE_PATCH"  ]]
  #then # We assumed that all checks with CRSVERSION should be run on all databases. But when crs version is 112 and db is 102, 112 patch checks are run on 10.2 db.
  #  versions_to_run=$CRSVERSION
  #  run_in_multiple_versions=1
  #  echo "Skipping patch check for $CRSVERSION"
  #fi

  if [[ $run_in_multiple_versions -eq 1 ]]
  then
    if [ $OFFLINE -eq 0  ]
    then
      current_version=$(grep "RDBMS_ORACLE_HOME = $l_mb_db_homes" $MASTERFIL|awk '{print $3}'|cut -d '|' -f2)
    else
      current_version=$(grep "RDBMS_ORACLE_HOME = $l_mb_db_homes" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f2)
    fi
    if [[ -n "$current_version" && `echo "$versions_to_run" | grep -ic "$current_version"` -eq 0 ]]
    then #dont run
      skip_this_version=1
      call_get_log_result=0
    else
      call_get_log_result=1
    fi
  fi

  #In upgrade mode, we need to skip checks on some versions which are not upgraded
  if [[ $upgrade_mode -gt 0 && ${mb_skip[$mb_db_counter]} -eq "1" ]]
  then
    skip_this_version=1
    call_get_log_result=0
  fi

  # Incase of a branch, a check needs to executed only if the branch succeded on the db
  if [[ $skip_this_version -eq "0" && $CUR_LEVEL -gt "1" ]]
  then
    prev_level=$(expr $CUR_LEVEL - 1)
    if [[ -n "${m_opstat[$prev_level]}" && `echo ${m_opstat[$prev_level]} | grep -ic $l_mb_db_homes-$l_mb_db_home_dname` -eq "0"  && `echo ${m_opstat[$prev_level]} | grep -ic $l_mb_db_homes-all` -eq "0" ]]
    then
      if [[ $l_mb_db_home_dname = "all" && `echo ${m_opstat[$prev_level]} | grep -ic $l_mb_db_homes-` -gt "0" ]] ; then
        # passed on some db. so should not skip.
        echo;
      else
        if [[ -n "${m_opstat[$prev_level]}" && ${m_opstat[$prev_level]} != "passed_on_all_targets" ]] ; then
          #echo
          #echo "Skipping below check "
          #echo "ROW=$ROW"
          #echo "COM=$COM"
          #echo "Passed on ${m_opstat[$prev_level]}"
          #echo "Current Home: $l_mb_db_homes"
          #echo
          skip_this_version=1
          call_get_log_result=0
        fi
      fi
    elif [ -z "${m_opstat[$prev_level]}" ] ; then
     skip_this_version=1
     call_get_log_result=0
    fi
  fi
}

function set_skip_this_target ()
{
  targetname=$1
  # Incase of a branch, a check needs to executed only if the branch succeded on the db
  #echo "$ROW $targetname - $skip_this_target - $CUR_LEVEL"
  if [[ $skip_this_target -eq "0" && $CUR_LEVEL -gt "1" ]]
  then
    prev_level=$(expr $CUR_LEVEL - 1)
    if [[ -n "${m_opstat[$prev_level]}" && `echo ${m_opstat[$prev_level]} | grep -ic $targetname` -eq "0"  ]]
    then
      if [[ `echo ${m_opstat[$prev_level]} | grep -ic passed_on_all_targets` -eq "0" ]] ; then
        skip_this_target=1
        call_get_log_result=0
      fi
    #elif [ -z "${m_opstat[$prev_level]}" ] ; then
    #  if [[ -n "$OPSTAT" && $OPSTAT -eq "0" ]] ; then
    #    skip_this_target=1
    #    call_get_log_result=0
    #  fi
    fi
  fi
}

function func_create_small_files ()
{
  #$READ -p "what os=$what_os and what db=$what_db and dbversion=$DBVERSION components=$components"
  reffil_old=$REFFIL
  reffil1_old=$REFFIL1 
  no_of_db_version=${#mb_oracle_versions_distinct[*]}
  if [ $OFFLINE -eq 0 ] 
  then
    #if [ "$TYP" = "-u" ]
    #then
    #   CRSVERSION=$(cat $OUTPUTDIR/mb_db_homes_versions_distinct_selected.out|head -1|cut -d '|' -f2)
    #   #CRSVERSION=112020
    #else
    if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]]
    then
      CRSVERSION=$exalogic_version
    elif [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]]
    then 
      CRSVERSION=$exalytics_version
    elif [[ -n "$is_bda_machine" && $is_bda_machine -eq 1 ]]
    then
      CRSVERSION=$bda_version
      CRSVERSION=$(echo $CRSVERSION|sed 's/[^0-9\.]//g'|sed 's/\.//g')
    elif [[ -n "$is_exadata_dom0_machine" && $is_exadata_dom0_machine -eq 1 ]] || [[ -n "$is_ssc_globalzone_machine" && $is_ssc_globalzone_machine -eq 1 ]]
    then
        CRSVERSION=121020 
    #following branch is to run preinstall profile to check best practice before installing target database version
    elif [[ "$profiles2run" = "preinstall" && -n "$targetversion" && $crs_up -eq 0 ]]
    then
        CRSVERSION=$targetversion 
    elif [[ -n "$what_db" && "$what_db" = "NODATABASE"  && $crs_up -eq 0 ]]
    then
      CRSVERSION=121010
    else
      local CRSVERSION=$(echo ${stack_crs_version[0]}|sed 's/\.//g') 
      if [[ -z "$CRSVERSION" && -n "$CRS" && $is_exalogic_machine -eq "0"  && $is_exalytics_machine -eq "0" ]]
      then
        save_crs
        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
          OLD_OH=$ORACLE_HOME
          ORACLE_HOME=$CRS
          get_dbOwner
          ORACLE_HOME=$OLD_OH
          su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch>/dev/null 2>&1"
          if [ $? -eq 0 ]; then CRSVERSION=$(su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch|sed -n 's/.*\[//p'|sed 's/\]//g'|sed 's/[^0-9\.]//g' | sed 's/[^0-9\.]//g'|sed 's/\.//g'"); fi
          cd $OLD_DIR
          unset OLD_DIR
	else
          $CRS/bin/crsctl query $crs_version_switch>/dev/null 2>&1
          if [ $? -eq 0 ]; then CRSVERSION=$($CRS/bin/crsctl query $crs_version_switch|sed -n 's/.*\[//p'|sed 's/\]//g'|sed 's/[^0-9\.]//g' | sed 's/[^0-9\.]//g'|sed 's/\.//g'); fi
	fi
        ret_crs
      elif [[ -z "$CRSVERSION" && -z "$CRS" && $is_exalogic_machine -eq "0"  && $is_exalytics_machine -eq "0" && -n "$what_db" && $single_instance_run -eq 1 ]]
      then
        CRSVERSION=$what_db  
      fi
      if [[ -n "$RAT_DB" ]]
      then 
        CRSVERSION="$RAT_DB"
      elif [[ -z "$CRSVERSION" && -z "$RAT_DB" ]]
      then 
	if [[ $EM_PROBE_MODE -eq 1 ]]
        then
	  EMSG="${program_name} did not find the Clusterware version from environment.\nPlease set RAT_DB to cluster version in current shell to override and re- run it.\neg export RAT_DB=112020"
	  update_probe_xml "ERROR" "GENERIC" "$EMSG"
        fi
        echo -e "${RED}${program_name} did not find the Clusterware version from environment.\n\nPlease set RAT_DB to cluster version in current shell to override and re- run it.${NORM}\n\n\neg export RAT_DB=112020"
        exit 1
      fi
      if [ "$what_db" != "NODATABASE" ] && [[ "$what_db" != "$CRSVERSION" || $no_of_db_version -gt 1 ]] &&  [[ "$TYP" != "-b" && $SILENT -eq 0 ]];then crsdb_mixed_version=1;else crsdb_mixed_version=0;fi
      if [ "$what_db" != "NODATABASE" ] && [[ "$what_db" != "$CRSVERSION" || $no_of_db_version -gt 1 ]] &&  [[ $SILENT -eq 0 ]];then crsdb_mixed_version4checks=1;else crsdb_mixed_version4checks=0;fi
    fi

    #####code to remove database from list if its already upgraded
    if [ $upgrade_mode -eq 2 ]
    then
      for db_name_to_check in ${mb_db_names_upgraded[@]}
      do
        echo -e "\n${GREEN}Database ${db_name_to_check} is already running at version $targetversion so no upgrade checks are required${NORM}"|tee -a $LOGFIL
      done
      if [[ $CRSVERSION -eq $targetversion && ${#mb_db_names[@]} -eq ${#mb_db_names_upgraded[@]} ]]
      then
        echo -e "\n${GREEN}grid infrastructure and all databases are already upgraded and no pre upgrade checks are required\nExiting....${NORM}"|tee -a $LOGFIL
        exit 0
      fi
      if [ "$CRSVERSION" -gt "$targetversion" ]
      then  
        echo -e "${RED}Source vesrsion ($CRSVERSION) is higher than Target version ($targetversion).\n\n${program_name} is exiting...${NORM}\n\n"
        exit 1
      fi
    elif [ $upgrade_mode -eq 3 ]
    then
      targetversion=$CRSVERSION   
      if [[ `echo $supportedTargetVersion|grep -icw $CRSVERSION` -lt 1 ]]
      then
        echo -e "\n${GREEN}grid infrastructure is not running $supportedTargetVersionPrint version so can not run post upgrade checks.\nExiting....${NORM}"|tee -a $LOGFIL
        exit 0
      fi 
      for db_name_to_check in "${mb_db_names[@]}"
      do
        if [[ -n "${mb_db_names_need_upgrade[@]}" && ` echo ${mb_db_names_need_upgrade[@]}|grep -icw $db_name_to_check` -ge 1 ]]   
        then
          echo -e "\n${GREEN}Database version for ${db_name_to_check} is not $supportedTargetVersionPrint so no post upgrade checks are required${NORM}"|tee -a $LOGFIL
        fi
        #for db_name_to_check in ${mb_db_names_upgraded[@]}
        #echo -e "\n${GREEN}Database ${db_name_to_check} is already running at version $what_db so no upgrade checks are required${NORM}"|tee -a $LOGFIL
      done
    fi
 
    #$READ -p "stop for deleteing databases"
    ###################
    grp_str=$(echo ${what_os}"_"${CRSVERSION})
    #if [ -n "$components" ];then grp_str=$(echo ${grp_str}-${components});fi
    #$READ -p "DBVERSION=$what_db and CRSVERSION=$CRSVERSION crsdb_mixed_version=$crsdb_mixed_version grp_str=$grp_str"
    echo "grp_str = $grp_str">>$MASTERFIL
  else
    local CRSVERSION=$(echo ${stack_crs_version[0]}|sed 's/\.//g') 
    local DBVERSION_OFFLINE=$(grep -i "DB_NAME"  $DUMPDIR/$CHKFIL|cut -d= -f2|cut -d'|' -f2|head -1|sed 's/\.//g')
    upgrade_mode=$(grep UPGRADE_MODE $DUMPDIR/$CHKFIL |awk '{print $3}');
    if [ ! -n "$upgrade_mode" ] ; then upgrade_mode=0; fi

    if [[ -n "$upgrade_mode" && $upgrade_mode -eq 3 ]] ; then targetversion=$CRSVERSION ; fi
    #DB=$(grep -i "DB_NAME" $DUMPDIR/$CHKFIL |cut -d= -f2)
    if [ -n "$DBVERSION_OFFLINE" ] && [[ "$DBVERSION_OFFLINE" != "$CRSVERSION" || $no_of_db_version -gt 1 ]] && [[ "$RUNSWITCH" != "-b" ]];then crsdb_mixed_version=1;else crsdb_mixed_version=0;fi
    if [ -n "$DBVERSION_OFFLINE" ] && [[ "$DBVERSION_OFFLINE" != "$CRSVERSION" || $no_of_db_version -gt 1 ]] ;then crsdb_mixed_version4checks=1;else crsdb_mixed_version4checks=0;fi
    #$READ -p "DBVERSION=$DBVERSION_OFFLINE and CRSVERSION=$CRSVERSION crsdb_mixed_version=$crsdb_mixed_version"
    grp_str=$(grep "grp_str" $DUMPDIR/$CHKFIL |awk '{print $3}')
    INPUTDIR_OLD=$INPUTDIR
    INPUTDIR=$DUMPDIR   
    if [[ `grep "PROFILE_RUN = 1" $DUMPDIR/$CHKFIL|grep -v 'EXCLUDE'|wc -l|sed 's/ //g'` -gt "0" ]] ; then 
      run_profile=1
      profileids2run=$(grep "PROFILES =" $DUMPDIR/$CHKFIL |grep -v 'EXCLUDE' |cut -d= -f2)
      profiles2run=$(grep "PROFILE_NAMES =" $DUMPDIR/$CHKFIL |grep -v 'EXCLUDE' |cut -d= -f2)
    fi
  fi

  #CRSVERSION was coming empty in insert statement so declared this new variable to use in insert statement because CRSVERSION is local to this function
  CRSVERSION_UPLOAD=$CRSVERSION
  VERSION_DAT=$SCRIPTPATH/.cgrep/versions.dat;
  if [[ -z "$RAT_RUNMODE_INTERNAL" ]] ; then
    if [[ $DECRYPT_VDAT = 1 ]];
    then
      get_winpath "VERSION_DAT"
      $GREP '' $VERSION_DAT > $INPUTDIR/versions.dat
      restore_winpath "VERSION_DAT"
    else
      cp $VERSION_DAT $INPUTDIR/versions.dat
    fi

    get_winpath "REFFIL"
    $GREP $grp_str $REFFIL >$INPUTDIR/collections_new.dat
    grp_str=$(echo ${grp_str}"-")
    #$READ -p "grep string =$grp_str"
    sed 's/'$grp_str'//g' $INPUTDIR/collections_new.dat > $INPUTDIR/collections.dat
    #$READ -p "stop 1"
    if [[ -n "$GREP" && `echo $GREP|grep -ci cgrep` -eq 1 ]]
    then
      $GREP -s -n /COLLECTIONS_START/,/COLLECTIONS_END/p $REFFIL >> $INPUTDIR/collections.dat
    else
      sed -n /COLLECTIONS_START/,/COLLECTIONS_END/p $REFFIL >> $INPUTDIR/collections.dat  
    fi
    restore_winpath "REFFIL"
    #to remove control-M after creating small files.
    ##CONTROLM    sed  's///g' $INPUTDIR/collections.dat >$INPUTDIR/collections_new.dat
    cat $INPUTDIR/collections.dat |tr -d '\r' >$INPUTDIR/collections_new.dat

    cp $INPUTDIR/collections_new.dat $INPUTDIR/collections.dat
    osCheckIndexNo=$(grep "OS_COLLECT_COUNT" $INPUTDIR/collections.dat|cut -d. -f1|sed 's/_//g')
    #$READ -p "osCheckIndexNo=$osCheckIndexNo"
    rm  $INPUTDIR/collections_new.dat
    #$READ -p "stop 2"
    # Merge the collections from other db versions
    if [[ -n "$crsdb_mixed_version4checks" && $crsdb_mixed_version4checks -eq 1 && -n "$upgrade_mode" && $upgrade_mode -ne "3" && $TYP != "-p" ]]
    then #multiple_version_support. But for post upgrade we only check latest, no need to merge
      append_version_checks;
    fi
    if [[ -n "$run_profile" && $run_profile -eq "1" ]] || [ $upgrade_mode -eq 2 ] || [[ -n "$exclude_profile" && $exclude_profile -eq 1 ]]; then
      select_collections4profile
    fi
  if [ $SILENT -eq 0 ]
  then
    get_winpath "REFFIL1"
    $GREP $grp_str $REFFIL1 >$INPUTDIR/rules_new.dat
    sed 's/'$grp_str'//g' $INPUTDIR/rules_new.dat > $INPUTDIR/rules.dat
    if [[ -n "$GREP" && `echo $GREP|grep -ci cgrep` -eq 1 ]]
    then
      $GREP -s -n /APPENDIX_START/,/APPENDIX_END/p $REFFIL1 >> $INPUTDIR/rules.dat
      $GREP -s -n /RULES_START/,/RULES_END/p $REFFIL1 >> $INPUTDIR/rules.dat
    else
      sed -n /APPENDIX_START/,/APPENDIX_END/p $REFFIL1 >> $INPUTDIR/rules.dat
      sed -n /RULES_START/,/RULES_END/p $REFFIL1 >> $INPUTDIR/rules.dat
    fi
    restore_winpath "REFFIL1"
    REFFIL1=$INPUTDIR/rules.dat
    #CONTROLM    sed  's///g' $REFFIL1 > $INPUTDIR/rules_new.dat
    cat $REFFIL1 | tr -d '\r'> $INPUTDIR/rules_new.dat
    cp $INPUTDIR/rules_new.dat $REFFIL1
    rm $INPUTDIR/rules_new.dat
    if [[ -n "$crsdb_mixed_version" && $crsdb_mixed_version -eq 1 ]]
    then
      for mb_db_version in ${mb_oracle_versions_distinct[@]}
      do
        if [ $OFFLINE -eq 0 ]
        then
          grp_str=$(echo ${what_os}"_"${mb_db_version})
        else
          what_os_offline=$(grep "grp_str" $DUMPDIR/$CHKFIL |awk '{print $3}'|cut -d_ -f1)
          grp_str=$(echo ${what_os_offline}"_"${mb_db_version})
          #$READ -p "grp_str=$grp_str"
        fi
        grp_str=$(echo ${grp_str}"-")
        get_winpath "reffil1_old"
        $GREP $grp_str $reffil1_old >$INPUTDIR/rules_new_${mb_db_version}.dat
        sed 's/'$grp_str'//g' $INPUTDIR/rules_new_${mb_db_version}.dat > $INPUTDIR/rules_${mb_db_version}.dat
        if [[ -n "$GREP" && `echo $GREP|grep -ci cgrep` -eq 1 ]]
        then
          $GREP -s -n /RULES_START/,/RULES_END/p $reffil1_old >> $INPUTDIR/rules_${mb_db_version}.dat
        else
          sed -n /RULES_START/,/RULES_END/p $reffil1_old >> $INPUTDIR/rules_${mb_db_version}.dat   
        fi
        restore_winpath "reffil1_old"
        #REFFIL2=$INPUTDIR/rules_crs.dat
        ##CONTROLM        sed  's///g' $INPUTDIR/rules_${mb_db_version}.dat >$INPUTDIR/rules_new_${mb_db_version}.dat
	cat $INPUTDIR/rules_${mb_db_version}.dat |tr -d '\r' >$INPUTDIR/rules_new_${mb_db_version}.dat
        cp $INPUTDIR/rules_new_${mb_db_version}.dat $INPUTDIR/rules_${mb_db_version}.dat
        rm $INPUTDIR/rules_new_${mb_db_version}.dat
      done
    fi
  fi
  REFFIL=$INPUTDIR/collections.dat
  #APPENDIX=$INPUTDIR/appendix.dat
  if [ $OFFLINE -eq 1 ] 
  then
    INPUTDIR=$INPUTDIR_OLD
  else
    validate_data_file
  fi
  else
    REFFIL=$INPUTDIR/collections.dat
    INPUTDIR=$INPUTDIR_OLD
  fi
   #$READ -p "REFFIL=$REFFIL REFFIL1=$REFFIL1 REFFIL2=$REFFIL2"
}

validate_data_file ()
{
  no_of_checks=$(grep -ic "CHECK_ID" $REFFIL)
  if [[ -n "$no_of_checks" && $no_of_checks -le 0 ]]
  then
    if [[ -n "$db_machine_compute" && $db_machine_compute -eq 0 ]]
    then  
      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
	EMSG="RC-003- Your platform/version is not currently supported.\nPlease refer to the section for this error code in \"Appendix A - Troubleshooting Scenarios\" of the ${program_name} User Guide."
	update_probe_xml "ERROR" "GENERIC" "$EMSG"
      fi
      echo -e "\n${RED}RC-003- Your platform/version is not currently supported.  Please refer to the section for this error code in "Appendix A - Troubleshooting Scenarios" of the "${program_name} User Guide".\n\n${program_name} exiting .....\n${NORM}" 
    else
      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
	EMSG="RC-003 - Your platform/version is not currently supported but more platform/version support is being added regularly.\nPlease check My Oracle Support (MOS) Note 1070954.1 for information about planned support for platforms/versions."
	update_probe_xml "ERROR" "GENERIC" "$EMSG"
      fi
      echo -e "\n${RED}RC-003 - Your platform/version is not currently supported but more platform/version support is being added regularly. Please check My Oracle Support (MOS) Note 1070954.1 for information about planned support for platforms/versions.\n\n${program_name} exiting .....\n${NORM}" 
    fi 
    exit 1;       
  fi
}

function validate_datafile_date ()
{
  #Check that data file are  not too old. if data file is more than 90 days
  #it will ask the confirmation and if customer wants, can abort and get new data files
  if [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]] ; then return; fi
  #Not to execute validate_datafile_date on ODA because no warning to customer and update should be from ODA bundle only
  if [[ -z "$RAT_ENABLE_STALENESS_VALIDATION" ]]
  then
      if [ -e /opt/oracle/oak/install/inittab ];then return; fi
      if [ -e /opt/oracle/bda ];then return; fi
  fi
  if [[ -n "$RAT_DISABLE_STALENESS_VALIDATION" && $RAT_DISABLE_STALENESS_VALIDATION -eq 1 ]];then return; fi 
  sysDateYear=$(date '+%Y')
  sysDateMonth=$(date '+%m'|sed 's/^0//')
  sysDateDay=$(date '+%d'|sed 's/^0//')
  dataFIleDay=$(echo $dataFIleDay|sed 's/^0//')
  dataFIleMonthNo=$(echo $dataFIleMonthNo|sed 's/^0//') 
  file_epoch=$(perl -e 'use Time::Local;print timelocal(00,00,00,"'$dataFIleDay'",'$dataFIleMonthNo'-1,'$dataFIleYear');')
  sys_epoch=$(perl -e 'use Time::Local;print timelocal(00,00,00,"'$sysDateDay'",'$sysDateMonth'-1,'$sysDateYear');')
  diff_epoch=`expr $sys_epoch - $file_epoch`
  #echo "\n\ndataFIleDay=$dataFIleDay dataFIleMonthNo=$dataFIleMonthNo dataFIleYear=$dataFIleYear file_epoch=$file_epoch diff_epoch=$diff_epoch\n\n">>$LOGFIL


  if [[ -n "$diff_epoch" && $diff_epoch -gt 11232000 ]] || [[ -z "$RAT_NOUPGRADE" && $no_upgrade -eq "0" ]]
  then
    if [[ -n "$diff_epoch" && $diff_epoch -lt 11232000 ]]
    then
	validVersionDays=$(expr $diff_epoch / 60 / 60 / 24)
        validVersionDays=$(expr 120 - $validVersionDays)	
    fi

    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      unset RAT_UPGRADE_LOC
    fi

    if [[ -n "$RAT_UPGRADE_LOC" ]]
    then
      check_upgrade
      if [ "$check_upgrade_ret_val" = "-1" ]
      then
		echo "
	unzip is not found. please install unzip, add it to the path and run again.
		";
      fi
      if [[ "$check_upgrade_ret_val" != "0" && "$check_upgrade_ret_val" != "-1" ]]
      then	
        if [[ $daemon_running -ne "1" ]] 
        then
          #latest_ver=$(echo $check_upgrade_ret_val | tr "," "\n");
          PRERDIR=`pwd`;
	  if [[ -n "$diff_epoch" && $diff_epoch -gt 11232000 ]]
	  then
          	echo -e $RED"This version of ${program_name} was released on $dataFilesDate and its older than 120 days.${NORM}\n\n"
	  fi
          oldVersionWarningMessage="Ran older version of ${program_name} released on ${dataFilesDate}"
          exec 3<&2; exec 2<&0
	  veratloc=`cat $WRKDIR/versionfil.dat`;
	  rm -rf $WRKDIR/versionfil.dat;
	  newscrloc=$(echo $check_upgrade_ret_val|sed 's/extract_files//g');
          $READ -p  "
Latest version of ${program_name} ($veratloc) is available at $newscrloc.

 Do you want to upgrade to the latest version of ${program_name}? [y/n][y]" cdfYesNo
	  read_code=`echo $?`;
          exec 2<&3
	  process_prompt "$read_code" "cdfYesNo" "n"

          case $cdfYesNo in
            y|Y|yes|YES|Yes) 
              cdfYes=1
              #UPDATE_RUN=1 
              #au_checked=1
              #download_from_mos
              upgrade_orachk
	      if [ $readonlyval -eq "1" ] ; then
		exec 3<&2; exec 2<&0
		$READ -p  "Do you want to continue running this version? [y/n][y]" cdfYesNo
		read_code=`echo $?`;
	        exec 2<&3
		process_prompt "$read_code" "cdfYesNo" "y"

	        case $cdfYesNo in
	          y|Y|yes|YES|Yes)
	            cdfYes=1
	            ;;
	          n|N|No|NO) echo "Exiting ... "
	            exit 0;
	            ;;
	          *)
	            cdfYes=1
	            ;;
	        esac

		echo "Running older version...";
	      else
                echo "Running the latest version...";
		NEWDIR=$(dirname $0)
                $NEWDIR/${program_name} ${argsaved};
                exit 0;
	      fi		
              ;;
            n|N|No|NO) echo ""
              #cdfYes=1
              #cleanup
              #exit 1
	      rm -rf $check_upgrade_ret_val;
              ;;
            *)
              cdfYes=1
              #UPDATE_RUN=1 
              #au_checked=1
              #download_from_mos
              upgrade_orachk
	      if [ $readonlyval -eq "1" ] ; then
		exec 3<&2; exec 2<&0
                $READ -p  "Do you want to continue running this version? [y/n][y]" cdfYesNo
		read_code=`echo $?`;
                exec 2<&3
		process_prompt "$read_code" "cdfYesNo" "y"

                case $cdfYesNo in
                  y|Y|yes|YES|Yes)
                    cdfYes=1
                    ;;      
                  n|N|No|NO) echo "Exiting ... "
                    exit 0; 
                    ;;      
                  *)      
                    cdfYes=1
                    ;;      
                esac
		echo "Running older version...";
              else             
                echo "Running the latest version...";
		NEWDIR=$(dirname $0)
                $NEWDIR/${program_name} ${argsaved};
                exit 0;
	      fi
              ;;
          esac
        else
          echo "Daemon is running. Sending email!!";
          upgrade_email_subj="New version of ${program_name} is available";
	  veratloc=`cat $WRKDIR/versionfil.dat`;
	  rm -rf $WRKDIR/versionfil.dat;
	  newscrloc=$(echo $check_upgrade_ret_val|sed 's/extract_files//g');
          matter="A new version of ${program_name} ($veratloc) is available at $newscrloc. Please restart the ${program_name} daemon to upgrade to latest version";
          send_email "$upgrade_email_subj" "$matter" "0" "all";
        fi #Daemon 
      else
       if [[ -n "$diff_epoch" && $diff_epoch -gt 11232000 ]]
       then
        echo -e $RED"This version of ${program_name} was released on $dataFilesDate and its older than 120 days. No new version of ${program_name} is available in RAT_UPGRADE_LOC. It is highly recommended that you download the latest version of ${program_name} from my oracle support to ensure the highest level of accuracy of the data contained within the report.${NORM}\n\n"
        exec 3<&2; exec 2<&0
        $READ -p  "Do you want to continue running this version? [y/n][y]" cdfYesNo
	read_code=`echo $?`;
        exec 2<&3
	process_prompt "$read_code" "cdfYesNo" "y"

        case $cdfYesNo in
          y|Y|yes|YES|Yes)
            cdfYes=1
            ;;
          n|N|No|NO) echo "Exiting ... "
            exit 0;
            ;;
          *)
            cdfYes=1
            ;;
        esac 
       fi
      fi # check_upgrade_ret_val !=  0
    else
     if [[ -n "$diff_epoch" && $diff_epoch -gt 11232000 ]]
     then
      echo -e $RED"This version of ${program_name} was released on $dataFilesDate and its older than 120 days. It is highly recommended that you download the latest version of ${program_name} from my oracle support to ensure the highest level of accuracy of the data contained within the report.${NORM}\n\n"
      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
        cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n27_nlsid">
        This version of ${program_name} was released on {1} its older than 120 days. It is highly recommended that you download the latest version of ${program_name} from my oracle support to ensure the highest level of accuracy of the data contained within the report.
      </text>
      <tokens>
        <token index="1">$dataFilesDate</token>
      </tokens>
      </tokenizedtext>
    </context>
    <text nls_id="orhc_exadata_n11_nlsid">
      Do you want to continue running this version
    </text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
</group>
EOF
	PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
        cdfYesNo="Yes"

        echo -e "Do you want to continue running this version? [y/n][y]"
      elif [[ $EM_XMLD_MODE -eq 1 ]]
      then
        echo -e "Do you want to continue running this version? [y/n][y]"

        read_probe_xml "Do you want to continue running this version" 
	cdfYesNo=$xml_rvalue
      else
	if [[ -n "$diff_epoch" && $diff_epoch -gt 11232000 ]]
        then
          exec 3<&2; exec 2<&0
	  $READ -p  "Do you want to continue running this version? [y/n][y]" cdfYesNo
	  read_code=`echo $?`;
          exec 2<&3
	  process_prompt "$read_code" "cdfYesNo" "y"
	else
	  cdfYesNo="Yes"
	fi
      fi
      case $cdfYesNo in
        y|Y|yes|YES|Yes)
          cdfYes=1
          ;;
        n|N|No|NO) echo "Exiting ... "
          exit 0;
          ;;
        *)
          cdfYes=1
          ;;
      esac
     fi
    fi #if [[ -n "$RAT_UPGRADE_LOC" ]]
  else
    validVersionDays=$(expr $diff_epoch / 60 / 60 / 24)
    validVersionDays=$(expr 120 - $validVersionDays)
  fi # if [[ -n "$diff_epoch" && $diff_epoch -gt 11232000 ]]
}

function write_asm_version_master ()
{
  if [ ${stack_asm_up[0]} -eq 1 ]
  then
    OLD_ORACLE_HOME=$ORACLE_HOME
    OLD_ORACLE_SID=$ORACLE_SID
    if [[ -n "$crs112" && $crs112 -ge 1 ]]
    then
      export ORACLE_SID=${stack_asm_sid[$stack_counter]}
      export ORACLE_HOME=$CRS
    else
      export ORACLE_HOME=${stack_asm_home[$stack_counter]}
      export ORACLE_SID=${stack_asm_sid[$stack_counter]}
    fi
    #$READ -p "IS_SYSDBA=$IS_SYSDBA ORACLE_HOME=$ORACLE_HOME and ORACLE_SID=$ORACLE_SID"
    # added 1=2 in first part of if to always fail because we never ask asm sysdba password and always login as / as sysdba
    if [[ -n $IS_SYSDBA && $IS_SYSDBA -eq 0 && 1 -eq 2 ]]
    then 
      #$READ -p "write asm version without asm sysdba"
      if [ `hostname|grep -c "\."` -ge 1 ]
      then
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  get_dbOwner

          STORE_VAL=`su $dbOwner -c "echo \"set feedback  off heading off
          select substr(lower(HOST_NAME),1,instr(lower(HOST_NAME),'.',1)-1)||'.'||INSTANCE_NAME||'.VERSION = '||VERSION from gv\\\\\\\$instance;\"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$"`

	  echo "$STORE_VAL" >> $MASTERFIL
	  cd $OLD_DIR
	  unset OLD_DIR
	else
          echo "set feedback  off heading off
          select substr(lower(HOST_NAME),1,instr(lower(HOST_NAME),'.',1)-1)||'.'||INSTANCE_NAME||'.VERSION = '||VERSION from gv\$instance;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^$>>$MASTERFIL
	fi
      else
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  get_dbOwner

          STORE_VAL=`su $dbOwner -c "echo \"set feedback  off heading off
          select lower(HOST_NAME)||'.'||INSTANCE_NAME||'.VERSION = '||VERSION from gv\\\\\\\$instance;\"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$"`

	  echo "$STORE_VAL" >> $MASTERFIL
	  cd $OLD_DIR
	  unset OLD_DIR
	else
          echo "set feedback  off heading off
          select lower(HOST_NAME)||'.'||INSTANCE_NAME||'.VERSION = '||VERSION from gv\$instance;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^$>>$MASTERFIL
	fi
      fi
    else
      if [ `hostname|grep -c "\."` -ge 1 ]
      then
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  get_dbOwner

	  STORE_VAL=`su $dbOwner -c "echo \"set feedback  off heading off
	  select substr(lower(HOST_NAME),1,instr(lower(HOST_NAME),'.',1)-1)||'.'||INSTANCE_NAME||'.VERSION = '||VERSION from gv\\\\\\\$instance;\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$"`
	  echo "$STORE_VAL" >> $MASTERFIL
	  cd $OLD_DIR
	  unset OLD_DIR
	else
          echo "set feedback  off heading off
          select substr(lower(HOST_NAME),1,instr(lower(HOST_NAME),'.',1)-1)||'.'||INSTANCE_NAME||'.VERSION = '||VERSION from gv\$instance;"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^$>>$MASTERFIL
	fi
      else
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  get_dbOwner

          STORE_VAL=`su $dbOwner -c "echo \"set feedback  off heading off
          select lower(HOST_NAME)||'.'||INSTANCE_NAME||'.VERSION = '||VERSION from gv\\\\\\\$instance;\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$"`
	  echo "$STORE_VAL" >> $MASTERFIL
	  cd $OLD_DIR
	  unset OLD_DIR
	else
          echo "set feedback  off heading off
          select lower(HOST_NAME)||'.'||INSTANCE_NAME||'.VERSION = '||VERSION from gv\$instance;"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^$>>$MASTERFIL
	fi
      fi
    fi
    export ORACLE_HOME=$OLD_ORACLE_HOME
    export ORACLE_SID=$OLD_ORACLE_SID

    if [[ $olsnodes_ssh_disabled -eq 1 ]];
    then
      tmp_client_host=""
      for mapping in ${hostmap[@]}
      do
        management_host=${mapping%%:*};
        client_host=${mapping#*:};
      	tmp_client_host=$(echo $client_host|awk -F"." '{print $1}');
        sed 's/'$tmp_client_host'\.+/'$management_host'\.+/' $MASTERFIL >$MASTERFIL.new
        mv $MASTERFIL.new $MASTERFIL
      done
    fi
  fi
}

# this fucntion to check the environment is set for uplaoding raccehck result to database or not
# modified by kumar
function upload_result_env_check ()
{
  if [[ -n "$1" && -n "$RAT_UPLOAD_USER"  && -n "$RAT_UPLOAD_PASSWORD" && -n "$RAT_UPLOAD_CONNECT_STRING" ]]
  then
    raccheck_upload_env_set=1
  else
    raccheck_upload_env_set=0
  fi
}

# this function is to check the database connectvity before uploading raccheck result to database at the end of the run
function upload_result_conn_check () 
{
  #$READ -p "raccheck_upload_env_set=$raccheck_upload_env_set"
  if [[ -n $raccheck_upload_env_set && $raccheck_upload_env_set -eq 1  ]]
  then
    if [ -n "$RAT_UPLOAD_ORACLE_HOME" ]
    then
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        OLD_OH=$ORACLE_HOME
	ORACLE_HOME=$RAT_UPLOAD_ORACLE_HOME
        get_dbOwner
	ORACLE_HOME=$OLD_OH
        upload_result_conn=$(su $dbOwner -c "echo \"set heading off
        select 1 from dual;\"|$RAT_UPLOAD_ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@\"$RAT_UPLOAD_CONNECT_STRING\" 2>&1|grep -v ^$")
	cd $OLD_DIR
 	unset OLD_DIR
      else
        upload_result_conn=$(echo "set heading off
        select 1 from dual;"|$RAT_UPLOAD_ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@"$RAT_UPLOAD_CONNECT_STRING" 2>>$ERRFIL|grep -v ^$)
      fi
    else
      if [[ -n $ORACLE_HOME ]]; then 
        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
          get_dbOwner
          upload_result_conn=$(su $dbOwner -c "echo \"set heading off
          select 1 from dual;\"|$ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@\"$RAT_UPLOAD_CONNECT_STRING\" 2>&1|grep -v ^$")
          cd $OLD_DIR
          unset OLD_DIR
        else
          upload_result_conn=$(echo "set heading off
          select 1 from dual;"|$ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@"$RAT_UPLOAD_CONNECT_STRING" 2>>$ERRFIL|grep -v ^$)
        fi
      fi
    fi
    if [[ `echo $upload_result_conn | grep -c "ORA-"` -ge 1 ]] || [[ -z $upload_result_conn ]]
    then 
      upload_result_conn_status=0
    else
      upload_result_conn_status=1
    fi
  fi
}

function upload_zip_file ()
{
  upload_result_env_check $RAT_ZIP_UPLOAD_TABLE
  upload_result_conn_check
  zip_data_upload_status=0
  
  OLD_RAT_UPLOAD_CONNECT_STRING=$RAT_UPLOAD_CONNECT_STRING
  RAT_UPLOAD_CONNECT_STRING=$(echo $RAT_UPLOAD_CONNECT_STRING|sed s'/=/\\=/g')
  if [ $raccheck_upload_env_set -eq 0 ]
  then
    zip_data_upload_status=1
  elif [ $upload_result_conn_status -eq 0 ]
  then
    zip_data_upload_status=2
  else
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      mkdir $TMP_OUTPUT/upload >/dev/null 2>&1; 
      mkdir $TMP_OUTPUT/log >/dev/null 2>&1;
      chmod -R 777 $TMP_OUTPUT/log >/dev/null 2>&1;

      LDRCTLFIL="$TMP_OUTPUT/upload/${program_name}_upload_zip_loader.ctl"
      LDRLOGFIL="$TMP_OUTPUT/log/${program_name}_upload_zip_loader.log"

      OLD_LDRCTLFIL="$OUTPUTDIR/upload/${program_name}_upload_zip_loader.ctl"
      OLD_LDRLOGFIL="$OUTPUTDIR/log/${program_name}_upload_zip_loader.log"
    else 
      LDRCTLFIL="$OUTPUTDIR/upload/${program_name}_upload_zip_loader.ctl"
      LDRLOGFIL="$OUTPUTDIR/log/${program_name}_upload_zip_loader.log"
    fi
    LDRCTLFIL_NEW="$OUTPUTDIR/upload/${program_name}_upload_zip_loader.ctl"
    LDRLOGFIL_NEW="$OUTPUTDIR/log/${program_name}_upload_zip_loader.log"

    echo "LOAD DATA" > $LDRCTLFIL
    echo "INFILE *" >> $LDRCTLFIL
    echo "INTO TABLE $RAT_ZIP_UPLOAD_TABLE" >> $LDRCTLFIL
    echo "APPEND" >> $LDRCTLFIL
    echo "FIELDS TERMINATED BY ','" >> $LDRCTLFIL
    echo "(" >> $LDRCTLFIL
    echo "FILENAME CHAR(100)," >> $LDRCTLFIL
    echo "FILE_BLOB LOBFILE (FILENAME) TERMINATED BY EOF," >> $LDRCTLFIL
    echo "ATTR1 CHAR(40)" >> $LDRCTLFIL
    echo ")" >> $LDRCTLFIL
    echo "BEGINDATA" >> $LDRCTLFIL
    echo `basename $1`,ZIP_FILE >> $LDRCTLFIL  

    if [ -n "$RAT_SQL_LOADER_HOME" ]
    then
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then

	OLD_OH=$ORACLE_HOME
	ORACLE_HOME=$RAT_SQL_LOADER_HOME
	get_dbOwner
	ORACLE_HOME=$OLD_OH

	DB_CONNECT_STRING=$RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@\"$OLD_RAT_UPLOAD_CONNECT_STRING\"
        su $dbOwner -c "$RAT_SQL_LOADER_HOME/bin/sqlldr \\\"$DB_CONNECT_STRING\\\" control=$LDRCTLFIL log=$LDRLOGFIL >/dev/null 2>&1"
        #su $dbOwner -c "$RAT_SQL_LOADER_HOME/bin/sqlldr $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@\"$RAT_UPLOAD_CONNECT_STRING\" control=$LDRCTLFIL log=$LDRLOGFIL >/dev/null 2>&1"

        move_files "$LDRCTLFIL" "$OLD_LDRCTLFIL" 
        move_files "$LDRLOGFIL" "$OLD_LDRLOGFIL"    
	cd $OLD_DIR
	unset OLD_DIR
      else
        $RAT_SQL_LOADER_HOME/bin/sqlldr $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@\"$RAT_UPLOAD_CONNECT_STRING\" control=$LDRCTLFIL log=$LDRLOGFIL >/dev/null 2>&1
      fi
    else
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	get_dbOwner

	DB_CONNECT_STRING=$RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@\"$OLD_RAT_UPLOAD_CONNECT_STRING\"
	su $dbOwner -c "$ORACLE_HOME/bin/sqlldr \\\"$DB_CONNECT_STRING\\\" control=$LDRCTLFIL log=$LDRLOGFIL >/dev/null 2>&1"
	#su $dbOwner -c "$ORACLE_HOME/bin/sqlldr $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@\"$RAT_UPLOAD_CONNECT_STRING\" control=$LDRCTLFIL log=$LDRLOGFIL >/dev/null 2>&1"

        move_files "$LDRCTLFIL" "$OLD_LDRCTLFIL" 
        move_files "$LDRLOGFIL" "$OLD_LDRLOGFIL"    
	cd $OLD_DIR
	unset OLD_DIR
      else
        $ORACLE_HOME/bin/sqlldr $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@\"$RAT_UPLOAD_CONNECT_STRING\" control=$LDRCTLFIL log=$LDRLOGFIL >/dev/null 2>&1
      fi
    fi

    if [ -r $LDRLOGFIL ]; then zip_upload_error=$(grep -wic '1 row successfully loaded' $LDRLOGFIL);fi
    if [[ -n "$zip_upload_error" && $zip_upload_error -gt 0 ]]
    then
      zip_data_upload_status=0
      zip_upload_message="\n\n${GREEN}${1} successfully uploaded to ${RAT_ZIP_UPLOAD_TABLE} table.${NORM}\n" 
    else
      zip_data_upload_status=3
      zip_upload_message="\n\n${RED}${1} file upload to database failed. check $LDRLOGFIL_NEW for more detail.\n\nLoad ${1} using $ORACLE_HOME/bin/sqlldr. SQL Loader controle file = $LDRCTLFIL_NEW${NORM}\n\n" 
    fi 
  fi
}

#Added by kumar
function insert_data_into_table ()
{
  sql_spool_file=$3
  upload_result_env_check $1
  upload_result_conn_check
  #$READ -p "RAT_UPLOAD_ORACLE_HOME=$RAT_UPLOAD_ORACLE_HOME and ORACLE_HOME=$ORACLE_HOME"
  if [ $raccheck_upload_env_set -eq 0 ] 
  then
    data_upload_status=1
  elif [ $upload_result_conn_status -eq 0 ]
  then
    data_upload_status=2
  else 
    if [ -n "$RAT_UPLOAD_ORACLE_HOME" ]
    then
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	OLD_OH=$ORACLE_HOME
	ORACLE_HOME=$RAT_UPLOAD_ORACLE_HOME
	get_dbOwner
	ORACLE_HOME=$OLD_OH
      
        su $dbOwner -c "$RAT_UPLOAD_ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@\"$RAT_UPLOAD_CONNECT_STRING\" >/dev/null 2>&1 <<EOF
 		     set head off
 		     set lines 80
 		     set serveroutput on
 		     spool $sql_spool_file
 		     @@$2
 		     spool off
 		     exit
EOF
"
	
	cd $OLD_DIR
	unset OLD_DIR
      else
        $RAT_UPLOAD_ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@"$RAT_UPLOAD_CONNECT_STRING"  >/dev/null 2>&1 <<EOF
 		     set head off
 		     set lines 80
 		     set serveroutput on
 		     spool $sql_spool_file
 		     @@$2
 		     spool off
 		     exit
EOF
      fi
    else
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	get_dbOwner

        su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@\"$RAT_UPLOAD_CONNECT_STRING\"  >/dev/null 2>&1 <<EOF
 		     set head off
 		     set lines 80
 		     set serveroutput on
 		     spool $sql_spool_file
 		     @@$2
 		     spool off
 		     exit
EOF
"
	cd $OLD_DIR
	unset OLD_DIR
      else
        $ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@"$RAT_UPLOAD_CONNECT_STRING"  >/dev/null 2>&1 <<EOF
 		     set head off
 		     set lines 80
 		     set serveroutput on
 		     spool $sql_spool_file
 		     @@$2
 		     spool off
 		     exit
EOF
      fi
    fi
    upload_error=$(grep -c "ORA-" $sql_spool_file)
    if [[ -n "$upload_error" && $upload_error -gt 0 ]]
    then
      data_upload_status=3
    else
      data_upload_status=0      
      if [ -n "$upload_pass_msg" ]
      then
        #upload_pass_msg2="and `cat $sql_spool_file|grep -i "1 row created" |wc -l|sed 's/ //g'` rows were added to $1 table.\n\n"
        upload_pass_msg2="and `grep -i "1 row created" $sql_spool_file |wc -l|sed 's/ //g'` rows were added to $1 table.\n\n"
      else   
        #upload_pass_msg="Uploading ${program_name} result to database was successfully. `cat $sql_spool_file|grep -i "1 row created" |wc -l|sed 's/ //g'` rows were added to $1 table.\n\n"
        upload_pass_msg="Uploading of ${program_name} result to database was successfull. `grep -i "1 row created" $sql_spool_file |wc -l|sed 's/ //g'` rows were added to $1 table.\n\n"
      fi
    fi            
  fi
}

#Added by Kumar
#following code is to get insert statements for installed patches into file
function insertStatementsForInstalledPatches ()
{
 l_version=$3;
 if [[ -n "$l_version" && `echo "$l_version"|grep -c "\."` -eq 0 ]]; then format_l_version; fi

 for host in `cat $HOSTLIST`
 do
  if [ -f $OUTPUTDIR/o_${1}_patchlist_${host}.out ]
  then
   for patch_no in `cat $OUTPUTDIR/o_${1}_patchlist_${host}.out`
   do
    if [[ -f $OUTPUTDIR/o_patch_result_${host}.out && $(grep -c $patch_no $OUTPUTDIR/o_patch_result_${host}.out) -ge 1 ]]
    then 
      echo "Do nothing" > /dev/null
    else
      if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
      then
        echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$host','$1','$2','$l_version','$patch_no','$cluster_name','null','null',1,0,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
      fi
    fi
   done
  fi
 done
}

uploadInstalledPatches ()
{
  installedPatchesFiles=$(find $OUTPUTDIR -name '*installed_patchlist*' -print)
  for installedPatchesFile in $(echo "$installedPatchesFiles")
  do
    installedPatchHostname=$(cat $installedPatchesFile|head -1|cut -d'|' -f1)
    installedPatchOracleHOmeType=$(cat $installedPatchesFile|head -1|cut -d'|' -f2)
    installedPatchOracleHOme=$(cat $installedPatchesFile|head -1|cut -d'|' -f3)
    installedPatchOracleHOmePath=$(echo $installedPatchOracleHOme|sed 's/\///g')
    installedPatchOracleHOmeVersion=$(cat $installedPatchesFile|head -1|cut -d'|' -f4)

    platform=`uname -s`
    if [ $platform = "SunOS" ]; then
      installedPatch_command=$(cat $installedPatchesFile|tail +2)
    else
      installedPatch_command=$(cat $installedPatchesFile|tail -n +2)
    fi

    #for installedPatch in $(cat $installedPatchesFile|tail -n +2)
    for installedPatch in $installedPatch_command
    do
      if [ "$installedPatchOracleHOmeType" = "crs" ]
      then
        installedPatchDescription=$(grep -w $installedPatch $OUTPUTDIR/o_${installedPatchOracleHOmeType}_inventory_${installedPatchHostname}.out| grep -wi description)
        if [ -z "$installedPatchDescription" ]
        then    
          installedPatchDescription=$(grep -w $installedPatch $OUTPUTDIR/o_${installedPatchOracleHOmeType}_inventory_${installedPatchHostname}.out|grep ^Patch)
        fi
      else
        installedPatchDescription=$(grep -w $installedPatch $OUTPUTDIR/o_${installedPatchOracleHOmeType}_inventory_${installedPatchOracleHOmePath}_${installedPatchHostname}.out| grep -wi description)
        if [ -z "$installedPatchDescription" ]
        then    
          installedPatchDescription=$(grep -w $installedPatch $OUTPUTDIR/o_${installedPatchOracleHOmeType}_inventory_${installedPatchOracleHOmePath}_${installedPatchHostname}.out|grep ^Patch)
        fi
      fi
      l_version=${installedPatchOracleHOmeVersion}
      if [[ -n "$l_version" && `echo "$l_version"|grep -c "\."` -eq 0 ]]; then format_l_version; fi

      echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'${installedPatchHostname}','${installedPatchOracleHOmeType}','${installedPatchOracleHOme}','${l_version}','$installedPatch','$cluster_name','$installedPatchDescription','Not Found',1,0,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
    done
  done

  if [ -e "$upload_raccheck_patch_result_fil" ]; then
    sort $upload_raccheck_patch_result_fil|uniq > $upload_raccheck_patch_result_fil.tmp
    mv $upload_raccheck_patch_result_fil.tmp $upload_raccheck_patch_result_fil
  fi
}

is_this_db_machine ()
{
  if [ $OFFLINE -eq 0 ]
  then
    if [ -f "/opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP" ]
    then
      db_machine_compute=1
      sunfire_x4270m2=0
      sunfire_x4270m3=0  
      is_avm_machine=0 
      dbm_vm=0
      decide_on_cpu=0
      if [ -e ${SYSTEM_DESC_FIL} ]
      then
        #sunfire_x4270m2=$(cat ${SYSTEM_DESC_FIL} 2>/dev/null|grep "SUN FIRE X4[1-2]70 M2"|wc -l)
        #sunfire_x4270m3=$(cat ${SYSTEM_DESC_FIL} 2>/dev/null|grep "SUN FIRE X4[1-2]70 M3"|wc -l) 
        #sunfire_x4270x4=$(cat ${SYSTEM_DESC_FIL} 2>/dev/null|grep "SUN SERVER X4-2"|wc -l) 
        sunfire_x4270m2=$(grep "SUN FIRE X4[1-2]70 M2" ${SYSTEM_DESC_FIL} 2>/dev/null|wc -l|tr -d ' ')
        sunfire_x4270m3=$(grep "SUN FIRE X4[1-2]70 M3" ${SYSTEM_DESC_FIL} 2>/dev/null|wc -l|tr -d ' ') 
        sunfire_x4270x4=$(grep "SUN SERVER X4-2" ${SYSTEM_DESC_FIL} 2>/dev/null|wc -l|tr -d ' ') 
        sunfire_x4270x5=$(grep "ORACLE SERVER X5-2" ${SYSTEM_DESC_FIL} 2>/dev/null|wc -l|tr -d ' ') 
      fi 
      if [[ ! -e ${SYSTEM_DESC_FIL} && -e ${SerialNumberFil} && $# -lt 2 ]]
      then
        #sed -e '/FRU Device Description[\t ]\+:[\t ]\+\/SYS/,/Product Name[\t ]\+:/!d;/Product Name[\t ]\+:/!d;s/Product Name[\t ]\+:[\t ]\+//g;' $SerialNumberFil | sort -u >$SYSTEM_DESC_FIL
        sed -e '/FRU Device Description[\t ]\+:[\t ]\+\/SYS/,/Product Name[\t ]\+:/!d;/Product Name[\t ]\+:/!d;s/Product Name[\t ]\+:[\t ]\+//g;' $SerialNumberFil | sort -u > ${RTEMPDIR}/cell_system_description.out
        #sunfire_x4270m2=$(cat ${SYSTEM_DESC_FIL} 2>/dev/null|grep "SUN FIRE X4[1-2]70 M2"|wc -l)
        #sunfire_x4270m3=$(cat ${SYSTEM_DESC_FIL} 2>/dev/null|grep "SUN FIRE X4[1-2]70 M3"|wc -l) 
        #sunfire_x4270x4=$(cat ${SYSTEM_DESC_FIL} 2>/dev/null|grep "SUN SERVER X4-2"|wc -l) 
        sunfire_x4270m2=$(grep "SUN FIRE X4[1-2]70 M2" ${SYSTEM_DESC_FIL} 2>/dev/null|wc -l|tr -d ' ')
        sunfire_x4270m3=$(grep "SUN FIRE X4[1-2]70 M3" ${SYSTEM_DESC_FIL} 2>/dev/null|wc -l|tr -d ' ') 
        sunfire_x4270x4=$(grep "SUN SERVER X4-2" ${SYSTEM_DESC_FIL} 2>/dev/null|wc -l|tr -d ' ') 
        sunfire_x4270x5=$(grep "ORACLE SERVER X5-2" ${SYSTEM_DESC_FIL} 2>/dev/null|wc -l|tr -d ' ') 
      fi  
      if [ -r $AVMIDFIL ]; then is_avm_machine=$(grep -iwc "<BACKUP_APPLIANCE>true</BACKUP_APPLIANCE>" $AVMIDFIL 2>/dev/null);fi
      if  [[ -n "$is_avm_machine" && $is_avm_machine -gt 0 ]]; then is_avm_machine=1;fi  
      print_compute_node=$(echo -e on ${BLINK}DATABASE SERVER${NORM})
      if [ -z "$platform" ]; then platform=$(uname -s);fi;

      if [ $platform = "Linux" ]
      then 
        #Change to support OL 6 where udevinfo does not exist
        if [ -x /usr/bin/udevinfo ]; then  dbm_status_v2=$(udevinfo -q all -p /sys/block/sda|grep -iq LSI;echo $?);else dbm_status_v2=0;fi 
        dbm_status_v1=$(ls /sys/block | grep -qi cciss;echo $?) 
        if [ "$1" = "$localnode" ]
        then  
          #no_of_cores=$(cat /proc/cpuinfo | grep -w "processor"|wc -l)
          if [ $is_exadata_dom0_machine -eq 0 ]
          then
              no_of_cores=$(grep -w "processor" /proc/cpuinfo |wc -l)
          else
              no_of_cores=$(/usr/sbin/xm info |grep -w nr_cpus|$AWK '{print $NF}')
          fi
          exadata_platform=$(uname -p) 
          cpu_model=$(grep -wi "Intel(R)" /proc/cpuinfo|sort -u|$AWK 'BEGIN{FS="CPU"}{print $2}'|$AWK 'BEGIN{FS="@"}{print $1}'|tr -d ' '|sed '/^$/d')
        else
          if [ $is_exadata_dom0_machine -eq 0 ]
          then
              no_of_cores=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 '/usr/sbin/xm info |grep -w nr_cpus')
              no_of_cores=$(echo "$no_of_cores"|$AWK '{print $NF}')
          else
              no_of_cores=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 'cat /proc/cpuinfo | grep -w "processor"|wc -l')
          fi
          exadata_platform=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 'uname -p')
          remote_cpuinfo=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 'cat /proc/cpuinfo | grep -wi "Intel(R)"|sort -u')
          cpu_model=$(echo "$remote_cpuinfo"|$AWK 'BEGIN{FS="CPU"}{print $2}'|$AWK 'BEGIN{FS="@"}{print $1}'|tr -d ' '|sed '/^$/d')
        fi
      else
        dbm_status_v2=0
        dbm_status_v1=1
        if [ "$1" = "$localnode" ]
        then 
          no_of_cores=$(/sbin/psrinfo|wc -l|tr -d ' ')
          exadata_platform=$(uname -p) 
          cpu_model=$(/usr/sbin/prtconf -v 2>/dev/null|grep -wi "Intel(R)"|sort -u|$AWK 'BEGIN{FS="CPU"}{print $2}'|$AWK 'BEGIN{FS="@"}{print $1}'|tr -d ' '|sed '/^$/d')
        else
          no_of_cores=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 '/sbin/psrinfo|wc -l|tr -d ' '')
          exadata_platform=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 'uname -p')
          remote_prtconf=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 '/usr/sbin/prtconf -v 2>/dev/null|grep -wi "Intel(R)"|sort -u')
          cpu_model=$(echo "$remote_prtconf"|$AWK 'BEGIN{FS="CPU"}{print $2}'|$AWK 'BEGIN{FS="@"}{print $1}'|tr -d ' '|sed '/^$/d')
        fi
      fi
      if [ -e $CELLIP ]; then no_of_cells=$(grep "cell=" $CELLIP|grep -v ^#|wc -l|tr -d ' ');fi
      it_is_rac=0
      if [ -n "$no_of_cells" ] && [[ $no_of_cells -eq 3 || $no_of_cells -eq 4 ]]
      then
        EXADATA_RACK=QUARTER
      elif [[ -n "$no_of_cells" && $no_of_cells -eq 7 ]]
      then
        EXADATA_RACK=HALF
      elif [[ -n "$no_of_cells" && $no_of_cells -ge 14 ]]
      then
        EXADATA_RACK=FULL
      fi
      if [ $is_exadata_dom0_machine -eq 1 ]; then add_vm_module="VM";else add_vm_module="";fi
      if [[ $is_exadata_dom0_machine -eq 1 || $is_ssc_globalzone_machine -eq 1 || $is_ssc_localzone_machine -eq 1 || $is_ssc_globalzone_dbmachine -eq 1  || "$HOSTTYPE" = "BAREMETAL" ]]
      then
          decide_on_cpu=1
      fi
      if [[ $dbm_status_v2 -eq 0 && $dbm_status_v1 -eq 1 && $decide_on_cpu -eq 1 ]]
      then
        #if [[ $no_of_cores -eq 16 && $sunfire_x4270m3 -ge 1  && "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        if [[ "$cpu_model" = "E5-26900" && $no_of_cores -eq 16  && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then
          dbm_v1=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_v2=0
          dbm_x3_2=1
          EXADATA_VERSION="EIGHTH RACK"
          EXADATA_RACK="EIGHTH RACK"
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:EIGHTH:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGREIGHTH)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGREIGHTH)
          fi
        #elif [[ $no_of_cores -eq 24 && $sunfire_x4270x4 -ge 1  && "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        elif [[ "$cpu_model" = "E5-2697v2" && $no_of_cores -eq 24 && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then
          dbm_v1=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_v2=0
          dbm_x3_2=1
          EXADATA_VERSION="EIGHTH RACK"
          EXADATA_RACK="EIGHTH RACK"
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:EIGHTHX4-2:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGREIGHTHX4-2)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGREIGHTHX4-2)
          fi
        #elif [[ $no_of_cores -eq 36 && $sunfire_x4270x5 -ge 1  && "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        elif [[ "$cpu_model" = "E5-2699v3" && $no_of_cores -eq 36  && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then
          dbm_v1=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_v2=0
          dbm_x3_2=1
          EXADATA_VERSION="EIGHTH RACK"
          EXADATA_RACK="EIGHTH RACK"
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:EIGHTHX5-2:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGREIGHTHX5-2)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGREIGHTHX5-2)
          fi

        #elif [[ $no_of_cores -gt 16 && $no_of_cores -le 24 && $sunfire_x4270m3 -ge 1 && "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        elif [[ "$cpu_model" = "E5-26900"  && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then
          #This branch is to cover IAAS where X3-2 will run in reduced capacity 
          dbm_v1=0
          dbm_v2=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_x3_2=1
          EXADATA_VERSION="X3-2" 
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:${add_vm_module}X3-2:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGRX3-2)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGRX3-2)
          fi
        #elif [[ $no_of_cores -gt 16 && $no_of_cores -le 24 && $sunfire_x4270m2 -ge 1 ]]
        #elif [[ $no_of_cores -gt 16 && $no_of_cores -le 24 && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc"  ]] 
        elif [[ "$cpu_model" = "X5670" || "$cpu_model" = "X5675" ]] && [[ -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc"  ]] 
        then
          dbm_v1=0
          dbm_v2=0
          dbm_x2_2=1
          dbm_x2_8=0
          dbm_x3_2=0
          EXADATA_VERSION="X2-2" 
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:${add_vm_module}X2-2:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGRX2-2)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGRX2-2)
          fi
        #elif [[ $no_of_cores -gt 24 && $no_of_cores -le 32 && "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        elif [[ "$cpu_model" = "E5-26900" && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then
          dbm_v1=0
          dbm_v2=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_x3_2=1
          EXADATA_VERSION="X3-2" 
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:${add_vm_module}X3-2:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGRX3-2)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGRX3-2)
          fi 
        #elif [[ $no_of_cores -gt 32 && $no_of_cores -le 48 && "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        elif [[ "$cpu_model" = "E5-2697v2" && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then
          dbm_v1=0
          dbm_v2=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_x3_2=1
          EXADATA_VERSION="X4-2"
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:${add_vm_module}X4-2:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGRX4-2)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGRX4-2)
          fi 
        #elif [[ $no_of_cores -gt 48 && $no_of_cores -le 72 && "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        elif [[ "$cpu_model" = "E5-2699v3" && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then
          dbm_v1=0
          dbm_v2=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_x3_2=1
          EXADATA_VERSION="X5-2"
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:${add_vm_module}X5-2:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGRX5-2)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGRX5-2)
          fi
        #if [[ $no_of_cores -ge 240  ]]
        elif [[ "$cpu_model" = "E7-8895v2" && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then 
	     dbm_v1=0
	     dbm_v2=0
	     dbm_x2_2=0
	     dbm_x2_8=1
	     dbm_x3_2=0
	     EXADATA_VERSION="X4-8"
	    if  [ $upgrade_mode -eq 0 ]
	    then
	      components=$(echo ${user_components}:${add_vm_module}X4-8:MAA)
	    elif [ $upgrade_mode -eq 2 ]
	    then
	      components=$(echo ${components}|sed 's/PREUPGR://g')
	      components=$(echo ${components}:PREUPGRX4-8)
	    elif [ $upgrade_mode -eq 3 ]
	    then
	      components=$(echo ${components}|sed 's/POSTUPGR://g')
	      components=$(echo ${components}:POSTUPGRX4-8)
	    fi
       #elif [[ $no_of_cores -ge 160  ]]
        elif [[ "$cpu_model" = "X5-8CPUTYPE" && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then 
	     dbm_v1=0
	     dbm_v2=0
	     dbm_x2_2=0
	     dbm_x2_8=1
	     dbm_x3_2=0
	     EXADATA_VERSION="X5-8"
	    if  [ $upgrade_mode -eq 0 ]
	    then
	      components=$(echo ${user_components}:${add_vm_module}X4-8:MAA)
	    elif [ $upgrade_mode -eq 2 ]
	    then
	      components=$(echo ${components}|sed 's/PREUPGR://g')
	      components=$(echo ${components}:PREUPGRX5-8)
	    elif [ $upgrade_mode -eq 3 ]
	    then
	      components=$(echo ${components}|sed 's/POSTUPGR://g')
	      components=$(echo ${components}:POSTUPGRX5-8)
	    fi

        elif [[ "$cpu_model" = "E7-8870" && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then 
             dbm_v1=0
	     dbm_v2=0
	     dbm_x2_2=0
	     dbm_x2_8=1
	     dbm_x3_2=0
	     EXADATA_VERSION="X3-8"
	    if  [ $upgrade_mode -eq 0 ]
	    then
	      components=$(echo ${user_components}:X3-8:MAA)
	    elif [ $upgrade_mode -eq 2 ]
	    then
	      components=$(echo ${components}|sed 's/PREUPGR://g')
	      components=$(echo ${components}:PREUPGRX3-8)
	    elif [ $upgrade_mode -eq 3 ]
	    then
	      components=$(echo ${components}|sed 's/POSTUPGR://g')
	      components=$(echo ${components}:POSTUPGRX3-8)
	    fi
        elif [[ "$cpu_model" = "X7560" && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc"  ]] 
        then
             dbm_v1=0
	     dbm_v2=0
	     dbm_x2_2=0
	     dbm_x2_8=1
	     dbm_x3_2=0
	     EXADATA_VERSION="X2-8"
	    if  [ $upgrade_mode -eq 0 ]
	    then
	      components=$(echo ${user_components}:X2-8:MAA)
	    elif [ $upgrade_mode -eq 2 ]
	    then
	      components=$(echo ${components}|sed 's/PREUPGR://g')
	      components=$(echo ${components}:PREUPGRX2-8)
	    elif [ $upgrade_mode -eq 3 ]
	    then
	      components=$(echo ${components}|sed 's/POSTUPGR://g')
	      components=$(echo ${components}:POSTUPGRX2-8)
	    fi
        elif [[ "$exadata_platform" = "sparc" ]]
        then
          dbm_v1=0
          dbm_v2=0
          dbm_x2_2=0
          dbm_x2_8=1
          dbm_x3_2=0
          #added this branch to support X4-2 storage servers on super cluster      
          if [[ $sunfire_x4270x5 -eq 1 && $is_ssc_localzone_machine -eq 0 ]]
          then
            if  [ $upgrade_mode -eq 0 ]
            then
              EXADATA_VERSION="SUPERCLUSTER"
       	      components=$(echo ${user_components}:SUPERCLUSTERX4-2:MAA)
              is_ssc_machine=1 
       	    elif [ $upgrade_mode -eq 2 ]
       	    then
       	      components=$(echo ${components}|sed 's/PREUPGR://g')
       	      components=$(echo ${components}:PREUPGRSUPERCLUSTER)
       	    elif [ $upgrade_mode -eq 3 ]
       	    then
       	      components=$(echo ${components}|sed 's/POSTUPGR://g')
       	      components=$(echo ${components}:POSTUPGRSUPERCLUSTER)
       	    fi
          elif [[ $sunfire_x4270x4 -eq 1 && $is_ssc_localzone_machine -eq 0 ]]
          then
            if  [ $upgrade_mode -eq 0 ]
            then
              EXADATA_VERSION="SUPERCLUSTER"
       	      components=$(echo ${user_components}:SUPERCLUSTERX4-2:MAA)
              is_ssc_machine=1 
       	    elif [ $upgrade_mode -eq 2 ]
       	    then
       	      components=$(echo ${components}|sed 's/PREUPGR://g')
       	      components=$(echo ${components}:PREUPGRSUPERCLUSTER)
       	    elif [ $upgrade_mode -eq 3 ]
       	    then
       	      components=$(echo ${components}|sed 's/POSTUPGR://g')
       	      components=$(echo ${components}:POSTUPGRSUPERCLUSTER)
       	    fi
            #added this branch to support X3-2 storage servers on super cluster      
          elif [[ $sunfire_x4270m3 -eq 1 && $is_ssc_localzone_machine -eq 0 ]]
       	  then
       	    if  [ $upgrade_mode -eq 0 ]
       	    then
       	      EXADATA_VERSION="SUPERCLUSTER"
       	      components=$(echo ${user_components}:SUPERCLUSTERX3-2:MAA)
       	      is_ssc_machine=1 
       	    elif [ $upgrade_mode -eq 2 ]
       	    then
       	      components=$(echo ${components}|sed 's/PREUPGR://g')
       	      components=$(echo ${components}:PREUPGRSUPERCLUSTER)
       	    elif [ $upgrade_mode -eq 3 ]
       	    then
       	      components=$(echo ${components}|sed 's/POSTUPGR://g')
       	      components=$(echo ${components}:POSTUPGRSUPERCLUSTER)
       	    fi
            #X3-2 storage server support for supercluster code ends her  
            
          elif [[ $sunfire_x4270x4 -eq 0 && $sunfire_x4270m3 -eq 0 && $is_ssc_localzone_machine -eq 0 ]]
       	  then
       	    if  [ $upgrade_mode -eq 0 ]
       	    then
       	      EXADATA_VERSION="SUPERCLUSTER"
       	      components=$(echo ${user_components}:SUPERCLUSTER:MAA)
       	      is_ssc_machine=1 
       	    elif [ $upgrade_mode -eq 2 ]
       	    then
       	      components=$(echo ${components}|sed 's/PREUPGR://g')
       	      components=$(echo ${components}:PREUPGRSUPERCLUSTER)
       	    elif [ $upgrade_mode -eq 3 ]
       	    then
       	      components=$(echo ${components}|sed 's/POSTUPGR://g')
       	      components=$(echo ${components}:POSTUPGRSUPERCLUSTER)
       	    fi
          elif [[ $is_ssc_localzone_machine -eq 1 ]] 
          then
            if  [ $upgrade_mode -eq 0 ]
       	    then
       	      EXADATA_VERSION="SUPERCLUSTER"
       	      components=$(echo ${user_components}:SUPERCLUSTERVM:MAA)
       	      is_ssc_machine=1 
       	    elif [ $upgrade_mode -eq 2 ]
       	    then
       	      components=$(echo ${components}|sed 's/PREUPGR://g')
       	      components=$(echo ${components}:PREUPGRSUPERCLUSTER)
       	    elif [ $upgrade_mode -eq 3 ]
       	    then
       	      components=$(echo ${components}|sed 's/POSTUPGR://g')
       	      components=$(echo ${components}:POSTUPGRSUPERCLUSTER)
       	    fi
            #X3-2 storage server support for supercluster code ends her  
            #fi Need to check why its extra
          fi
        elif [[ $no_of_cores -gt 16 && $no_of_cores -le 32 && $sunfire_x4270m2 -eq 0  && $sunfire_x4270m2 -eq 0 && "$platform" = "SunOS" ]]
        then
          #this branch is to cover when storage server are skipped and serial number file is not found on database server  
          dbm_v1=0
          dbm_v2=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_x3_2=1
          EXADATA_VERSION="X3-2" 
          if  [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:X3-2:MAA)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGRX3-2)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGRX3-2)
          fi
        elif [[ -n "$is_avm_machine" &&  $is_avm_machine -eq 1 ]] 
        then
          dbm_v1=0
          dbm_x2_2=0
          dbm_x2_8=0
          dbm_v2=0
          AVM_VERSION="X3-2"
          dbm_x3_2=1
          if [ $upgrade_mode -eq 0 ]
          then
            components=$(echo ${user_components}:AVM)
          elif [ $upgrade_mode -eq 2 ]
          then
            components=$(echo ${components}|sed 's/PREUPGR://g')
            components=$(echo ${components}:PREUPGRAVM)
          elif [ $upgrade_mode -eq 3 ]
          then
            components=$(echo ${components}|sed 's/POSTUPGR://g')
            components=$(echo ${components}:POSTUPGRAVM)
          fi 
        elif [[ "$cpu_model" = "E5540" && -n "$is_avm_machine" &&  $is_avm_machine -eq 0 && "$exadata_platform" != "sparc" ]]
        then
            dbm_v1=0
       	    dbm_x2_2=0
       	    dbm_x2_8=0
       	    dbm_v2=1
       	    EXADATA_VERSION="V2"
       	    dbm_x3_2=0
       	    if [ $upgrade_mode -eq 0 ]
       	    then
       	      components=$(echo ${user_components}:EXADATA:MAA)
       	    elif [ $upgrade_mode -eq 2 ]
       	    then
       	      components=$(echo ${components}|sed 's/PREUPGR://g')
       	      components=$(echo ${components}:PREUPGRDBM)
       	    elif [ $upgrade_mode -eq 3 ]
       	    then
       	      components=$(echo ${components}|sed 's/POSTUPGR://g')
       	      components=$(echo ${components}:POSTUPGRDBM)
       	    fi
        else
           #Added this condition so if exachk misclasify exadata hardware and end up thinking that its V2 but its not actually V2 than exit if -c command line is not used
           if [ -z "$options_components" ]
           then   
	     if [[ $EM_PROBE_MODE -eq 1 ]]
	     then
	       EMSG="$program_name is not able to determine Exadata Hardware type. Please use -c option to specify hardware type like ./${program_name} -c X4-2,MAA."
	       update_probe_xml "ERROR" "GENERIC" "$EMSG"
	     fi
	     echo -e "${RED}$program_name is not able to determine Exadata Hardware type. Please use -c option to specify hardware type like ./${program_name} -c X4-2,MAA.${NORM}"
	     exit 1
           else
             #-c command line was used to override modules so making it some kind of exadata
             dbm_v1=0
             dbm_v2=0
             dbm_x2_2=0
             dbm_x2_8=1
             dbm_x3_2=0
           fi
        fi
      elif [[ $dbm_status_v2 -eq 1 && $dbm_status_v1 -eq 0 && $HOSTTYPE = "BAREMETAL" ]]
      then
        dbm_x2_2=0
        dbm_x2_8=0
        dbm_v1=1
        dbm_v2=0
        EXADATA_VERSION=V1
      elif [[ $HOSTTYPE = "XENDOMU" ]]
      then
         dbm_x2_2=0
         dbm_x2_8=0
         dbm_vm=1
         dbm_v2=0
         dbm_v1=0
         dbm_x3_2=0
         EXADATA_VERSION="EXADATA-GUEST"
         if [ $upgrade_mode -eq 0 ]
         then
           components=$(echo ${user_components}:EDVM:MAA)
         elif [ $upgrade_mode -eq 2 ]
         then
           components=$(echo ${components}|sed 's/PREUPGR://g')
           components=$(echo ${components}:PREUPGREDVM)
         elif [ $upgrade_mode -eq 3 ]
         then
           components=$(echo ${components}|sed 's/POSTUPGR://g')
           components=$(echo ${components}:POSTUPGREDVM)
         fi 
      fi
    else 
       print_compute_node=""
       db_machine_compute=0
       dbm_v1=0
       dbm_v2=0
       dbm_x2_2=0
       dbm_x2_8=0
       if [[ -n "$oda_machine" && $oda_machine -eq 1 ]]
       then 
         it_is_rac=0
       elif [[ -n "$single_instance_run" && $single_instance_run -eq 1 ]]
       then
         it_is_rac=0
       else 
         it_is_rac=1
       fi 
       dbm_x3_2=0 
       dbm_vm=0 
       if [[ $upgrade_mode -eq 0 && "$components" = "NONE" ]]; then components=$(echo ${components}:RACCHECK:MAA);fi
    fi
  fi
  #If its running on Exadata DOM0 then change component for DOM0 by adding VM
  if [ -n "$options_components" ]; then components=$final_components;fi
  #$READ -p "see values in $components"
}

#Function to write Exadata components in env file. This function was added because exadata discover function will be called for each node
write_db_machine_info_to_envfile ()
{
  if [ $OFFLINE -eq 0 ]
  then
    echo "${1}.EXADATA_COMPUTE = $db_machine_compute">>$MASTERFIL
    echo "${1}.EXADATA_DBMV1 = $dbm_v1">>$MASTERFIL
    echo "${1}.EXADATA_DBMV2 = $dbm_v2">>$MASTERFIL
    echo "${1}.EXADATA_DBM_X2_2 = $dbm_x2_2">>$MASTERFIL
    echo "${1}.EXADATA_DBM_X2_8 = $dbm_x2_8">>$MASTERFIL
    echo "${1}.EXADATA_DBM_X3_2 = $dbm_x3_2">>$MASTERFIL
    echo "${1}.EXADATA_RACK = $EXADATA_RACK">>$MASTERFIL
    echo "${1}.EXADATA_VERSION = $EXADATA_VERSION">>$MASTERFIL
    echo "${1}.IT_IS_RAC = $it_is_rac">>$MASTERFIL
    echo "${1}.COMPONENTS = $components" >>$MASTERFIL
    echo "${1}.IS_AVM_MACHINE = $is_avm_machine">>$MASTERFIL
    echo "db_machine_compute=$db_machine_compute dbm_status_v2=$dbm_status_v2 dbm_status_v1=$dbm_status_v1 dbm_v1=$dbm_v1 dbm_v2=$dbm_v2">> $LOGFIL
  else
    db_machine_compute=$(grep ${1}.EXADATA_COMPUTE $DUMPDIR/$CHKFIL|awk '{print $3}')
    dbm_v1=$(grep ${1}.EXADATA_DBMV1 $DUMPDIR/$CHKFIL|awk '{print $3}')
    dbm_v2=$(grep ${1}.EXADATA_DBMV2 $DUMPDIR/$CHKFIL|awk '{print $3}')
    dbm_x2_2=$(grep ${1}.EXADATA_DBM_X2_2 $DUMPDIR/$CHKFIL|awk '{print $3}')
    dbm_x2_8=$(grep ${1}.EXADATA_DBM_X2_8 $DUMPDIR/$CHKFIL|awk '{print $3}')
    it_is_rac=$(grep ${1}.IT_IS_RAC $DUMPDIR/$CHKFIL|awk '{print $3}')
    is_avm_machine=$(grep ${1}.IS_AVM_MACHINE $DUMPDIR/$CHKFIL|awk '{print $3}')
    dbm_x3_2=$(grep ${1}.EXADATA_DBM_X3_2 $DUMPDIR/$CHKFIL|awk '{print $3}')
    EXADATA_RACK=$(grep ${1}.EXADATA_RACK $DUMPDIR/$CHKFIL|awk '{print $3}')
    EXADATA_VERSION=$(grep ${1}.EXADATA_VERSION $DUMPDIR/$CHKFIL|head -1|awk '{print $3}')
    components=$(grep ${1}.COMPONENTS $DUMPDIR/$CHKFIL|head -1|awk '{print $3}')  
  fi
  #$READ -p "see values in $components"
}

ports_find_sid ()
{
  case `/bin/uname` in
    Linux)
      #$READ -p "db_name_to_check=$db_name_to_check"
      oSID=$(ps -ef |grep pmon_${db_name_to_check}|grep -v grep|awk '{print $8}'|cut -d_ -f3)
      bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`
      ;;
    SunOS)
      oSID=$(ps -ef |grep pmon_${db_name_to_check}|grep -v grep|awk '{print $9}'|cut -d_ -f3)
      bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $9'}`
      if [ -z "$oSID" ]; then  oSID=$(ps -ef |grep pmon_${db_name_to_check}|grep -v grep|awk '{print $8}'|cut -d_ -f3);fi;
      if [ -z "$bgproc" ]; then  bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`;fi
      #$READ -p "oSID=$oSID and db_name_to_check=$db_name_to_check"
      ;;
    HP-UX) 
      oSID=$(ps -ef |grep pmon_${db_name_to_check}|grep -v grep|awk '{print $9}'|cut -d_ -f3)
      bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $9'}`
      if [ -z "$bgproc" ]; then  bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`;fi
      ;;
    AIX)  
      oSID=$(ps -ef |grep pmon_${db_name_to_check}|grep -v grep|awk '{print $9}'|cut -d_ -f3)
      bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $9'}`
      if [ -z "$bgproc" ]; then  bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`;fi
      ;;
    *) 
      /bin/echo "ERROR: Unknown Operating System"
      exit -1
      ;;
  esac
}

function GetMachineRole()
{
  if [ $OFFLINE -eq 0 ]
  then
    HOSTTYPE=BAREMETAL; ROLE="";VMTYPE="NONE";
    if [ -d /proc/xen ]
    then
      if grep -q "control_d" /proc/xen/capabilities > /dev/null 2>&1
      then
        HOSTTYPE=XENDOM0
      else
        HOSTTYPE=XENDOMU
        #xblk=`/sbin/lsmod |grep -i xenblk`
        #xnet=`/sbin/lsmod |grep -i xennet`
        xblk=`/sbin/lsmod |egrep -i 'xenblk|xen_blkfront'`
        xnet=`/sbin/lsmod |egrep -i 'xennet|xen_netfront'`   
        if [[ -n $xblk && -n $xnet ]]
        then
          VMTYPE=PVM
        else
          VMTYPE=HVM_PVHVM
        fi
      fi
    fi

    if grep "Oracle VM server release 2.2" /etc/ovs-release > /dev/null 2>&1
    then
      OVMSERVER=`cat /etc/ovs-release`
      ROLE="OVMSERVER" # will include 2.2.1
    elif rpm --quiet -q ovs-manager > /dev/null 2>&1
    then
      ROLE="OVMMANAGER"
    elif [ -f /etc/enterprise-release ]
    then
      GENERIC="`cat /etc/enterprise-release`"
      ROLE="GENERIC"
    elif [ -f /etc/redhat-release ]
      then GENERIC="`cat /etc/redhat-release`"
      ROLE="GENERIC"
    else
      ROLE="Not_Supported"
      return 1 # not a RH, EL or Fedora based distro... maybe someday, but not today
    fi
    echo "HOST_ROLE = "$ROLE >>$MASTERFIL
    echo "HOST_TYPE = "$HOSTTYPE >>$MASTERFIL
    echo "VM_TYPE = "$VMTYPE >>$MASTERFIL
  else
    ROLE=$(grep HOST_ROLE $DUMPDIR/$CHKFIL|awk '{print $3}')
    HOSTTYPE=$(grep HOST_TYPE $DUMPDIR/$CHKFIL|awk '{print $3}')
    VMTYPE=$(grep VM_TYPE $DUMPDIR/$CHKFIL|awk '{print $3}')
  fi
  #echo "HOST_ROLE = $ROLE  HOST_TYPE = $HOSTTYPE VM_TYPE = $VMTYPE"
}

function killtree() {
  local _pid=$1
  local _sig=${2-TERM}
  kill -stop ${_pid}
  for _child in $(ps -ef |awk '$3 == '${_pid}' {print $2}'); do 
     killtree ${_child} ${_sig}
  done
  kill -${_sig} ${_pid}
}

cleanup () 
{
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then umask ${oumask} >/dev/null; fi

  if [[ -n "$initexit" && "$initexit" -eq "-1" ]]; then return; fi
  old_IFS=$IFS
  unset IFS

  update_zip_files

  if [[ ! -n "$RAT_KEEP_PASSWORD_IN_DEBUG" && -f "$RAT_DEBUG_FILENAME_INTERNAL" && ! -f "$RAT_DEBUG_FILENAME_INTERNAL.orig" ]] ; then
    if [[ -n "$RAT_KEEP_ORIG_DEBUG_FILE" && $RAT_KEEP_ORIG_DEBUG_FILE -eq "1" ]] ; then
      cp $RAT_DEBUG_FILENAME_INTERNAL $RAT_DEBUG_FILENAME_INTERNAL.orig
    fi
    remove_passwords_in_debug;
  fi

  if [[ $RAT_RUNMODE_INTERNAL = "slave" ]] ; then
    child_pid=$(ps -ef |grep "$watchdog_pid"|grep -v 'grep'|grep -w 'sleep'|awk '{print $2}'|sed 's/ //g')
    kill $watchdog_pid > /dev/null 2>&1
    if [[ -n "$child_pid" ]] ; then kill $child_pid > /dev/null 2>&1;fi   
    #kill $watchdog_pid > /dev/null 2>&1
    return;
  fi

  tty -s && stty echo

  if [ -e "$ROOT_LCKFIL" ] ; then rm -f $ROOT_LCKFIL >/dev/null 2>&1; fi
  if [[ -d $INPUTDIR && -z "$RAT_NOCLEAN_DIR" ]]
  then 
    # if it's run from NFS in Exalogic Machine, need to kill watchdog.sh first to delete .input dir
    if [ $is_exalogic_machine -eq 1 ]; then wrkdir_filesystem_type=$(stat -f -L -c %T $(echo $WRKDIR));fi
    #wrkdir_filesystem_type=$(stat -f -L -c %T $(echo $WRKDIR))
    if [[ $is_exalogic_machine -eq 1 && "$wrkdir_filesystem_type" = "nfs" ]]
    then
      child_pid=$(ps -ef |grep $watchdog_pid|grep -v 'grep'|grep 'sleep'|awk '{print $2}'|sed 's/ //g')
      kill $watchdog_pid > /dev/null 2>&1
      if [[ -n "$child_pid" ]] ; then   kill $child_pid > /dev/null 2>&1;fi 
      #kill $watchdog_pid > /dev/null 2>&1
    fi
    rm -rf $INPUTDIR >/dev/null 2>&1
  fi
  if [[ -n "$RAT_CELL_RUNMODE" && $RAT_CELL_RUNMODE = "parallel" ]] ; then
    saved_errfil=$ERRFIL
    ERRFIL=/dev/null
    on_signal_cell_cleanup;
    ERRFIL=$saved_errfil
  fi
  if [[ -n "$RAT_IBSWITCH_RUNMODE" && $RAT_IBSWITCH_RUNMODE = "parallel" ]] ; then
    saved_errfil=$ERRFIL
    ERRFIL=/dev/null
    on_signal_ib_cleanup;
    ERRFIL=$saved_errfil
  fi

  if [[ -n "$RAT_COMPUTE_RUNMODE" && $RAT_COMPUTE_RUNMODE = "parallel" ]]
  then
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      saved_errfil=$OLD_ERRFIL
    else
      saved_errfil=$ERRFIL
    fi
    ERRFIL=/dev/null
    on_signal_compute_cleanup;
    ERRFIL=$saved_errfil
  fi

  if [ -d "$TMPDIR/report1_$$" ]; then rm -rf $TMPDIR/report1_$$ >/dev/null 2>&1; fi
  if [ -d "$TMPDIR/report2_$$" ]; then rm -rf $TMPDIR/report2_$$ >/dev/null 2>&1; fi

  if [ -e "$HOSTLIST.org" ] ; then mv $HOSTLIST.org $HOSTLIST; fi

  if [[ -n "$delete_lock_file" && $delete_lock_file -eq 0 ]]
  then
    if [ -d $RTEMPDIR ]; then rm -rf $RTEMPDIR >/dev/null 2>&1; fi; 
    if [ -e $LOCKFIL ]; then rm $LOCKFIL >/dev/null 2>&1; fi;

    SYSTEMD_USED=0; SYSTEMD_USED=`ps -ef |grep systemd|head -1|awk '{print $2}'|sed 's/ //g'`

    if [[ -e "${RATENV_FIL}" && $SYSTEMD_USED -eq 0 ]] || [[ -e "${RATENV_FIL}" && -n "$setup_inittab" && $setup_inittab -eq "10" && $SYSTEMD_USED -gt 0 ]]; then 
      rm -f ${RATENV_FIL} >/dev/null 2>&1;
    fi;

    if [ -e  $HOSTLIST ]
    then
      for hname in `cat $HOSTLIST`
      do
        if [ $hname = $localnode ]
        then

          rm -f ${RTEMPDIR}/o_*.out >/dev/null 2>&1 # gadiga - not needed as dir is already purged
          if [ -e $EXADATA_CELL_COLLECTIONS ]; then rm -f $EXADATA_CELL_COLLECTIONS >/dev/null 2>&1; fi;
          if [ -e $TMPDIR/raccheck_env.out ]; then  rm -f $TMPDIR/raccheck_env.out >/dev/null 2>&1; fi;
          if [ -e $TMPDIR/CellFlashCacheMode.out ]; then  rm -f $TMPDIR/CellFlashCacheMode.out >/dev/null 2>&1; fi;
          if [ -e $TMPDIR/set_orcl_env.sh ]; then rm -f $TMPDIR/set_orcl_env.sh >/dev/null 2>&1;fi;
          if [ -e $ROOTSCRPT ]; then rm -f $ROOTSCRPT >/dev/null 2>&1;fi;
          #if [ -e /tmp/cprofile.sh ]; then rm -f /tmp/cprofile.sh >/dev/null 2>&1;fi;
          if [ -e $TMPDIR/mail.out ]; then rm -f $TMPDIR/mail.out >/dev/null 2>&1;fi;
          if [ -e "${TMP_RATENV_FIL}" ]; then rm -f ${TMP_RATENV_FIL} >/dev/null 2>&1;fi;
          #if [ -e "${RATENV_FIL}" ]; then rm -f ${RATENV_FIL} >/dev/null 2>&1; fi;
    	  if [[ -e "${RATENV_FIL}" && $SYSTEMD_USED -eq 0 ]] || [[ -e "${RATENV_FIL}" && -n "$setup_inittab" && $setup_inittab -eq "10" && $SYSTEMD_USED -gt 0 ]]; then rm -f ${RATENV_FIL} >/dev/null 2>&1; fi;
          if [ -e "${TMPSTFILE}" ]; then rm -f ${TMPSTFILE} >/dev/null 2>&1;fi;
          rm -f $TMPDIR/o_root_clusterwide_check*.out >/dev/null 2>&1
          if [ -e $RTEMPDIR/cells.out ]; then rm $RTEMPDIR/cells.out >/dev/null 2>&1;fi
          if [ -e ${PROBE_XML}.tmp ]; then rm -f ${PROBE_XML}.tmp >/dev/null 2>&1;fi;
          if [ -e ${PROBE_XML}.tmp2 ]; then rm -f ${PROBE_XML}.tmp2 >/dev/null 2>&1;fi;
	  if [ -e "$COLLDIFFFIL" ]; then rm -f $COLLDIFFFIL >/dev/null 2>&1;fi;
          if [ -e "$CHECKSFILE" ]; then rm -f $CHECKSFILE >/dev/null 2>&1;fi;
          #delete utility script at the end of execution
          for utlscrpt in "${a_utlscrpt[@]}"
          do
            if [ -e $TMPDIR/${utlscrpt} ]; then rm -f $TMPDIR/${utlscrpt} >/dev/null 2>&1;fi
          done	
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    if [ -d $TMP_OUTPUT ]; then rm -rf $TMP_OUTPUT >/dev/null 2>&1; fi
	  fi
        else
          #$SSHELL $hname rm -f /tmp/o_*.out >/dev/null 2>&1
          #Using $SHELL gives error /usr/bin/ssh -q: No such file or directory
          #So hardcoded ssh
          #ssh -q $hname 'if [ -d $RTEMPDIR ]; then rm -rf $RTEMPDIR >/dev/null 2>&1; fi'
          $SSHELL $hname "$bash_scr -c \"if [ -d $RTEMPDIR ]; then rm -rf $RTEMPDIR >/dev/null 2>&1; fi\""
          $SSHELL $hname " $bash_scr -c \"if [ -e $EXADATA_CELL_COLLECTIONS ]; then rm -f $EXADATA_CELL_COLLECTIONS >/dev/null 2>&1; fi;\""
          $SSHELL $hname "$bash_scr -c \"rm -f $TMPDIR/raccheck_env.out >/dev/null 2>&1\""
          $SSHELL $hname "$bash_scr -c \"rm -f $TMPDIR/set_orcl_env.sh >/dev/null 2>&1\""
          $SSHELL $hname "$bash_scr -c \"rm -f $ROOTSCRPT >/dev/null 2>&1\""
          $SSHELL $hname "$bash_scr -c \"rm -f $TMPDIR/CellFlashCacheMode.out >/dev/null 2>&1\""
          $SSHELL $hname "$bash_scr -c \"rm -f $TMPDIR/o_root_clusterwide_check*.out >/dev/null 2>&1\""
          #$SSHELL $hname "$bash_scr -c \"rm -f /tmp/cprofile.sh >/dev/null 2>&1\""
          $SSHELL $hname "$bash_scr -c \"rm -f ${TMP_RATENV_FIL} >/dev/null 2>&1\""
          $SSHELL $hname "$bash_scr -c \"rm -f ${RATENV_FIL} >/dev/null 2>&1\""
          $SSHELL $hname "$bash_scr -c \"rm -f ${TMPSTFILE} >/dev/null 2>&1\""
          $SSHELL $hname "$bash_scr -c \"rm -f ${PROBE_XML}.tmp >/dev/null 2>&1\""
          $SSHELL $hname "$bash_scr -c \"rm -f ${PROBE_XML}.tmp2 >/dev/null 2>&1\""
	  get_winpath "COLLDIFFFIL"
	  get_winpath "CHECKSFILE"
          $SSHELL $hname "$bash_scr -c \"if [ -e $COLLDIFFFIL ]; then rm -f ${COLLDIFFFIL} >/dev/null 2>&1; fi;\""
	  $SSHELL $hname "$bash_scr -c \"if [ -e $CHECKSFILE ]; then rm -f ${CHECKSFILE} >/dev/null 2>&1; fi;\""
	  restore_winpath "COLLDIFFFIL"
	  restore_winpath "CHECKSFILE"
          #delete utility script at the end of execution
          for utlscrpt in "${a_utlscrpt[@]}"
          do
             $SSHELL $hname " $bash_scr -c \"if [ -e $TMPDIR/${utlscrpt} ]; then rm -f $TMPDIR/${utlscrpt} >/dev/null 2>&1;fi\""
          done
          if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	     $SSHELL $hname " $bash_scr -c \"if [ -d $TMP_OUTPUT ]; then rm -rf $TMP_OUTPUT >/dev/null 2>&1;fi\"";
	  fi
        fi
      done
    fi

    if [ -e $WRKDIR/cgrep ]; then rm -f $WRKDIR/cgrep >/dev/null 2>&1;fi;
    if [ -e a_dbm_asm_diskgroup_attributes_dbmv2.out ]; then rm a_dbm_asm_diskgroup_attributes_dbmv2.out >/dev/null 2>&1;fi;
  fi

  if [ -e  $HOSTLIST ]
  then 
    if [ $OFFLINE -eq 0 ]
    then
      if [[ -n $arr && $arr -ge 0 ]]; then arr=`expr $arr - 1`;fi
      while [[ -n $arr && $arr -ge 0 ]]
      do
        if [ ${hnameArr[$arr]} = $localnode ]
        then
          #rm -rf ~/.ssh 2>/dev/null
          mv -f $HOME/.ssh/authorized_keys.tmp $HOME/.ssh/authorized_keys 
          mv -f $HOME/.ssh/known_hosts.tmp $HOME/.ssh/known_hosts 
        else
          #ssh ${hnameArr[$arr]} rm -rf ~/.ssh
          $SSHELL -o StrictHostKeyChecking=no -x -l $usern ${hnameArr[$arr]} "/bin/sh -c \"mv -f \$HOME/.ssh/known_hosts.tmp \$HOME/.ssh/known_hosts; mv -f \$HOME/.ssh/authorized_keys.tmp \$HOME/.ssh/authorized_keys\""  
        fi
        arr=`expr $arr - 1`
      done
    fi 
  fi

  if [ -n "$watchdog_pid" ]; then child_pid=$(ps -ef |grep "$watchdog_pid"|grep -v 'grep'|grep -w 'sleep'|awk '{print $2}'|sed 's/ //g'); fi
  kill $watchdog_pid > /dev/null 2>&1
  if [[ -n "$child_pid" ]] ; then kill $child_pid > /dev/null 2>&1;fi
  #kill $watchdog_pid > /dev/null 2>&1
  if [[ -d $OUTPUTDIR && -z "$RAT_NOCLEAN_DIR" ]]
  then
    ZIPFIL=${UPLOADFIL}.zip
    if [ ! -e $ZIPFIL ]; then ZIPFIL=${UPLOADFIL}.tar.gz; fi
    if [[ -n "$ZIPFIL" && ! -e $ZIPFIL ]] || [[ -n "$stack_counter" && $stack_counter -lt 1 && -n $SSH_blocked && $SSH_blocked -eq 0 ]]
    then
      rm -rf $OUTPUTDIR >/dev/null 2>&1
    fi
  fi
 
  #removed unrequired messages from log file
  if [[ -e $LOGFIL ]];
  then
    ftdir=$(dirname $LOGFIL);
    $(grep -iv "bash: line.*: Not a directory" $LOGFIL > $ftdir/.${program_name}.log);
    if [[ -e $ftdir/.${program_name}.log ]];
    then
      $(mv -f $ftdir/.${program_name}.log $LOGFIL >/dev/null 2>&1);
      $(rm -f $ftdir/.${program_name}.log >/dev/null 2>&1);
    fi
  fi
  if [[ -d $WRKDIR/.MERGED_COLLECTIONS/ ]];
  then
    rm -rf $WRKDIR/.MERGED_COLLECTIONS >/dev/null 2>&1
  fi
}

reorg_output_dir ()
{
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
     move_files "$ERRFIL" "$OLD_ERRFIL"  
     mv $TMP_OUTPUT/pxhcdr*.zip $OUTPUTDIR >/dev/null 2>&1
  fi
 
  if [[ -n "$RAT_COPY_EM_XML_FILES" && $RAT_COPY_EM_XML_FILES -eq "2" ]]; then 
    mv $XMLREPFIL $WRKDIR >/dev/null 2>&1
    mv $XMLSKIPFIL $WRKDIR >/dev/null 2>&1
  else 
    XMLREPFIL_NEW=$(echo "$XMLREPFIL"|sed "s/${program_name}_results.xml/${localnode}_${program_name}_results.xml/g")
    XMLSKIPFIL_NEW=$(echo "$XMLSKIPFIL"|sed "s/${program_name}_exceptions.xml/${localnode}_${program_name}_exceptions.xml/g")
    mv "$XMLREPFIL" "$XMLREPFIL_NEW" >/dev/null 2>&1
    mv "$XMLSKIPFIL" "$XMLSKIPFIL_NEW" >/dev/null 2>&1
  fi
 
  if [ ! -e $OUTPUTDIR/outfiles ]; then mkdir $OUTPUTDIR/outfiles >/dev/null 2>&1;fi
  if [ ! -e $OUTPUTDIR/scripts ]; then mkdir $OUTPUTDIR/scripts >/dev/null 2>&1;fi
  if [ ! -e $OUTPUTDIR/reports ]; then mkdir $OUTPUTDIR/reports >/dev/null 2>&1;fi
  if [ ! -e $OUTPUTDIR/upload ]; then mkdir $OUTPUTDIR/upload >/dev/null 2>&1;fi
  if [ ! -e $OUTPUTDIR/log ]; then mkdir $OUTPUTDIR/log >/dev/null 2>&1;fi
 
  if [  -e $OUTPUTDIR/outfiles ]; then mv -f $OUTPUTDIR/*.out $OUTPUTDIR/outfiles >/dev/null 2>&1;fi
  if [  -e $OUTPUTDIR/scripts ]; then mv -f $OUTPUTDIR/*.sh $OUTPUTDIR/scripts >/dev/null 2>&1;fi
  if [  -e $OUTPUTDIR/reports ]; then mv -f $OUTPUTDIR/*.rep $OUTPUTDIR/reports >/dev/null 2>&1;fi
  if [  -e $OUTPUTDIR/upload ]; then mv -f $OUTPUTDIR/*.sql $OUTPUTDIR/upload >/dev/null 2>&1;fi
  if [  -e $OUTPUTDIR/upload ]; then mv -f $OUTPUTDIR/*.ctl $OUTPUTDIR/upload >/dev/null 2>&1;fi
  if [[ -z "$RAT_COPY_EM_XML_FILES" && -e $OUTPUTDIR/upload ]]; then mv -f $OUTPUTDIR/*.xml $OUTPUTDIR/upload >/dev/null 2>&1;fi

  if [[  -e $HTML_REPFILE && -e $OUTPUTDIR/reports ]] && [ -z "$MERGEFILES" ]
  then
    cp -f $HTML_REPFILE ${HTML_REPFILE}_copy >/dev/null 2>&1
    mv -f $OUTPUTDIR/*.html $OUTPUTDIR/reports >/dev/null 2>&1
    cp -f ${HTML_REPFILE}_copy $HTML_REPFILE >/dev/null 2>&1
    cp -f $HTML_REPFILE $OUTPUTDIR/reports >/dev/null 2>&1
    rm -f ${HTML_REPFILE}_copy >/dev/null 2>&1
  fi

  if [  -e $OUTPUTDIR/log ]; then mv -f $OUTPUTDIR/*.log $OUTPUTDIR/log >/dev/null 2>&1;mv -f $OUTPUTDIR/*.txt $OUTPUTDIR/log >/dev/null 2>&1;mv -f $OUTPUTDIR/*.lst $OUTPUTDIR/log >/dev/null 2>&1;fi
  ERRFIL=${OUTPUTDIR}/log/${program_name}_error.log
  HOSTLIST=${OUTPUTDIR}/outfiles/$(basename $HOSTLIST)
 
  if [[ -n "$RAT_CLIENT_DEBUG" && $RAT_CLIENT_DEBUG -eq "1" ]]
  then
    if [[ ! -z "$RAT_CLIENT_DEB_FIL" ]]
    then
      debugFileName=$RAT_CLIENT_DEB_FIL
      for slave_debug in `find $OUTPUTDIR/log -name "*_slave_debug.log"`
      do
        echo "" 			>> $debugFileName
        echo "\n\nCopying results from ${slave_debug}\n\n" >> $debugFileName
        echo ""			>> $debugFileName 
        cat "$slave_debug" 	>> $debugFileName
        rm -f "$slave_debug" >/dev/null 2>&1;
      done
    fi
  fi

  mv -f $COLLDIFFFIL $OUTPUTDIR/log >/dev/null 2>&1
  mv -f $CHECKSFILE $OUTPUTDIR/outfiles >/dev/null 2>&1

}

mb_validate_oracle_home ()
{
  oracle_home_to_check=$1
  if [[ -d $oracle_home_to_check && -f $oracle_home_to_check/bin/oracle ]];then validate_oracle_home_status=1;else validate_oracle_home_status=0;fi;
}

mb_read_oracle_home()
{
  mb_read_oracle_home_called=0
  mb_read_oracle_home_found=0
  if [ -z "$1" ] || [[ -n "$valideate_oracle_home_status" && $valideate_oracle_home_status -eq 0 ]]
  then
    mb_db_counter_read=0
    for db_name_to_check_to_read in "${mb_db_names[@]}"
    do
      if [[ "$db_name_to_check_to_read" = ${2} && -n "${mb_oracle_homes[$mb_db_counter_read]}" ]]
      then 
        mb_ask_oracle_home=${mb_oracle_homes[$mb_db_counter_read]}
        mb_read_oracle_home_found=1
        mb_read_oracle_home_called=1
        break
      fi
      mb_db_counter_read=$(expr $mb_db_counter_read + 1 )
    done

    if [[ -n "$validate_oracle_home_tries" && $validate_oracle_home_tries -lt 1 && $mb_read_oracle_home_found -eq 0 ]]
    then
      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
        cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="TEXT" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n79_nlsid">
        Unable to find ORACLE_HOME for {1} database        
      </text>
      <tokens>
	<token index="1">${2}</token>
      </tokens>
      </tokenizedtext>
    </context>
    <text nls_id="orhc_exadata_n80_nlsid">
       Enter it here 
    </text>
  </question>
</group>
EOF
        PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
      elif [[ $EM_XMLD_MODE -eq 1 ]]
      then
	read_probe_xml ""
	mb_ask_oracle_home=$xml_rvalue

        mb_read_oracle_home_called=1
      else
        exec 3<&2; exec 2<&0
        $READ -p "${program_name} did not find ORACLE_HOME for ${2} database.Please enter it here:- " mb_ask_oracle_home
        exec 2<&3

        mb_read_oracle_home_called=1
      fi
    elif [[ $mb_read_oracle_home_found -eq 0 ]]
    then
      exec 3<&2; exec 2<&0
      $READ -p "Invalid ORACLE_HOME for ${2} database.you can try `expr 4 - $validate_oracle_home_tries ` more times including this:- " mb_ask_oracle_home
      exec 2<&3

      mb_read_oracle_home_called=1
    fi
    #mb_read_oracle_home_value=$mb_ask_oracle_home
  fi
  mb_db_counter_read=0
}

read_targetversion ()
{
  if [ $read_targetversion_count -eq 0 ]
  then
    exec 3<&2; exec 2<&0
    $READ -p "Enter upgrade target version (valid versions are 11.2.0.3.0, 11.2.0.4.0, 12.1.0.1.0, 12.1.0.2.0 and 12.2.0.1.0):- " targetversion
    exec 2<&3

    targetversion=$(echo $targetversion|sed 's/[A-Za-z]//g')
    targetversion=$(echo $targetversion|sed 's/\.//g')
    #$READ -p "$targetversion"
    if [ `echo $targetversion|wc -c` -ne 7 ] || [ `echo $supportedTargetVersion|grep -icw $targetversion` -lt 1 ]
    then
      echo -e "${RED}\nInvalid upgrade target version format or upgrade version not yet supported.${NORM}\n"
      correct_target_version=0
    else
      correct_target_version=1
    fi
  else
    exec 3<&2; exec 2<&0
    $READ -p "Enter upgrade target version (valid versions are 11.2.0.3.0, 11.2.0.4.0, 12.1.0.1.0, 12.1.0.2.0 and 12.2.0.1.0) `expr 3 - $read_targetversion_count` tries left:- " targetversion
    exec 2<&3

    targetversion=$(echo $targetversion|sed 's/[A-Za-z]//g')
    targetversion=$(echo $targetversion|sed 's/\.//g')
    if [ `echo $targetversion|wc -c` -ne 7 ] || [ `echo $supportedTargetVersion|grep -icw $targetversion` -lt 1 ]
    then
      echo -e "${RED}\nInvalid upgrade target version format or upgrade version not yet supported.${NORM}\n"
      correct_target_version=0
    else
      correct_target_version=1
    fi 
  fi
}

function update_zip_files ()
{
  is_update_needed

  #echo "is_update_needed=$update_needed "
  if [[ $update_needed -eq "0" ]] ; then return; fi

  cd $WRKDIR
  for collection_dir in `find . -name "check_env.out" | sed 's/\/check_env.out//'`
  do
    #echo "replacing $collection_dir" 
    fdir=$(dirname $collection_dir)
    cd $WRKDIR/$fdir
    collection_dir=$(basename $collection_dir)
    replace_string "$collection_dir/$collection_dir.html"
    replaced_files="$collection_dir/$collection_dir.html"

    for ofile in `find $collection_dir/ -name "9EC87FB8BF2E4ED8E040E50A1EC03015*"`
    do
      replace_string "$ofile"
      replaced_files="$replaced_files $ofile"
    done
    for ofile in `find $collection_dir/ -name "595A436B3A7172FDE0401490CACF5BA5*"`
    do
      replace_string "$ofile"
      replaced_files="$replaced_files $ofile"
    done
    for ofile in `find $collection_dir/ -name "A18401E2DDFF63D2E040E50A1EC077C4*"`
    do
      replace_string "$ofile"
      replaced_files="$replaced_files $ofile"
    done

    if [[ -e "$collection_dir.zip" && -n "$replaced_files" ]] ; then
      zip $collection_dir.zip $replaced_files >/dev/null 2>&1
    elif [  -e "$collection_dir.tar.gz" ] ; then
      rm -f $collection_dir.tar.gz
      tar -cf "$collection_dir.tar.gz"  $collection_dir/* >/dev/null 2>&1
    fi
  done
  mark_update_done
  #exit
}

function replace_string ()
{ 
  l_file=$1
  if [ -e "$l_file" ] ; then
    sed 's/RAT_COMPUTEPASSWORD_INTERNAL=.*//g' $l_file > $TMPDIR/$$.2replace.txt
    cp -f $TMPDIR/$$.2replace.txt $l_file
    rm -f $TMPDIR/$$.2replace.txt
  fi
}

function is_readme_writable ()
{ 
  readme_writable=1
  if [[ -e "$SCRIPTPATH/readme.txt" && -w "$SCRIPTPATH/readme.txt" ]] ; then
    readme_writable=1
  else
    readme_writable=0
  fi
}

function is_update_needed ()
{ 
  is_readme_writable

  #echo "$readme_writable $SCRIPTPATH/readme.txt"
  update_needed=1
  if [[ $readme_writable -eq "1" && `grep -ic "f20130501" $SCRIPTPATH/readme.txt` -eq "0"  ]] ; then
    update_needed=0
  else 
    if [ -e "$WRKDIR/.f20130501.txt" ] ; then update_needed=0; fi
  fi
}

function mark_update_done ()
{ 
  is_readme_writable 
  if [ $readme_writable -eq "1" ] ; then
    sed 's/f20130501//' $SCRIPTPATH/readme.txt > $TMPDIR/$$.2replace.txt
    cp -f $TMPDIR/$$.2replace.txt $SCRIPTPATH/readme.txt
    rm -f $TMPDIR/$$.2replace.txt
  else
    touch $WRKDIR/.f20130501.txt
  fi
}

function check_wrkdir ()
{
  touch ${WRKDIR}/$$.touched >/dev/null 2>&1
  if [ $? -ne "0" ] ; then
    # $WRKDIR is not writable
    echo;
    echo -e "${RED}${WRKDIR} is not writable. Please set the RAT_OUTPUT and run again.";
    echo -e "${NORM}"
    echo "ex: export RAT_OUTPUT=/directory/writable"
    echo;
    echo;
    exit 1;
  fi
  rm -f ${WRKDIR}/$$.touched >/dev/null 2>&1
}

change_old_env_variables ()
{
  if [ -n "$RACCHECK_TIMEOUT" ]; then RAT_TIMEOUT=$RACCHECK_TIMEOUT;fi
  if [ -n "$RACCHECK_UPLOAD_CONNECT_STRING" ]; then RAT_UPLOAD_CONNECT_STRING=$RACCHECK_UPLOAD_CONNECT_STRING;fi
  if [ -n "$RACCHECK_UPLOAD_TABLE" ]; then RAT_UPLOAD_TABLE=$RACCHECK_UPLOAD_TABLE;fi
  if [ -n "$RACCHECK_ZIP_UPLOAD_TABLE" ]; then RAT_ZIP_UPLOAD_TABLE=$RACCHECK_ZIP_UPLOAD_TABLE;fi
  if [ -n "$RACCHECK_PATCH_UPLOAD_TABLE" ]; then RAT_PATCH_UPLOAD_TABLE=$RACCHECK_PATCH_UPLOAD_TABLE;fi
  if [ -n "$RACCHECK_UPLOAD_USER" ]; then RAT_UPLOAD_USER=$RACCHECK_UPLOAD_USER;fi
  if [ -n "$RACCHECK_UPLOAD_PASSWORD" ]; then RAT_UPLOAD_PASSWORD=$RACCHECK_UPLOAD_PASSWORD;fi
  if [ -n "$RACCHECK_UPLOAD_ORACLE_HOME" ]; then RAT_UPLOAD_ORACLE_HOME=$RACCHECK_UPLOAD_ORACLE_HOME;fi
  if [ -n "$RACCHECK_INV_LOC" ]; then RAT_INV_LOC=$RACCHECK_INV_LOC;fi
  if [ -n "$RACCHECK_CRS_HOME" ]; then RAT_CRS_HOME=$RACCHECK_CRS_HOME;fi
  if [ -n "$RACCHECK_ORACLE_HOME" ]; then RAT_ORACLE_HOME=$RACCHECK_ORACLE_HOME;fi
  if [ -n "$RACCHECK_ASM_HOME" ]; then RAT_ASM_HOME=$RACCHECK_ASM_HOME;fi
  if [ -n "$RACCHECK_OS" ]; then RAT_OS=$RACCHECK_OS;fi
  if [ -n "$RACCHECK_DB" ]; then RAT_DB=$RACCHECK_DB;fi
  if [ -n "$RACCHECK_DBNAMES" ]; then RAT_DBNAMES=$RACCHECK_DBNAMES;fi
  if [ -n "$RACCHECK_DBHOMES" ]; then RAT_DBHOMES=$RACCHECK_DBHOMES;fi
  if [ -n "$RACCHECK_OUTPUT" ]; then RAT_OUTPUT=$RACCHECK_OUTPUT;fi
  if [ -n "$RACCHECK_DEBUG" ]; then RAT_DEBUG=$RACCHECK_DEBUG;fi
  if [ -n "$RACCHECK_INFOPASS" ]; then RAT_INFOPASS=$RACCHECK_INFOPASS;fi
}

# set variable node_type based on system
set_node_type ()
{
  l_node_name=$1
  node_type="Compute Node";
  if  [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
  then
    node_type="Database server"
  fi
  if [[ -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" ]] ; then
    get_el_prefix "$l_node_name"
    if [[ $el_prefix = "DB" ]] ; then
        node_type="Control DB Node"
    elif [[ $el_prefix = "EC" ]] ; then
        node_type="Enterprise Controller"
    elif [[ $el_prefix = "PC" ]] ; then
        node_type="Proxy Controller"
    elif [[ $el_prefix = "OVMM" ]] ; then
        node_type="OVM Manager Node"
    elif [[ $el_prefix = "CS" ]] ; then
        node_type="Control vServer"
    fi
  fi
}

generate_exadata_report ()
{
  h_printed=0
  if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] 
  then
    h_printed=1
    echo "<h2>Systemwide firmware and software versions</h2>">> $OUTPUTDIR/${program_name}_versions.html
    echo "<p>Please compare these versions against Database Machine and Exadata Storage Server 11g Release 2 (11.2) Supported Versions (<a href=\"https://support.oracle.com/CSP/main/article?cmd=show&type=NOT&id=888828.1\">Doc ID 888828.1</a>) in MyOracle Support</p>" >> $OUTPUTDIR/${program_name}_versions.html
  fi
 
  if [[ `echo $components|grep -iwc SUPERCLUSTER` -le 0 && -e "$OUTPUTDIR/${program_name}_${ASREXACHK}.html" ]] 
  then
    echo "<h2>Systemwide Automatic Service Request (ASR) healthcheck</h2>">> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
  elif [ $h_printed -eq "0" ] ; then
    echo "<h2>Systemwide firmware and software versions</h2>">> $OUTPUTDIR/${program_name}_versions.html
  fi
  #echo "<p>Please check ASR Exadata Configuration Check via ASREXACHECK (<a href=\"https://support.oracle.com/CSP/main/article?cmd=show&type=NOT&id=1450112.1\">Doc ID 1450112.1</a>) in MyOracle Support</p>" >> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
 
   
  for xfilename in `find $OUTPUTDIR \( -name '*asrexachk*' -o -name '*exadata_versions*' \) -print|grep -v cbc|sort`
  do
    if [[ -e $xfilename &&  `echo $xfilename|grep -c report` -lt 1 ]]
    then
      if [[ -e $xfilename &&  `echo $xfilename|grep -c asrexachk` -ge 1 ]]
      then
        node_name_f=$(basename $xfilename|awk -F_ '{print $NF}')
        if [ `echo $node_name_f | grep -c '^[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*'` -gt "0" ] ; then
          node_name=$(echo $node_name_f| sed 's/\.out//');
        else
          node_name=$(echo $node_name_f| cut -d. -f1)
        fi
        set_node_type $node_name
        if  [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
        then  
          echo "<h3>Database server $node_name</h3>">> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
        else
          echo "<h3>$node_type $node_name</h3>">> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
        fi
        echo "<pre>" >> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
        cat $xfilename | sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
        echo "</pre>" >> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
      else
        node_name_f=$(basename $xfilename|awk -F_ '{print $NF}')
        if [ `echo $node_name_f | grep -c '^[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*'` -gt "0" ] ; then
          node_name=$(echo $node_name_f| sed 's/\.out//');
        else
          node_name=$(echo $node_name_f| cut -d. -f1)
        fi
        set_node_type $node_name
        if  [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
        then  
          echo "<h3>Database server $node_name</h3>">> $OUTPUTDIR/${program_name}_versions.html
        else
          echo "<h3>$node_type $node_name</h3>">> $OUTPUTDIR/${program_name}_versions.html
        fi
        echo "<pre>" >> $OUTPUTDIR/${program_name}_versions.html
        cat $xfilename | sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $OUTPUTDIR/${program_name}_versions.html
        echo "</pre>" >> $OUTPUTDIR/${program_name}_versions.html
      fi
    fi 
  done
 
  for xfilename in `find $OUTPUTDIR \( -name '*asrexachk_*' -o -name '*exadata_versions*' \) -print|grep cbc|sort`
  do
    if [[ -e $xfilename &&  `echo $xfilename|grep -c report` -lt 1 ]]
    then 
      node_name=$(basename $xfilename|$AWK 'BEGIN { FS = "_" } {printf $4"."$5"."$6"."$7}'|sed 's/\.out//g')
      #node_name=$(cat $CELLDIR/cells.out |grep -w "$node_name"|cut -d= -f2|tr -d ' ')
      node_name=$(grep -w "$node_name" $CELLDIR/cells.out|cut -d= -f2|tr -d ' ')
      if [[ -e $xfilename &&  `echo $xfilename|grep -c asrexachk` -ge 1 ]]
      then
        echo "<h3>Storage server $node_name</h3>">> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
        echo "<pre>" >> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
        cat $xfilename | sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
        echo "</pre>" >> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
      else 
        echo "<h3>Storage server $node_name</h3>">> $OUTPUTDIR/${program_name}_versions.html
        echo "<pre>" >> $OUTPUTDIR/${program_name}_versions.html
        cat $xfilename | sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g'>> $OUTPUTDIR/${program_name}_versions.html
        echo "</pre>" >> $OUTPUTDIR/${program_name}_versions.html
      fi
    fi
  done
 
  for sfilename in `find $OUTPUTDIR -name 's_nm2version*' -print |grep -v _report.out |grep -v .CELLDIR |sort`
  do
    if [[ -e $sfilename &&  `echo $sfilename|grep -c report` -lt 1 ]]
    then
      switch_name_f=$(basename $sfilename)
      if [ `echo $switch_name_f | grep -c '[0-9]*\_[0-9]*\_[0-9]*\_[0-9]*\.out'` -gt "0" ] ; then
        switch_name=$(basename $sfilename|sed 's/s_nm2version_//' |sed 's/\.out//' | sed 's/\_/./g')
      else
        switch_name=$(echo $switch_name_f|cut -d_ -f3| cut -d. -f1)
      fi
      echo "<h3>Infiniband switch $switch_name</h3>">> $OUTPUTDIR/${program_name}_versions.html
      echo "<pre>" >> $OUTPUTDIR/${program_name}_versions.html
      cat $sfilename | sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $OUTPUTDIR/${program_name}_versions.html
      echo "</pre>" >> $OUTPUTDIR/${program_name}_versions.html
    fi
  done

  for zfsfilename in `find $OUTPUTDIR -name '*exalogic_zfs_checks*' -print |sort`
  do
    if [ -e $zfsfilename ]
    then
      storage_name_f=$(basename $zfsfilename)
      if [ `echo $storage_name_f | grep -c '[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*\.exalogic'` -gt "0" ] ; then
        storage_name=$(echo $storage_name_f|sed 's/\.exalogic\_zfs\_checks\.out//')
      else
	storage_name=$(echo $storage_name_f|cut -d. -f1)
      fi	
      echo "<h3>ZFS Storage Appliance $storage_name</h3>">> $OUTPUTDIR/${program_name}_versions.html
      #echo "<h3>ZFS Storage Appliance $storage_name</h3>">> /tmp/check.out
      echo "<pre>" >> $OUTPUTDIR/${program_name}_versions.html
      
      begin=0
      for i in `cat $zfsfilename` 
      do

        if [ `echo $i| grep -ic "END_OF_REPORT_chkHWInfo"` -gt 0 ]; then
                begin=0
        fi
        if [ $begin -eq "1" ]; then
          #echo $i >>/tmp/check.out
	  if [ `echo $i| grep -ic "Hardware Version Information"` -gt 0 ]; then
          echo "<b>$i</b>"| sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $OUTPUTDIR/${program_name}_versions.html
	  else
		echo $i| sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $OUTPUTDIR/${program_name}_versions.html
	  fi 
        fi
        if [ `echo $i| grep -ic "START_OF_REPORT_chkHWInfo"` -gt 0 ]; then
                begin=1
        fi
      done 
      echo "</pre>" >> $OUTPUTDIR/${program_name}_versions.html
    fi
  done

}

#Function to write entries of collection to log file if that requires root 
write_root_collections_log ()
{
  echo "OS DATA COLLECTION BY ROOT SENT TO $1" >>$LOGFIL
  echo "ROW = $ROW" >>$LOGFIL
  echo "PARAMETER OR PATH = $PARAM_PATH" >>$LOGFIL
  echo "COMMAND = $COM" >>$LOGFIL
  echo -e "CHECK ID = $CHECK_ID \nCOLLECTION_NAME = $COLLECTION_NAME\n">>$LOGFIL
  echo -e "---------------------------------------------\n\n" >>$LOGFIL
 }
#Function to write values of environment variables to log file if they are set before executing the tool

log_env_varaibles ()
{
  if [ -n "$2" ]; then echo "$1 = $2">>$LOGFIL;echo $fmt_line_header >>$LOGFIL;fi
  #To remove commas if user has used while setting envrionment variable
  if [[ $# -gt 2 && -n "$2"  && `echo $2|grep -ic ","` -gt 0 ]]
  then
    env_var_name=$1
    export $env_var_name="$(echo $2|tr '\054' " ")"  
  fi
}

function wait_for_compute_completion ()
{
  if [[ -n "${#cpids[@]}" && ${#cpids[@]} -eq "0" ]] ; then return ; fi;

  keep_looping=1
  first_time_in_loop=1
  while [ $keep_looping -eq "1" ]
  do
    if [[ -n "${#cpids[@]}" && ${#cpids[@]} -eq "0" ]] ; then return ; fi;
    for cell_pid in "${cpids[@]}"
    do
      # wait till we finish collection running on node
      if [ `ps -ef | grep _compute |grep -c $cell_pid` -gt 0 ]
      then
        if [[ $first_time_in_loop -eq "1" ]] ; then
          printf "\nWaiting for ${program_name} to finish on remote nodes \n\n"
          first_time_in_loop=0
        fi
        printf "."
      else
        cname=${cpid_names[$cell_pid]};
        #echo "Finished run on $cname `date`";
        copy_from_compute;
        unset cpids[$cell_pid]; # remove from array
        cls_check_host_list[$stack_counter]=$cname
        stack_counter=$(expr $stack_counter + 1)
        #echo "Finished report generation on $cname `date`";
        #return;
      fi
    done
    sleep 2
  done

}

function on_signal_compute_cleanup ()
{
  if [[ -n "${#cpids[@]}" && ${#cpids[@]} -eq "0" ]] ; then return ; fi;

  for ib_pid in "${cpids[@]}"
  do
    kill $ib_pid >/dev/null 2>&1
  done
}

function copy_from_compute ()
{
  printf "\n\nCopying results from $cname and generating report. This might take a while. Be patient.\n\n"
  mkdir $OUTPUTDIR/$cname
  get_cygpath "OUTPUTDIR"
  get_cygpath "RTEMPDIR"
  $SCOPY -r $cname:$RTEMPDIR $OUTPUTDIR/$cname >/dev/null 2>&1
  restore_cygpath "OUTPUTDIR"
  restore_cygpath "RTEMPDIR"
  rm -f $OUTPUTDIR/$cname/.${program_name}/*.sh 
  rm -f $OUTPUTDIR/$cname/.${program_name}/*.dat 
  rm -f $OUTPUTDIR/$cname/.${program_name}/${program_name}
  rm -f $OUTPUTDIR/$cname/.${program_name}/cgrep

  $SSHELL $cname rm -rf $RTEMPDIR
  cp $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*$cname* $OUTPUTDIR 2>/dev/null

  if [[ -n "$RAT_CLIENT_DEBUG" && $RAT_CLIENT_DEBUG -eq "1" ]]
  then
    cp $OUTPUTDIR/$cname/.${program_name}/*_slave_debug.log $OUTPUTDIR 2>/dev/null
  fi
  
  crs_cid_file=$(ls $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/crs_checkids.out 2>/dev/null)
  cross_node_cid_file=$(ls $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/cross_node_checkids.out 2>/dev/null)
  
  if [[ -z "$clusterware_check_count" ]] ; then clusterware_check_count=0; fi
  if [[ -n "$crs_cid_file" && -e "$crs_cid_file" ]] ; then
    while read crs_cid
    do
      if [[ $clusterware_check_count -gt "0" ]] ; then
        # Check if it exists in array else insert
        crs_cid_exists=0
        for cid_in_arr in "${crs_check_id[@]}"
        do
          if [[ $cid_in_arr = $crs_cid ]] ; then crs_cid_exists=1; fi
        done
        if [[ $crs_cid_exists -eq "0" ]] ; then
          crs_check_id[$clusterware_check_count]=$crs_cid
          clusterware_check_count=$(expr $clusterware_check_count + 1)
        fi
      else
        crs_check_id[$clusterware_check_count]=$crs_cid
        clusterware_check_count=$(expr $clusterware_check_count + 1)
      fi
    done < $crs_cid_file
  fi

  crs_stack_counter=$clusterware_check_count
  crs_check_file_counter=0
  while [[ $crs_stack_counter -gt 0 && $SILENT -eq 0 ]]
  do  # append cluster wide check o/p
    CLUSTERCHECK_FIL=${OUTPUTDIR}/${crs_check_id[$crs_check_file_counter]}.out
    caf=$(ls $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/${crs_check_id[$crs_check_file_counter]}.out 2>/dev/null)
    if [[ -n "$caf" ]] ; then
      cat $caf >> $CLUSTERCHECK_FIL
      rm -f $caf
    fi
    crs_check_file_counter=$(expr $crs_check_file_counter + 1);
    crs_stack_counter=$(expr $crs_stack_counter - 1)
  done

  run_report;

  if [[ ! -z $RAT_SCRIPT_DEBUG ]]; then
    cat $OUTPUTDIR/$cname.slave.log
    #due to security concerns deleting slave log.
    #rm -rf $OUTPUTDIR/$cname.slave.log >/dev/null 2>&1
  else
    #cat $OUTPUTDIR/$cname.slave.log |grep -v "Pseudo-terminal will not be allocated"
    grep -v "Pseudo-terminal will not be allocated" $OUTPUTDIR/$cname.slave.log
  fi
  rm -rf $OUTPUTDIR/$cname/ 

}

function copy_from_dir ()
{
  if [ $d_index -ne 0 ];
  then
    cp -r $WRKDIR/.MERGED_COLLECTIONS/$xdir $OUTPUTDIR >/dev/null 2>&1
    cp $OUTPUTDIR/$xdir/outfiles/*.* $OUTPUTDIR 2>/dev/null
    cp -rf $OUTPUTDIR/$xdir/.CELLDIR $OUTPUTDIR 2>/dev/null
   
    crs_cid_file=$(ls $OUTPUTDIR/$xdir/outfiles/crs_checkids.out 2>/dev/null)
    cross_node_cid_file=$(ls $OUTPUTDIR/$xdir/outfiles/cross_node_checkids.out 2>/dev/null)

    #-reset values...
    multiple_db=$(grep MULTIPLE_DATABASE $OUTPUTDIR/$xdir/outfiles/check_env.out |awk '{print $3}')  
    multiple_oracle_homes=$(grep MULTIPLE_ORACLE_HOMES $OUTPUTDIR/$xdir/outfiles/check_env.out |awk '{print $3}'|head -1)  
  else
    CELLDIR=$OUTPUTDIR
    crs_cid_file=$(ls $OUTPUTDIR/crs_checkids.out 2>/dev/null)
    cross_node_cid_file=$(ls $OUTPUTDIR/cross_node_checkids.out 2>/dev/null)
  fi

  if [[ -n "$cross_node_cid_file" && -e "$cross_node_cid_file" ]] ; then
    process_cross_node_checks=1
    while read cross_cid
    do
      cross_node_checkids[$cross_node_checkids_counter]=$cross_cid
      cross_node_checkids_counter=$(expr $cross_node_checkids_counter + 1 )
    done < $cross_node_cid_file
  fi

  if [[ -z "$clusterware_check_count" ]] ; then clusterware_check_count=0; fi
  if [[ -n "$crs_cid_file" && -e "$crs_cid_file" ]] ; then
    while read crs_cid
    do
      if [[ $clusterware_check_count -gt "0" ]] ; then
        crs_cid_exists=0
        for cid_in_arr in "${crs_check_id[@]}"
        do
          if [[ $cid_in_arr = $crs_cid ]] ; then crs_cid_exists=1; fi
        done
        if [[ $crs_cid_exists -eq "0" ]] ; then
          crs_check_id[$clusterware_check_count]=$crs_cid
          clusterware_check_count=$(expr $clusterware_check_count + 1)
        fi
      else
        crs_check_id[$clusterware_check_count]=$crs_cid
        clusterware_check_count=$(expr $clusterware_check_count + 1)
      fi
    done < $crs_cid_file
  fi

  crs_stack_counter=$clusterware_check_count
  crs_check_file_counter=0
  while [[ $crs_stack_counter -gt 0 && $SILENT -eq 0 ]]
  do  
    CLUSTERCHECK_FIL=$WRKDIR/.MERGED_COLLECTIONS/${crs_check_id[$crs_check_file_counter]}.out
    if [ $d_index -ne 0 ]; 
    then
      caf=$(ls $OUTPUTDIR/$xdir/outfiles/${crs_check_id[$crs_check_file_counter]}.out 2>/dev/null)
    else
      caf=$(ls $OUTPUTDIR/${crs_check_id[$crs_check_file_counter]}.out 2>/dev/null)
    fi
    if [[ -n "$caf" ]] ; then
      cat $caf >> $CLUSTERCHECK_FIL
      rm -f $caf
    fi
    crs_check_file_counter=$(expr $crs_check_file_counter + 1);
    crs_stack_counter=$(expr $crs_stack_counter - 1)
  done

  dir_run_report;
  if [ $d_index -ne 0 ];
  then
    rm -rf $OUTPUTDIR/$xdir/ 
  fi
}

function dir_run_report ()
{
  cname=`grep LOCALNODE $DUMPDIR/$CHKFIL |awk '{print $3}'`
  cnt=0

  rm $OUTPUTDIR/slave_results.out.new 2>/dev/null 
  if [ $d_index -ne 0 ];
  then
    #cat $OUTPUTDIR/$xdir/upload/*_results.xml |grep -v "Results modelVersion=" > $OUTPUTDIR/${cname}_results.xml 2>/dev/null
    grep -v "Results modelVersion=" $OUTPUTDIR/$xdir/upload/*_results.xml > $OUTPUTDIR/${cname}_results.xml 2>/dev/null
    cat $OUTPUTDIR/$xdir/upload/patch_summary.html >> $OUTPUTDIR/patch_summary.html 2>/dev/null
    cat $OUTPUTDIR/$xdir/upload/patch_detailed.html >> $OUTPUTDIR/patch_detailed.html 2>/dev/null
    rm -f $OUTPUTDIR/$xdir/upload/patch_summary.html $OUTPUTDIR/$xdir/upload/patch_detailed.html 2>/dev/null

    for file in `ls $OUTPUTDIR/$xdir/outfiles/*_timings.out 2>/dev/null`
    do
      filen=$(basename $file)
      cat $file >> $OUTPUTDIR/$filen
    done
    slave_pattern="$OUTPUTDIR/$xdir/outfiles/slave_results_*"
  else
    slave_pattern="$OUTPUTDIR/slave_results_*"
  fi
    
  printf "  ."
  for file in `ls $slave_pattern 2>/dev/null`
  do
    i=$(basename $file)
    i=$(echo $i|sed 's/slave_results_//g')
    i=$(echo $i|sed 's/\.out//g')

    OSCHECKRESULT=$OUTPUTDIR/o_audit_result_${i}.out
    while read line
    do
      printf "."
      CHECK_ID=$(echo $line | cut -d"|" -f1)
      ALVL=$(echo $line | cut -d"|" -f2)
      COMTYPE=$(echo $line | cut -d"|" -f3)
      status_on_target=$(echo $line | cut -d"|" -f4)
      db_name_to_check=$(echo $line | cut -d"|" -f5)
      inst_name=$(echo $line | cut -d"|" -f6)
      mb_db_homes=$(echo $line | cut -d"|" -f7)
      message4Home=$(echo $line | cut -d"|" -f8)
      cch_cname=$(echo $line | cut -d"|" -f9)
      sl_hosts=$(echo $line | cut -d"|" -f10)

      storage_id_file=$(grep -i "^storage|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2|sed 's/ //g')
      switch_id_file=$(grep -i "^switch|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2|sed 's/ //g')
      if [ `grep -ic $CHECK_ID $SCRIPTPATH/.cgrep/profiles/${switch_id_file}.prf` -gt 0 ];
      then
        switchname=$sl_hosts;
      elif [ `grep -ic $CHECK_ID $SCRIPTPATH/.cgrep/profiles/${storage_id_file}.prf` -gt 0 ];
      then
	cell_count_cwc=0
	unset a_cellname
	unset a_cellCheckStatus

	if [[ -e $CELLIP && -e $CELLDIR/cells.out ]]
	then
	  for cellname in `cat $CELLIP|cut -d= -f2|cut -d\; -f2|sed 's/"//g'`
	  do
	    check_status=0
	    cellipaddr=$cellname

	    cellname=$(cat $CELLDIR/cells.out|grep -w "$cellname"|awk '{print $NF}')
	    if [ -e $OUTPUTDIR/${program_name}_skipped_nodes.log ]
	    then
	      is_it_skipped_cell=$(grep -icw $cellipaddr $OUTPUTDIR/${program_name}_skipped_nodes.log)
	    fi

            if [ -z "$sl_hosts" ]
	    then
	      a_cellCheckStatus[$cell_count_cwc]="PASS"
	    else
              if [ `echo "$sl_hosts"|grep -icw "$cellname"` -gt 0 ];
	      then 
	    	a_cellCheckStatus[$cell_count_cwc]=$ALVL
	      else
	    	a_cellCheckStatus[$cell_count_cwc]="PASS"
              fi
	    fi

 	    a_cellname[$cell_count_cwc]=$cellname;
	    cell_count_cwc=$(expr $cell_count_cwc + 1);
	  done
	fi	
      fi

      if [ $d_index -eq 0 ];
      then
        htmlf=$(ls $OUTPUTDIR/$CHECK_ID.html.out 2>/dev/null |tail -1)
      else
        htmlf=$(ls $OUTPUTDIR/$xdir/outfiles/$CHECK_ID.html.out 2>/dev/null |tail -1)
      fi

      for cid_in_arr in "${crs_check_id[@]}"
      do
  	if [[ $cid_in_arr = $CHECK_ID ]] ; then htmlf=""; fi	
      done

      for crosscid_in_arr in "${cross_node_checkids[@]}"
      do
	if [[ $cross_cid_in_arr = $CHECK_ID ]] ; then htmlf=""; fi
      done

      #--exclude duplicates
      if [ `echo "$slave_check_index"|grep -ic "${CHECK_ID}|$sl_hosts;"` -eq 0 ]
      then
	slave_check_index="${slave_check_index};${CHECK_ID}|${sl_hosts};"
      else
	htmlf="";
      fi

      if [ -e "$htmlf" ] ; then
        read_checkid_vars;
	if [[ $execute_once -eq 1 && "$i" != "$localnode" ]]
	then
	  maa_id_file=$(grep -i "^maa|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2|sed 's/ //g')
	  if [[ `grep -ic $CHECK_ID $SCRIPTPATH/.cgrep/profiles/${maa_id_file}.prf` -gt 0 ]]; then
	    create_report_files;
	  else
	    printf "."
	  fi
	else
          create_report_files;
        fi
      fi
    done < $file
    cat $file >> $CURRDIR/.MERGED_COLLECTIONS/slave_results.out.merge
  done
  echo -e ""   

  cat $OUTPUTDIR/${cname}_results.xml >> $XMLREPFIL 2>/dev/null
  rm -f $OUTPUTDIR/${cname}_results.xml 2>/dev/null;
  if [ $d_index -ne 0 ];
  then
    #cat $OUTPUTDIR/$xdir/upload/*_exceptions.xml |grep -v "Exclusions modelVersion" >> $XMLSKIPFIL 2>/dev/null
    grep -v "Exclusions modelVersion" $OUTPUTDIR/$xdir/upload/*_exceptions.xml >> $XMLSKIPFIL 2>/dev/null
  fi
  if [ -e "$OUTPUTDIR/$xdir/reports/${program_name}.rep" ]
  then
    for file in $OUTPUTDIR/$xdir/reports/*.rep
    do
      fname=$(basename $file)
      cat $file >> $OUTPUTDIR/$fname
    done
  fi

  if [ $d_index -ne 0 ];
  then
    cat $OUTPUTDIR/$xdir/log/*_skipped_checks.log >> $OUTPUTDIR/${program_name}_skipped_checks.log 2>/dev/null
    echo "LOG FROM $xdir" >> $OUTPUTDIR/watchdog.log
    cat $OUTPUTDIR/$xdir/log/watchdog.log >> $OUTPUTDIR/watchdog.log 2>/dev/null
    cat $OUTPUTDIR/$xdir/log/${program_name}.log >> $OUTPUTDIR/${program_name}.log 2>/dev/null
    echo "LOG FROM $xdir" >> $OUTPUTDIR/${program_name}_error.log 
    cat $OUTPUTDIR/$xdir/log/${program_name}_error.log >> $OUTPUTDIR/${program_name}_error.log 2>/dev/null
    cat $OUTPUTDIR/$xdir/log/excluded_check_ids.log >> $OUTPUTDIR/excluded_check_ids.log 2>/dev/null
  fi
}

function run_report ()
{
  i=$cname
  cnt=0
  #echo "checkinmg and removing files from .${program_name}/${program_name}_${FDS}/"
  #cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*_results.xml |grep -v "Results modelVersion=" > $OUTPUTDIR/${cname}_results.xml 2>/dev/null
  grep -v "Results modelVersion=" $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*_results.xml > $OUTPUTDIR/${cname}_results.xml 2>/dev/null
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/patch_summary.html >> $OUTPUTDIR/patch_summary.html 2>/dev/null
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/patch_detailed.html >> $OUTPUTDIR/patch_detailed.html 2>/dev/null
  #fix to upload data to databae from remote nodes
  R_OUTPUTDIR=$OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}
  r_upload_raccheck_result_fil_base=$R_OUTPUTDIR/upload_${program_name}_result_base.sql
  r_upload_raccheck_result_fil=$R_OUTPUTDIR/upload_${program_name}_result.sql
  r_upload_raccheck_patch_result_fil=$R_OUTPUTDIR/upload_${program_name}_patch_result.sql
  R_UPDATEFIL=$R_OUTPUTDIR/db_update_$FDS.sql

  if [ -f "$r_upload_raccheck_result_fil_base" ] ; then cat $r_upload_raccheck_result_fil_base >> $upload_raccheck_result_fil_base 2>/dev/null ; fi
  if [ -f "$r_upload_raccheck_result_fil" ] ; then cat $r_upload_raccheck_result_fil >> $upload_raccheck_result_fil 2>/dev/null ; fi
  if [ -f "$r_upload_raccheck_patch_result_fil" ] ; then cat $r_upload_raccheck_patch_result_fil >> $upload_raccheck_patch_result_fil 2>/dev/null; fi
  if [ -f "$R_UPDATEFIL" ] ; then cat $R_UPDATEFIL >> $UPDATEFIL 2>/dev/null; fi
 #fix to upload data to databae from remote nodes ends here

  rm -f $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/patch_summary.html $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/patch_detailed.html 2>/dev/null
  for file in `ls $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*_timings.out 2>/dev/null`
  do
    filen=$(basename $file)
    cat $file >> $OUTPUTDIR/$filen
  done

  #while read line
  #do
  #  if [[ `echo $line | grep -ic CheckID` -gt 0 ]] ; then
  #    CHECK_ID=$(echo $line | cut -d">" -f2 | cut -d"<" -f1)
  #    status_on_target="";
  #  fi
  #  if [[ `echo $line | grep -ic CheckType` -gt 0 ]] ; then
  #    COMTYPE=$(echo $line | cut -d">" -f2 | cut -d"<" -f1)
  #  fi
  #  if [[ `echo $line | grep -ic "<Status>"` -gt 0 ]] ; then
  #    l_chk_status=$(echo $line | cut -d">" -f2 | cut -d"<" -f1)
  #    if [[ $l_chk_status = "PASS" ]] ; then ALVL="PASS"; fi;
  #  fi
  #  if [[ `echo $line | grep -ic "<AlertType>"` -gt 0 ]] ; then
  #    ALVL=$(echo $line | cut -d">" -f2 | cut -d"<" -f1)
  #  fi
  #  if [[ `echo $line | grep -ic "<ColumnValue Name=.InstanceName."` -gt 0 ]] ; then
  #    status_on_target=$(echo $line | cut -d"\"" -f4)
  #  fi
  #  if [[ `echo $line | grep -ic "/[a-zA-Z]*Result>"` -gt 0 ]] ; then
  #    read_checkid_vars;
  #    create_report_files;
  #  fi
  #done  < $OUTPUTDIR/${cname}_results.xml
  if [ -e "$OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/slave_results_${cname}.out" ]
  then 
    while read line
    do
      CHECK_ID=$(echo $line | cut -d"|" -f1)
      ALVL=$(echo $line | cut -d"|" -f2)
      COMTYPE=$(echo $line | cut -d"|" -f3)
      status_on_target=$(echo $line | cut -d"|" -f4)
      db_name_to_check=$(echo $line | cut -d"|" -f5)
      inst_name=$(echo $line | cut -d"|" -f6)
      mb_db_homes=$(echo $line | cut -d"|" -f7)
      message4Home=$(echo $line | cut -d"|" -f8)
      cch_cname=$(echo $line | cut -d"|" -f9)
      sl_hosts=$(echo $line | cut -d"|" -f10)
      htmlf=$(ls $OUTPUTDIR/$i/.${program_name}/${program_name}_${FDS}/$CHECK_ID.html 2>/dev/null |tail -1)
      if [ -e "$htmlf" ] ; then
        read_checkid_vars;
        create_report_files;
      fi
    done < $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/slave_results_${cname}.out
  fi

  cat $OUTPUTDIR/${cname}_results.xml >> $XMLREPFIL 2>/dev/null
  rm -f $OUTPUTDIR/${cname}_results.xml 2>/dev/null
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*_exceptions.xml |grep -v "Exclusions modelVersion" >> $XMLSKIPFIL 2>/dev/null
  if [ -e "$OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/${program_name}.rep" ]
  then
    for file in $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*.rep
    do
      fname=$(basename $file)
      cat $file >> $OUTPUTDIR/$fname
    done
  fi

  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*_skipped_checks.log >> $OUTPUTDIR/${program_name}_skipped_checks.log 2>/dev/null
  echo "LOG FROM $i" >> $OUTPUTDIR/watchdog.log
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/watchdog.log >> $OUTPUTDIR/watchdog.log 2>/dev/null
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*_env.out.diff | grep '^> ' | sed 's/^..//' >> $MASTERFIL 2>/dev/null
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/${program_name}.log >> $LOGFIL 2>/dev/null
  echo "LOG FROM $i" >> $ERRFIL
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/${program_name}_error.log >> $ERRFIL 2>/dev/null
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/excluded_check_ids.log >> $EXCLUDELOG 2>/dev/null
}

function create_report_files ()
{
  #echo "creating report for  $ALVL $CHECK_ID";
  init_arrays_html "$ALVL"
  write_additional_info $ALVL
  # gadiga for SHS

  skip_count=0
  if [ -n "$MERGEFILES" ]
  then
    if [ `grep -ic $CHECK_ID $SCRIPTPATH/.cgrep/profiles/${storage_id_file}.prf` -gt 0 ];
    then
      skip_count=1
    elif [ `grep -ic $CHECK_ID $SCRIPTPATH/.cgrep/profiles/${switch_id_file}.prf` -gt 0 ];
    then
      skip_count=0
    fi
  fi
  
  if [ $skip_count -eq 0 ]
  then
    if [[ $ALVL != "PASS" ]] ; then
      case "$ALVL" in
        "FAIL")
           let G_FAIL_CHECKS=$G_FAIL_CHECKS+1
           ;;
        "WARNING")
           let G_WARN_CHECKS=$G_WARN_CHECKS+1
           ;;
        "INFO")
	   if [[ -n "$LOGIC" && "$LOGIC" = "Y" ]]
           then
	           let G_INFO_CHECKS_SCORE=$G_INFO_CHECKS_SCORE+1
	   fi
	   let G_INFO_CHECKS=$G_INFO_CHECKS+1
           ;;
        *)
           let G_FAIL_CHECKS=$G_FAIL_CHECKS+1
           ;;
      esac
    fi
    let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1; 
    validate_needs_running;
  fi
  #end code for SHS
}

function read_checkid_vars()
{
  PARAM_PATH=`grep _$CHECK_ID\-PARAM_PATH $REFFIL |awk {'print $2'}`
  HOME_PATH=`grep _$CHECK_ID\-HOME_PATH $REFFIL |awk {'print $2'}`
  ISBRANCH=`grep _$CHECK_ID\-IS_BRANCH $REFFIL |awk {'print $2'} `
  EPFILRES_ROOT_OS=`grep _$CHECK_ID\-REQUIRES_ROOT $REFFIL |awk {'print $2'}`
  PARAM=`grep "_"$CHECK_ID"-PARAM_PATH" $REFFIL |sed  -n 's/.*PARAM_PATH //p'`
  NEEDS_RUNNING=`grep "_"$CHECK_ID"-NEEDS_RUNNING" $REFFIL |sed  -n 's/.*NEEDS_RUNNING //p'| sed 's/^ *\(.*\) *$/\1/'`
  TARGET_TYPE=`grep "_"$CHECK_ID"-TARGET_TYPE" $REFFIL |sed  -n 's/.*TARGET_TYPE //p'| sed 's/^ *\(.*\) *$/\1/'`
  execute_once=`grep "_"$CHECK_ID"-EXECUTE_ONCE" $REFFIL |sed  -n 's/.*EXECUTE_ONCE //p'| sed 's/^ *\(.*\) *$/\1/'`
  check_exadata_version=$(grep "_"$CHECK_ID"-EXADATA_VERSION" $REFFIL |sed  -n 's/.*EXADATA_VERSION //p'| sed 's/^ *\(.*\) *$/\1/')
  check_database_role=$(grep "_"$CHECK_ID"-DATABASE_ROLE" $REFFIL |sed  -n 's/.*DATABASE_ROLE //p'| sed 's/^ *\(.*\) *$/\1/')
  SF=`grep "_"$CHECK_ID"-SF" $REFFIL |sed  -n 's/.*-SF //p'`
  check_components=`grep "_"$CHECK_ID"-COMPONENTS" $REFFIL |sed  -n 's/.*COMPONENTS //p'| sed 's/^ *\(.*\) *$/\1/'`
  OP=`grep _$CHECK_ID\-OPERATOR $REFFIL |sed  -n 's/.*OPERATOR //p'`
  if [[ -z "$OP" && -e $REFFIL1 ]];then OP=`grep _$CHECK_ID\-OPERATOR $REFFIL1 |sed  -n 's/.*OPERATOR //p'`;fi
  COMP=`grep "_"$CHECK_ID"-COMPARE_VALUE" $REFFIL |sed  -n 's/.*COMPARE_VALUE //p'`
  if [[ -z "$COMP" && -e $REFFIL1 ]];then  COMP=`grep "_"$CHECK_ID"-COMPARE_VALUE" $REFFIL1 |sed  -n 's/.*COMPARE_VALUE //p'`;fi
  audit_check_name=`grep "_"${CHECK_ID}"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
  #COM=`grep "_"$CHECK_ID"-OS_COMMAND" $REFFIL |sed  -n 's/.*OS_COMMAND //p'`
  com_begin_pattern="_${CHECK_ID}-OS_COMMAND_START"
  com_end_pattern="_${CHECK_ID}-OS_COMMAND_END"
  COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d')

  if [[ `echo $COM|grep -ic "limits.conf"` -ge 1 || `echo $COM|grep -ic "usrlimit"` -ge 1 ]]; then ulimit_cmd=1;else ulimit_cmd=0;fi

  if [ -n "$MERGEFILES" ]
  then
    if [ $d_index -eq 0 ];
    then
      htmlf=$(ls $OUTPUTDIR/$CHECK_ID.html.out |tail -1)
    else
      htmlf=$(ls $OUTPUTDIR/$xdir/outfiles/$CHECK_ID.html.out |tail -1)
    fi
  else
    htmlf=$(ls $OUTPUTDIR/$i/.${program_name}/${program_name}_${FDS}/$CHECK_ID.html |tail -1)
  fi

  FMSG="$cch_cname"
  PMSG="$cch_cname"
  SOURCEFIL_REPORT=""
  SOURCEFIL_REPORT_NEW=""
  if [ -n "$htmlf" ] ; then
    #grep_for="Status"
    #if [[ `grep -ic "Status on" $htmlf` -gt 1 && -n "$status_on_target" ]] ; then
    #  grep_for="$status_on_target"
    #fi

    #FMSG=$(grep "Status on" $htmlf |grep "$grep_for" |sed 's/.*=> //' | sed 's/<\/p.*//')
    #PMSG=$FMSG
    #ALVL=$(grep "Status on" $htmlf |grep "$grep_for" |tail -1 | sed 's/<\/span> =>.*//' |sed 's/.*span class="status_//' | cut -d">" -f2)
    SOURCEFIL_REPORT=$htmlf
    SOURCEFIL_REPORT_NEW=$htmlf
  else
    echo "#### Did not find html file for $CHECK_ID on $i"
  fi
}

function copy_env_files_to_tmp ()
{
  localcmdval=$RTEMPDIR/.localcmd.val

  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] && [[ -n $1 && "$1" = "${root_user}" ]]; then 
    OLD_TMPDIR=$TMPDIR; 
    TMPDIR=$TMP_OUTPUT; 
    COM=$(echo "$COM"|sed 's/\$TMPDIR/\$TMP_OUTPUT/g'|sed 's/\$RTEMPDIR/\$TMP_OUTPUT/g')
    COM_REPORT=$(echo "$COM_REPORT"|sed 's/\$TMPDIR/\$TMP_OUTPUT/g'|sed 's/\$RTEMPDIR/\$TMP_OUTPUT/g')
  fi  
 
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then localcmdval=$TMP_OUTPUT/.localcmd.val; fi

  TRGTORCLENV=$TMPDIR/`basename $ORCLENVFIL`
  localcmd=$TMPDIR/localcmd.sh

  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] && [[ -n $1 && "$1" = "${root_user}" ]]; then rm -f $TRGTORCLENV >/dev/null 2>&1; fi

  if [ $OFFLINE -eq 0 ]
  then
    if [ $i = $localnode ]
    then
      if [ ! -e "$TRGTORCLENV" ]; then cp -r $ORCLENVFIL $TMPDIR >/dev/null 2>&1;fi
      if [ ! -e "$TMPDIR/raccheck_env.out" ]; then cp -r $MASTERFIL $TMPDIR >/dev/null 2>&1;fi
    else
      get_cygpath "ORCLENVFIL"
      get_cygpath "TMPDIR"
      get_cygpath "MASTERFIL"
      remote_trgtenvfile=$($SSHELL $i  "ls -l $TRGTORCLENV 2>/dev/null|wc -l")
      if [ $remote_trgtenvfile -le 0 ]; then $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null 2>&1;fi
      remote_masterfile=$($SSHELL $i  "ls -l $TMPDIR/raccheck_env.out 2>/dev/null|wc -l")
      if [ $remote_masterfile -le 0 ]; then $SCOPY $MASTERFIL $i:$TMPDIR/ >/dev/null 2>&1;fi
      restore_cygpath "ORCLENVFIL"
      restore_cygpath "TMPDIR"
      restore_cygpath "MASTERFIL"
    fi
  fi
  
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] && [[ -n $1 && "$1" = "${root_user}" ]]; then TMPDIR=$OLD_TMPDIR; fi  
}

# watch all pids running in background and unset array element when not found  
# exit when there are no elements

function wait_for_cell_completion ()
{
  if [[ -n "${#cell_pids[@]}" && ${#cell_pids[@]} -eq "0" ]] ; then return ; fi;

  keep_looping=1
  while [ $keep_looping -eq "1" ]
  do
    if [[ -n "${#cell_pids[@]}" && ${#cell_pids[@]} -eq "0" ]] ; then return ; fi;
    for cell_pid in "${cell_pids[@]}"
    do
      # wait till we finish collection running on cell
      if [ `ps -ef | grep _cell |grep -c $cell_pid` -gt 0 ]
      then
        if [[ -n "$cell_type" && $cell_type  = "zfscell" ]] ; then 
	  #if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] ; then
	  #if [[ -n "$RAT_GLOBAL_RUNMODE" && $RAT_GLOBAL_RUNMODE = "serial" ]] ; then 
          printf "."
	  #fi
	fi
        #echo "runing $cell_pid on ${cell_pid_names[$cell_pid]}";
      else
        #echo "Finished run($cell_pid) on ${cell_pid_names[$cell_pid]}";
        cellname=${cell_pid_names[$cell_pid]};
        cell_rootpassword=${cell_root_password[$cell_pid]}
        copy_from_cell;
        cleanup_cell;
        unset cell_pids[$cell_pid]; # remove from array
      fi
    done
    sleep 2
  done
}

function on_signal_cell_cleanup ()
{
  if [[ -n "${#cell_pids[@]}" && ${#cell_pids[@]} -eq "0" ]] ; then return ; fi;
  for cell_pid in "${cell_pids[@]}"
  do
    kill -9 $cell_pid >/dev/null 2>&1
    cell_rootpassword=${cell_root_password[$cell_pid]}
    cellname=${cell_pid_names[$cell_pid]};
    cleanup_cell;
  done
}

function setup_cell ()
{
  fixRootPassword "$cell_rootpassword"
  $EXPECT -f - 2>>$ERRFIL << IBEOF
    set timeout $passwordcheck_timeout
    set le_cell_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SCOPY $CELLSSCRPT $SCRIPTPATH/.cgrep/$ASREXACHK $SCRIPTPATH/.cgrep/$checkFlashCache $cell_ssh_user@$cellname:$CELLTMPDIR
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
        send -- "yes\n"
      }
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      -nocase eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "Timed out while copying on $cellname\n";
        exit
      }

    }
IBEOF
  $EXPECT -f - 2>>$ERRFIL << IBEOF
    set timeout $passwordcheck_timeout
    set le_cell_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SSHELL $cell_ssh_user@$cellname mkdir ${CELLRTEMPDIR}
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
        send -- "yes\n"
      }
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      -nocase eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "Timed out while running mkdir on $cellname\n";
        exit
      }

    }
IBEOF
  $EXPECT -f - 2>>$ERRFIL << IBEOF
    set timeout $passwordcheck_timeout
    set le_cell_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SSHELL $cell_ssh_user@$cellname chmod 744 $CELLTMPDIR/${program_name}_cells.sh $CELLTMPDIR/$ASREXACHK $CELLTMPDIR/$checkFlashCache
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
        send -- "yes\n"
      }
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      -nocase eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "Timed out while chmod on $cellname\n";
        exit
      }

    }
IBEOF

}

# TODOS
# Create this as a script so that different passwords are handled. This will work only when password is same on all cells.

function copy_from_cell ()
{
  cellname_short=$(echo $cellname|sed 's/\./_/g')
  CELLDIR_SHORT=$CELLDIR/$cellname_short
  #delete directory in exachk output directory for this cell if it exits 
  if [ -e $CELLDIR_SHORT ]; then rm -rf $CELLDIR_SHORT >/dev/null 2>&1; fi
  mkdir -p $CELLDIR_SHORT

  fixRootPassword "$cell_rootpassword"
  $EXPECT -f - 2>>$ERRFIL << IBEOF
    #set timeout 5
    set timeout $passwordcheck_timeout
    set le_cell_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SCOPY $cell_ssh_user@$cellname:${CELLRTEMPDIR}/c_*.out $CELLDIR_SHORT
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
        send -- "yes\n"
      }
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      -nocase eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "Timed out while copying files from $cellname\n";
        exit
      }

    }
IBEOF
  if [[ -e $CELLDIR/c_root_collect_timing.out && -e $COLLECT_TIMING ]]
  then
    cat $CELLDIR/c_root_collect_timing.out >> $COLLECT_TIMING
    rm -f $CELLDIR/c_root_collect_timing.out  >/dev/null 2>&1
  fi
  if [ -e $CELLDIR_SHORT ]; then format_cell_switch_files "$cellname_short" "$CELLDIR_SHORT" "cell";fi
}

function cleanup_cell ()
{
  fixRootPassword "$cell_rootpassword"
  $EXPECT -f - 2>>$ERRFIL << IBEOF
    set timeout $passwordcheck_timeout
    set le_cell_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SSHELL $cell_ssh_user@$cellname rm -f ${CELLRTEMPDIR}/SSH_chk_file.sh ${CELLRTEMPDIR}/c_*.out ${CELLRTEMPDIR}/o_*.out $CELLTMPDIR/${program_name}_cells.sh $CELLTMPDIR/$ASREXACHK $CELLTMPDIR/$checkFlashCache 
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
        send -- "yes\n"
      }
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      -nocase eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "Timed out while removing files on $cellname\n";
        exit
      }

    }
IBEOF
  $EXPECT -f - 2>>$ERRFIL << IBEOF
    set timeout $passwordcheck_timeout
    set le_cell_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SSHELL $cell_ssh_user@$cellname rmdir  ${CELLRTEMPDIR}
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
        send -- "yes\n"
      }
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      -nocase eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      -nocase "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "Timed out while removing temp dir on $cellname\n";
        exit
      }

    }
IBEOF
}

# Start the run in  background
# Put the current pid in cell_pids[pid]=pid

function start_run_on_cell_in_background ()
{
  cleanup_cell;
  setup_cell;
  t_flag="";
  sudo_flag="";
  if [[ -n "$DOROOT" && $DOROOT -eq 1 && -n "$RAT_CELL_SSH_USER" && $RAT_CELL_SSH_USER = "celladmin" ]] || [[ -n "$RAT_CELL_SSH_USER" && "$RAT_CELL_SSH_USER" = "cellmonitor" ]]
  then
    t_flag="-t";
    sudo_flag="sudo";
  fi
  rm -f $RTEMPDIR/cell.pid
  cr_file=$RTEMPDIR/${program_name}_cell_$cellname.sh
  #cp ${CELLSSCRPT} /tmp/${program_name}_cells_$cellname.sh
  echo "#!/bin/env bash" > $cr_file
  echo "$RAT_DEBUG_FLG" >>$cr_file
  echo "echo \$\$ > $RTEMPDIR/cell.pid" >> $cr_file
  if [[ $in_last_cell -eq 1 ]] && [[ -n "$RAT_GLOBAL_RUNMODE" && $RAT_GLOBAL_RUNMODE = "serial" ]]; then
    echo "$SSHELL $t_flag $cell_ssh_user@$cellname  $sudo_flag \"$CELLTMPDIR/${program_name}_cells.sh\" 2>>$ERRFIL|tee ${RTEMPDIR}/${cellname}.out" >> $cr_file
  else
    echo "$SSHELL $t_flag $cell_ssh_user@$cellname  $sudo_flag \"$CELLTMPDIR/${program_name}_cells.sh\" > ${RTEMPDIR}/${cellname}.out 2>>$ERRFIL" >> $cr_file
  fi
  chmod +x $cr_file

  is_SSH_blocked "$cellname" "$cell_ssh_user" "$cell_rootpassword" "CELL"
  if [[ $SSH_blocked -eq 1 ]]; then
    echo -e "\n${RED}Skipping $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER ${NORM} ${RED} ${cellname} is available but SSH is blocked.${NORM}\n"|tee -a $LOGFIL
    add_to_skipped_nodes "${cellname}" "SSH Issue: STORAGE SERVER is reachable but SSH is blocked"
    return;
  fi

  fixRootPassword "$cell_rootpassword"
  $EXPECT -f - 2>>$WATCHLOG << IBEOF &
    set timeout $passwordcheck_timeout
    set le_cell_rootpassword "$fixedRootPassword"
    log_user 0
    spawn -noecho $cr_file
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
         send -- "yes\n"
       }
      -nocase "*?assword:*" {
	send -- "\$le_cell_rootpassword\n"
      }
      -nocase eof {
         exit
       }
    }
    # Look for passwd prompt
    set timeout $watchdog_wakeup_root
    expect {
      -nocase "*?assword:*" {
	send -- "\$le_cell_rootpassword\n"
      }
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "\nTimed out while running collections on $cellname\n";
        exit
      }
    }
IBEOF
  #only for execution
  returncode=`echo $?`
  move_failed_to_skipped "$returncode" "$CELLTMPDIR/${program_name}_cells.sh execution"
			
  #sleep 2;
  #cell_pid=$(cat $RTEMPDIR/cell.pid)
  cell_pid=$!
  cell_pids[$cell_pid]="$cell_pid";
  cell_pid_names[$cell_pid]="$cellname"
  cell_root_password[$cell_pid]="$cell_rootpassword"
}


# functions to run collection on ib switches in background
function start_run_on_ib_in_background ()
{
  cleanup_ib;
  setup_ib;
  rm -f $RTEMPDIR/ib.pid
  cr_file=$RTEMPDIR/${program_name}_run_ibswitch_$switchname.sh
  cp $IBSWITCHSCRPT $RTEMPDIR/${program_name}_ibswitch_$switchname.sh
  echo "#!/bin/env bash" > $cr_file
  echo "$RAT_DEBUG_FLG" >> $cr_file
  echo "echo \$\$ > $RTEMPDIR/ib.pid" >> $cr_file
  if [[ $in_last_ib -eq 1 ]] && [[ -n "$RAT_GLOBAL_RUNMODE" && $RAT_GLOBAL_RUNMODE = "serial" ]]; then
    echo "$SSHELL_EL $ibswitch_user@$switchname  < $RTEMPDIR/${program_name}_ibswitch_$switchname.sh 2>>$ERRFIL |tee ${RTEMPDIR}/${switchname}.out" >> $cr_file
  else
    echo "$SSHELL_EL $ibswitch_user@$switchname  < $RTEMPDIR/${program_name}_ibswitch_$switchname.sh > ${RTEMPDIR}/${switchname}.out 2>>$ERRFIL" >> $cr_file
  fi
  chmod +x $cr_file

  is_SSH_blocked "$switchname" "$ibswitch_user" "$switch_rootpassword" "SWITCH"
  if [[ $SSH_blocked -eq 1 ]]; then
    echo -e "\n${RED}Skipping $ibswitch_user privileged commands on ${BLINK}INFINIBAND SWITCH ${NORM} ${RED} ${switchname} is available but SSH is blocked.${NORM}\n"|tee -a $LOGFIL 
    add_to_skipped_nodes "${switchname}" "SSH Issue: INFINIBAND SWITCH is reachable but SSH is blocked"
    return;
  fi   

  fixRootPassword "$switch_rootpassword"

  $EXPECT -f - 2>>$WATCHLOG << IBEOF &
    set timeout $passwordcheck_timeout
    set le_switch_rootpassword "$fixedRootPassword"
    log_user 0
    spawn -noecho $cr_file
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
         send -- "yes\n"
       }
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      -nocase eof {
         exit
       }
    }
    # Look for passwd prompt
    set timeout $watchdog_wakeup_root
    expect {
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "\nTimed out while running collections on $switchname\n";
        exit
      }
    }
IBEOF
  #only for execution
  returncode=`echo $?`		
  move_failed_to_skipped "$returncode" "$RTEMPDIR/${program_name}_ibswitch_$switchname.sh execution"

  #sleep 2;
  #ib_pid=$(cat $RTEMPDIR/ib.pid)
  ib_pid=$!
  ib_pids[$ib_pid]="$ib_pid";
  ib_pid_names[$ib_pid]="$switchname"
  ib_root_password[$ib_pid]="$switch_rootpassword"
}

function wait_for_ib_completion ()
{
  if [[ -n "${#ib_pids[@]}" && ${#ib_pids[@]} -eq "0" ]] ; then return ; fi;

  keep_looping=1
  while [ $keep_looping -eq "1" ]
  do
    if [[ -n "${#ib_pids[@]}" && ${#ib_pids[@]} -eq "0" ]] ; then return ; fi;
    for ib_pid in "${ib_pids[@]}"
    do
      # wait till we finish collection running on ib switch
      if [ `ps -ef | grep _ibswitch_ |grep -c $ib_pid` -gt 0 ]
      then
        printf ""
      else
        #echo "Finished run on ${ib_pid_names[$ib_pid]}";
        switchname=${ib_pid_names[$ib_pid]};
        switch_rootpassword=${ib_root_password[$ib_pid]}
        copy_from_ib;
        cleanup_ib;
        unset ib_pids[$ib_pid]; # remove from array
      fi
    done
    sleep 2
  done
}

function wait_for_system_completion ()
{
  if [[ -n "${#cell_pids[@]}" && ${#cell_pids[@]} -eq "0" ]] && [[ -n "${#ib_pids[@]}" && ${#ib_pids[@]} -eq "0" ]]; then return ; fi;

  keep_looping=1
  start_rd=1;
  last_rd=0;
  if [[ -n "$RAT_CELL_RUNMODE" && $RAT_CELL_RUNMODE = "parallel" ]]; then
    if [[ "$last_ib_name" != "" ]] || [[ "$profiles2run" = "storage" ]] || [[ $no_ib_switch -eq "1" ]]; then
      if [[ "$last_cell_name" != "" ]]; then
      	if [[ -n "$cell_type" && $cell_type  != "zfscell" ]] || [[ -z $cell_type ]] ; then
      	  echo -e "\n"
      	  echo "Collections from STORAGE SERVER:";
      	  echo "----------------------------------";
      	fi
      fi
    fi
  fi
	
  while [ $keep_looping -eq "1" ]
  do
    print_ib=0;
    if [[ -n "${#cell_pids[@]}" && ${#cell_pids[@]} -eq "0" ]] && [[ -n "${#ib_pids[@]}" && ${#ib_pids[@]} -eq "0" ]]; then print_ib=1; return ; fi;

    if [[ -n "$RAT_CELL_RUNMODE" && $RAT_CELL_RUNMODE = "parallel" ]]; then
      if [[ -n "${#cell_pids[@]}" && ${#cell_pids[@]} -gt "0" ]] ; then
        for cell_pid in "${cell_pids[@]}"
        do
          if [ `ps -ef | grep _cell |grep -c $cell_pid` -gt 0 ]
          then
            if [[ -n "$cell_type" && $cell_type  = "zfscell" ]] ; then
              if [[ -n "$RAT_GLOBAL_RUNMODE" && $RAT_GLOBAL_RUNMODE = "serial" ]] ;
              then
        	printf "."
              fi
            fi
          else
            cellname=${cell_pid_names[$cell_pid]};
            cell_rootpassword=${cell_root_password[$cell_pid]}
            copy_from_cell;
            cleanup_cell;
            unset cell_pids[$cell_pid]; # remove from array
          fi
        done
      fi
    fi
    
    if [[ -n "$RAT_IBSWITCH_RUNMODE" && $RAT_IBSWITCH_RUNMODE = "parallel" ]]; then
      if [[ -n "${#ib_pids[@]}" && ${#ib_pids[@]} -gt "0" ]] ; then
        for ib_pid in "${ib_pids[@]}"
        do
          if [ `ps -ef | grep _ibswitch_ |grep -c $ib_pid` -gt 0 ]
          then
            printf ""
          else
            switchname=${ib_pid_names[$ib_pid]};
            switch_rootpassword=${ib_root_password[$ib_pid]}
            copy_from_ib;
            cleanup_ib;
            unset ib_pids[$ib_pid]; # remove from array
          fi
        done
      fi
    fi
    
    if [[ -n "$RAT_CELL_RUNMODE" && $RAT_CELL_RUNMODE = "parallel" ]]; then
      if [[ "$last_ib_name" != "" ]] || [[ "$profiles2run" = "storage" ]] || [[ $no_ib_switch -eq "1" ]]; then
        if [[ "$last_cell_name" != "" ]]; then
          if [[ -n "$cell_type" && $cell_type  != "zfscell" ]] || [[ -z $cell_type ]] ; then
            last_rd=$(cat ${RTEMPDIR}/${last_cell_name}.out|wc -l);
            last_rd=$(echo "$last_rd"|sed 's/[ ]*//g');
            sed -n "$start_rd,${last_rd}p" ${RTEMPDIR}/${last_cell_name}.out; 		
            start_rd=$(expr $last_rd + 1);
          fi
        fi
      fi
    fi
    sleep 2	
  done
}

function on_signal_ib_cleanup ()
{
  if [[ -n "${#ib_pids[@]}" && ${#ib_pids[@]} -eq "0" ]] ; then return ; fi;

  for ib_pid in "${ib_pids[@]}"
  do
    kill -9 $ib_pid >/dev/null 2>&1
    switchname=${ib_pid_names[$ib_pid]};
    switch_rootpassword=${ib_root_password[$ib_pid]}
    cleanup_ib;
  done
}

function setup_ib ()
{
  ibTmpDirStatus=0
  ibs_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $switchname ls >/dev/null 2>&1;echo $?)
  if [ $ibs_ssh_status -eq 0 ]
  then
    ibTmpDirStatus=$($SSHELL $ibswitch_user@$switchname "if [ -e $IBTMPDIR ]; then echo 0;else echo 1;fi") 
  else 
    ibTmpDirStatus=0
    fixRootPassword "$switch_rootpassword"
    $EXPECT -f - << IBEOF
                                    set timeout $passwordcheck_timeout
                                    set le_switch_rootpassword "$fixedRootPassword"
				    log_user 0
                                    if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                      exp_internal 1
                                    } 
                                    spawn $SSHELL $ibswitch_user@$switchname "ls -ltr $IBTMPDIR"
				    match_max 100000
			       	    expect {
				      -nocase "permission denied *" {
				      exit 4;
			            }
			      	      -nocase "no)?" {
				      send -- "yes\n"
			            }
			              -nocase "*?assword:*" {
				      send -- "\$le_switch_rootpassword\n"
			            }
				      -nocase "*no such file*directory*" {
				      exit 1
				    }
			      	      -nocase eof {
				      exit 0
			            }
			    }
			    expect {
			      -nocase "*?assword:*" {
				send -- "\$le_switch_rootpassword\n"
			      }
			      -nocase eof {
				exit 0
			      } -nocase timeout {
                                send_error "Timed out while checking temp dir existance on $switchname\n";
				exit 2
			      }
				-nocase "*no such file*directory*" {
				  exit 1
			      }
			    }
			    expect -nocase eof
IBEOF

    ibTmpDirStatus=$(echo $?)
  fi
  #echo "ibTmpDirStatus=$ibTmpDirStatus"
  if [ $ibTmpDirStatus -eq 1 ]
  then
    echo -e "${RED}home directory(\$HOME) for $ibswitch_user user does not exists on $switchname"
    echo -e "${RED}Please set RAT_IB_TMPDIR(eg export RAT_IB_TMPDIR=/home/nm2user) to directory available on $switchname which is accessible to $ibswitch_user ${NORM}\n\n"
    exit 1
  else 
    echo -e "\n$IBTMPDIR is avilable on $switchname\n" >>$LOGFIL
  fi
 
  $EXPECT -f - 2>>$ERRFIL << IBEOF
    set timeout $passwordcheck_timeout
    set le_switch_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SSHELL $ibswitch_user@$switchname mkdir ${IBRTEMPDIR}
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
        send -- "yes\n"
      }
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      -nocase eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "Timed out while creating temp dir on $switchname\n";
        exit
      }

    }
IBEOF

  $EXPECT -f - 2>>$ERRFIL << IBEOF
    set timeout $passwordcheck_timeout
    set le_switch_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SCOPY $SWITCH_TYPE_FIL $ibswitch_user@$switchname:${IBRTEMPDIR}
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
        send -- "yes\n"
      }
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      -nocase eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "Timed out while creating temp dir on $switchname\n";
        exit
      }

    }
IBEOF
}

function copy_from_ib ()
{
  #Following code is to change switch ip address to fully qualified domain name so OS_OUT_CHECK dont get skipped
  is_ibswitch_ip=$(echo $switchname|grep -c [A-Za-z])
  if [[ -n $is_ibswitch_ip && $is_ibswitch_ip -eq 0 ]]
  then
    switchname_short=$(echo $switchname|sed 's/\./_/g')
  else
    switchname_short=$(echo $switchname|cut -d. -f1)            
  fi
  switchDirShort=$OUTPUTDIR/$switchname_short
  if [ -e $switchDirShort ]; then rm -rf $switchDirShort >/dev/null 2>&1; fi
  mkdir -p $switchDirShort  

  fixRootPassword "$switch_rootpassword"
  $EXPECT -f - 2>>$ERRFIL << IBEOF
    #set timeout 5
    set timeout $passwordcheck_timeout
    set le_switch_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SCOPY $ibswitch_user@$switchname:${IBRTEMPDIR}/s_*.out $switchDirShort
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
        send -- "yes\n"
      }
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      -nocase eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "Timed out while copying files from $switchname\n";
        exit
      }

    }
IBEOF
  if [[ -e $OUTPUTDIR/s_root_collect_timing.out && -e $COLLECT_TIMING ]]
  then
    cat $OUTPUTDIR/s_root_collect_timing.out >> $COLLECT_TIMING
    rm -f $OUTPUTDIR/s_root_collect_timing.out  >/dev/null 2>&1
  fi
  if [ -e $switchDirShort ]; then format_cell_switch_files "$switchname_short" "$switchDirShort" "switch";fi

}

function cleanup_ib ()
{
  if [ -e "$TMPDIR/${program_name}_ibswitch_$switchname.sh" ] ; then
    rm -f $TMPDIR/${program_name}_ibswitch_$switchname.sh
  fi

  fixRootPassword "$switch_rootpassword"

  $EXPECT -f - 2>>$ERRFIL << IBEOF
  set timeout $passwordcheck_timeout
  set le_switch_rootpassword "$fixedRootPassword"
  log_user 0
  spawn $SSHELL $ibswitch_user@$switchname rm -f ${IBRTEMPDIR}/SSH_chk_file.sh ${IBRTEMPDIR}/s_*.out ${IBRTEMPDIR}/o_*.out ${IBRTEMPDIR}/${SWITCH_TYPE_FIL_SHORT}
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
        send -- "yes\n"
      }
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      -nocase eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "Timed out while cleaning files on $switchname\n";
        exit
      }

    }
IBEOF
  $EXPECT -f - 2>>$ERRFIL << IBEOF
  set timeout $passwordcheck_timeout
  set le_switch_rootpassword "$fixedRootPassword"
  log_user 0
  spawn $SSHELL $ibswitch_user@$switchname rmdir ${IBRTEMPDIR}
    match_max 100000
    expect {
      -nocase "permission denied *" {
	 exit 4;
      }
      -nocase "no)?" {
        send -- "yes\n"
      }
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      -nocase eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      -nocase "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      -nocase eof {
        exit
      } -nocase timeout {
        send_error "Timed out while removing temp dir on $switchname\n";
        exit
      }

    }
IBEOF

}

#Function to validate root password
checkUserPassword ()
{
  validateUserPassword=$4
  nodeNameToCheck=$1
  userToCheck=$2
  passwordToCheck=$3
 
  fixRootPassword "$passwordToCheck"
 
  if [ -n "$5" ] 
  then
   targetHostType="$5"
  else
   targetHostType="normal"
  fi
  if [[ -n "$5" && "$5" = "ibswitch" ]]; then hostTypeSwitch=1;else hostTypeSwitch=0;fi
  if [[ -n "$5" && "$5" = "normal" ]]; then hostTypeCell=1;else hostTypeCell=0;fi
  if [[ `uname -s` = "Linux" || $hostTypeCell -eq 1 ]] && [ $hostTypeSwitch -eq 0 ];then loginDelayHost=1;else loginDelayHost=0;fi  
 
  if [[ -n "$RAT_PASSWORDCHECK_TIMEOUT" && $RAT_PASSWORDCHECK_TIMEOUT -gt 1 ]] 
  then 
    passwordcheck_timeout=$RAT_PASSWORDCHECK_TIMEOUT
  else 
    if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
    then
      passwordcheck_timeout=20
    else
      passwordcheck_timeout=10
    fi
  fi

  #Node is pingable but ssh takes long time...
  CONNECTTIMEOUT=$passwordcheck_timeout
  $EXPECT -f - << IBEOF
            set timeout $CONNECTTIMEOUT
            log_user 0
            if { "$RAT_EXPECT_DEBUG" == "-d" } {
              exp_internal 1
            }
            if { "$targetHostType" == "normal" } {
              spawn -noecho $SSHELL $userToCheck@$nodeNameToCheck "ls >/dev/null 2>&1"
            } else {
              spawn -noecho $SSHELL $userToCheck@$nodeNameToCheck script "ls >/dev/null 2>&1;"
            }
            match_max 100000
            expect {
              -nocase "no)?" {
                  send -- "yes\n"
              }
              -nocase "*?assword:*" {
		 exit 5;
              }
              -nocase "permission denied *" {
                  exit 4;
              }
              -nocase timeout {
                  exit 2;
              }
              -nocase eof {
                  exit 0;
              }
           }
            expect {
              -nocase "*?assword:*" {
           	  exit 5; 
              }
              -nocase "permission denied *" {
                  exit 4;
              }
              -nocase timeout {
                  exit 2;
              }
              -nocase eof {
                  exit 0;
              }
           }
         expect {
                 -nocase default {exit 0}
              }
         exit 0
IBEOF
  tmp_passwordCheckStatus=$(echo $?)
  if [[ $tmp_passwordCheckStatus -eq "2" ]] ; then
    echo -e  "\n\n${RED}Timed out while checking password on ${nodeNameToCheck}.\nSet RAT_PASSWORDCHECK_TIMEOUT to increase timeout. Ex: export RAT_PASSWORDCHECK_TIMEOUT=10\n\n${program_name} is exiting.${NORM}"
    exit 1;
  fi
  tty -s && stty echo
  #...........................................
 
  #tty -s && stty -echo
  #echo "passwordcheck_timeout=$passwordcheck_timeout"
  #if [ $validateUserPassword -gt 1 ]; then  hasDollar=$(echo $passwordToCheck|grep -c "$");if [ $hasDollar -ge 1 ]; then passwordToCheck=$(echo $passwordToCheck|sed 's/\$/\\$/g');fi;fi
 
  if [[ $targetHostType = "zfscell" ]] ; then passwordcheck_timeout=10; fi
 
  PCSHELL=$(echo $SSHELL|sed 's/ -q//g')
 
  if [[ -n "$PubkeyAuthentication" && "$PubkeyAuthentication" -eq "no" ]];
  then
    PCSHELL=$(echo "$PCSHELL -o PubkeyAuthentication=$PubkeyAuthentication")
  fi
 
  $EXPECT -f - << IBEOF
                           set timeout $passwordcheck_timeout
			   set le_passwordToCheck "$fixedRootPassword"
                           log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } { 
                             exp_internal 1
                           } 
			   if { "$targetHostType" != "zfscell" } {
                             spawn -noecho $PCSHELL $userToCheck@$nodeNameToCheck "echo \"LoginSuccessfull\""
			   } else {
                             spawn -noecho $PCSHELL $userToCheck@$nodeNameToCheck script "printf(\"LoginSuccessfull\\\\n\");"
			   }
                           match_max 100000
                           expect {
                             -nocase "no)?" {
                                 send -- "yes\n"
                                 }
                             -nocase "*?assword:*" {
				 send -- "\$le_passwordToCheck\n"
                                 }
                             -nocase "permission denied *" {
                                 exit 4;
                                 }
                             LoginSuccessfull { exit 0; }
 			     -nocase timeout {
                                 send_error "Timed out\n";
                                 exit 3
                             }
                             -nocase eof {
                                 exit 0
                                 }
                          }
                           expect {
                             -nocase "*?assword:*" {
				 send -- "\$le_passwordToCheck\n"
                                 }
                             -nocase "permission denied *" {
                                 exit 4;
                                 }
                             LoginSuccessfull { exit 0; }
 			     -nocase timeout {
                                 send_error "Timed out\n";
                                 exit 3
                             }
                             -nocase eof {
                                 exit 0
                                 }
                          }
                        expect {
                                -nocase default {exit 2}
                                LoginSuccessfull
                               }
                         exit 0
IBEOF
  #tty -s && stty echo
  passwordCheckStatus=$(echo $?)
  if [[ $passwordCheckStatus -eq "4" ]] ; then
    echo -e "\n\n${RED}Login to ${nodeNameToCheck} as ${userToCheck} is disabled in ssh configuration. Please review ssh configuration and retry ${program_name} run.\n\n${program_name} is exiting.${NORM}\n"
    noRootScriptNode[$noRootScriptNodeCount]=$nodeNameToCheck
    noRootScriptNodeCount=$( expr $noRootScriptNodeCount + 1 )
    exit 1;
  fi

  if [[ $passwordCheckStatus -eq "3" ]] ; then
    passwordCheckStatus=2
    #echo -e  "\n\n${RED}Timed out while checking password on ${nodeNameToCheck}\n. Set RAT_PASSWORDCHECK_TIMEOUT to increase timeout. Ex: export RAT_PASSWORDCHECK_TIMEOUT=10\n\n${program_name} is exiting.${NORM}"
  fi
  if [[ -n "$prepare_init" && $prepare_init -eq "1" ]] && [[ -z "$cell_type" ]]
  then
    if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 && $loginDelayHost -eq 1 && $passwordCheckStatus -ne 0 && $validateUserPassword -gt 1 ]]
    then
      #echo -e  "\n\n${RED}The password entered for the ${userToCheck} userid did not validate on ${nodeNameToCheck}\n\nThis userid may now be subject to a login delay on the specified node.Please review the pam utility configuration, and allow the specified amount of login delay time to elapse before retrying exachk.Please also check your pam failed login counts for this userid against the permitted total, and clear if required.\n\n${program_name} is exiting.${NORM}"
      echo -e  "\n\n${RED}Either the password entered for the ${userToCheck} userid did not validate on ${nodeNameToCheck} or Login to ${nodeNameToCheck} as ${userToCheck} is disabled in ssh configuration.Please review ssh configuration.\n\nThis userid may now be subject to a login delay on the specified node.Please review the pam utility configuration, and allow the specified amount of login delay time to elapse before retrying exachk.Please also check your pam failed login counts for this userid against the permitted total, and clear if required.\n\n${program_name} is exiting.${NORM}"
      exit 1
    fi
  fi

  while [[ $passwordCheckStatus -ne 0  && $validateUserPassword -gt 1 ]]
   do
     if [[ -n "$PubkeyAuthentication" && "$PubkeyAuthentication" -eq "no" ]];
     then
       OLD_SSHELL="$SSHELL"
       SSHELL=$(echo "$SSHELL -o PubkeyAuthentication=$PubkeyAuthentication")
     fi
 
     validateUserPassword=$(expr $validateUserPassword - 1 )
 
     if [[ $EM_XMLD_MODE -eq 1 ]]
     then
       break;
     fi

     echo -e "\n\n${RED}${userToCheck} password for $nodeNameToCheck was incorrect. $validateUserPassword retries remaining.${NORM}\n"
     printf  "Enter $userToCheck  password for ${BLINK}${nodeNameToCheck}${NORM} :- "
     tty -s && stty -echo
     $READ -r passwordToCheck
     printf "\n\nVerifying ${userToCheck} password.\n\n. . ";
 
     fixRootPassword "$passwordToCheck"
 
     #if [ $validateUserPassword -gt 1 ]; then  hasDollar=$(echo $passwordToCheck|grep -c "$");if [ $hasDollar -ge 1 ]; then passwordToCheck=$(echo $passwordToCheck|sed 's/\$/\\$/g');fi;fi
     $EXPECT -f - << IBEOF
                           set timeout $passwordcheck_timeout
			   set le_passwordToCheck "$fixedRootPassword"
                           log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } { 
                             exp_internal 1
                           } 
			   if { "$targetHostType" == "normal" } {
                             spawn -noecho $SSHELL $userToCheck@$nodeNameToCheck "echo \"LoginSuccessfull\""
			   } else {
                             spawn -noecho $SSHELL $userToCheck@$nodeNameToCheck script "printf(\"LoginSuccessfull\\\\n\");"
			   }
                           match_max 100000
                           expect {
                             -nocase "no)?" {
                                 send -- "yes\n"
                                 }
                             -nocase "*?assword:*" {
				 send -- "\$le_passwordToCheck\n"
                                 }
                             LoginSuccessfull { exit 0; }
 			     -nocase timeout {
                                 send_error "Timed out\n";
                                 exit 2
                             }
                             -nocase eof {
                                 exit 0
                                 }
                          }
                           expect {
                             -nocase "*?assword:*" {
				send -- "\$le_passwordToCheck\n"
                                 }
                             LoginSuccessfull { exit 0; }
 			     -nocase timeout {
                                 send_error "Timed out\n";
                                 exit 2
                             }
                             -nocase eof {
                                 exit 0
                                 }
                          }
                        expect {
                                -nocase default {exit 3}
                                LoginSuccessfull
                               }
                         exit 0
IBEOF
    passwordCheckStatus=$(echo $?)

    if [[ -n "$PubkeyAuthentication" && "$PubkeyAuthentication" -eq "no" ]];
    then
      SSHELL="$OLD_SSHELL"
    fi

    if [[ $passwordCheckStatus -eq "2" ]] ; then
      echo -e  "\n\n${RED}Timed out while checking password on ${nodeNameToCheck}.\nSet RAT_PASSWORDCHECK_TIMEOUT to increase timeout. Ex: export RAT_PASSWORDCHECK_TIMEOUT=10\n\n${program_name} is exiting.${NORM}"
      exit 1;
    fi
    tty -s && stty echo
  done

  if [[ $passwordCheckStatus -ne 0 && $4 -gt 1 ]]
  then
    #echo -e "\n\n${RED}${userToCheck} password for $nodeNameToCheck was incorrect. $userToCheck privileged checks will not be executed on $nodeNameToCheck ${NORM}\n"
    echo -e "\n\n${RED}Either ${userToCheck} password for $nodeNameToCheck was incorrect or Login to ${nodeNameToCheck} as ${userToCheck} is disabled in ssh configuration.${NORM}"
    echo -e "\n${RED}$userToCheck privileged checks will not be executed on $nodeNameToCheck ${NORM}\n\n"

    noRootScriptNode[$noRootScriptNodeCount]=$nodeNameToCheck
    noRootScriptNodeCount=$( expr $noRootScriptNodeCount + 1 )
  fi
  #echo "\n noRootScriptNode=${noRootScriptNode[*]}"
  #echo "passwordCheckStatus=$passwordCheckStatus"
}

checkCellSshConfig ()
{
  cell_ssh_counter=0
  for cellip in `cat $CELLIP|cut -d\" -f2|cut -d\; -f2`
  do
    cell_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $1 $cellip pwd >/dev/null 2>&1;echo $?);
    if [ $cell_ssh_status -ne 0 ];then a_cellWithNoSsh[$cell_ssh_counter]=$cellip;fi
    cell_ssh_counter=$(expr $cell_ssh_counter + 1 )
  done
  cell_ssh_counter=0
}

show_version ()
{
  get_winpath "REFFIL"
  dataFilesDate=$($GREP FILE_DATE $REFFIL|awk '{print $3}')
  restore_winpath "REFFIL"
  dataFIleMonth=$(echo $dataFilesDate|cut -d- -f2|tr "[a-z]" "[A-Z]")  
  case $dataFIleMonth in
    JAN) dataFIleMonthNo=01;;
    FEB) dataFIleMonthNo=02;;
    MAR) dataFIleMonthNo=03;;
    APR) dataFIleMonthNo=04;;
    MAY) dataFIleMonthNo=05;;
    JUN) dataFIleMonthNo=06;;
    JUL) dataFIleMonthNo=07;;
    AUG) dataFIleMonthNo=08;;
    SEP) dataFIleMonthNo=09;;
    OCT) dataFIleMonthNo=10;;
    NOV) dataFIleMonthNo=11;;
    DEC) dataFIleMonthNo=12;;
    *) dataFIleMonthNo=00;;
  esac
  dataFIleDay=$(echo $dataFilesDate|cut -d- -f1|tr "[a-z]" "[A-Z]")  
  dataFIleYear=$(echo $dataFilesDate|cut -d- -f3|tr "[a-z]" "[A-Z]")  
  #echo -e "\n$program_name  version: 2.1.0.${dataFIleYear}${dataFIleMonthNo}${dataFIleDay}\n"
}
 
# gadiga : create /tmp/.program in all nodes to store temp files
create_rtemp_dir ()
{
  for hname in `cat $HOSTLIST`
  do
    if [ $hname != $localnode ]
    then
      $SSHELL $hname "$bash_scr -c \"if [ -f $RTEMPDIR ] ; then rm -f $RTEMPDIR >/dev/null 2>&1; fi; if [ ! -d $RTEMPDIR ]; then if [[ $usern = "${root_user}" ]]; then umask 0000; fi;  mkdir -p $RTEMPDIR>/dev/null 2>&1;fi\""
      $SSHELL $hname "$bash_scr -c \"if [ ! -e $EXADATA_CELL_COLLECTIONS ]; then touch $EXADATA_CELL_COLLECTIONS;fi\""
      remote_script='
         i=0;
	 hname=$(hostname);
         if [ -e "/etc/profile" ] ;
         then
                   pfiles[$i]="/etc/profile";
                   i=$(($i + 1));
         fi;
         bpfile=""
         if [ -e "$HOME/.bash_profile" ] ;
         then
                   pfiles[$i]="$HOME/.bash_profile";
                   bpfile="$HOME/.bash_profile";
                   i=$(($i + 1));
         elif [ -e "$HOME/.bash_login" ] ;
         then
                   pfiles[$i]="$HOME/.bash_login";
                   bpfile="$HOME/.bash_login";
                   i=$(($i + 1));
         elif [ -e "$HOME/.profile" ] ;
         then
                   pfiles[$i]="$HOME/.profile";
                   bpfile="$HOME/.profile";
                   i=$(($i + 1));
         fi
         C_PROMPT=0;
         FFILES="";
         for pfile in ${pfiles[*]}
         do
         #remote_profile_prompt_check=$(cat $pfile /dev/null 2>&1|tr "\011" " "|sed -e '\''s/^[ ]*//'\''|grep -v ^#|grep -ci '\''read -p'\'')
         remote_profile_prompt_check=0
         remote_profile_trap_check=$(cat $pfile /dev/null 2>&1|tr "\011" " "|sed -e '\''s/^[ ]*//'\''|grep -v ^#|grep -wi '\''trap'\'' | grep -wci '\''logout'\'')
         #remote_profile_oraenv_check=$(cat $pfile /dev/null 2>&1|tr "\011" " "|sed -e '\''s/^[ ]*//'\''|grep -v ^#|grep -ciw '\''oraenv'\'')
         remote_profile_oraenv_check=0

         if [[ -n "$remote_profile_prompt_check" ]] && [[ $remote_profile_prompt_check -gt 0 || $remote_profile_trap_check -gt 0 || $remote_profile_oraenv_check -gt 0 ]]
         then
                C_PROMPT=1;
                FFILES=$FFILES" "$pfile;
         fi
         done

         if [ $C_PROMPT -eq 1 ];
         then
                echo -e "There are prompts, traps or calling oraenv in $FFILES on $hname which will cause issue in $program_name successful execution. Please remove or comment all read -p, trap and oraenv statements and run again"
         else
                echo "PASS";
         fi
'
      #-----Different shell issue
      echo "#!$bash_scr" > ${RTEMPDIR}/cprofile.sh
      #echo "$bash_source" >> ${RTEMPDIR}/cprofile.sh
      echo "$RAT_DEBUG_FLG" >> ${RTEMPDIR}/cprofile.sh
      echo "$remote_script" >> ${RTEMPDIR}/cprofile.sh
      chmod +x ${RTEMPDIR}/cprofile.sh
      $SCOPY ${RTEMPDIR}/cprofile.sh $hname:${RTEMPDIR} >/dev/null 2>&1

      $($SSHELL -o NumberOfPasswordPrompts=0 $hname "chmod +x ${RTEMPDIR}/cprofile.sh >/dev/null");
      remote_node_profile=$($SSHELL -o NumberOfPasswordPrompts=0 $hname ${RTEMPDIR}/cprofile.sh)
      $($SSHELL -o NumberOfPasswordPrompts=0 $hname "rm -f ${RTEMPDIR}/cprofile.sh >/dev/null");

      if [[ -z $remote_node_profile || $remote_node_profile = "" ]]
      then
	if [[ $EM_PROBE_MODE -eq 1 ]]
	then
	  EMSG="SSH issue on $hname node. Please review ssh configuration or set RAT_CLUSTERNODES like RAT_CLUSTERNODES=node1,node2 to skip $hname and retry ${program_name} run."
	  update_probe_xml "ERROR" "GENERIC" "$EMSG"
	fi
      	echo -e $RED"SSH issue on $hname node. Please review ssh configuration or set RAT_CLUSTERNODES like RAT_CLUSTERNODES=node1,node2 to skip $hname and retry ${program_name} run."$NORM;
      	echo -e $RED"${program_name} is exiting..."$NORM;
      	exit 1;
      fi

      if [ "$remote_node_profile" != "PASS" ];
      then
	if [[ `echo "$remote_node_profile"|grep -wc 'PASS'` -eq 0 ]]
        then
	  if [[ $EM_PROBE_MODE -eq 1 ]]
	  then
	    EMSG="$remote_node_profile"
	    update_probe_xml "ERROR" "GENERIC" "$EMSG"
	  fi
          echo -e $RED"\n\n$remote_node_profile\n\n"$NORM;
          exit 1;
	fi
      fi
    else
      i=0;
      if [ -e "/etc/profile" ] ;
      then
        pfiles[$i]="/etc/profile";
        i=$(($i + 1));
      fi;
      bpfile=""
      if [ -e "$HOME/.bash_profile" ] ;
      then
        pfiles[$i]="$HOME/.bash_profile";
        bpfile="$HOME/.bash_profile";
        i=$(($i + 1));
      elif [ -e "$HOME/.bash_login" ] ;
      then
        pfiles[$i]="$HOME/.bash_login";
        bpfile="$HOME/.bash_login";
        i=$(($i + 1));
      elif [ -e "$HOME/.profile" ] ;
      then
        pfiles[$i]="$HOME/.profile";
        bpfile="$HOME/.profile";
        i=$(($i + 1));
      fi

      C_PROMPT=0;
      FFILES='';
      for pfile in ${pfiles[*]}
      do
        #this check is done in check_cascade_prompt
        #profile_prompt_check=$(cat $pfile /dev/null 2>&1|tr "\011" " "|sed -e 's/^[ ]*//'|grep -v ^#|grep -ci 'read -p')
        profile_prompt_check=0
        profile_trap_check=$(cat $pfile /dev/null 2>&1|tr "\011" " "|sed -e 's/^[ ]*//'|grep -v ^#|grep -wi 'trap' |grep -wci 'logout')
        #profile_oraenv_check=$(cat $pfile /dev/null 2>&1|tr "\011" " "|sed -e 's/^[ ]*//'|grep -v ^#|grep -ciw 'oraenv')
        profile_oraenv_check=0
        if [[ -n "$profile_prompt_check" ]] && [[ $profile_prompt_check -gt 0 || $profile_oraenv_check -gt 0 || $profile_trap_check -gt 0 ]]
        then
          C_PROMPT=1;
          FFILES=$FFILES" "$pfile;
        fi
      done
      if [ $C_PROMPT -eq 1 ];
      then
	if [[ $EM_PROBE_MODE -eq 1 ]]
	then
	  EMSG="There are prompts, traps or calling oraenv in $FFILES on $hname which will cause issue in $program_name successful execution. Please remove or comment all read -p,trap and oraenv statements and run again"	  
	  update_probe_xml "ERROR" "GENERIC" "$EMSG"
	fi
        echo -e $RED"\n\nThere are prompts, traps or calling oraenv in $FFILES on $hname which will cause issue in $program_name successful execution. Please remove or comment all read -p, trap and oraenv statements and run again\n\n"$NORM
        exit 1
      fi
    fi
    #profile prompt checking code ends here
  done
  if [ $is_windows -eq "1" ] ; then
    run_windiscovery;
  fi
}

function run_windiscovery ()
{
  for hname in `cat $HOSTLIST`
  do
    if [ $hname != $localnode ] ; then
      get_cygpath "SCRIPTPATH"
      get_cygpath "RTEMPDIR"
      $SCOPY $SCRIPTPATH/.cgrep/readreg.pl $hname:${RTEMPDIR}/readreg.pl >/dev/null 2>$ERRFIL
      $SSHELL $hname "$bash_scr -c \"$perl_exe $RTEMPDIR/readreg.pl $RTEMPDIR\"" >/dev/null 2>$ERRFIL
      $SCOPY $hname:$RTEMPDIR/win_services.out $RTEMPDIR/$hname.win_services.out >/dev/null 2>$ERRFIL
      $SCOPY $hname:$RTEMPDIR/windiscover.out $RTEMPDIR/$hname.windiscover.out >/dev/null 2>$ERRFIL
      restore_cygpath "SCRIPTPATH"
      restore_cygpath "RTEMPDIR"
    fi
  done
}

function get_cygpath
{
  if [ $is_windows -eq "0" ] ; then
    return
  else
    #echo "var : $1";
    cygpath_orig="${1}_cygpath_orig"
    cygpath_ip=\$"$1"
    cygpath_ip_val=`eval echo $cygpath_ip`;
    eval "$cygpath_orig=\"$cygpath_ip_val\""
    #echo "Before : $cygpath_ip_val"

    cygpath_val=$(cygpath `eval echo $cygpath_ip;`)
    eval "$1=\"$cygpath_val\""
    #echo "After : $cygpath_val";
  fi
}

function restore_cygpath
{
  if [ $is_windows -eq "0" ] ; then
    return
  else
    cygpath_orig=\$"${1}_cygpath_orig"
    cygpath_ip=\$"$1"

    cygpath_orig_val=`eval echo $cygpath_orig`;
    eval "$1=\"$cygpath_orig_val\""
    #echo "Restore: $cygpath_orig_val";
  fi
}

function get_winpath
{
  if [ $is_windows -eq "0" ] ; then
    return
  else
    #echo "win var : $1";
    winpath_orig="${1}_winpath_orig"
    winpath_ip=\$"$1"
    winpath_ip_val=`eval echo $winpath_ip`;
    eval "$winpath_orig=\"$winpath_ip_val\""
    #echo "win Before : $winpath_ip_val"

    winpath_val=$(cygpath -w `eval echo $winpath_ip;`)
    eval "$1=\"$winpath_val\""
    #echo "win After : $winpath_val";
  fi
}

function restore_winpath
{
  if [ $is_windows -eq "0" ] ; then
    return
  else
    winpath_orig=\$"${1}_winpath_orig"
    winpath_ip=\$"$1"

    winpath_orig_val=`eval echo $winpath_orig`;
    eval "$1=\"$winpath_orig_val\""
    #echo "Restore: $winpath_orig_val";
  fi
}

create_rtemp_dir_in_cells ()
{
  for cellname in `cat $CELLIP|cut -d\" -f2|cut -d\; -f2`
  do
    $SSHELL $cell_ssh_user@$cellname " if [ ! -d $RTEMPDIR ]; then mkdir -p $RTEMPDIR>/dev/null 2>&1;fi"
  done
}

is_this_oda ()
{
  if [ $OFFLINE -eq 0 ]
  then
    if [ -e /opt/oracle/oak/install/inittab ] 
    then
      oda_machine=1
      it_is_rac=0
      ORANGE="\033[35;40m"
      components=$(echo ${user_components}:ODA)
      #changin default timeout for ODA
      if [ -z "$RAT_ROOT_TIMEOUT" ]; then watchdog_wakeup_root=600;echo -e "\nincreasing root collection time out to 600 for ODA\n">>$LOGFIL;fi
      #Added new model to support VM in ODA
      if [[ -n "$VMTYPE" && "$VMTYPE" = "PVM" ]]; then components=$(echo ${user_components}:ODA_VM) ;fi
      #To copy rpm_list.out file from script dir to .cgrep to be used for custom rpm audit check
      if [ -f $SCRIPTPATH/bm_rpm_list.out ]; then cp  $SCRIPTPATH/bm_rpm_list.out $SCRIPTPATH/.cgrep;fi
      if [ -f $SCRIPTPATH/vm_rpm_list.out ]; then cp  $SCRIPTPATH/vm_rpm_list.out $SCRIPTPATH/.cgrep;fi
      if [ $upgrade_mode -gt 0 ]
      then
        echo -e "${RED}Checking upgrade best practices are not yet supported by ${program_name} for Oracle database appliance${NORM}"
        exit 1
      fi 
      if [ $TYP = "-p" ]
      then
        echo -e "${RED}Patch recommendations are not yet supported by ${program_name} for Oracle database appliance${NORM}"
        exit 1
      fi 
      if [ $upgrade_mode -eq 2 ]
      then
        components=$(echo ${components}:PREUPGR)
      elif [ $upgrade_mode -eq 3 ]
      then
        components=$(echo ${components}:POSTUPGR)
      fi
    else
      oda_machine=0
    fi 
    echo "ORACLE_DATABASE_APPLIANCE = $oda_machine">>$MASTERFIL   
  else
    oda_machine=$(grep -w "ORACLE_DATABASE_APPLIANCE" $DUMPDIR/$CHKFIL|awk '{print $3}')
    if [[ -n "$oda_machine" && $oda_machine -eq 1 ]];then 
      it_is_rac=0; 
      ORANGE="\033[35;40m"; 
    fi
  fi
}

#-- done creating tmp dir
copy_em_xml_files_to_remote_nodes ()
{
  old_IFS=$IFS
  unset IFS
  EMSSHELL=$(echo $SSHELL|sed 's/ -q//g')
  EMSCOPY=$(echo $SCOPY|sed 's/ -q//g')
  if [[ -n "$RAT_OUTPUT" && -n "$RAT_COPY_EM_XML_FILES" && $RAT_COPY_EM_XML_FILES -eq 1 ]]
  then
    for racNodeName in `cat $HOSTLIST`
    do
      BASEXMLREPFIL=$(basename $XMLREPFIL)
      BASEXMLSKIPFIL=$(basename $XMLSKIPFIL) 
      BASEXMLRECFIL=$(basename $XMLRECFIL)
      if [ $racNodeName = $localnode ]
      then
        if [ -e $RAT_OUTPUT/${localnode}_${BASEXMLREPFIL} ];then mv $RAT_OUTPUT/${localnode}_${BASEXMLREPFIL} $RAT_OUTPUT/${localnode}_${BASEXMLREPFIL}_${FDS} >/dev/null 2>&1;fi
        if [ -e $RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL} ];then mv $RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL} $RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL}_${FDS} >/dev/null 2>&1;fi
        if [ -e $RAT_OUTPUT/${localnode}_${BASEXMLRECFIL} ];then mv $RAT_OUTPUT/${localnode}_${BASEXMLRECFIL} $RAT_OUTPUT/${localnode}_${BASEXMLRECFIL}_${FDS} >/dev/null 2>&1;fi
        cp $XMLREPFIL $RAT_OUTPUT/${localnode}_${BASEXMLREPFIL} >/dev/null 2>&1
        cp $XMLSKIPFIL $RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL}  >/dev/null 2>&1
        cp $XMLRECFIL $RAT_OUTPUT/${localnode}_${BASEXMLRECFIL}  >/dev/null 2>&1
      else
        $EMSSHELL $usern@$racNodeName "if [ -e $RAT_OUTPUT/${localnode}_${BASEXMLREPFIL} ];then mv $RAT_OUTPUT/${localnode}_${BASEXMLREPFIL} $RAT_OUTPUT/${localnode}_${BASEXMLREPFIL}_${FDS} >/dev/null 2>&1;fi" >/dev/null 2>&1
        $EMSSHELL $usern@$racNodeName "if [ -e $RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL} ];then mv $RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL} $RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL}_${FDS} >/dev/null 2>&1;fi" >/dev/null 2>&1
        $EMSSHELL $usern@$racNodeName "if [ -e $RAT_OUTPUT/${localnode}_${BASEXMLRECFIL} ];then mv $RAT_OUTPUT/${localnode}_${BASEXMLRECFIL} $RAT_OUTPUT/${localnode}_${BASEXMLRECFIL}_${FDS} >/dev/null 2>&1;fi" >/dev/null 2>&1
        $EMSSHELL $usern@$racNodeName "ls -l $RAT_OUTPUT >/dev/null 2>&1" >/dev/null 2>&1
        ratOutputExists=$(echo $?)
        if [ $ratOutputExists -eq 0 ]
        then
          $EMSCOPY $XMLREPFIL $usern@$racNodeName:$RAT_OUTPUT/${localnode}_${BASEXMLREPFIL} >/dev/null 2>&1 
          $EMSCOPY $XMLSKIPFIL $usern@$racNodeName:$RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL}  >/dev/null 2>&1
          $EMSCOPY $XMLRECFIL $usern@$racNodeName:$RAT_OUTPUT/${localnode}_${BASEXMLRECFIL}  >/dev/null 2>&1
        else
          echo "$RAT_OUTPUT does not exists on $racNodeName so can not copy $XMLREPFIL and $XMLSKIPFIL" >>$LOGFIL
        fi       
      fi
    done
  else
    echo "RAT_OUTPUT is not set or RAT_COPY_EM_XML_FILES is not set to 1 so can not copy xml files to remote compute nodes" >>$LOGFIL
  fi
  IFS=$old_IFS
}

# Added this function to not to check MAA score card if no database was chosen or no database was running on cluster
check_maa_scorecard ()
{
  if [[ -n "$db_name_to_check_none" &&  $db_name_to_check_none -eq 1 ]]
  then 
    maa_scorecard=0
  elif [[ -n "$upgrade_mode" && $upgrade_mode -eq 2 ]]
  then
    maa_scorecard=0
  else
    #Not to have MAA scorecard for DBLRA
    if [[ "$is_avm_machine" &&  $is_avm_machine -eq 1 ]]
    then
        maa_scorecard=0
    elif [ ${#mb_db_names[@]} -gt 0 ]
    then
      maa_scorecard=1
    else
      maa_scorecard=0
    fi
  fi  

  if [[ $is_exadata_dom0_machine -eq "1" || $is_ssc_globalzone_machine -eq 1 ]]; then maa_scorecard=1; fi

  #if [ "$TYP" = "-m" ]; then skip_maa_scorecard=1;else skip_maa_scorecard=0;fi  
}

check_hacheck ()
{
  if [[ -n "$db_name_to_check_none" &&  $db_name_to_check_none -eq 1 ]]
  then 
    include_hacheck=0
  elif [[ -n "$upgrade_mode" && $upgrade_mode -gt 0 ]]
  then
    include_hacheck=0
  else
    if [ ${#mb_db_names[@]} -gt 0 ]
    then
      include_hacheck=1
    else
      include_hacheck=0
    fi
  fi   
  #if [ "$TYP" = "-r" ]; then skip_hacheck=1;else skip_hacheck=0;fi  
}

###########################################################
# Test if this is an Exalogic compute node
# Returns 1 if it's Exalogic, 0 otherwise
###########################################################

check_if_exalogic()
{
  EMOC_FILE=/usr/lib/init-exalogic-node/.emoc_version
  ELControl_FILE=/usr/lib/init-exalogic-node/.el_control_version
  IMAGE_ID_FILE=/usr/lib/init-exalogic-node/.image_id
  IMAGE_HISTORY_FILE=/var/log/init-exalogic-node/.image_history
  IMAGEINFO=/usr/sbin/imageinfo

  is_exalogic_machine=0
  in_ec_exalogic=0

  if [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq "1" ]]
  then
    return;
  fi

  if [[ -f "$EMOC_FILE" || -f "$ELControl_FILE" ]] ; then
    in_ec_exalogic=1
    is_exalogic_machine=1
  fi

  only_hacheck_run=0
  if [[ $is_exalogic_machine -eq "0" ]] ; then
    check_if_exalogic_physical;
  else
    set_exalogic_env;
  fi

  if [[ ! -f "exadiscover/exadiscover.sh" && $in_ec_exalogic -eq "1" ]] ; then
    if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "0" ]] ; then
      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
	EMSG="Error: exadiscover does not exists"
	update_probe_xml "ERROR" "GENERIC" "$EMSG"
      fi
      echo -e "${RED}Error: exadiscover does not exists.. exiting${NORM}";
      exit 1;
    fi
  fi
}

check_if_exalogic_physical()
{
  is_exalogic_machine=1
  if [ $is_exalytics_machine -eq 0 ]; then  RackIdentifier="";fi
  exalogic_version_actual="";
  exalogic_version_cn="";

  # Testing if /usr/lib/init-exalogic-node/.image_id file exists
  if [ ! -f ${IMAGE_ID_FILE} ] ; then
    #echo "ERROR: This is not an Exalogic compute node"
    is_exalogic_machine=0
  fi
  # Testing if /var/log/init-exalogic-node/.image_history file exists
  if [ ! -f ${IMAGE_HISTORY_FILE} ] ; then
    #echo "ERROR: This is not an Exalogic compute node"
    is_exalogic_machine=0
  fi

  dom0_node=0
  if grep -q "control_d" /proc/xen/capabilities > /dev/null 2>&1
  then
    dom0_node=1
  fi

  localnode=`hostname | tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r'`
  if [[ $is_exalogic_machine -eq "1" && $in_ec_exalogic -eq "0" && $dom0_node -eq "1" ]] ; then
    printf "$localnode is an Oracle Virtual Server Node. It is recommended to run ${program_name} from Enterprise Controller Node. Do you want to continue running on this node [y|n] [n] :"

    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o2" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n28_nlsid">
        {1} is an Oracle Virtual Server Node. It is recommended to run ${program_name} from Enterprise Controller Node
      </text>
      <tokens>
        <token index="1">$localnode</token>
      </tokens>
      </tokenizedtext>
    </context>
    <text nls_id="orhc_exadata_n12_nlsid">
      Do you want to continue running on this node
    </text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>	
</group>
EOF
      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
      ans="n"
    elif [[ $EM_XMLD_MODE -eq 1 ]]
    then
      read_probe_xml "Do you want to continue running on this node"
      ans=$xml_rvalue
    else
      $READ ans;
      read_code=`echo $?`;
      process_prompt "$read_code" "ans" "y"

      case "$ans" in 
        Y|y)
          echo "Running ${program_name} on $localnode";;
          #in_ec_exalogic=1;;
        *)
          echo "Exiting.."; exit;;
      esac
    fi
  fi

  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
  then
    set_exalogic_env;
  else
    if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "1" ]]	
    then
      echo -e "${RED}${program_name} is running on non exalogic system. '-vmguest' can only be specified for exalogic systems.${NORM}"
      echo -e "${RED}${program_name} is exiting...  ${NORM}\n";
      exit 1;
    fi
  fi
}

function set_exalogic_env ()
{
  html_rack_type="System"
  it_is_rac=0
  if [[ -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" ]] ; then
    #RackIdentifier=$(grep rack_name $EOUT | cut -d= -f2 | awk '{print $NF}')
    RackIdentifier=""
  else
    #checking for existance of binary to support solaris because ipmitool does not exists there
    if [ `uname -s` = "Linux" ]; then IPMITOOL="/usr/bin/ipmitool";elif [ `uname -s` = "SunOS" ]; then IPMITOOL="/opt/ipmitool/bin/ipmitool";fi
    if [ -e $IPMITOOL ]; then RackIdentifier=$($IPMITOOL sunoem cli force "show /SP system_identifier"|grep "system_identifier "|awk '{print $NF}');fi
    #RackIdentifier=$(ipmitool sunoem cli force "show /SP system_identifier"|grep "system_identifier "|awk '{print $NF}')
  fi

  if [ -n "$RAT_DB" ]
  then
    exalogic_version_actual=$RAT_DB
  elif [ -e "$IMAGEINFO" ]
  then
    exalogic_version_actual=$($IMAGEINFO|grep -iw "image version"|cut -d':' -f2|cut -d' ' -f2)
  elif [ -e "/usr/lib/init-exalogic-node/.emoc_version" ]
  then
    exalogic_version_actual=$(cat /usr/lib/init-exalogic-node/.emoc_version | cut -d= -f2 | sed "s/'//g")
  elif [ -e "/usr/lib/init-exalogic-node/.el_control_version" ]
  then 
     exalogic_version_actual=$(cat /usr/lib/init-exalogic-node/.el_control_version | cut -d= -f2 | sed "s/'//g") 
  else
    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      EMSG="${program_name} did not find Exalogic version from environment. Please set RAT_DB like RAT_DB=1.0.0.2 and run $program_name again"
      update_probe_xml "ERROR" "GENERIC" "$EMSG"
    fi
    echo -e "${RED} ${program_name} did not find Exalogic version from environment. Please set RAT_DB like RAT_DB=1.0.0.2 and run $program_name again${NORM}"
    exit 1
  fi

  #if [[ -n "$exalogic_version" && $exalogic_version -eq 20100 ]]; then components=$(echo ${components}:EXALOGIC_VM);else components=$(echo ${components}:EXALOGIC);fi 
  exalogic_version=$(echo $exalogic_version_actual |tr -d '.')
  if [ -n "$exalogic_version" ]; then exalogic_version=10020;fi

  if [ $upgrade_mode -gt 0 ]
  then
    echo -e "${RED}Checking upgrade best practices are not supported by ${program_name} for Exalogic${NORM}"
    exit 1
  fi

  if [ $TYP = "-p" ]
  then
    echo -e "${RED}Patch recommendations are not supported by ${program_name} for Exalogic${NORM}"
    exit 1
  fi 

}

node_pingable ()
{
  nodename="$1"
  ping -c 1 $nodename >/dev/null 2>&1
  if [ $? -eq "0" ]
  then
    pingable=1
  else #Not Pingable - Check SSH Speed
    check_ssh_speed $USER $nodename
    if [[ -n $ssh_go_ahead && $ssh_go_ahead = 0 ]] ; then
       pingable=0;
    else
       pingable=1
    fi
  fi
}

add_to_swlist_file ()
{
  if [[ $el_node_ping -eq "0" || $switch_version_valid -lt 1 ]]
  then
    echo
    echo "Failed to ping switch or Entered IP is not a valid gateway switch"
  else
    echo "${n_prefix}" >> $swlist_file
  fi
}

get_ip_from_user ()
{
  u_msg=$1
  unset n_prefix

  if [[ $EM_XMLD_MODE -eq 1 ]]
  then
    if [[ `echo "$u_msg" | grep -c "second"` -gt 0 ]]
    then
      read_probe_xml "Enter IP address for second gateway infiniband switch"
    elif [[ `echo "$u_msg" | grep -c "third"` -gt 0 ]]
    then
      read_probe_xml "Enter IP address for third gateway infiniband switch"
    elif [[ `echo "$u_msg" | grep -c "fourth"` -gt 0 ]]
    then
      read_probe_xml "Enter IP address for fourth gateway infiniband switch"
    fi
    n_prefix=$xml_rvalue
  else
    el_done=0
    while [ $el_done -lt 3 ] 
    do
      el_done=$(expr $el_done + 1)
      exec 3<&2; exec 2<&0
      $READ -p "$u_msg" n_prefix
      exec 2<&3
      #$READ -p "Enter the $USER password for the above gateway infiniband switch : " n_passwd
      #exec 2<&3
      test_node_reachability;
      #if [ $el_node_ping -eq "1" ] ; then break; fi;
      if [ $el_node_ping -eq "1" ] ; then
        if [ `echo $n_prefix | grep -c '^[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*'` -gt "0" ] ; then
          echo -e "\n"
          printf  "Enter the $USER password for the above gateway infiniband switch :- "
          tty -s && stty -echo
          $READ -r n_passwd
          tty -s && stty echo
          echo
          echo

          isSwitch ${n_prefix} ${n_passwd}
          if [ $switch_version_valid -ge 1 ]
          then
            break
          else
            echo "Entered IP is not a valid gateway switch"
          fi
        fi
      fi
    done
  fi
}

isSwitch()
{
	switchipval=$1
        userpasswd=$2 
	
              switch_version=$($EXPECT -f - << IBEOF
                                    set timeout $passwordcheck_timeout
                                    set le_zfs_password "$userpasswd"
                                    spawn -noecho $SSHELL $USER@$switchipval "version"
                                    match_max 100000
                                    expect {
                                      -nocase "permission denied *" {
                                      exit 4;
                                    }
                                      -nocase "no)?" {
                                      send -- "yes\n"
                                    }
                                      -nocase "*?assword:*" {
                                      send -- "\$le_zfs_password\n"
                                    }
                                      -nocase eof {
                                      exit
                                    }
                                    }
                                    # Look for passwd prompt
                                    expect {
                                      -nocase "*?assword:*" {
                                        send -- "\$le_zfs_password\n"
                                      }
                                      # Stop the on logon tests and if asked to connect to master switch choose no
                                      -nocase eof {
                                        exit
                                      } -nocase timeout {
                                        send_error "Timed out while running version command on $switchipval\n";
                                        exit
                                      }
                                    }
                                    expect -nocase eof
IBEOF
)
              switch_version_valid=$(echo "$switch_version"|grep -wc "DCS gw")

}

test_node_reachability ()
{
  #Calling Format: test_node_reachability ["hostname"] ["usern"] ["hostip"] ["hosttype"] 
  nodename=$1;
  tuser=$2;
  nodename_ip=$3; 
  host_type=$4;

  el_node_ping=0
  platform=`uname -s`
  tnr_note=""

  if [[ -z $nodename ]]; then nodename="${n_prefix}"; fi
  if [[ -z $tuser ]]; then tuser="$USER"; fi
  if [[ -z $host_type ]]; then host_type="Node"; fi

  PING_W_FLAG=""
  if [ $platform = "Linux" ]
  then
    PING="/bin/ping"
    PING_W_FLAG="-w 5"
  else
    PING="/usr/sbin/ping"
  fi

  #First Validation: Pingable or not
  #-------------------------------------------------------
  if [ $platform = "SunOS" ]; then
      $PING -s $nodename 5 5 >/dev/null 2>&1
  elif [ $platform = "HP-UX" ]; then
      $PING $nodename -n 5 -m 5 >/dev/null 2>&1
  else
      $PING -c 1 $PING_W_FLAG $nodename >/dev/null 2>&1
  fi
  #ping -c 1 $nodename >/dev/null 2>&1
  if [ $? -eq "0" ]; then 
    el_node_ping=1; 
  else
    tnr_log=`$PING -c 1 $PING_W_FLAG $nodename 2>&1 | tr -d '\r'`
    tnr_log=`echo -e "$tnr_log \n ${host_type} ${nodename} is not reachable so its being skipped from checking best practicing."`
 
    tnr_note="Node is not reachable"
  fi

  #Second Validation: SSH speed 
  #-------------------------------------------------------
  check_ssh_speed "$nodename" "$tuser"
  if [[ -n $ssh_go_ahead && $ssh_go_ahead = 0 ]] ; then
    if [[ $el_node_ping -eq "1" ]]; then
      tnr_log="${host_type} ${nodename} is reachable but ssh takes too long."
      tnr_note="Network latency issue: ${host_type} is reachable but ssh takes too long"
    fi
    el_node_ssh=0
    echo "Error: Host $nodename is not reachable.";
  else
    el_node_ssh=1
  fi

  #Third Validation: DNS Configured or not
  #-------------------------------------------------------
  if [[ $el_node_ssh -eq "1" ]]; then 
    isDNSconfigured "$nodename" "$tuser"
    if [[ $DNSconfigured -eq 0 ]]; then 
      if [[ $el_node_ping -eq 0 ]]; then
        tnr_log="${host_type} ${nodename} Error: Either host is not reachable or DNS issue: failure in name resolution"
        tnr_note="Error: Either host $nodename is not reachable or DNS issue: failure in name resolution"

        echo "Error: Either host $nodename is not reachable or DNS issue: failure in name resolution"
      else
        tnr_log="${host_type} ${nodename} : failure in name resolution"
        tnr_note="DNS issue: failure in name resolution"

        echo "Error: DNS issue: failure in name resolution"
      fi
      el_node_dns=0; 
      el_node_ping=0;
    else
      el_node_dns=1;
      el_node_ping=1;
    fi
  else
    el_node_dns=0;
    el_node_ping=0;
  fi

  #Fourth Validation: SSH breaks because of Login user profile(s)
  #-------------------------------------------------------
  #if [[ $el_node_ping -eq "1" ]]; then
  #  is_SSH_blocked "$nodename" "$tuser" "$testnode_password"
  #  if [[ $SSH_blocked -ne 0 ]]; then 
  #    el_node_ping=0; 

  #    tnr_log="${host_type} ${nodename} is reachable but SSH is blocked."
  #    tnr_note="SSH Issue: ${host_type} ${nodename} is reachable but SSH is blocked"

  #    echo "${host_type} ${nodename} is reachable but SSH is blocked so its being skipped from checking best practicing."
  #  fi
  #fi

  if [[ -n $nodename_ip && $el_node_ping -eq "0" ]]; then 
    nodename="$nodename_ip"
    test_node_reachability  "$nodename" "$tuser" "" "$host_type"
    if [[ "$host_type" = 'Infiniband switch'  && $el_node_ping -eq "1" ]]; then switchname=$nodename; fi
  else
    if [ -e $LOGFIL ]; then echo "$tnr_log" >> $LOGFIL; fi
  fi
}

#Commented old way to decide either its physical or logical Rack and coverted it to function which will be called for each remote node to support hybrid rack
assign_exalogic_module ()
{
  if [[ $OFFLINE -eq 0 || $RAT_RUNMODE_INTERNAL = "slave" ]]
  then
    el_prefix="";
    if [[ "$1" = "$ea_db_node" ]]; then 
      el_prefix="_DB"; 
    fi
    if [[ "$1" = "$ea_ec1_node" ]]; then 
      if [[ -z "$el_prefix" ]]; then 
      	el_prefix="_EC"
      else
      	el_prefix="_EC:EXALOGIC"$el_prefix
      fi
    fi
    if [[ "$1" = "$ea_ovmm_node" ]]; then 
      if [[ -z "$el_prefix" ]]; then 
      	el_prefix="_OVMM"
      else
      	el_prefix="_OVMM:EXALOGIC"$el_prefix
      fi
    fi
    if [[ "$1" = "$ea_pc1_node" ]] || [[ "$1" = "$ea_pc2_node" ]] ; then 
      if [[ -z "$el_prefix" ]]; then 
      	el_prefix="_PC"
      else
      	el_prefix="_PC:EXALOGIC"$el_prefix
      fi
    fi 

    #case $1 in
    #  $ea_db_node)
    #    el_prefix="_DB";;
    #  $ea_ec1_node)
    #    el_prefix="_EC";;
    #  $ea_ovmm_node)
    #    el_prefix="_OVMM";;
    #  "$ea_pc1_node"|"$ea_pc2_node")
    #    el_prefix="_PC";;
    #  *)
    #    el_prefix="";;
    #esac
    if [[ -n "$el_prefix" ]] ; then
      if [ `echo $components|grep -c ":"` -eq 0 ]
      then
        components=$(echo ${components}:EXALOGIC$el_prefix)
      else
        components=$(echo $components|$AWK -F":" 'sub($NF"$","")')
        components=$(echo ${components}EXALOGIC$el_prefix)  
      fi
    else
      if [[ -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" && -z "$exalogic_version_actual_cn" ]] ; then
        if [[  $RAT_RUNMODE_INTERNAL = "slave" ]] ; then
          exalogic_version_actual_cn=$(/usr/sbin/imageinfo 2>/dev/null |grep -iw "image version"|cut -d':' -f2|cut -d' ' -f2)
        else
          exalogic_version_actual_cn=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $1 "/usr/sbin/imageinfo 2>/dev/null |grep -iw \"image version\"|cut -d':' -f2|cut -d' ' -f2")
        fi

        echo "EXALOGIC_ACTUAL_VERSION_CN = $exalogic_version_actual_cn" >>$MASTERFIL
      fi
      if [[  $RAT_RUNMODE_INTERNAL = "slave" ]] ; then
        remote_node_component_check=$(ls -ld /proc/xen >/dev/null 2>&1;echo $?)
      else
        remote_node_component_check=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $1 "ls -ld /proc/xen" >/dev/null 2>&1;echo $?)
      fi
      if [ $remote_node_component_check -eq 0 ]
      then
        if [ `echo $components|grep -c ":"` -eq 0 ]
        then
          components=$(echo ${components}:EXALOGIC_VM)
        else
          components=$(echo $components|$AWK -F":" 'sub($NF"$","")')
          components=$(echo ${components}EXALOGIC_VM)  
        fi
      else
        if [ `echo $components|grep -c ":"` -eq 0 ]
        then
          components=$(echo ${components}:EXALOGIC)
        else
          components=$(echo $components|$AWK -F":" 'sub($NF"$","")')
          components=$(echo ${components}EXALOGIC)  
        fi
      fi
    fi

    if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "1" ]] 
    then
      components="NONE:EXALOGIC_GUEST"
    fi
    components=$(echo "$components"|sed 's/:RACCHECK//g');

    echo "$1.COMPONENT = $components">>$MASTERFIL
  else
    components=$(grep "$i.COMPONENT" $DUMPDIR/$CHKFIL |awk '{print $3}') 
  fi 
  #if [[ -n "$exalogic_version" && $exalogic_version -eq 20100 ]]; then components=$(echo ${components}:EXALOGIC_VM);else components=$(echo ${components}:EXALOGIC);fi 
}

generate_exalogic_node_info_from_exadiscover ()
{
  # More info about exadiscover here
  # https://stbeehive.oracle.com/teamcollab/wiki/Exalogic+Health+Check:Exacheck%27s+Integration+with+ExaDiscover
  # https://stbeehive.oracle.com/teamcollab/wiki/Exalogic+Diagnostics:ExaDiscover
  if [ -n "$RAT_EL_GVM" ]
  then
    echo "IS_EXALOGIC_GUEST_VM = $is_exalogic_guest_vm" >> $MASTERFIL
  else
    echo "IS_EXALOGIC_GUEST_VM = 0" >> $MASTERFIL
  fi	

  EOUT=$WRKDIR/exadiscover.out
  EAOUT=$WRKDIR/exachk_exalogic.conf

  from_exadiscover=1
  #if [[ ! -f "$EOUT" ]] ; then
    #sh exadiscover/exadiscover.sh -f shell | grep rack_ > $EAOUT
  #fi

  if [[ ! -f "$EAOUT" ]] ; then
    sh exadiscover/exadiscover.sh -f shell | grep rack_ > $EAOUT
    sh exadiscover/exadiscover.sh -f shell -a >> $EAOUT
    cp -f $EAOUT $WRKDIR/.cgrep/
  else
    if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "0" ]] ; then
      echo "Using cached file $EAOUT ...."
    fi
  fi
  
  if [[ -e "$EAOUT" ]] ; then
    cp -f $EAOUT $OUTPUTDIR 2>/dev/null
  fi

  # Get the racktype
  rtype=$(grep rack_size $EAOUT | cut -d= -f2)
  case "$rtype" in 
    "Full")
      exalogic_rack=3;;
    "Half")
      exalogic_rack=2;;
    "Quarter")
      exalogic_rack=1;;
    "Eighth")
      exalogic_rack=0;;
    *)
      exalogic_rack=3;;
  esac
  RackIdentifier=$(grep "rack_id_01=" $EAOUT | cut -d= -f2 | head -1|awk '{print $NF}')

  ea_need_vm=1
  if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_cvm_only -eq "1" ]] ; then
    ea_need_vm=0
  fi

  if [[ $ea_need_vm -eq "1" ]] ; then
    grep "c_nodes_[0-9]*_IPoIB-admin=" $EAOUT  | cut -d= -f2 > $WRKDIR/o_host_list.out
  fi

  ea_db_node=$(grep "db_[0-9]*_IPoIB-admin=" $EAOUT  | cut -d= -f2 | head -1)
  echo "$ea_db_node" >> $WRKDIR/o_host_list.out

  ea_ec1_node=$(grep "ec_[0-9]*_IPoIB-admin=" $EAOUT  | cut -d= -f2 | head -1)
  ea_ec1_node=$localnode
  echo "$ea_ec1_node" >> $WRKDIR/o_host_list.out

  ea_ovmm_node=$(grep "ovmm_[0-9]*_IPoIB-admin=" $EAOUT  | cut -d= -f2 | head -1)
  echo $ea_ovmm_node >> $WRKDIR/o_host_list.out

  ea_pc1_node=$(grep "pc_01_IPoIB-admin=" $EAOUT  | cut -d= -f2 | head -1)
  if [[ -n "$ea_pc1_node" ]] ; then
    echo $ea_pc1_node >> $WRKDIR/o_host_list.out
  fi

  ea_pc2_node=$(grep "pc_02_IPoIB-admin=" $EAOUT  | cut -d= -f2 | head -1)
  if [[ -n "$ea_pc2_node" ]] ; then
    echo $ea_pc2_node >> $WRKDIR/o_host_list.out
  fi

  if [[ -z $ea_db_node ]];
  then
    ea_db_node=$(grep "db_ip_01" $EAOUT  | cut -d= -f2 | head -1)
    if [[ "$ea_db_node" = "127.0.0.1" ]];
    then
      ea_db_node=$ea_ec1_node
      echo "$ea_db_node" >> $WRKDIR/o_host_list.out
    fi
  fi

  rack_id=$(grep "rack_id_01=" $EAOUT  | cut -d= -f2 | head -1)

  if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "1" ]] 
  then
    rm -f $WRKDIR/o_storage.out
    rm -f $WRKDIR/o_ibswitches.out

    echo "IS_EXALOGIC_MACHINE = $is_exalogic_machine" >> $MASTERFIL
    echo "IS_EXALOGIC_EC_MACHINE = $in_ec_exalogic" >> $MASTERFIL
    echo "EXALOGIC_VERSION = $exalogic_version" >> $MASTERFIL
    echo "EXALOGIC_ACTUAL_VERSION = $exalogic_version_actual" >> $MASTERFIL
    echo "EXALOGIC_RACK = $exalogic_rack" >> $MASTERFIL
    echo "EXALOGIC_RACK_IDENTIFIER = $RackIdentifier" >> $MASTERFIL

    return;
  fi

  #grep "sn_nodes_[0-9]*.*-eth-admin=" $EAOUT | cut -d= -f2 | sed 's/,/\n/g' |sort -u> $WRKDIR/o_storage.out
  rm -f $WRKDIR/o_storage.out
  for snip in `grep "sn_nodes_[0-9]*.*-eth-admin=" $EAOUT | cut -d= -f2 | sed 's/,/\n/g' |sort -u`
  do
    sname=$(nslookup $snip |grep -w name|awk '{print $NF}'|sed 's/.$//')
    if [[ -z "$sname" ]] ; then
      sname="$snip";
    fi
    echo "$sname" >> $WRKDIR/o_storage.out
  done

  rm -f $WRKDIR/o_ibswitches.out
  for switchip in `grep "ib_switch_[0-9]*_.*-eth-admin" $EAOUT | cut -d= -f2 |sort -u`
  do
    switchname=$(nslookup $switchip|grep -w name|awk '{print $NF}'|sed 's/.$//')
    if [[ -z "$switchname" ]] ; then
      switchname=$switchip
    fi
    echo "$switchname" >> $WRKDIR/o_ibswitches.out
  done

  #generate spine switch for virtual exalogic
  spineswitchip=$(grep "ib_switch_spine_[0-9]*_.*-eth-admin" $EAOUT | cut -d= -f2 |head -1)
  if [[ -n $spineswitchip ]]; then 
    spineswitchname=$(nslookup $spineswitchip|grep -w name|awk '{print $NF}'|sed 's/.$//')
    if [[ -z "$spineswitchname" ]] ; then spineswitchname=$spineswitchip; fi
  
    test_node_reachability "$spineswitchname"
    if [ $el_node_ping -eq "1" ] ; then echo ""; else spineswitchname=""; fi
    echo "$spineswitchname" >> $WRKDIR/o_ibswitches.out
  fi
}

generate_exalogic_node_info()
{
  #assign_exalogic_module
  if [ $OFFLINE -eq "0" ]
  then
    from_exadiscover=0
    if [[ -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" ]] ; then
      generate_exalogic_node_info_from_exadiscover;
    else
      el_cfile="/usr/lib/init-exalogic-node/exalogic_machine.conf"
      if [ -z "$RAT_ELRACKTYPE" ] ;  # 3=FULL, 2=HALF, 1=QUARTER 0=1/8
      then 
        if [ -r "$el_cfile" ]
        then
          exalogic_rack=$(grep "RACK_TYPE=" $el_cfile | cut -d"=" -f2)
        fi
        if [ -z "$exalogic_rack" ]
        then
          if [[ $EM_PROBE_MODE -eq 1 ]]
          then
	    EMSG="Unable to determine rack type. Please set RAT_ELRACKTYPE and try again"
	    update_probe_xml "ERROR" "GENERIC" "$EMSG"
          fi
          echo "Unable to determine rack type. Please set RAT_ELRACKTYPE and try again"
          exit 1;
        fi
      else 
        exalogic_rack="$RAT_ELRACKTYPE";
      fi;
    fi;

    cnlist_file="$OUTPUTDIR/o_host_list.out"
    snlist_file="$OUTPUTDIR/o_storage.out"
    swlist_file="$OUTPUTDIR/o_ibswitches.out"
    HOSTLIST=$cnlist_file
    EAOUT=$WRKDIR/exachk_exalogic.conf

    if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "1" ]] 
    then
      return;
    fi
    #To generate list of compute nodes
    if [ -n "$RAT_CLUSTERNODES" ]  # First check for env
    then
      rm -f $HOSTLIST
      for nodename in `echo $RAT_CLUSTERNODES`
      do
        echo $nodename>>$cnlist_file
      done
    elif [[ -r "$WRKDIR/o_host_list.out" && -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" ]]
    then # Use cached nodes list from previous run
      if [[ $from_exadiscover -eq "0" ]] ; then
        echo -e "Using cached file $WRKDIR/o_host_list.out for nodes list ....\n\n";
      fi
      cp $WRKDIR/o_host_list.out $cnlist_file
    elif [[ -n "$RAT_EXALOGIC_CONF" || -e "exalogic_deploy.conf" ]]
    then # Read the conf file
      rm -f $cnlist_file $snlist_file $swlist_file
      generate_exalogic_node_info_from_conf;
    else
      # Compute nodes
      case $exalogic_rack in
      3) #FULL
        cn_cnt=30
        sw_cnt=4
        EXALOGIC_RACK=FULL
        ;;
      2) #HALF
        cn_cnt=16
        sw_cnt=2
        EXALOGIC_RACK=HALF
        ;;
      1) #QUARTER
        cn_cnt=8
        sw_cnt=2
        EXALOGIC_RACK=QUARTER
        ;;
      0) #1/8 rack
        cn_cnt=4
        sw_cnt=2
        EXALOGIC_RACK="1/8"
        ;;
      *)
        if [[ $EM_PROBE_MODE -eq 1 ]]
        then
	  EMSG="Invalid value for RACK '$exalogic_rack'"
	  update_probe_xml "ERROR" "GENERIC" "$EMSG"
        fi
        echo "Invalid value for RACK '$exalogic_rack'";
        exit 1;
        ;;
      esac

      n_prefix=$(hostname|cut -d. -f1|sed 's/[0-9][0-9]$//');
      n_cnt=0;
      while [[ $n_cnt -lt $cn_cnt ]]
      do
        n_cnt=$(expr $n_cnt + 1);
        nodename=$(printf "${n_prefix}%02d" $n_cnt);
        echo "$nodename" >> $cnlist_file
      done
    fi

    if [[ -n "$skip_in_silent" && $skip_in_silent -eq 0 ]]
    then
      #To generate spine switch for physical
      #if [[ ! -z "$phy_nodes" ]]; then
      if [[ -z "$in_ec_exalogic" ]] || [[ -n "$in_ec_exalogic" && $in_ec_exalogic -ne "1" ]] ; then
	$READ -p "Enter IP address for spine infiniband switch : " spineswitchip
	if [[ -n "$spineswitchip" ]]; then	
	  is_IP "$spineswitchip"
	  if [[ $is_IPADDRESS -eq "1" ]]; then 
	    spineswitchname=$(nslookup $spineswitchip|grep -w name|awk '{print $NF}'|sed 's/.$//')
	    if [[ -z "$spineswitchname" ]] ; then spineswitchname=$spineswitchip; fi
	  else 
	    spineswitchname="$spineswitchip"
	  fi
	fi

	test_node_reachability "$spineswitchname"
	if [ $el_node_ping -eq "1" ] ; then echo ""; else spineswitchname=""; fi

        #echo "$spineswitchname" >> $WRKDIR/o_ibswitches.out
      fi

      #To generate list of infinband switchces to test
      if [ -n "$RAT_IBSWITCHES" ]
      then
        for switchname in `echo $RAT_IBSWITCHES`
        do
          echo "$switchname">>$swlist_file
        done
      elif [ -r "$WRKDIR/o_ibswitches.out" ]
      then # Use cached nodes list from previous run
        if [[ $from_exadiscover -eq "0" ]] ; then
          echo -e "Using cached file $WRKDIR/o_ibswitches.out for gateway infiniband switches list....\n\n";
        fi
        cp $WRKDIR/o_ibswitches.out $swlist_file
      elif [[ -n "$RAT_EXALOGIC_CONF" || -e "exalogic_deploy.conf" ]]
      then # Read the conf file
        rm -f  $swlist_file 
        generate_exalogic_node_info_from_conf;
      else
	if [[ $EM_PROBE_MODE -eq 1 ]]
	then		
	  cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="SINGLE_SELECT" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <text nls_id="orhc_exadata_n29_nlsid">
        Could not find infiniband gateway switch names from env or configuration file
      </text>
    </context>
    <text nls_id="orhc_exadata_n13_nlsid">
      Indicate your selection from one of the options 
    </text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o1q1">
        <text nls_id="orhc_exadata_n14_nlsid">Switch Name</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2" qid="q${PROBE_QUES_CNT}o2q1">
        <text nls_id="orhc_exadata_n15_nlsid">Switch IP address</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1" questionType="TEXT" outcome="No">
    <text nls_id="orhc_exadata_n30_nlsid">
      Enter the first gateway infiniband switch name
    </text>
  </question>
EOF
	  if [ $exalogic_rack -eq 3 ] ; then
	    cat >> ${PROBE_XML}.tmp <<EOF
  <question id="q${PROBE_QUES_CNT}o2q1" questionType="MULTIPART_QUESTION" outcome="No">
    <text nls_id="orhc_exadata_n87_nlsid">Enter Valid gateway infiniband switch IP addresses</text>
    <multipart-question>
      <question id="q${PROBE_QUES_CNT}o2q1q1" questionType="TEXT" outcome="No">
        <text nls_id="orhc_exadata_n31_nlsid">
          Enter IP address for first gateway infiniband switch
        </text>
      </question>
      <question id="q${PROBE_QUES_CNT}o2q1q2" questionType="TEXT" outcome="No">
        <text nls_id="orhc_exadata_n32_nlsid">
          Enter IP address for second gateway infiniband switch 
        </text>
      </question>
      <question id="q${PROBE_QUES_CNT}o2q1q3" questionType="TEXT" outcome="No">
        <text nls_id="orhc_exadata_n33_nlsid">
          Enter IP address for third gateway infiniband switch
        </text>
      </question>
      <question id="q${PROBE_QUES_CNT}o2q1q4" questionType="TEXT" outcome="No">
        <text nls_id="orhc_exadata_n34_nlsid">
          Enter IP address for fourth gateway infiniband switch 
        </text>
      </question>
    </multipart-question>
  </question>
EOF
	  else
	    cat >> ${PROBE_XML}.tmp <<EOF
  <question id="q${PROBE_QUES_CNT}o2q1" questionType="MULTIPART_QUESTION" outcome="No">
    <text nls_id="orhc_exadata_n87_nlsid">Enter Valid gateway infiniband switch IP addresses</text>
    <multipart-question>
      <question id="q${PROBE_QUES_CNT}o2q1q1" questionType="TEXT" outcome="No">
        <text nls_id="orhc_exadata_n31_nlsid">
          Enter IP address for first gateway infiniband switch
        </text>
      </question>
      <question id="q${PROBE_QUES_CNT}o2q1q2" questionType="TEXT" outcome="No">
        <text nls_id="orhc_exadata_n32_nlsid">
          Enter IP address for second gateway infiniband switch
        </text>
      </question>
    </multipart-question>
  </question>
</group>
EOF
	  fi

	  PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
	  echo -e "Could not find infiniband gateway switch names from env or configuration file.Please enter the first gateway infiniband switch name : "
	elif [[ $EM_XMLD_MODE -eq 1 ]]
	then
	  echo -e "Could not find infiniband gateway switch names from env or configuration file.Please enter the first gateway infiniband switch name : "

          read_probe_xml "Could not find infiniband gateway switch names from env or configuration file"
          if [[ $xml_rvalue = "Switch Name" ]] || [[ $xml_rvalue -eq 1 ]]
          then
            read_probe_xml "Please enter the first gateway infiniband switch name"
          elif [[ $xml_rvalue = "Switch IP address" ]] || [[ $xml_rvalue -eq 2 ]]
          then
            read_probe_xml "Enter IP address for first gateway infiniband switch"
          fi
          n_prefix=$xml_rvalue

          test_node_reachability;
	else
          unset n_prefix
          el_done=0
          while [ $el_done -lt 3 ] 
          do
            el_done=$(expr $el_done + 1)
            exec 3<&2; exec 2<&0
            $READ -p "Could not find infiniband gateway switch names from env or configuration file.Please enter the first gateway infiniband switch name : " n_prefix
            exec 2<&3
            test_node_reachability;
            if [ $el_node_ping -eq "1" ] ; then 
              if [ `echo $n_prefix | grep -c '^[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*'` -gt "0" ] ; then
	        echo -e "\n"
	        printf  "Enter the $USER password for the above gateway infiniband switch :- "
	        tty -s && stty -echo
	        $READ -r n_passwd
	        tty -s && stty echo
	        echo
	        echo

                isSwitch ${n_prefix} ${n_passwd}
                if [ $switch_version_valid -ge 1 ]
                then
                  echo "${n_prefix}" > $swlist_file
                  break
                else
                  echo "Entered IP is not a valid gateway switch"
                fi
	      else
	      	break;
              fi  
            fi
          done
	fi

        if [[ $el_node_ping -eq "0"  ]] || [[ `echo $n_prefix | grep -c '^[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*'` -gt "0" && $switch_version_valid -lt 1 ]]
        then
          echo "Failed to get infiniband gateway switch names. Skipping infiniband gateway switches.";
          touch $swlist_file
        else
          if [ `echo $n_prefix | grep -c '^[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*'` -gt "0" ] ; then
            # User entered IP address. ask second cell ip address too.

            if [ $exalogic_rack -eq 3 ] ; then # 4 switches
              get_ip_from_user "Enter IP address for second gateway infiniband switch : "
              add_to_swlist_file ${n_prefix}
              get_ip_from_user "Enter IP address for third gateway infiniband switch : "
              add_to_swlist_file ${n_prefix}
              get_ip_from_user "Enter IP address for fourth gateway infiniband switch : "
              add_to_swlist_file ${n_prefix}
            else # 2 switches
              get_ip_from_user "Enter IP address for second gateway infiniband switch : "
              add_to_swlist_file ${n_prefix}
            fi
            echo
          else
      	    n_prefix_sub=$(echo $n_prefix|sed s/.$//);  
      	    n_prefix_sub=$(echo $n_prefix_sub|sed s/.$//);  
      	    n_suffix=$(echo $n_prefix|sed 's/^.*\(..\)$/\1/');
      	    n_suffix_counter=0
      	    if [ $exalogic_rack -eq 3 ]
      	    then 
      	      while [ $n_suffix_counter -lt 4 ]
      	      do 
      	        if [ $n_suffix_counter -eq 0 ]
      	        then
      	          echo "${n_prefix_sub}${n_suffix}" >> $swlist_file
      	          n_suffix=$( expr $n_suffix + 1 ) 
      	          n_suffix_counter=$( expr $n_suffix_counter + 1 ) 
      	        else
      	          echo "${n_prefix_sub}0${n_suffix}" >> $swlist_file
      	          n_suffix=$( expr $n_suffix + 1 ) 
      	          n_suffix_counter=$( expr $n_suffix_counter + 1 ) 
      	        fi
      	      done
      	    else
      	      while [ $n_suffix_counter -lt 2 ]
      	      do 
      	        if [ $n_suffix_counter -eq 0 ]
      	        then
      	          echo "${n_prefix_sub}${n_suffix}" >> $swlist_file
      	          n_suffix=$( expr $n_suffix + 1 )
      	          n_suffix_counter=$( expr $n_suffix_counter + 1 )
      	        else
      	          echo "${n_prefix_sub}0${n_suffix}" >> $swlist_file
      	          n_suffix=$( expr $n_suffix + 1 )
      	        n_suffix_counter=$( expr $n_suffix_counter + 1 )
      	       fi 
      	      done
      	    fi
      	    n_suffix_counter=0
          fi
        fi
        #/usr/sbin/ibswitches|egrep -wi 'IB|GW'|cut -d'"' -f2|awk '{print $6}'|grep -vw localhost|cut -d' ' -f1>$swlist_file
      fi # -n IBSWITCHES close here

      if [[ -n $spineswitchname && `if [ -e $WRKDIR/o_ibswitches.out ]; then grep -wic "$spineswitchname" $WRKDIR/o_ibswitches.out; else echo '0'; fi` -eq "0" ]]; then echo "$spineswitchname"       >> $swlist_file; fi

      #To generate list of storage nodes   
      if [ -n "$RAT_ZFS_NODES" ]
      then
        for cellname in `echo $RAT_ZFS_NODES`
        do
          echo "$cellname">>$snlist_file
        done
      elif [ -r "$WRKDIR/o_storage.out" ]
      then # Use cached nodes list from previous run
        if [[ $from_exadiscover -eq "0" ]] ; then
          echo -e "Using cached file $WRKDIR/o_storage.out for storage nodes list ....\n\n";
        fi
        cp $WRKDIR/o_storage.out $snlist_file
      elif [[ -n "$RAT_EXALOGIC_CONF" || -e "exalogic_deploy.conf" ]]
      then # Read the conf file
        rm -f  $snlist_file 
        generate_exalogic_node_info_from_conf;
      else # Ask user
	if [[ $EM_PROBE_MODE -eq 1 ]]
   	then
	  cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_CC}" groupHeader="${GID_CC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="SINGLE_SELECT"  defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <text nls_id="orhc_exadata_n36_nlsid">
        Could not find storage node names from env or configuration file
      </text>
    </context>
    <text nls_id="orhc_exadata_n13_nlsid">
      Indicate your selection from one of the options 
    </text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o1q1">
        <text nls_id="orhc_exadata_n18_nlsid">Storage Node Name</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2" qid="q${PROBE_QUES_CNT}o2q1">
        <text nls_id="orhc_exadata_n37_nlsid">Storage IP address</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1" questionType="TEXT" outcome="No">
    <text nls_id="orhc_exadata_n55_nlsid">
      Enter the first storage server
    </text>
  </question>
  <question id="q${PROBE_QUES_CNT}o2q1" questionType="MULTIPART_QUESTION" outcome="No">
    <text nls_id="orhc_exadata_n88_nlsid">Enter Valid storage server IP addresses</text>
    <multipart-question>
      <question id="q${PROBE_QUES_CNT}o2q1q1" questionType="TEXT" outcome="No">
        <text nls_id="orhc_exadata_n19_nlsid">
  	Enter IP address for first storage server
        </text>
      </question>
      <question id="q${PROBE_QUES_CNT}o2q1q2" questionType="TEXT" outcome="No">
        <text nls_id="orhc_exadata_n22_nlsid">
  	Enter IP address for second storage server
        </text>
      </question>
    </multipart-question>
  </question>
</group>
EOF

	  PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
	  echo -e "Could not find storage node names from env or configuration file.Please enter the first storage server: "
	elif [[ $EM_XMLD_MODE -eq 1 ]]
	then
	  echo -e "Could not find storage node names from env or configuration file.Please enter the first storage server: "

	  read_probe_xml "Could not find storage node names from env or configuration file"
	  if [[ $xml_rvalue = "Storage Node Name" ]] || [[ $xml_rvalue -eq 1 ]]
	  then
	    read_probe_xml "Please enter the first storage server"
	  elif [[ $xml_rvalue = "Storage IP address" ]] || [[ $xml_rvalue -eq 2 ]]
	  then
	    read_probe_xml "Enter IP address for first storage server"
	  fi
	  n_prefix=$xml_rvalue

          test_node_reachability;
	else
          # Cells
          unset n_prefix
          el_done=0
          while [ $el_done -lt 3 ] 
          do
            el_done=$(expr $el_done + 1)
            exec 3<&2; exec 2<&0
            $READ -p "Could not find storage node names from env or configuration file.Please enter the first storage server : " n_prefix
            exec 2<&3

            test_node_reachability;
            if [ $el_node_ping -eq "1" ] ; then break; fi;
          done
        fi

        if [ $el_node_ping -eq "0" ]
        then
          echo "Failed to get storage node info. Skipping storage node.";
          touch $snlist_file
        else
          if [ `echo $n_prefix | grep -c '^[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*'` -gt "0" ] ; then
            # User enetered IP address. ask second cell ip address too.
            echo "${n_prefix}" > $snlist_file
            unset n_prefix
            el_done=0
            while [ $el_done -lt 3 ] 
            do
              el_done=$(expr $el_done + 1)
	      
	      if [[ $EM_XMLD_MODE -eq 1 ]]
	      then
		echo "Please enter the second storage server : "
		read_probe_xml "Enter IP address for second storage server"
	      else
                exec 3<&2; exec 2<&0
                $READ -p "Please enter the second storage server : " n_prefix
                exec 2<&3
	      fi
              
              test_node_reachability;
              if [ $el_node_ping -eq "1" ] ; then break; fi;
            done
            if [ $el_node_ping -eq "0" ]
            then
              echo "Failed to get storage node info. Skipping storage node.";
            else
              echo "${n_prefix}" >> $snlist_file
            fi
          else
            n_prefix=$(echo $n_prefix|sed s/.$//);  
            echo "${n_prefix}1" > $snlist_file
            echo "${n_prefix}2" >> $snlist_file
          fi
        fi
      fi
    fi #NO_QUESTION if closes here

    validate_exalogic_rack;

    echo "IS_EXALOGIC_MACHINE = $is_exalogic_machine" >> $MASTERFIL
    echo "IS_EXALOGIC_EC_MACHINE = $in_ec_exalogic" >> $MASTERFIL
    echo "EXALOGIC_VERSION = $exalogic_version" >> $MASTERFIL
    echo "EXALOGIC_ACTUAL_VERSION = $exalogic_version_actual" >> $MASTERFIL
    echo "EXALOGIC_RACK = $exalogic_rack" >> $MASTERFIL
    echo "EXALOGIC_RACK_IDENTIFIER = $RackIdentifier" >> $MASTERFIL
    #echo "COMPONENTS = $components" >>$MASTERFIL
    if [ -e $snlist_file ]; then cp $snlist_file  $WRKDIR >/dev/null 2>&1;fi
    if [ -e $swlist_file ]; then cp $swlist_file  $WRKDIR >/dev/null 2>&1;fi
    #rm -f $WRKDIR/o_host_list.out $WRKDIR/o_storage.out $WRKDIR/o_ibswitches.out

    #-generate exalogic physical node list and update conf file.....
    echo "IS_EXALOGIC_HYBRID = $exalogic_hybrid" >> $MASTERFIL

    if [[ -n "$exalogic_hybrid" && "$exalogic_hybrid" -eq "1" ]]
    then
      if [ -z "$phy_nodes" ]
      then
        #For standard hybrid, there are only 4 configurations:
        #1) 1/8 - 2 virt + 2 physical nodes.
        #2) 1/4 - 4 virt + 4 physical.
        #3) 1/2 - 8 virt + 8 physical.
        #4) full - 16 virt + 14 physical.

        #EXAERROR=0
        #virtual_nodes=$(grep -c "c_nodes_.*_IPoIB-admin" $EAOUT) 
      	#case $exalogic_rack in
        #    3) 
        #	add_compute=15 
        #	if [[ $virtual_nodes != "16" ]] ; then EXAERROR=1; fi
        #    ;;
        #    2) 
        #	add_compute=8
        #	if [[ $virtual_nodes != "8" ]] ; then EXAERROR=1; fi
        #    ;;
        #    1) 
        #	add_compute=4
        #	if [[ $virtual_nodes != "4" ]] ; then EXAERROR=1; fi
        #    ;;
        #    0) 
        #	add_compute=2
        #	if [[ $virtual_nodes != "2" ]] ; then EXAERROR=1; fi
        #    ;;
        #  esac

        #  if [[ $EXAERROR = "1" ]]
        #  then
        #    echo -e ""
        #    echo -e "${RED}${program_name} could not determine physical nodes. please use -phy flag like ./${program_name} -hybrid -phy phy_node1,phy_node2.\n${NORM}"   
        #    echo -e ${RED}"\n${program_name} is exiting..${NORM}\n"
        #    rm -rf $HOSTLIST
        #    exit
        #  fi

        #  first_compute=$(grep "c_nodes_01_IPoIB-admin=" $EAOUT |cut -d= -f2)
        #  first_compute=$(echo "$first_compute" | sed 's/\.[0-9]*$/\.X/g')

        #  if [[ $exalogic_rack = "3" ]] ; then add_compute=$(expr $add_compute + 1); fi 

        #  comp_cnt=$(($add_compute * 2))
        #  while [[ $add_compute -lt $comp_cnt ]]
        #  do
        #    add_compute=$(expr $add_compute + 1)
        #    phy_compute=$(echo "$first_compute" | sed "s/.X$/\.$add_compute/g")
        #    phy_nodes=$phy_nodes","$phy_compute;
        #  done

        if [[ `grep -c "phy_nodes=" $EAOUT` -eq 0 ]]
        then
          if [[ $EM_PROBE_MODE -eq 1 ]]
          then
	    EMSG="${program_name} could not determine physical nodes. please use -phy flag like ./${program_name} -hybrid -phy phy_node1,phy_node2."
	    update_probe_xml "ERROR" "GENERIC" "$EMSG"
          fi
          echo -e ""
          echo -e "${RED}${program_name} could not determine physical nodes. please use -phy flag like ./${program_name} -hybrid -phy phy_node1,phy_node2.\n${NORM}"   
          echo -e ${RED}"\n${program_name} is exiting..${NORM}\n"
          rm -rf $HOSTLIST
          exit 1
        else
          phy_nodes=$(grep "phy_nodes=" $EAOUT|sed 's/phy_nodes=//g'|sed 's/ //g')
        fi
      fi

      phy_nodes=$(echo $phy_nodes | sed 's/^,//g' | sed 's/,$//g')

      uniq_phy_nodes=""
      for exa_phy_node in `echo "$phy_nodes" | sed 's/,/ /g'`
      do
        if [ `echo "$uniq_phy_nodes"|grep -iwc "$exa_phy_node"` -eq 0 ]
        then
          uniq_phy_nodes="${uniq_phy_nodes},${exa_phy_node}," 

          echo "$exa_phy_node" >> $cnlist_file
        fi
      done
    
      uniq_phy_nodes=$(echo "$uniq_phy_nodes" | sed 's/,,/,/g' | sed 's/^,//g' | sed 's/,$//g');

      sed /phy_nodes/d $EAOUT > $EAOUT.new  
      echo "phy_nodes=$uniq_phy_nodes" >> $EAOUT.new
      mv $EAOUT.new $EAOUT

      phy_nodes=$uniq_phy_nodes;
    fi
  else
    is_exalogic_machine=`grep IS_EXALOGIC_MACHINE $MASTERFIL | awk '{print $3}'`
    if [ ! -n "$is_exalogic_machine" ] ; then is_exalogic_machine=0; fi
    in_ec_exalogic=`grep IS_EXALOGIC_EC_MACHINE $MASTERFIL | awk '{print $3}'`
    exalogic_version=`grep EXALOGIC_VERSION $MASTERFIL | awk '{print $3}'`
    exalogic_version_actual=`grep EXALOGIC_ACTUAL_VERSION $MASTERFIL | awk '{print $3}'`
    exalogic_rack=`grep EXALOGIC_RACK $MASTERFIL | awk '{print $3}'`
    RackIdentifier=`grep EXALOGIC_RACK_IDENTIFIER $MASTERFIL | sed 's/EXALOGIC_RACK_IDENTIFIER = //'`

    exalogic_hybrid=`grep IS_EXALOGIC_HYBRID $MASTERFIL | awk '{print $3}'`
    phy_nodes=`grep PHYSICAL_NODES $MASTERFIL | awk '{print $3}'`   
  fi

  case $exalogic_rack in
    3) #FULL
      EXALOGIC_RACK=FULL
      ;;
    2) #HALF
      EXALOGIC_RACK=HALF
      ;;
    1) #QUARTER
      EXALOGIC_RACK=QUARTER
      ;;
    0) #1/8 rack
      EXALOGIC_RACK="1/8"
      ;;
    *) #1/8 rack
      EXALOGIC_RACK="FULL"
      ;;
  esac

  if [[ -n $go_next && $go_next = "e" ]] ; then exit; fi
}

######################################################
# This script generates the info for Exalogic node info in each of these output files respectively:
# 1. o_host_list.out = contains hostname of compute nodes
# 2. o_storage.out = contains hostname of ZFS storage
# 3. o_ibswitches.out = contains hostname of switches for IB nodes
######################################################
generate_exalogic_node_info_from_conf()
{
  #db_machine_compute=1
  if [ $OFFLINE -eq "0" ]
  then
   if [ -n "$RAT_EXALOGIC_CONF" ]
   then
     conf_file="$RAT_EXALOGIC_CONF"
   elif [ $# -eq 0 ] ; then
     conf_file="exalogic_deploy.conf"
   elif [ $# -eq 1 ] ; then
     conf_file=$1
   fi
 
   #echo "Parsing $conf_file"
   if [ ! -f $conf_file ] ; then
     if [[ $EM_PROBE_MODE -eq 1 ]]
     then
       EMSG="The exalogic config file doesn't exist. Set conf file location in env variable RAT_EXALOGIC_CONF and run again"
       update_probe_xml "ERROR" "GENERIC" "$EMSG"
     fi
     echo "The exalogic config file doesn't exist. Set conf file location in env variable RAT_EXALOGIC_CONF and run again"
     exit 1
   fi
 
   if [ -e $cnlist_file -a -e $snlist_file -a -e $swlist_file ] ; then
     if [[ $EM_PROBE_MODE -eq 1 ]]
     then
       EMSG="Exalogic node info files already exist. Please refer to $cnlist_file, $swlist_file, and $snlist_file for more information"
       update_probe_xml "ERROR" "GENERIC" "$EMSG"
     fi
     echo "Exalogic node info files already exist. Please refer to $cnlist_file, $swlist_file, and $snlist_file for more information"
     exit 1
   else
     rm -rf $cnlist_file
     rm -rf $swlist_file
     rm -rf $snlist_file
   fi
 
   ###########################
   # Retrieve the required info
   ##########################
   rackname=""
   sn_prefix=""
   cn_prefix=""
   # Storage node name prefix
   #sn_prefix=`cat $conf_file | grep SNODE_PREFIX | cut -d ' ' -f 2`
   sn_prefix=`grep SNODE_PREFIX $conf_file | cut -d ' ' -f 2`
 
   # Rackname
   #rackname=`cat $conf_file | grep RACK_NAME | cut -d ' ' -f 2`
   rackname=`grep RACK_NAME $conf_file | cut -d ' ' -f 2`
 
   # Compute node name prefix
   #cn_prefix=`cat $conf_file | grep CNODE_PREFIX | cut -d ' ' -f 2`
   cn_prefix=`grep CNODE_PREFIX $conf_file | cut -d ' ' -f 2`
 
   ####################################################
   # Generate o_host_list.out
   #cat $conf_file | grep "$rackname$cn_prefix" | cut -f2 > $cnlist_file
   grep "$rackname$cn_prefix" $conf_file | cut -f2 > $cnlist_file
   #cat $conf_file | grep "$rackname$cn_prefix" | cut -f2 > $cnlist_file
 
   ######################################################
   # Generate o_storage.out
   #cat $conf_file | grep "$rackname$sn_prefix" | cut -f2 > $snlist_file
   grep "$rackname$sn_prefix" $conf_file | cut -f2 > $snlist_file
 
   ######################################################
   # Generate o_ibswitches.out
   #cat $conf_file | grep swnode | cut -d " " -f 2 | cut -f2 > $swlist_file
   grep swnode $conf_file | cut -d " " -f 2 | cut -f2 > $swlist_file
 
   components=$(echo ${user_components}:EXALOGIC)
 
   #echo "$cnlist_file, $snlist_file, and $swlist_file generated successfully"
   #echo "IS_EXALOGIC_MACHINE = $is_exalogic_machine" >> $MASTERFIL
   #echo "EXALOGIC_VERSION = $exalogic_version" >> $MASTERFIL
  else
   is_exalogic_machine=`grep IS_EXALOGIC_MACHINE $MASTERFIL | awk '{print $3}'`
   if [ ! -n "$is_exalogic_machine" ] ; then is_exalogic_machine=0; fi
   in_ec_exalogic=`grep IS_EXALOGIC_EC_MACHINE $MASTERFIL | awk '{print $3}'`
   exalogic_version=`grep EXALOGIC_VERSION $MASTERFIL | awk '{print $3}'`
   exalogic_version_actual=`grep EXALOGIC_ACTUAL_VERSION $MASTERFIL | awk '{print $3}'`
   RackIdentifier=`grep EXALOGIC_RACK_IDENTIFIER $MASTERFIL | sed 's/EXALOGIC_RACK_IDENTIFIER = //'`
   #echo "Offline mode"
  fi
}

validate_exalogic_rack()
{
  if [[ -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" ]] ; then return; fi;
  no_of_switches=$(cat $swlist_file|wc -l)
  no_of_compute_nodes=$(cat $cnlist_file|wc -l)
  #if [[ $no_of_switches -gt 2 && $no_of_compute_nodes -lt 30 ]]
  if [[ $no_of_switches -gt 2 && $no_of_compute_nodes -lt 30 && -z "$RAT_CLUSTERNODES" && -z "$RAT_IBSWITCHES" && -z "$RAT_ELRACKTYPE" ]]
  then
    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      EMSG="${program_name} could not determine rack type like full or half from environment. please set RAT_ELRACKTYPE to specify rack type as following.\nIf full rack then set RAT_ELRACKTYPE to 3\nIf half rack then set RAT_ELRACKTYPE to 2\nIf quarter rack then set RAT_ELRACKTYPE to 1\nIf 1/8 rack then set RAT_ELRACKTYPE to 0"
      update_probe_xml "ERROR" "GENERIC" "$EMSG"
    fi
    echo -e "${RED}${program_name} could not determine rack type like full or half from environment. please set RAT_ELRACKTYPE to specify rack type as following.\n${NORM}"
    echo -e "If full rack then set RAT_ELRACKTYPE to 3\nIf half rack then set RAT_ELRACKTYPE to 2\nif quarter rack then set RAT_ELRACKTYPE to 1\nif 1/8 rack then set RAT_ELRACKTYPE to 0"
    rm -f $HOSTLIST # gadiga avoid cleanup and ssh password prompts for each host
    exit 1
  fi  
}

function check_in_profiles ()
{
  if [[ -n "$exclude_profile" && $exclude_profile -eq 1 ]]
  then
    ex_profile=1
    if [ -z "$CHECK_ID" ]; then return; fi
    for aprofile in $profileids2exclude
    do
      if [[ `grep -ic "$CHECK_ID" "$SCRIPTPATH/.cgrep/profiles/$aprofile.prf"` -gt "0" ]] ; then
        ex_profile=0
        return;
      fi
    done
  else
    in_profile=0
    if [ -z "$CHECK_ID" ]; then return; fi
    for aprofile in $profileids2run
    do
      if [[ `grep -ic "$CHECK_ID" "$SCRIPTPATH/.cgrep/profiles/$aprofile.prf"` -gt "0" ]] ; then
        in_profile=1
        return;
      fi
    done
  fi
}

function check_in_targetversion ()
{
  in_profile=0
  if [[ `grep -ic "$CHECK_ID" "$targetVesionCheckFil"` -gt "0" ]] 
   then
     in_profile=1
     return;
  fi
}


assign_stack_status ()
{
  db_status_counter=0
  dbinst_up=0
  asminst_up=0

  if [ $OFFLINE -eq 0  ]
  then
    chk_fname=$MASTERFIL
  else
    chk_fname=$DUMPDIR/$CHKFIL
  fi

  #echo "========================================================================="
  #echo
  for db_name_to_check in "${mb_db_names[@]}"
  do
    if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]] ; then
      stack_db_status[$db_status_counter]=`grep -i "${db_name_to_check}.INSTANCE_MODE"  $chk_fname |awk '{print $3}' |sort -n |tail -1`
    else
      stack_db_status[$db_status_counter]=`grep -i "$i.${db_name_to_check}.INSTANCE_MODE"  $chk_fname |awk '{print $3}'`
    fi
    if [ -z "${stack_db_status[$db_status_counter]}" ] ; then
      stack_db_status[$db_status_counter]=0
    fi
    if [[ $dbinst_up -eq "0" && ${stack_db_status[$db_status_counter]} -gt "0" ]] ; then
      dbinst_up=${stack_db_status[$db_status_counter]}
    fi
    #echo "db_status_counter=$db_status_counter, db_name_to_check=$db_name_to_check, stack_db_status=${stack_db_status[$db_status_counter]}, dbinst_up=$dbinst_up"
    db_status_counter=$(expr $db_status_counter + 1);
  done

  stack_dbinst_up[$stack_counter]=$dbinst_up

  if [ -z "${stack_db_status[0]}" ] ; then stack_db_status[0]=0; fi
  asminst_up=`grep -i "$i.ASM_STATUS"  $chk_fname |awk '{print $3}'`
  if [ -z "$asminst_up" ] ; then asminst_up=0; fi
  stack_asm_up[$stack_counter]=$asminst_up

  #echo "stack_dbinst_up= ${stack_dbinst_up[$stack_counter]}"
  #echo "========================================================================="
  #echo
}

copy_utl_script_to_tmp ()
{
  #copy utility scripts to /tmp on all nodes so audit check can find it and execute it
  utlscrpcounter=0
  printf "\n\nCopying plug-ins\n\n. . " 
  #for utlscrpt_full in `if [ -d $SCRIPTPATH/.cgrep ]; then ls -l $SCRIPTPATH/.cgrep/[a-z][!cgrep]*|awk '{print $NF}';fi`
  for utlscrpt_full in `if [ -d $SCRIPTPATH/.cgrep ]; then ls -l $SCRIPTPATH/.cgrep/ 2>/dev/null >&1|grep ^-|grep -v "grep"|awk '{print $NF}';fi`  
  do
    utlscrpt=$(basename $utlscrpt_full)
    for hname in `cat $HOSTLIST`
    do
      if  [ -e $SCRIPTPATH/.cgrep/${utlscrpt} ]
      then  
        if [ $hname = $localnode ]
        then
          cp -f $SCRIPTPATH/.cgrep/${utlscrpt} $TMPDIR  >/dev/null 2>&1  
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "$ASREXACHK" ]; then chmod 744 $TMPDIR/$ASREXACHK;fi
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "checkDiskFGMapping.sh" ]; then chmod 744 $TMPDIR/checkDiskFGMapping.sh;fi
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "checkDiskScheduler.sh" ]; then chmod 744 $TMPDIR/checkDiskScheduler.sh;fi
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "checkvg.sh" ]; then chmod 744 $TMPDIR/checkvg.sh;fi
	
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
            cp -f $SCRIPTPATH/.cgrep/${utlscrpt} $TMP_OUTPUT  >/dev/null 2>&1  
            chmod 755 $TMP_OUTPUT/${utlscrpt}
	  fi 
        else
          $SCOPY $SCRIPTPATH/.cgrep/${utlscrpt}   $usern@$hname:$TMPDIR/ >/dev/null 2>&1 
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "$ASREXACHK" ]; then $SSHELL $usern@$hname "chmod 744 $TMPDIR/$ASREXACHK";fi
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "checkDiskFGMapping.sh" ]; then $SSHELL $usern@$hname "chmod 744 $TMPDIR/checkDiskFGMapping.sh";fi
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "checkDiskScheduler.sh" ]; then $SSHELL $usern@$hname "chmod 744 $TMPDIR/checkDiskScheduler.sh";fi
          if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "checkvg.sh" ]; then $SSHELL $usern@$hname "chmod 744 $TMPDIR/checkvg.sh";fi

	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
            $SCOPY $SCRIPTPATH/.cgrep/${utlscrpt} $usern@$hname:$TMP_OUTPUT/ >/dev/null 2>&1 
            $SSHELL $usern@$hname "chmod 755 $TMP_OUTPUT/${utlscrpt}";
	  fi 
        fi
      fi
      #$READ -p "stop for $SCRIPTPATH/.cgrep/$ASREXACHK"
    done
    a_utlscrpt[$utlscrpcounter]=$utlscrpt 
    utlscrpcounter=$(expr $utlscrpcounter + 1 )
    printf ". "
  done
  printf "\n\n" 
  utlscrpcounter=0 
}

add_maa_scorecard ()
{
  if [[ -n "$skip_maa_scorecard" && $skip_maa_scorecard -eq 1  ]]
  then 
    if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] || [[ -n "$it_is_rac" && $it_is_rac -eq 1 ]]
    then
      components=$(echo ${components}|sed 's/:MAA//')
    elif [ $single_instance_run -eq 1 ]
    then
      components=$(echo ${components}|sed 's/:SIDBMAA//')   
    else
      components=$(echo ${components}:MAA)
    fi
    TYP=-a
  fi
  if [[ -n "$maa_scorecard" && $maa_scorecard -eq 0 ]]; then components=$(echo ${components}|sed 's/:MAA//');components=$(echo ${components}|sed 's/:SIDBMAA//'); fi
  if [[ $is_exadata_dom0_machine -eq "1" || $is_ssc_globalzone_machine -eq 1 ]] ; then components=$(echo ${components}|sed 's/:MAA//');fi
}

add_hacheck ()
{
  if [[ -n "$skip_hacheck" && $skip_hacheck -eq 1  ]] 
  then 
    #if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] || [[ -n "$it_is_rac" && $it_is_rac -eq 1 ]]
    if [[ -n "$it_is_rac" && $it_is_rac -eq 1 ]] || [[ -n "$oda_machine" && $oda_machine -eq 1 ]]
    then
      components=$(echo ${components}:HACHECK)
      #components=$(echo ${components}|sed 's/:HACHECK//')
    elif [ $single_instance_run -eq 1 ]
    then
      components=$(echo ${components}:SIDBHACHECK)
      #components=$(echo ${components}|sed 's/:SIDBHACHECK//')
      #else
      #components=$(echo ${components}:HACHECK)
    fi
    TYP=-a
  fi
  if [[ -n "$include_hacheck" && $include_hacheck -eq 0 ]]
  then 
    if [ $single_instance_run -eq 1 ]
    then
      components=$(echo ${components}|sed 's/:SIDBHACHECK//')
    else
      components=$(echo ${components}|sed 's/:HACHECK//')
    fi
  fi
}

match_database_role ()
{
  dbrole_match_count=0
  dbrole_match_count=$(echo $check_database_role|grep -icw $1)
}
match_database_type ()
{
  dbtype_match_count=0
  dbtype_match_count=$(echo $check_database_type|grep -icw $1)
}

compare_collections ()
{

  res1=$1;
  res2=$2;


  if [ -n $3 ] ; then
	res3=$3;
  fi

  if [[ -z "$res1" || -z "$res2" ]] ; then
    echo -e "${RED}This command requires two arguments.${NORM}";
    display_usage;
  fi

  remove_res1=0
  remove_res2=0

  if [ `echo $res1 | grep -ic '\.zip$'` -gt "0" ] ; then
    zip_base=$(basename $res1 | sed 's/\.zip//');
    rm -rf $TMPDIR/$zip_base
    unzip $res1 -d $TMPDIR >/dev/null 2>&1
    if [ -e "$TMPDIR/$zip_base/$zip_base.html" ] ; then
      remove_res1=1
      res1_dir="$TMPDIR/$zip_base"
    else
      echo -e "${RED}Error while unzipping $res1.. exiting${NORM}";
      exit;
    fi
  else
    res1_dir=$res1
  fi

  if [ `echo $res2 | grep -ic '\.zip$'` -gt "0" ] ; then
    zip_base=$(basename $res2 | sed 's/\.zip//');
    rm -rf $TMPDIR/$zip_base 
    unzip $res2 -d $TMPDIR >/dev/null 2>&1
    if [ -e "$TMPDIR/$zip_base/$zip_base.html" ] ; then
      remove_res2=1
      res2_dir="$TMPDIR/$zip_base"
    else
      echo -e "${RED}Error while unzipping $res2.. exiting${NORM}";
      exit;
    fi
  else
    res2_dir=$res2
  fi

  if [ -e "$res1_dir/outfiles/check_env.out" ]
  then
    MASTERFIL1=$res1_dir/outfiles/check_env.out
  else
    MASTERFIL1=$res1_dir/outfiles/raccheck_env.out
  fi
 
  if [ `grep -iwc "IT_IS_RAC = 1" $MASTERFIL1` -gt 0 ]
  then
    $perl_exe $SCRIPTPATH/.cgrep/diff_collections.pl $WRKDIR $res1_dir $res2_dir $res3 
  fi

  if [[ $remove_res1 -eq "1" && -d "$res1_dir" ]] ; then
    rm -rf $res1_dir
  fi
  if [[ $remove_res2 -eq "1" && -d "$res2_dir" ]] ; then
    rm -rf $res2_dir
  fi


}

compare_reports ()
{
  perl_exe=$(which perl| tr -d '\r')
  if [ -z "$perl_exe" ] ; then
    echo -e "${RED}This feature requires Perl command. If its installed, please set PATH and try again, else please install perl and try again.${NORM}";
    display_usage; 
  fi

  args=$(echo $* | sed 's/.*-diff//');
  if [ -z "$args" ] ; then 
    echo -e "${RED}Missing arguments${NORM}";
    display_usage; 
  fi

  report1=$(echo $args | awk '{print $1}');

  if [[ $report1 = "-h" ]] ; then
    echo -e "   
        -diff <Old Report> <New Report> [-outfile <Output HTML>]
                Diff two ${program_name} reports. Pass directory name or zip file or html report file as <Old Report> & <New Report>
    "
    exit 1;
  fi

  report2=$(echo $args | awk '{print $2}');
  if [ -z "$report3" ] ; then
    report3=$(echo $args | awk '{print $3}');
    if [[ -n "$report3" && $report3 = "-outfile" ]] ; then
      report3=$(echo $args | awk '{print $4}');
    else
      unset report3;
    fi
  fi

  if [[ -z "$report1" || -z "$report2" ]] ; then
    echo -e "${RED}This command requires two arguments.${NORM}";
    display_usage; 
  fi

  report1col=$report1;
  report2col=$report2;

  if [ -e "$res1_dir/outfiles/check_env.out" ]
  then
    MASTERFIL1=$res1_dir/outfiles/check_env.out
  else
    MASTERFIL1=$res1_dir/outfiles/raccheck_env.out
  fi

  if [[ `echo $report1 | grep -ic '\.html$'` -gt "0" || `echo $report2 | grep -ic '\.html$'` -gt "0" ]] ; then
        diffcoll=0;
  else
        diffcoll=1;
  fi

  remove_report1=0
  remove_report2=0
  if [ `echo $report1 | grep -ic '\.zip$'` -gt "0" ] ; then
    #zip_base=$(basename $report1 | sed 's/\.zip//');
    #unzip $report1 $zip_base/$zip_base.html -d /tmp >/dev/null 2>&1
    #if [ -e "/tmp/$zip_base/$zip_base.html" ] ; then
    #  report1=/tmp/$zip_base/$zip_base.html
    #  remove_report1=1
    #  report1_dir="/tmp/$zip_base/"

    zip_base=$(basename $report1 | sed 's/\.zip//');
    unzip $report1 -d $TMPDIR/report1_$$ >/dev/null 2>&1

    if [ -e "$TMPDIR/report1_$$/$zip_base/outfiles/check_env.out" ]
    then
      MASTERFIL1=$TMPDIR/report1_$$/$zip_base/outfiles/check_env.out
    else
      MASTERFIL1=$TMPDIR/report1_$$/$zip_base/outfiles/raccheck_env.out
    fi
    if [ `grep -iwc "IT_IS_RAC = 1" $MASTERFIL1` -gt 0 ]
    then
            diffcoll=1;
    else
            diffcoll=-1;
    fi

    if [ -e "$TMPDIR/report1_$$/$zip_base/$zip_base.html" ] ; then
      report1=$TMPDIR/report1_$$/$zip_base/$zip_base.html
      remove_report1=1
      report1_dir="$TMPDIR/report1_$$/"
      report1_file="$zip_base.html"
    else
      echo -e "${RED}Error while unzipping $report1.. exiting${NORM}";
    fi
  fi

  if [ `echo $report2 | grep -ic '\.zip$'` -gt "0" ] ; then
    #zip_base=$(echo $report2 | sed 's/\.zip//');
    #unzip $report2 $zip_base/$zip_base.html -d /tmp >/dev/null 2>&1
    #if [ -e "/tmp/$zip_base/$zip_base.html" ] ; then
    #  report2=/tmp/$zip_base/$zip_base.html
    #  remove_report2=1
    #  report2_dir="/tmp/$zip_base/"

    zip_base=$(basename $report2 | sed 's/\.zip//');
    unzip $report2 $zip_base/$zip_base.html -d $TMPDIR/report2_$$ >/dev/null 2>&1
    if [ -e "$TMPDIR/report2_$$/$zip_base/$zip_base.html" ] ; then
      report2=$TMPDIR/report2_$$/$zip_base/$zip_base.html
      remove_report2=1
      report2_dir="$TMPDIR/report2_$$/"
      report2_file="$zip_base.html"
    else
      echo -e "${RED}Error while unzipping $report2.. exiting${NORM}";
    fi
  fi
   

  $perl_exe $SCRIPTPATH/.cgrep/diff_checks.pl $diffcoll $WRKDIR $report1 $report2 $report3

  if [[ $remove_report1 -eq "1" && -d "$report1_dir" ]] ; then
    rm -f $report1_dir/$report1_file
    #rmdir $report1_dir
    rm -rf $report1_dir
  fi
  if [[ $remove_report2 -eq "1" && -d "$report2_dir" ]] ; then
    rm -f $report2_dir/$report2_file
    #rmdir $report2_dir
    rm -rf $report2_dir
  fi

  if [[ $diffcoll -eq "1" ]] ; then
  	compare_collections $report1col $report2col $report3 
  fi
}

compare_exalogic_rack ()
{
  python_exe=$(which python)
  if [ -z "$python_exe" ] ; then
    echo -e "${RED}This feature requires python command. If its installed, please set PATH and try again, else please install python and try again.${NORM}";
    display_usage;
  fi
  
  args=$(echo $* | sed 's/.*-exadiff//');
  if [ -z "$args" ] ; then
    echo -e "${RED}Missing arguments${NORM}";
    display_usage;
  fi
  
  report1=$(echo $args | awk '{print $1}');
  report2=$(echo $args | awk '{print $2}');
  report3=$(echo $args | awk '{print $3}');
  
  if [[ -n "$report3" ]] || [[ -z "$report1" || -z "$report2" ]] ; then 
    echo -e "${RED}This command requires two arguments.${NORM}";
    display_usage;
  fi

  if [[ `echo $report1 | grep -ic '\.zip$'` -eq "0" ]] ; then
    if [ -f "$report1" ]; then
      echo -e "${RED}This command requires two collections. First argument is a file.${NORM}";
      display_usage;
    fi
  fi
  if [[ `echo $report2 | grep -ic '\.zip$'` -eq "0" ]] ; then
    if [ -f "$report2" ] ; then
      echo -e "${RED}This command requires two collections. Second argument is a file.${NORM}";
      display_usage;
    fi
  fi
 
  $python_exe $SCRIPTPATH/.cgrep/rack_comparison.py $report1 $report2 
}

reset_crs ()
{
  
  perl_exe=$(which perl| tr -d '\r');
  if [ -z "$perl_exe" ] ; then
    echo -e "${RED}This feature requires Perl command. If its installed, please set PATH and try again, else please install perl and try again.${NORM}";
    display_usage; 
    return 
  fi

  args=$(echo $* | sed 's/.*-resetcrs//');
  if [ -z "$args" ] ; then
    echo -e "${RED}Missing arguments${NORM}";
    display_usage;
    return 
  fi

  if [ -e "$SCRIPTPATH/.cgrep/reset_crshome.pl" ]
  then
    chmod 744 $SCRIPTPATH/.cgrep/reset_crshome.pl >/dev/null 2>&1
    $perl_exe $SCRIPTPATH/.cgrep/reset_crshome.pl $args 
  fi
}

check_if_bda ()
{
  is_bda_machine=0
  bda_machine=""
  bda_identifier="";
  bda_version="";
  if [ -e /opt/oracle/bda/ ];
  then
    bda_machine=$(rpm -q bda);
    if [ `echo "$bda_machine" |grep -ic bda` -gt 0 ]	
    then
      is_bda_machine=1
    fi
  fi
  localnode=`hostname | tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r'`
  if [ $is_bda_machine -eq 1 ];
  then
    if [ `uname -s` = "Linux" ]; then IPMITOOL="/usr/bin/ipmitool";elif [ `uname -s` = "SunOS" ]; then IPMITOOL="/opt/ipmitool/bin/ipmitool";fi
    if [ -e $IPMITOOL ]; then bda_identifier=$($IPMITOOL sunoem cli force "show /SP system_identifier"|grep "system_identifier "|awk '{print $NF}');fi
    set_bda_env
  fi
}

function set_bda_env()
{
  if [ -n "$RAT_DB" ];
  then
    bda_version=$RAT_DB
  else
    bda_version=`imageinfo |grep IMAGE_VERSION | awk ' { print $3} '`
    if [[ -z "$bda_version" ]];
    then
      bda_version=`rpm -q bda|cut -d- -f2`
    fi
  fi
  bda_actual_version=$bda_version;
  if [[ -z "$bda_version" ]];
  then
    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      EMSG="${program_name} did not find Big Data Appliance version from environment. Please set RAT_DB like export RAT_DB=2.2.0 and run $program_name again"
      update_probe_xml "ERROR" "GENERIC" "$EMSG"
    fi
    echo -e "${RED} ${program_name} did not find Big Data Appliance version from environment. Please set RAT_DB like export RAT_DB=2.2.0 and run $program_name again${NORM}"
    exit 1
  else
    if [[ ${#bda_version} -eq 5 ]];
    then
      bda_version=$bda_version'.0.0'
    elif [[ ${#bda_version} -eq 7 ]];
    then
      bda_version=$bda_version'.0'
    elif [[ ${#bda_version} -lt 5 || ${#bda_version} -gt 9 ]] 
    then
      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
	EMSG="Big Data Appliance version is not correct. Please set RAT_DB like RAT_DB=2.2.0 and run $program_name again"
	update_probe_xml "ERROR" "GENERIC" "$EMSG"
      fi
      echo -e "${RED} Big Data Appliance version is not correct. Please set RAT_DB like RAT_DB=2.2.0 and run $program_name again${NORM}"
      exit 1
    fi
  fi
  
  if [ $upgrade_mode -gt 0 ]
  then
    echo -e "${RED}Checking upgrade best practices are not supported by ${program_name} for Big Data Appliance ${NORM}"
    exit 1
  fi

  if [ $TYP = "-p" ]
  then
    echo -e "${RED}Patch recommendations are not supported by ${program_name} for Big Data Appliance ${NORM}"
    exit 1
  fi

}

function generate_bda_node_info()
{
  if [ $OFFLINE -eq 0 ]
  then
    cnlist_file="$OUTPUTDIR/o_host_list.out"
    swlist_file="$OUTPUTDIR/o_ibswitches.out"
    HOSTLIST=$cnlist_file

    if [ -n "$RAT_CLUSTERNODES" ]
    then
      rm -f $HOSTLIST
      for nodename in `echo $RAT_CLUSTERNODES`
      do
        echo $nodename>>$HOSTLIST
      done
    else 
      if [[ -f /opt/oracle/bda/install/state/config.json ]];
      then
       bda_nodes=`/opt/oracle/bda/bin/bdacli getinfo cluster_node_names`
      elif [[ -f /opt/oracle/bda/install/state/mammoth-saved.params ]];
      then
        bda_nodes=`grep -m 1 "NODE_NAMES" /opt/oracle/bda/install/state/mammoth-saved.params | sed 's/.*=(//' | sed 's/)//'`
      else
        if [[ -f /opt/oracle/bda/BdaDeploy.json ]];
        then
          bda_nodes=`/opt/oracle/bda/bin/json-select --jpx=BONDETH0_NAMES /opt/oracle/bda/BdaDeploy.json`
        else
          if [[ $EM_PROBE_MODE -eq 1 ]]
          then
	    EMSG="Network is not configured on this Big Data Appliance. Please configure the network and run $program_name again"
	    update_probe_xml "ERROR" "GENERIC" "$EMSG"
          fi
          echo -e "${RED}Network is not configured on this Big Data Appliance. Please configure the network and run $program_name again${NORM}"
          exit 1
        fi
      fi
      if [[ -z "$bda_nodes" ]];
      then
        if [[ $EM_PROBE_MODE -eq 1 ]]
        then
	  EMSG="Unable to determine compute nodes in Big Data Appliance. Please set RAT_CLUSTERNODES like RAT_CLUSTERNODES=node1,node2 and run $program_name again"
	  update_probe_xml "ERROR" "GENERIC" "$EMSG"
        fi
        echo -e "${RED}Unable to determine compute nodes in Big Data Appliance. Please set RAT_CLUSTERNODES like RAT_CLUSTERNODES=node1,node2 and run $program_name again${NORM}"
        exit 1
      else
        rm -f $cnlist_file
        touch $cnlist_file
        for nodename in `echo $bda_nodes`
        do
          echo $nodename>>$cnlist_file
        done 
      fi
    fi

    if [ -n "$RAT_IBSWITCHES" ];
    then
      rm -f $swlist_file
      touch $swlist_file
      for switchname in `echo $RAT_IBSWITCHES`
      do
       	echo "$switchname">>$swlist_file
      done
    fi
    #else
    #    rm -f $swlist_file
    #    touch $swlist_file
    #    /usr/sbin/ibswitches|egrep -wi 'IB|GW'|cut -d'"' -f2|awk '{print $6}'|grep -vw localhost|cut -d' ' -f1>$swlist_file
    #    if [ -s $swlist_file ];
    #    	then
    #        	echo ""
    #    else
    #		echo "Failed to get infiniband gateway switch names. Please set RAT_IBSWITCHES like RAT_IBSWITCHES=switch1,switch2 and run $program_name. Skipping infiniband gateway switches for this run.";
    #        	touch $swlist_file		
    #    fi
    #fi

    echo "IS_BDA_MACHINE = $is_bda_machine" >> $MASTERFIL
    echo "BDA_VERSION = $bda_version" >> $MASTERFIL
    echo "BDA_ACTUAL_VERSION = $bda_actual_version" >> $MASTERFIL
    echo "BDA_IDENTIFIER = $bda_identifier" >> $MASTERFIL
  else
    is_bda_machine=`grep IS_BDA_MACHINE $DUMPDIR/$CHKFIL | awk '{print $3}'`
    bda_version=`grep BDA_VERSION $DUMPDIR/$CHKFIL | awk '{print $3}'`
    bda_actual_version=`grep BDA_ACTUAL_VERSION $DUMPDIR/$CHKFIL | awk '{print $3}'`
    bda_identifier=`grep BDA_IDENTIFIER $DUMPDIR/$CHKFIL | awk '{print $3}'`
  fi
}

function bda_machine_type()
{
  if [[ $is_bda_machine -ne "1" ]]; then return; fi
  if [ $OFFLINE -eq 0 ]
  then
    if [ -z "$platform" ]; then platform=$(uname -s);fi;
    sunfire_x4270m2=0
    sunfire_x4270m3=0
    
    if [ $platform = "Linux" ]
    then
      if [ "$1" = "$localnode" ]
      then
        #no_of_cores=$(cat /proc/cpuinfo | grep -w "processor"|wc -l)
        no_of_cores=$(grep -w "processor" /proc/cpuinfo | wc -l | tr -d ' ')
        bda_platform=$(uname -p)
      else
        no_of_cores=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 'cat /proc/cpuinfo | grep -w "processor"|wc -l|tr -d ' '')
        bda_platform=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 'uname -p')
      fi
    else
      if [ "$1" = "$localnode" ]
      then
        no_of_cores=$(/sbin/psrinfo|wc -l|tr -d ' ')
        bda_platform=$(uname -p)
      else
        no_of_cores=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 '/sbin/psrinfo|wc -l|tr -d ' '')
        bda_platform=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 'uname -p')
      fi
    fi
    
    if [[ $no_of_cores -eq 24 ]]
    then
      sunfire_x4270m2=1
      components=$(echo ${user_components}:BDAX2-2)
    elif [[ $no_of_cores -eq 32 ]]
    then
      sunfire_x4270m3=1
      components=$(echo ${user_components}:BDAX3-2)
    fi
    
    rdbms_installed[0]=0
    if [[ -f /opt/oracle/bda/install/state/mammoth-saved.params ]];
    then
      rdbms_installed[0]=1	
    fi
    echo "$1.RDBMS_INSTALLED = ${rdbms_installed[0]}">> $MASTERFIL;
  fi
}

check_if_exalytics()
{
  IMAGE_ID_FILE=/usr/lib/init-exalogic-node/.image_id
  IMAGE_HISTORY_FILE=/var/log/init-exalogic-node/.image_history
  IMAGEINFO=/opt/exalytics/bin/exalytics_imageinfo
  is_exalytics_machine=1
  RackIdentifier="";
  exalytic_version_actual="";
  exalytic_version_cn="";

  if [ -r /var/exalytics/info/em-context.info ]
  then
    #ipmi_system_identifier=$(cat /var/exalytics/info/em-context.info|grep -wi "system_identifier"|grep -iwc "exalytics")
    ipmi_system_identifier=$(grep -wi "system_identifier" /var/exalytics/info/em-context.info|grep -iwc "exalytics")
  else
    ipmi_system_identifier=$(/usr/bin/ipmitool sunoem cli force 2>/dev/null "show /SP system_identifier")
    ipmi_system_identifier_exalytics=$(echo $ipmi_system_identifier|grep "system_identifier"|grep -cwi "exalytics")
  fi

  if [[ -n "$ipmi_system_identifier_exalytics" && "$ipmi_system_identifier_exalytics"  -eq 0 ]]; then is_exalytics_machine=0;fi
  dom0_node=0
  if grep -q "control_d" /proc/xen/capabilities > /dev/null 2>&1
  then
    dom0_node=1
  fi
  localnode=`hostname | tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r'`
  if [ $is_exalytics_machine -eq 1 ]
  then
    set_exalytics_env  
  fi
}

 
function set_exalytics_env ()
{
  html_rack_type="System"
  it_is_rac=0
  #checking for existance of binary to support solaris because ipmitool does not exists there
  if [ -e /usr/bin/ipmitool ]; then RackIdentifier=$(/usr/bin/ipmitool sunoem cli force "show /SP system_identifier"|grep "system_identifier "|awk '{print $NF}');fi
  if [ -n "$RAT_DB" ]
  then
    exalytics_version_actual=$RAT_DB
  elif [ -e "$IMAGEINFO" ]
  then
    exalytics_version_actual=$($IMAGEINFO|grep -iw "image version"|cut -d':' -f2|cut -d' ' -f2)
  elif [ -e "/usr/lib/init-exalogic-node/.emoc_version" ]
  then
    exalytics_version_actual=$(cat /usr/lib/init-exalogic-node/.emoc_version | cut -d= -f2 | sed "s/'//g")
  else
    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      EMSG="${program_name} did not find Exalytics version from environment. Please set RAT_DB like RAT_DB=1.0.0.5 and run $program_name again"
      update_probe_xml "ERROR" "GENERIC" "$EMSG"
    fi
    echo -e "${RED} ${program_name} did not find Exalytics version from environment. Please set RAT_DB like RAT_DB=1.0.0.5 and run $program_name again${NORM}"
    exit 1
  fi
  exalytics_version=$(echo $exalytics_version_actual |tr -d '.')
  #new command returns 4 digit version and all checks have five digit version so adding one more 0 to match system and check version
  if [[ `echo $exalytics_version|grep -ci 1005` -ge 1 ]]; then exalytics_version=10050;fi 
  if [[ `echo $exalytics_version|grep -ci 1006` -ge 1 ]]; then exalytics_version=10060;fi 
  if [[ `echo $exalytics_version|grep -ci 1007` -ge 1 ]]; then exalytics_version=10060;fi 
  components=$(echo ${components}:EXALYTICS)
  if [ $upgrade_mode -gt 0 ]
  then
    echo -e "${RED}Checking upgrade best practices are not supported by ${program_name} for Exalytics ${NORM}"
    exit 1
  fi

  if [ $TYP = "-p" ]
  then
    echo -e "${RED}Patch recommendations are not supported by ${program_name} for Exalytics ${NORM}"
    exit 1
  fi

  if [ $exalytics_version  -lt 10050 ]
  then
    echo -e "${RED}\n\n${program_name} is not supported on Exalytics version $exalytics_version_actual ${NORM}\n\n"
    exit 1
  fi
}

function generate_exalytics_node_info ()
{
  echo $localnode>$OUTPUTDIR/o_host_list.out
  echo "$localnode.COMPONENT = $components">>$MASTERFIL 
  echo "EXALYTICS_VERSION = $exalytics_version" >>$MASTERFIL
  echo "EXALYTICS_VERSION_ACTUAL = $exalytics_version_actual" >>$MASTERFIL
  echo "IS_EXALYTICS_MACHINE = $is_exalytics_machine" >>$MASTERFIL
  echo "EXALYTICS_RACK_IDENTIFIER = $RackIdentifier" >> $MASTERFIL 
  rdbms_installed[0]=0
  ttx_installed[0]=0
  set_exalytics_bi_env
  read_exalytics_bi_env
  #-------------------TimesTen
  # added branch not to call timesten stuffs if profile is obiee
  if [ "$profiles2run" != "obiee" ]; then set_exalytics_tt_env;fi
  #---------------------------
}

#-------------------TimesTen
function set_exalytics_tt_env ()
{
  TTX_FILENAME="/etc/TimesTen/instance_info"

  if [ -e "$OUTPUTDIR/check_env.out" ]
  then
    MASTERFIL1=$OUTPUTDIR/check_env.out
  else
    MASTERFIL1=$OUTPUTDIR/raccheck_env.out
  fi

  TTX_TMPFILE=$MASTERFIL1

  if [[ -e $TTX_FILENAME && -s $TTX_FILENAME ]]
  then
    if [ $OFFLINE -eq 0 ]
    then
      echo ""
      sed -e '/^#/d' -e '/./{H;$!d;}' -e 'x;/\[ [^ ]* \]/!d;/Product=/!d;/InstallDir=/!d' $TTX_FILENAME |
                        awk -v TMPFILE=$TTX_TMPFILE -v SILENT=$skip_in_silent 'BEGIN{
                                n=0;ret=1;
                        }
                        {
                                IGNORECASE=1;if($0~/^\[/) {n++;p=index($0," ]");inst[n]=substr($0,3,p-3)};
                                if($0~/^Product=/) {prod[n]=substr($0,17);if(prod[n]~/11.2.2/) prodOK[n]=1;}
                                if($0~/^InstallDir=/) instdir[n]=substr($0,12);
                                if($0~/^InstanceAdministrator=/) {admin[n]=substr($0,23);if(admin[n]=="oracle") adminOK[n]=1}
                                if($0~/^DaemonHome=/) dhome[n]=substr($0,12);
                                if($0~/^BitLevel=/) {bit[n]=substr($0,10);if(bit[n]=="64") bitOK[n]=1}
                                if($0~/^Component=/) {comp[n]=substr($0,11);if(comp[n]=="Client/Server and DataManager") compOK[n]=1;}
                        }
                        END{
				if (n>0) {
	                		printf "List of running TimesTen databases\n" > "/dev/stderr";
					printf "\n" > "/dev/stderr";
					printf "\n[BEGIN TIMESTEN BLOCK\n" >> TMPFILE;
				}
                                dbIdx=1;
                                printf "DBNAME=TTX_DBPATH | TTX_VERSION | TTX_INSTANCE_NAME | TTX_HOME | TTX_DAEMON_HOME\n" >> TMPFILE;
                                printf "--------------------------------------------------------------------------------\n" >> TMPFILE;
                                for(i=1;i<=n;i++) {
                                        m=0;
					cmd1="ls "dhome[i]"/DBI* 2>/dev/null"; while((cmd1 | getline dbif[m])>0) {m++}; close(cmd1);
					if (m>0) printf "\n+ installation [%s]:\t %s, %s\n",inst[i],prod[i],instdir[i];
                                        for(j=0;j<m;j++) {
						duplicateDB=0;dbiInst[j]="";
						s="";p=0;DBILINES=5;cmd2="/usr/bin/od -A n -S2 "dbif[j]" | head -n "DBILINES; cmd2 | getline dbiInst[j]; while(s!~/^\// && p<DBILINES) {p++;cmd2 | getline s}; if(s~/^\//) {dbiDBPath[dbIdx]=s} else {print "error parsing DBI file "dbif[j]}; close(cmd2);
						for(k=1;k<dbIdx;k++) { if (dbiDBPath[dbIdx] == dbiDBPath[k]) duplicateDB=1; }
						if (dbiDBPath[dbIdx]!="" && dbiInst[j]==inst[i] && duplicateDB!=1) {
							printf "[%d] database=%s\n",dbIdx,dbiDBPath[dbIdx];
       		                                        printf "%d. %s\n",dbIdx,dbiDBPath[dbIdx] > "/dev/stderr";
							printf "DBNAME%d=%s|%s|%s|%s|%s\n",dbIdx,dbiDBPath[dbIdx],prod[i],inst[i],instdir[i],dhome[i] >> TMPFILE;		
                        	                        dbIdx++;
						}
                                        }
                                }
				if (n>0) {
					aindex=dbIdx;
					printf "%d. %s\n",dbIdx,"All of Above" > "/dev/stderr";
					printf "%d. %s\n",dbIdx,"All of Above" >> TMPFILE; 
					dbIdx++;
					tindex=dbIdx;
					printf "%d. %s\n",dbIdx,"None of Above" > "/dev/stderr";
					printf "%d. %s\n",dbIdx,"None of Above" >> TMPFILE; 
					printf "\n" > "/dev/stderr";
					if (SILENT == 0) {
						printf "Select databases from list for checking best practices. For multiple databases, select %d for All or comma separated number like 1,2 etc [1-%d][%d].",aindex,tindex,aindex > "/dev/stderr";
					}
					printf "END TIMESTEN BLOCK]\n\n" >> TMPFILE;
				}
                        }' 2>&1 > /dev/null

      AINDEX=$(grep -i 'All of Above' $TTX_TMPFILE|awk -F"." '{print $1}');
      NINDEX=$(grep -i 'None of Above' $TTX_TMPFILE|awk -F"." '{print $1}');
      
      if [[ $skip_in_silent -eq 0 ]] && [[ $EM_PROBE_MODE -eq 0 ]] && [[ $EM_XMLD_MODE -eq 0 ]]
      then
      	exec 3<&2; exec 2<&0
      	$READ -p "" TTX_INPUT
	read_code=`echo $?`;
      	exec 2<&3
	process_prompt "$read_code" "TTX_INPUT" "$AINDEX"
      elif [[ $EM_XMLD_MODE -eq 1 ]]
      then
	read_probe_xml "List of running TimesTen databases"
 	TTX_INPUT=$xml_rvalue	
      else
      	TTX_INPUT=$AINDEX;
      fi
      echo ""
      
      case $TTX_INPUT in
      	[0-9]*)		
      	  SHOW_TTX=$TTX_INPUT		
      	  if [ "$TTX_INPUT" = "$AINDEX" ]; then SHOW_TTX='all'; fi 
      	  if [ "$TTX_INPUT" = "$NINDEX" ]; then SHOW_TTX='none'; fi 
      	  ;;
      	*)
      	  SHOW_TTX='all'		
      	  ;;
      esac
      echo "TTX_CHECKS = $SHOW_TTX">> $TTX_TMPFILE;
    fi
  
    bln=$(grep -n 'BEGIN TIMESTEN BLOCK' $TTX_TMPFILE|awk -F":" '{print $1}');
    eln=$(grep -n 'END TIMESTEN BLOCK' $TTX_TMPFILE|awk -F":" '{print $1}');
    
    if [ $OFFLINE -eq 1 ]; then SHOW_TTX=`grep -i "TTX_CHECKS" $TTX_TMPFILE |awk '{print $3}'`; fi

    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      cat >> ${PROBE_XML}.tmp << EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="MULTI_SELECT" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <text nls_id="orhc_exadata_n38_nlsid">
        List of running TimesTen databases 
      </text>
    </context>
      <text nls_id="orhc_exadata_n8_nlsid">
        Select databases from list for checking best practices 
      </text>
    <options>
EOF
    fi
    
    if [ "$SHOW_TTX" != "none" ]; then
      O_IFS=$IFS
      IFS=$'\n'
      for LINE in `sed -n "$bln, $eln p" $TTX_TMPFILE`
      do
        i=`echo "$LINE" | awk '{t=-1;if(/^DBNAME[0-9]+=/) {p=index($0,"=");t=substr($0,7,p-7)};print t}'`
        if [ $i -ge 0 ]; then
      	  dbstr[$i]=`echo "$LINE" | awk '{p=index($0,"=");print substr($0,p+1);}'`
      	  ttx_dbpath[$i]=`echo "${dbstr[$i]}"| awk '{n=split($0,a,"|");print a[1]}'`
      	  ttx_version[$i]=`echo "${dbstr[$i]}" | awk '{n=split($0,a,"|");print a[2]}'`
      	  ttx_instance_name[$i]=`echo "${dbstr[$i]}" | awk '{n=split($0,a,"|");print a[3]}'`
      	  ttx_home[$i]=`echo "${dbstr[$i]}" | awk '{n=split($0,a,"|");print a[4]}'`
      	  ttx_daemon_home[$i]=`echo "${dbstr[$i]}" | awk '{n=split($0,a,"|");print a[5]}'`
      	  allDBIdxs="$allDBIdxs $i"

          if [[ $EM_PROBE_MODE -eq 1 ]]
          then
            cat >> ${PROBE_XML}.tmp << EOF
      <option id="q${PROBE_QUES_CNT}o${i}">
        <text${ttx_dbpath[$i]}|${ttx_version[$i]}|${ttx_instance_name[$i]}|${ttx_home[$i]}|${ttx_daemon_home[$i]}</text>
      </option>
EOF
          fi
        fi
      done
      IFS=$O_IFS;

      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
	i=$(expr ${i} + 1);
        cat >> ${PROBE_XML}.tmp << EOF
      <option id="q${PROBE_QUES_CNT}o${i}">
        <text nls_id="orhc_exadata_n4_nlsid">All</text>
      </option>
EOF
	i=$(expr ${i} + 1);
        cat >> ${PROBE_XML}.tmp << EOF
      <option id="q${PROBE_QUES_CNT}o${i}">
        <text nls_id="orhc_exadata_n3_nlsid">None</text>
      </option>
    </options>
  </question>
</group>
EOF
        PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
      fi

      if [ "$SHOW_TTX" == "all" ]; then
      	dbToCheck="$allDBIdxs"
      else
      	for j in $(echo $SHOW_TTX | sed 's/,/ /g'); do
      	  dbToCheck="$dbToCheck $j"
      	done
      fi
    
      #--------------------------
      mb_ttx_db_counter=0
      if [ ${#mb_db_names[@]} -gt 0 ]; then mb_ttx_db_counter=${#mb_db_names[@]}; fi
      
      for d in $dbToCheck 
      do
      	ttx_installed[0]=1
      	mb_db_names[$mb_ttx_db_counter]=${ttx_dbpath[$d]}
      	echo ${ttx_home[$d]} >>$OUTPUTDIR/mb_db_homes_distinct.out
      	mb_ttx_db_counter=$(expr $mb_ttx_db_counter + 1)
      done
      #--------------------------
    
      #--------------------------
      mb_ttx_db_counter=0
      if [ ${#mb_oracle_homes_distinct[@]} -gt 0 ]; then mb_ttx_db_counter=${#mb_oracle_homes_distinct[@]}; fi
      
      for mb_db_home in `if [ -e $OUTPUTDIR/mb_db_homes_distinct.out ]; then cat $OUTPUTDIR/mb_db_homes_distinct.out|sort -u;fi;`
      do
      	H_FOUND=0;
      	for homes in "${ttx_home[@]}"
      	do
      	  if [ $mb_db_home == $homes ]; then H_FOUND=1; fi
      	done
      
      	if [ $H_FOUND -eq 1 ]
      	then
      	  I_H_FOUND=0;
      	  for i_mb_db_home in ${mb_oracle_homes_distinct[@]}
      	  do
      	    if [ $i_mb_db_home == $mb_db_home ]
      	    then
      	      I_H_FOUND=1;
      	    fi
      	  done
      	  if [ $I_H_FOUND -eq 0 ]
      	  then
      	    mb_oracle_homes_distinct[$mb_ttx_db_counter]=$mb_db_home
      	    mb_ttx_db_counter=$(expr $mb_ttx_db_counter + 1)
      	  fi
      	fi
      done
      #-------------------------
      multiple_oracle_homes=$mb_ttx_db_counter
      mb_ttx_db_counter=0
    else
      dbToCheck=""
    fi
  fi
}

function set_exalytics_bi_env ()
{
  if [[ -e /etc/oraInst.loc || -e /u01/app/oracle/product/exalytics/config/domains.xml ]] && [ "$profiles2run" != "timesten" ] 
  then
    exalytics_reads_domains_xml  
    if [ -z "$RAT_BI_HOMES" ]
    then
      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
	EMSG="$program_name found OBIEE installation and RAT_BI_HOMES environment variable is not set.\nset RAT_BI_HOMES environment variable to comma separated list of BI homes installed on this system and re-run $program_name.\nlike export RAT_BI_HOMES=\"/u01/oracle/BIMachine,/u02/oracle/BIMachine\""
	update_probe_xml "ERROR" "GENERIC" "$EMSG"
      fi
      echo -e "${RED}\n$program_name found OBIEE installation and RAT_BI_HOMES environment variable is not set.\n${NORM}"
      echo -e "${RED}\nset RAT_BI_HOMES environment variable to comma separated list of BI homes installed on this system and re-run $program_name.\n${NORM}"
      echo -e "${RED}\nlike export RAT_BI_HOMES=\"/u01/oracle/BIMachine,/u02/oracle/BIMachine\"\n${NORM}"
      exit 1
    else      
      log_env_varaibles "RAT_BI_HOMES" "$RAT_BI_HOMES" "1"
      for mb_db_home in $RAT_BI_HOMES
      do
        bi_home_all_instances=""
        if [ -e "$mb_db_home/instances" ] 
        then 
          if [ -e "$mb_db_home/Oracle_BI1/bifoundation/version.txt" ]
          then
            bi_home_version=$(grep -i 'Release Version: Oracle Business Intelligence' "$mb_db_home/Oracle_BI1/bifoundation/version.txt"|sed 's/Release Version: Oracle Business Intelligence//g'|sed 's/ //g')
            echo "OBIEE Release Version: $mb_db_home = $bi_home_version" >> $MASTERFIL 
          fi
          if [ -d "$mb_db_home/instances" ]
          then
            for bi_instance in $(ls -l "$mb_db_home/instances"|grep ^d|awk '{print $NF}')
            do
       	     bi_home_all_instances=$bi_instance","$bi_home_all_instances;
            done	
            bi_home_all_instances=$(echo $bi_home_all_instances|sed 's/,$//g');
            echo "OBIEE_INSTANCE_MAP: $mb_db_home = $bi_home_all_instances" >> $MASTERFIL
          fi
          echo $mb_db_home >>$OUTPUTDIR/mb_db_homes_distinct.out
        else
          echo -e "\n${RED} ${mb_db_home} is not valid path for OBIEE home so skipping for checking best practices\n${NORM}"|tee -a $LOGFIL 
        fi 
      done
    fi
  fi
}

function read_exalytics_bi_env ()
{
  mb_db_counter=0
  for mb_db_home in `if [ -e $OUTPUTDIR/mb_db_homes_distinct.out ]; then cat $OUTPUTDIR/mb_db_homes_distinct.out|sort -u;fi;`
  do
    rdbms_installed[0]=1
    mb_oracle_homes_distinct[$mb_db_counter]=$mb_db_home
    mb_db_counter=$(expr $mb_db_counter + 1)
  done 
  if [ $OFFLINE -eq 0 ]; then echo "$localnode.RDBMS_INSTALLED = ${rdbms_installed[0]}">> $MASTERFIL;fi   
  multiple_oracle_homes=$mb_db_counter
  mb_db_counter=0
}

function discover_ssc_zfs_nodes ()
{
  if [ -n "$RAT_ZFS_NODES" ]
  then
    for zfsname in `echo $RAT_ZFS_NODES`
    do
      echo "$zfsname">>$OUTPUTDIR/zfsip.ora
    done
    ZFSIP=$OUTPUTDIR/zfsip.ora
  else
    #ssc_zfs_appliances=$(cat /etc/hosts|grep sn[1-2]|grep -v ilom|awk '{print $1}'|sed 's/#//g')
    ssc_zfs_appliances=$(grep sn[1-2] /etc/hosts|grep -v ilom|awk '{print $1}'|sed 's/#//g')
    for zfsname in `echo $ssc_zfs_appliances`
    do
      echo "$zfsname">>$OUTPUTDIR/zfsip.ora
    done
    ZFSIP=$OUTPUTDIR/zfsip.ora
  fi
}

function execute_zfs_collection ()
{
  if  [[ $OFFLINE -eq 0 && $zfs_password_status -ne 3 ]]
  then
    if [ -z "$noRootScriptNode" ];then noPasswordAvailable=0;fi
    if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -e $1 ]]  
    then
      #cat $IBSWITCHSCRPT
      #$READ -p "good to run"
      if [ ! -e $CELLDIR ];then mkdir $CELLDIR >/dev/null 2>&1;fi
      cp $1 $CELLDIR 2>/dev/null 2>&1
      
      root_zfs_counter=0
      no_of_cells=$(wc -l $1 |awk '{print $1}'|tr -d ' ')
      no_of_cells=$(expr $no_of_cells - 1);
      in_last_cell=0
      last_cell_name=""
      if [[ ! -n "$RAT_ZFS_RUNMODE" ]] ; then RAT_ZFS_RUNMODE="parallel"; fi;
      for cellname in `cat $1|cut -d= -f2|sed 's/"//g'` 
      do
        #cellPingStatus=$($PING -c 1 $PING_W_FLAG $cellname >/dev/null 2>&1;echo $?)  
 	
        test_node_reachability "$cellname" "$zfs_ssh_user";
	if [ $el_node_ping -eq "1" ] ; then
	  cellPingStatus=0;
	else
	  cellPingStatus=1;
	fi     
        
        #if [[ -n "$cellPingStatus" && $cellPingStatus -eq 0 ]] 
        #then
        #  check_ssh_speed $zfs_ssh_user $cellname
        #  if [[ -n $ssh_go_ahead && $ssh_go_ahead = 0 ]] ; then cellPingStatus=255; fi
        #fi
        if [[ -n "$cellPingStatus" && $cellPingStatus -eq 0 ]]
        then
          noPasswordAvailable=$(echo ${noRootScriptNode[*]}|grep -c $cellname)
          if [[ $no_of_cells -eq $root_zfs_counter ]] ; then last_cell_name=$cellname; in_last_cell=1; fi
          cell_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $zfs_ssh_user $cellname ls >/dev/null 2>&1;echo $?);
          if [ $noPasswordAvailable -eq 0 ]
          then
            if [[ -n "$RAT_ZFS_RUNMODE" && $RAT_ZFS_RUNMODE = "parallel" ]] ; then
              echo -e "\nStarting to run $zfs_ssh_user privileged commands in background on ${BLINK}ZFS Storage Appliance${NORM} $cellname\n"
            else
              echo -e "\nPreparing to run $zfs_ssh_user privileged commands on ${BLINK}ZFS Storage Appliance${NORM} $cellname\n"
            fi
            if [[ -n "$zfs_samerootpassword" && $zfs_samerootpassword -eq 0 ]]
            then 
              zfs_rootpassword=${a_zfs_rootpassword[$root_zfs_counter]}
            fi			      

	    #is_SSH_blocked "$cellname" "$zfs_ssh_user" "$zfs_rootpassword"
	    #if [[ $SSH_blocked -eq 1 ]]; then
            #  echo -e "\n${RED}Skipping $zfs_ssh_user privileged commands on ${BLINK}STORAGE SERVER ${NORM} ${RED} ${cellname} is available but SSH is blocked.${NORM}\n"|tee -a $LOGFIL
            #  add_to_skipped_nodes "${cellname}" "SSH Issue: STORAGE SERVER is reachable but SSH is blocked"
	    #  continue;	
	    #fi

            cell_type="zfscell"
            zfs_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $zfs_ssh_user $cellname ls >/dev/null 2>&1;echo $?);
            if [[ -n "$zfs_ssh_status" && $zfs_ssh_status -ne 0 ]] ; then
              checkUserPassword "$cellname" "$zfs_ssh_user" "$zfs_rootpassword" "1"  "$cell_type"
            else
              passwordCheckStatus=0
            fi
            if [[ $passwordCheckStatus -eq 0 ]]
            then
              #echo "Running on ZFS cell";
              #echo "$cellname = $cellname" >>$CELLDIR/cells.out
              rm -f $RTEMPDIR/zfscell.pid
              cr_name=$RTEMPDIR/${program_name}_${cellname}_cells.sh
              echo "#!/bin/env bash" > $cr_name
              echo "$RAT_DEBUG_FLG" >> $cr_name
              echo "echo \$\$ > $RTEMPDIR/zfscell.pid" >> $cr_name
              #echo "$SSHELL $zfs_ssh_user@$cellname  < $2 > $OUTPUTDIR/${cellname}.exalogic_zfs_checks.out" >> $cr_name
              echo "$SSHELL $zfs_ssh_user@$cellname set session_annotation=\"${program_name}_session\" < $2 > $OUTPUTDIR/${cellname}.exalogic_zfs_checks.out" >> $cr_name
              chmod +x $cr_name
      
	      local_cr_name=$RTEMPDIR/.${program_name}_${cellname}_conf.aksh
	      echo "$SSHELL $zfs_ssh_user@$cellname set session_annotation=\"${program_name}_session\" <<EOF
script printf('\\\\n'); printf('\\\\n%s\\\\n',run('configuration version get product'))
EOF" > $local_cr_name
	      chmod +x $local_cr_name

              fixRootPassword "$zfs_rootpassword"
              #code to verify that its ZFS storage
              zfs_node_config=$($EXPECT -f - << IBEOF
                            set timeout $passwordcheck_timeout
	      		    set le_zfs_password "$fixedRootPassword"
	      		    #log_user 0
                            if { "$RAT_EXPECT_DEBUG" == "-d" } {
                              exp_internal 1
                            } 
	                    spawn -noecho $bash_scr $local_cr_name
	      		    match_max 100000
	      	       	    expect {
	      		      -nocase "permission denied *" {
	      		      exit 4;
	      	            }
	      	      	      -nocase "no)?" {
	      		      send -- "yes\n"
	      	            }
	      	              -nocase "*?assword:*" {
	      		      send -- "\$le_zfs_password\n"
	      	            }
	      	      	      -nocase eof {
	      		      exit
	      	            }
	      	    	    }
	      	    	    # Look for passwd prompt
	      	    	    expect {
	      	    	      -nocase "*?assword:*" {
	      	    	        send -- "\$le_zfs_password\n"
	      	    	      }
	      	    	      # Stop the on logon tests and if asked to connect to master switch choose no
	      	    	      -nocase eof {
	      	    	        exit
	      	    	      } -nocase timeout {
	      	    	        send_error "Timed out while running imageinfo command on $cellname\n";
	      	    	        exit
	      	    	      }
	      	    	    }
	      	    	    expect -nocase eof
IBEOF
)
              #zfs_node_config_valid=$(echo "$zfs_node_config"|grep -wc "ZFS Storage")   
              zfs_node_config_valid=$(echo "$zfs_node_config"|grep -vwi 'session_annotation'|grep -wc "ZFS Storage")   
   	      #code to verify that its zfs storage ends here
              if [ $zfs_node_config_valid -ge 1 ]
              then
	        if [ -z "$RAT_ZFS_ROOT_TIMEOUT" ]; then
	          #Default is 20mins
	          zfs_wakeup_root=1200
	        else
	          zfs_wakeup_root=$RAT_ZFS_ROOT_TIMEOUT
	        fi

	        $EXPECT -f - << IBEOF &
	         set timeout $passwordcheck_timeout
	         set le_zfs_rootpassword "$fixedRootPassword"
	         log_user 0
	         if { "$RAT_EXPECT_DEBUG" == "-d" } {
	           exp_internal 1
	         }
	         spawn $cr_name
	         match_max 100000
	           expect {
	         -nocase "permission denied *" {
	           exit 4;
	         }
	         -nocase "no)?" {
	           send -- "yes\n"
	         }
	         -nocase "*?assword:*" {
	           send -- "\$le_zfs_rootpassword\n"
	         }
	         -nocase eof {
	           exit
	         }
	         }
	         # Look for passwd prompt
	         expect -nocase "*?assword:*"
	         send -- "\$le_zfs_rootpassword\n"
	         #set timeout $watchdog_wakeup_root
	         set timeout $zfs_wakeup_root
	         expect { 
	           -nocase eof {
	              exit
	           } 
	           -nocase timeout {
	              send_error "\nTimed out while running collections on $cellname\n";
	              exit
	           }	
	         }
IBEOF
	        sleep 2 # Wait till pid file gets created
	        zcell_pid=$(cat $RTEMPDIR/zfscell.pid)
	        if [ -n "$zcell_pid" ]
	        then # wait till we finish collection running on cell
	          #Not in control of watchdog.
	          touch $RTEMPDIR/nowatch.pid
	          echo "$zcell_pid" >>  $RTEMPDIR/nowatch.pid
	          if [[ -n "$RAT_ZFS_RUNMODE" && $RAT_ZFS_RUNMODE = "parallel" ]] ; then
	            cell_pids[$zcell_pid]="$zcell_pid";
	            cell_pid_names[$zcell_pid]="$cellname"
	            cell_root_password[$zcell_pid]="$cell_rootpassword"
	          else
	            keep_looping=1
	            while [ $keep_looping -eq "1" ]
	            do
	              if [ `ps -ef | grep _cells.sh |grep -c $zcell_pid` -gt 0 ]
	              then
	                if [[ -n "$RAT_GLOBAL_RUNMODE" && $RAT_GLOBAL_RUNMODE = "serial" ]] ;
	                then
	                  printf ". "
	                fi
	              else
	                break
	              fi
	              sleep 2
	            done
	          fi
	        fi 
              else
                echo -e "\n${RED}Skipping $zfs_ssh_user privileged commands on ${BLINK}STORAGE SERVER ${NORM} ${RED} ${cellname} because its not valid Sun ZFS Storage .${NORM}\n"|tee -a $LOGFIL
                add_to_skipped_nodes "${cellname}" "Not valid Sun ZFS Storage" 
                grep -vw "$cellname" $1 > $CELLDIR/cellip.ora.bk
                mv $CELLDIR/cellip.ora.bk $1
              fi # end of if [ $zfs_node_config_valid -ge 1 ]
	    fi   # end of if [[ $passwordCheckStatus -eq 0 ]] 
	  else
	    echo -e "\n\n${RED}Skipping ${userToCheck} privileged checks for ${nodeNameToCheck}.\nThe $userToCheck password must have been changed since the passwords were validated at the beginning of tool execution ${NORM}\n"|tee -a $LOGFIL  
	  fi #end of if [ $noPasswordAvailable -eq 0 ]
	  if [[ -e $CELLDIR/c_root_collect_timing.out && -e $COLLECT_TIMING ]]
	  then
	    cat $CELLDIR/c_root_collect_timing.out >> $COLLECT_TIMING
	    rm -f $CELLDIR/c_root_collect_timing.out  >/dev/null 2>&1
	  fi
        else 
	  if [[ $ssh_go_ahead = 0 ]]
	  then
	    echo -e "\n${RED}Skipping $zfs_ssh_user privileged commands on ${BLINK}STORAGE SERVER ${NORM} ${RED} ${cellname} is available but ssh took too long.${NORM}\n"|tee -a $LOGFIL
	    add_to_skipped_nodes "${cellname}" "Network latency issue: Storage Server is pingable but ssh took too long"
	  else
	    echo -e "\n${RED}Skipping $zfs_ssh_user privileged commands on ${BLINK}STORAGE SERVER ${NORM} ${RED} ${cellname} because its not available.${NORM}\n"|tee -a $LOGFIL
	    add_to_skipped_nodes "${cellname}" "Storage Server is not available"
	  fi
        fi  #end of cellPingStatus
        root_zfs_counter=$(expr $root_zfs_counter + 1)
      done
      if [[ -n "$RAT_ZFS_RUNMODE" && $RAT_ZFS_RUNMODE = "parallel" ]] && [[ -n "$RAT_GLOBAL_RUNMODE" && $RAT_GLOBAL_RUNMODE = "serial" ]] ; then 
        wait_for_cell_completion;
      fi
    fi
    #if [ -e $CELLDIR/cells.out ]; then cp $CELLDIR/cells.out $RTEMPDIR >/dev/null 2>&1;fi
    root_zfs_counter=0 
    echo -e "\n\n"
  fi 
}

#function to discover mixed hardware cells
mixed_hardware_cells_discovery ()
{
  if [ $OFFLINE -eq 0 ]
  then
      for mixedCellFil in $(ls $CELLDIR/*CellMakeModel*report.out 2>/dev/null)
      do
      	cellHardwareTypeV2=$(grep -wci "SUN FIRE X4275" $mixedCellFil)
	cellHardwareTypeX22=$(grep -wci "SUN FIRE X4[1-2]70 M2" $mixedCellFil)
	cellHardwareTypeX23=$(grep -wci "SUN FIRE X4[1-2]70 M3" $mixedCellFil)
	cellHardwareTypeX24=$(grep -ci "SUN SERVER X4-2" $mixedCellFil)	
	cellHardwareTypeX25=$(grep -ci "ORACLE SERVER X5-2" $mixedCellFil)	
        #Dom0 then get cell name from file name otherwise get ip address 
        if [[ $is_exadata_dom0_machine -eq 1 || $is_ssc_globalzone_machine -eq 1 ]]
        then
            hardwareTypecellName=$(basename $mixedCellFil|$AWK 'BEGIN { FS = "_" } {print $4}')
        else
            hardwareTypecellName=$(basename $mixedCellFil|$AWK 'BEGIN { FS = "_" } {printf $4"."$5"."$6"."$7}')
        fi 
        if [ $cellHardwareTypeV2 -ge 1 ];then  echo "${hardwareTypecellName}.COMPONENTS = V2">>$MASTERFIL;cellHardwareType="EXADATA";fi
        if [ $cellHardwareTypeX22 -ge 1 ];then  echo "${hardwareTypecellName}.COMPONENTS = X2-2">>$MASTERFIL;cellHardwareType="X2";fi
        if [ $cellHardwareTypeX23 -ge 1 ];then  echo "${hardwareTypecellName}.COMPONENTS = X3-2">>$MASTERFIL;cellHardwareType="X3";fi
        if [ $cellHardwareTypeX24 -ge 1 ];then  echo "${hardwareTypecellName}.COMPONENTS = X4-2">>$MASTERFIL;cellHardwareType="X4";fi
        if [ $cellHardwareTypeX25 -ge 1 ];then  echo "${hardwareTypecellName}.COMPONENTS = X5-2">>$MASTERFIL;cellHardwareType="X5";fi
      done
  fi
  #$READ -p "change files in $CELLDIR" 
  mixed_hardware=0
  if [ -e $CELLDIR ]; then  mixed_hardware=$(find $CELLDIR -name '*CellMakeModel*report.out' -exec md5sum {} \;|awk '{print $1}'|sort -u|wc -l|sed 's/ //g');fi
  #If all cells are same type than checking local compute node type to make sure its same hardware and if not then making it mixed hardware type
  if [ $mixed_hardware -lt 2 ];then if [[ -n "$cellHardwareType" ]]; then cellComputeMatch=$(echo "$components" |grep -ic "$cellHardwareType"); fi; fi 
  #if [[ -n "$cellComputeMatch" && $cellComputeMatch -eq 0 ]]; then mixed_hardware=2;fi
  if [[ -n "$cellComputeMatch" && $cellComputeMatch -eq 0 && `echo "$components"|grep -icw "AVM"` -eq 0 ]]; then mixed_hardware=2;fi
  if [[ $mixed_hardware -gt 1 ]]
  then
    for mixedCellFil in $(ls $CELLDIR/*CellMakeModel*report.out 2>/dev/null)
    do
      #mixed_hardware_v2=$(cat $mixedCellFil|grep -wci "SUN FIRE X4275")
      mixed_hardware_v2=$(grep -wci "SUN FIRE X4275" $mixedCellFil)
      if [ $mixed_hardware_v2 -ge 1 ]; then break;fi
    done
    for mixedCellFil in $(ls $CELLDIR/*CellMakeModel*report.out 2>/dev/null)
    do
      #mixed_hardware_x2_2=$(cat $mixedCellFil|grep -wci "SUN FIRE X4[1-2]70 M2")
      mixed_hardware_x2_2=$(grep -wci "SUN FIRE X4[1-2]70 M2" $mixedCellFil)
      if [ $mixed_hardware_x2_2 -ge 1 ]; then break;fi
    done
    for mixedCellFil in $(ls $CELLDIR/*CellMakeModel*report.out 2>/dev/null)
    do
      #mixed_hardware_x3_2=$(cat $mixedCellFil|grep -wci "SUN FIRE X4[1-2]70 M3")
      mixed_hardware_x3_2=$(grep -wci "SUN FIRE X4[1-2]70 M3" $mixedCellFil)
      if [ $mixed_hardware_x3_2 -ge 1 ]; then break;fi
    done
    for mixedCellFil in $(ls $CELLDIR/*CellMakeModel*report.out 2>/dev/null)
    do
      #mixed_hardware_x4_2=$(cat $mixedCellFil|grep -ci "SUN SERVER X4-2")
      mixed_hardware_x4_2=$(grep -ci "SUN SERVER X4-2" $mixedCellFil)
      if [ $mixed_hardware_x4_2 -ge 1 ]; then break;fi
    done
    for mixedCellFil in $(ls $CELLDIR/*CellMakeModel*report.out 2>/dev/null)
    do
      #mixed_hardware_x4_2=$(cat $mixedCellFil|grep -ci "SUN SERVER X4-2")
      mixed_hardware_x5_2=$(grep -ci "ORACLE SERVER X5-2" $mixedCellFil)
      if [ $mixed_hardware_x5_2 -ge 1 ]; then break;fi
    done
 
  fi
  if [ $OFFLINE -eq 0 ];then
      echo -e "\nmixed hardware status = $mixed_hardware mixed_hardware_v2=$mixed_hardware_v2 mixed_hardware_x2_2=$mixed_hardware_x2_2 mixed_hardware_x3_2=$mixed_hardware_x3_2 mixed_hardware_x4_2=$mixed_hardware_x4_2 \n mixed_hardware_x5_2=$mixed_hardware_x5_2\n">>$LOGFIL
  fi
}

function set_root_all_prompt ()
{
  return
  if [ $userid -eq 0 ] ; then return; fi
  if [ -e "$EXPECT" ] ; then
    echo
    echo
    exec 3<&2; exec 2<&0
    read -p  "Is ${root_user} password same on all components?[y/n][y]" samerootpassword_YesNo
    exec 2<&3
    process_prompt "$read_code" "samerootpassword_YesNo" "y"

    if [ -z "$samerootpassword_YesNo" ] ; then samerootpassword_YesNo="y"; fi
    case $samerootpassword_YesNo in
    y|Y|Yes|YES|yes)
      echo -e "\n"
      printf  "Enter ${root_user} password for components :- "
      tty -s && stty -echo
      $READ -r global_root_password
      tty -s && stty echo
      echo
      echo
      root_hostname=$(cat $HOSTLIST|head -1)
      checkUserPassword "$root_hostname" "${root_user}" "$global_root_password" "3"
      if [ $passwordCheckStatus -eq 0 ]
      then
        root_all_prompt=1
        global_root_password="$passwordToCheck"
      fi
    esac
  fi
}

function submit_client_run ()
{
  # Set all RAT_ env in client run
  rm -f $RTEMPDIR_D/setenv.sh
  env | grep RAT_ | grep -v RAT_EXPECT_DEBUG | grep -v RAT_EXPECT_STRACE_DEBUG  > $RTEMPDIR_D/rat_env.txt
  while read envs
  do
    e_key=$(echo $envs| cut -d"=" -f1)
    e_val=$(echo $envs| sed 's/[^=]*=//')
    echo "export $e_key=\"$e_val\"" >> $RTEMPDIR_D/setenv.sh
  done < $RTEMPDIR_D/rat_env.txt

  echo $argsaved > $RTEMPDIR_D/commands
  touch $RTEMPDIR_D/run.log

  keep_looping=0
  while [ $keep_looping -eq "1" ] ; do
    if [ -e "$LOCKFIL" ] ; then
      epid=$(cat $LOCKFIL)
      keep_looping=0
    fi
    if [ ! -e "$RTEMPDIR_D/run.log" ] ; then keep_looping=0; fi;
    if [ $keep_looping -eq "1" ] ; then sleep 1; fi
  done

  #kill -INT $dpid
  #if [ -n "$epid" ] ; then
  #tail --pid=$epid -f $RTEMPDIR_D/run.log
  mypid=$$
  echo $mypid > $RTEMPDIR_D/client.pid
  tail -f $RTEMPDIR_D/run.log 2>/dev/null
  if [ -e "$RTEMPDIR_D/run_error.log" ] ; then
    cat $RTEMPDIR_D/run_error.log; rm -f $RTEMPDIR_D/run_error.log
  fi
  # | while read line; do
    #if [[ `echo "$line" | grep -c "UPLOAD.if required"` -eq "0" ]] ; then
    #  echo "$line"
    #else
    #  echo "$line"
    #  exit
    #fi
  #done
  #fi
  exit;
}

function stop_daemon_client ()
{
  if [ -e "$RTEMPDIR_D/client.pid" ] ; then
    #user run...
    cpid=$(cat $RTEMPDIR_D/client.pid)
  elif [ -e "$RTEMPDIR_D/run.pid" ] ; then
    #auto run...
    cpid=$(cat $RTEMPDIR_D/run.pid)
  fi

  if [ -n "$cpid" ] ; then 
    if [[ `ps -ef |grep -w "$cpid"| grep -v grep|wc -l` -gt "0" ]] ; then
      tpid=$(ps -ef |grep -w $cpid|grep tail |grep -v grep |awk '{print $2}')
      if [ -n "$tpid" ] ; then
        killsub $tpid >/dev/null 2>&1
      else
        killtree $cpid 9 >/dev/null 2>&1
      fi
    fi
 
    if [ -e "$RTEMPDIR_D/commands" ]; then rm $RTEMPDIR_D/commands >/dev/null 2>&1; fi;
    if [ -e $LOCKFIL ]; then rm $LOCKFIL >/dev/null 2>&1; fi;

    cleanup_client

    echo
    echo "client run on daemon is successfully stopped."
    echo
    log_daemon "client run on daemon is stopped on user request"
  else
    echo -e "No daemon client is running."
  fi
}

function stop_daemon_actual ()
{
  dpid=$(cat $RTEMPDIR_D/daemon.pid)
  kill -15 $dpid 2>/dev/null
  stopped=0;
  while [[ $stopped -eq "0" ]] ; do
    if [[ `ps -ef | grep -w $dpid | grep -v grep | wc -l` -eq "0" ]] ; then
      stopped=1;
    else
      printf ". ";
      sleep 1;
    fi
  done

  rm -rf $RTEMPDIR_D
  rm -rf $DAEMONFIL

  echo
  echo
  echo "Stopped."
  echo
  log_daemon "Daemon is stopped on user request"
  exit;
}

function stop_daemon ()
{
  #log_daemon "Stopping daemon as the $1 password is changed on $2 after daemon was started"
  #send_email "${program_name} daemon was stopped" "Stopping daemon as the $1 password is changed on $2 after daemon was started. Please restart the daemon."

  log_daemon "Stopping daemon as the $1 password could not be authenticated on $2 after daemon was started"
  send_email "${program_name} daemon was stopped" "Stopping daemon as the $1 password could not be authenticated on $2 after daemon was started. Please restart the daemon." "0" "all"
  touch $RTEMPDIR_D/stop
}

function set_date_vars ()
{
  t_yr=$(echo $1 | cut -d":" -f1)
  t_yr=$(expr $t_yr + 0)

  t_mm=$(echo $1 | cut -d":" -f2)
  t_mm=$(expr $t_mm + 0)

  t_dd=$(echo $1 | cut -d":" -f3)
  t_dd=$(expr $t_dd + 0)

  t_hh=$(echo $1 | cut -d":" -f4)
  t_hh=$(expr $t_hh + 0)

  t_mi=$(echo $1 | cut -d":" -f5)
  t_mi=$(expr $t_mi + 0)

  t_ss=$(echo $1 | cut -d":" -f6)
  t_ss=$(expr $t_ss + 0)

  t_dn=$(echo $1 | cut -d":" -f7)
  t_dn=$(expr $t_dn + 0)

  set_t_day
}

function set_t_day ()
{
  case "$t_dn" in
    0) t_day="sun";;
    1) t_day="mon";;
    2) t_day="tue";;
    3) t_day="wed";;
    4) t_day="thu";;
    5) t_day="fri";;
    6) t_day="sat";;
  esac
}

function convert_in_epoch 
{
  autorun_type=$1
  autorun_value=$2
  
  d_start_time=$(cat $RTEMPDIR_D/daemon_start_time|sed 's/^\s*//g'|sed 's/\s*$//g')
  if [ ! -e "$RTEMPDIR_D/last_autorun_time" ] ; then
    echo "ID=>${autorun_ids} - $d_start_time" > $RTEMPDIR_D/last_autorun_time
  else
    #if [[ `cat "$RTEMPDIR_D/last_autorun_time"|grep -c "^ID=>"` -eq 0 ]]; then
    if [[ `grep -c "^ID=>" "$RTEMPDIR_D/last_autorun_time"` -eq 0 ]]; then
      la_start_time=$(cat $RTEMPDIR_D/last_autorun_time|sed 's/^\s*//g'|sed 's/\s*$//g')
      rm -f $RTEMPDIR_D/last_autorun_time
      echo "ID=>${autorun_ids} - $la_start_time" > $RTEMPDIR_D/last_autorun_time
    else 
      #if [[ `cat "$RTEMPDIR_D/last_autorun_time"|grep -c "^ID=>${autorun_ids} -"` -eq 0 ]]; then
      if [[ `grep -c "^ID=>${autorun_ids} -" "$RTEMPDIR_D/last_autorun_time"` -eq 0 ]]; then
        echo "ID=>${autorun_ids} - $d_start_time" >> $RTEMPDIR_D/last_autorun_time
      fi
    fi
  fi

  #dlast=$(cat $RTEMPDIR_D/last_autorun_time|grep "^ID=>${autorun_ids} -"|cut -d'-' -f2|sed 's/^\s*//g'|sed 's/\s*$//g')
  dlast=$(grep "^ID=>${autorun_ids} -" $RTEMPDIR_D/last_autorun_time|cut -d'-' -f2|sed 's/^\s*//g'|sed 's/\s*$//g')

  #if [ ! -e "$RTEMPDIR_D/last_autorun_time" ] ; then
  #  cp $RTEMPDIR_D/daemon_start_time $RTEMPDIR_D/last_autorun_time
  #fi
  #dlast=$(cat $RTEMPDIR_D/last_autorun_time)

  set_date_vars $dlast
  epoch_last=$(perl -e 'use Time::Local;print timelocal('$t_ss','$t_mi','$t_hh','$t_dd','$t_mm'-1,'$t_yr');')

  if [[ -n $autorun_type && $autorun_type = "AUTORUN_INTERVAL" ]]; then
    auto_interval_in_mins=$(expr $autorun_value \* 60)
    auto_interval_in_secs=$(expr $auto_interval_in_mins \* 60)
 
    next_epoch=$(expr $epoch_last + $auto_interval_in_secs)

  elif [[ -n $autorun_type && $autorun_type = "AUTORUN_SCHEDULE" ]]; then
    autorun_hrs=`echo "$p_conf_value"| awk '{print $1}'`;
    if [[ "$autorun_hrs" = "*" ]]; then autorun_hrs="0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23"; fi

    autorun_dte=`echo "$p_conf_value"| awk '{print $2}'`;
    if [[ "$autorun_dte" = "*" ]]; then autorun_dte="1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"; fi

    autorun_mon=`echo "$p_conf_value"| awk '{print $3}'`;
    if [[ "$autorun_mon" = "*" ]]; then autorun_mon="1,2,3,4,5,6,7,8,9,10,11,12"; fi

    autorun_day=`echo "$p_conf_value"| awk '{print $4}'`;
    if [[ "$autorun_day" = "*" ]]; then autorun_day="0,1,2,3,4,5,6"; fi

    old_ifs=$IFS
    IFS=","

    year=$t_yr
    year_limit=$(expr $year + 10)
    br_out_loop=0

    while [[ $year -le $year_limit ]]
    do
      sameYear=0; if [[ $curDateYear -eq $year ]]; then sameYear=1; fi

      leap_year=0
      if [ `expr $year % 4` -eq 0 ]; then leap_year=1; fi

      for t_months in $(echo "$autorun_mon")
      do
	sameMonth=0; if [[ $curDateMonth -eq $t_months ]]; then sameMonth=1; fi
	if [[ $sameYear -eq "1" && $t_months -lt $curDateMonth ]]; then continue; fi

        t_autorun_dte=$autorun_dte
        if [[ $t_months -eq 2 ]]; then
          t_autorun_dte=$(echo "$autorun_dte"|sed 's/,*31//g'|sed 's/,*30//g'|sed 's/,*29//g')
          if [[ $leap_year -eq 1 ]]; then
            t_autorun_dte=$(echo "$autorun_dte"|sed 's/,*31//g'|sed 's/,*30//g');
          fi
	else
	  if [[ $t_months -eq 4 || $t_months -eq 6 || $t_months -eq 9 || $t_months -eq 11 ]]; then	
	    t_autorun_dte=$(echo "$autorun_dte"|sed 's/,*31//g');
	  fi
        fi

        br_out_loop=0;
        month=$t_months;

        for t_days in $(echo "$t_autorun_dte")
        do
	  sameDay=0; if [[ $curDateDay -eq $t_days ]]; then sameDay=1; fi
	  if [[ $sameYear -eq "1" && $sameMonth -eq "1" && $t_days -lt $curDateDay ]]; then continue; fi

          day=$t_days;

          for t_hours in $(echo "$autorun_hrs")
          do
	    sameHour=0; if [[ $curDateHour -eq $t_hours ]]; then sameHour=1; fi
	    if [[ $sameYear -eq "1" && $sameMonth -eq "1" && $sameDay -eq "1" && $t_hours -lt $curDateHour ]]; then continue; fi

            hour=$t_hours;
            next_epoch=$(perl -e 'use Time::Local;print timelocal(00,00,'$hour','$day','$month'-1,'$year');')

            pos_diff=$(expr $next_epoch - $epoch_last)

            compare_values=1
            if [[ $hour -eq $t_hh ]]; then
              if [[ $day -ne $t_dd ]]; then
                compare_values=1
              else
                if [[ $year -ne $t_yr ]]; then
                  compare_values=1
                else
                  compare_values=0
                fi
              fi
            fi
            if [[ $pos_diff -ge 0 ]] && [[ $compare_values -eq "1" ]]; then
              week_day=$(perl -e 'use Time::Local; my @months = ("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"); my($wday)=(localtime('$next_epoch'))[6];print $wday;');
              for week_day_list in $(echo "$autorun_day")
              do
                if [[ $week_day_list = $week_day ]]; then
                  br_out_loop=1
                  break;
                fi
              done
            fi
            if [[ $br_out_loop = 1 ]]; then break; fi
          done
          if [[ $br_out_loop = 1 ]]; then break; fi
        done
        if [[ $br_out_loop = 1 ]]; then break; fi
      done
      year=$(expr $year + 1)
      if [[ $br_out_loop = 1 ]]; then break; fi
    done
    IFS="$old_ifs"
  fi

  ar_epoch_value=$next_epoch
}

function check_multiple_autoruns
{
  display_nar="$1"

  if [[ -n "$setting_autorun_id" && $setting_autorun_id -eq "1" ]] && [[ -n $display_nar && $display_nar -eq "1" ]]; then	  
    if [[ -f "$p_conf_file" ]]; then
      #is_id_exist=$(cat "$p_conf_file" | grep -c "^\s*@${autorun_id}_START\s*$" | sed 's/ //g')
      is_id_exist=$(grep -c "^\s*@${autorun_id}_START\s*$" "$p_conf_file" | sed 's/ //g')
      if [[ $is_id_exist -eq "0" ]]; then
        echo
        echo -e "${RED}Specified ID[${autorun_id}] doesn't exist.${NORM}"
        echo
        exit 1
      fi
    fi
  fi

  if [[ -f "$p_conf_file" ]]; then
    store_p_conf_file="$p_conf_file"

    get_dnow
    #numids=$(cat "$p_conf_file" | grep -c "^\s*@.*_START\s*$" | sed 's/ //g')
    numids=$(grep -c "^\s*@.*_START\s*$" "$p_conf_file" | sed 's/ //g')
    
    if [[ $numids -gt 0 ]]; then
      id_counter=0
  	
      #for autorun_ids in `cat "$p_conf_file" | grep -w "^\s*@.*_START\s*$" | sed 's/_START//g' | sed 's/^\s*@//g'`
      for autorun_ids in `grep "^\s*@.*_START\s*$" "$p_conf_file" | sed 's/_START//g' | sed 's/^\s*@//g'`
      do
        if [[ -n "$setting_autorun_id" && $setting_autorun_id -eq "1" ]] && [[ -n $display_nar && $display_nar -eq "1" ]]; then
          if [[ $autorun_ids != $autorun_id ]]; then
	    continue;
	  fi
        fi
        
        sed -n "/^@${autorun_ids}_START$/,/^@${autorun_ids}_END$/p" "$p_conf_file" > "$p_conf_file.tmp"
      
        swap_p_conf_file "$p_conf_file.tmp"
        if [[ `grep -ic "AUTORUN_INTERVAL" $p_conf_file` -gt "0" ]] ; then
          read_conf "AUTORUN_INTERVAL"
      	
          if [[ $p_conf_value -eq "0" ]] ; then continue; fi
      	
          convert_in_epoch "AUTORUN_INTERVAL" "$p_conf_value"
        elif [[ -f "$p_conf_file" && `grep -ic "AUTORUN_SCHEDULE" $p_conf_file` -gt "0" ]] ; then
          read_conf "AUTORUN_SCHEDULE"
          convert_in_epoch "AUTORUN_SCHEDULE" "$p_conf_value"
        fi	   
        schedules_values[$id_counter]="$ar_epoch_value"
        schedules_ids[$id_counter]="$autorun_ids"
      
        id_counter=$(expr $id_counter + 1)
  
	rm -f $p_conf_file >/dev/null 2>&1;
        swap_p_conf_file "$store_p_conf_file"
      done

      id_counter=0
      r_id_counter=0
      smallest_epoch=${schedules_values[0]}
      for schedules in "${schedules_values[@]}"
      do
        if [[ $schedules -lt $smallest_epoch ]]; then
	  smallest_epoch=$schedules
   	  r_id_counter=$id_counter
        fi
	id_counter=$(expr $id_counter + 1)
      done

      if [[ -n $display_nar && $display_nar -eq "1" ]] ; then
        echo 
        echo "ID: ${schedules_ids[$r_id_counter]} "

        echo
        sed -n "/^@${schedules_ids[$r_id_counter]}_START$/,/^@${schedules_ids[$r_id_counter]}_END$/p" $p_conf_file|grep 'AUTORUN_SCHEDULE='

        perl -e 'use Time::Local; my @months = ("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"); my ($sec, $min, $hour, $day,$month,$year) = (localtime('$smallest_epoch'))[0,1,2,3,4,5];print "Next auto run starts on ".$months[$month]." ".$day.", ".($year+1900);printf(" %02d:%02d:%02d\n", $hour,$min,$sec);'; 
        echo

        swap_p_conf_file "$store_p_conf_file"
        exit 1
      elif [[ -n $display_nar && $display_nar -eq "0" ]]; then
	sed -n "/^@${schedules_ids[$r_id_counter]}_START$/,/^@${schedules_ids[$r_id_counter]}_END$/p" $p_conf_file > $cur_p_conf_file
        autorun_id=${schedules_ids[$r_id_counter]}      
	swap_p_conf_file "$cur_p_conf_file"
	return 
      fi
    fi
  fi
}

function next_autorun_on ()
{
  curDateYear=$(date '+%Y')
  curDateMonth=$(date '+%m'|sed 's/^0//')
  curDateDay=$(date '+%d'|sed 's/^0//')
  curDateHour=$(date '+%H'|sed 's/^0//')
  curDateMin=$(date '+%H'|sed 's/^0//')

  #Multiple schedules
  check_multiple_autoruns "1" 

  #if [[ -f "$p_conf_file" && `grep -c "AUTORUN_INTERVAL" $p_conf_file` -gt "0" ]] ; then
  if [[ -f "$p_conf_file" && `grep -ic "AUTORUN_INTERVAL" $p_conf_file` -gt "0" ]] ; then
    read_conf "AUTORUN_INTERVAL"
    if [[ $p_conf_value -eq "0" ]] ; then 
      echo
      echo -e "${RED}Auto run is not configured. Please use ${program_name} -set AUTORUN_INTERVAL=<n[h|d]> to enable auto run.${NORM}"
      echo
      return;
    fi
    auto_interval_in_mins=$(expr $p_conf_value \* 60)
    auto_interval_in_secs=$(expr $auto_interval_in_mins \* 60)
  #elif [[ -f "$p_conf_file" && `grep -c "AUTORUN_SCHEDULE" $p_conf_file` -gt "0" ]] ; then
  elif [[ -f "$p_conf_file" && `grep -ic "AUTORUN_SCHEDULE" $p_conf_file` -gt "0" ]] ; then
    read_conf "AUTORUN_SCHEDULE"
    if [[ -z "$p_conf_value" ]] ; then
      echo
      echo -e "${RED}Auto run is not configured. Please use ${program_name} -set AUTORUN_INTERVAL=<n[h|d]> to enable auto run.${NORM}"
      echo
      return;
    fi
    echo "AUTORUN_SCHEDULE = $p_conf_value"

    get_dnow
    if [ ! -e "$RTEMPDIR_D/last_autorun_time" ] ; then
      d_start_time=$(cat $RTEMPDIR_D/daemon_start_time|sed 's/^\s*//g'|sed 's/\s*$//g')
      echo "ID=>${autorun_id} - $d_start_time" > $RTEMPDIR_D/last_autorun_time

      #cp $RTEMPDIR_D/daemon_start_time $RTEMPDIR_D/last_autorun_time
    else
      la_start_time=$(cat $RTEMPDIR_D/last_autorun_time|sed 's/^\s*//g'|sed 's/\s*$//g')      
      rm -f $RTEMPDIR_D/last_autorun_time
      echo "ID=>${autorun_id} - $la_start_time" > $RTEMPDIR_D/last_autorun_time
    fi

    dlast=$(cat $RTEMPDIR_D/last_autorun_time|cut -d'-' -f2|sed 's/^\s*//g'|sed 's/\s*$//g')
    #dlast=$(cat $RTEMPDIR_D/last_autorun_time)

    set_date_vars $dlast
    epoch_last=$(perl -e 'use Time::Local;print timelocal('$t_ss','$t_mi','$t_hh','$t_dd','$t_mm'-1,'$t_yr');')

    autorun_hrs=`echo "$p_conf_value"| awk '{print $1}'`;
    if [[ "$autorun_hrs" = "*" ]]; then autorun_hrs="0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23"; fi
    
    autorun_dte=`echo "$p_conf_value"| awk '{print $2}'`;
    if [[ "$autorun_dte" = "*" ]]; then autorun_dte="1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"; fi
    
    autorun_mon=`echo "$p_conf_value"| awk '{print $3}'`;
    if [[ "$autorun_mon" = "*" ]]; then autorun_mon="1,2,3,4,5,6,7,8,9,10,11,12"; fi
    
    autorun_day=`echo "$p_conf_value"| awk '{print $4}'`;
    if [[ "$autorun_day" = "*" ]]; then autorun_day="0,1,2,3,4,5,6"; fi
    
    old_ifs=$IFS
    IFS=","
    
    year=$t_yr
    year_limit=$(expr $year + 10)
    br_out_loop=0

    while [[ $year -le $year_limit ]]
    do
      sameYear=0; if [[ $curDateYear -eq $year ]]; then sameYear=1; fi

      leap_year=0
      if [ `expr $year % 4` -eq 0 ]; then leap_year=1; fi
    
      for t_months in $(echo "$autorun_mon")
      do
	sameMonth=0; if [[ $curDateMonth -eq $t_months ]]; then sameMonth=1; fi
	if [[ $sameYear -eq "1" && $t_months -lt $curDateMonth ]]; then continue; fi

        t_autorun_dte=$autorun_dte
        if [[ $t_months -eq 2 ]]; then
          t_autorun_dte=$(echo "$autorun_dte"|sed 's/,*31//g'|sed 's/,*30//g'|sed 's/,*29//g')
          if [[ $leap_year -eq 1 ]]; then
            t_autorun_dte=$(echo "$autorun_dte"|sed 's/,*31//g'|sed 's/,*30//g');
          fi
	else
	  if [[ $t_months -eq 4 || $t_months -eq 6 || $t_months -eq 9 || $t_months -eq 11 ]]; then	
	    t_autorun_dte=$(echo "$autorun_dte"|sed 's/,*31//g');
	  fi
        fi
    
        br_out_loop=0;
        month=$t_months;
    
        for t_days in $(echo "$t_autorun_dte")
        do
          sameDay=0; if [[ $curDateDay -eq $t_days ]]; then sameDay=1; fi
	  if [[ $sameYear -eq "1" && $sameMonth -eq "1" && $t_days -lt $curDateDay ]]; then continue; fi

          day=$t_days;
    
          for t_hours in $(echo "$autorun_hrs")
          do
	    sameHour=0; if [[ $curDateHour -eq $t_hours ]]; then sameHour=1; fi
	    if [[ $sameYear -eq "1" && $sameMonth -eq "1" && $sameDay -eq "1" && $t_hours -lt $curDateHour ]]; then continue; fi

            hour=$t_hours;
            next_epoch=$(perl -e 'use Time::Local;print timelocal(00,00,'$hour','$day','$month'-1,'$year');')
    
            pos_diff=$(expr $next_epoch - $epoch_last)

	    compare_values=1
	    if [[ $hour -eq $t_hh ]]; then
	      if [[ $day -ne $t_dd ]]; then
	  	compare_values=1
	      else
		if [[ $year -ne $t_yr ]]; then
		  compare_values=1
		else
		  compare_values=0
		fi
              fi
            fi

            if [[ $pos_diff -ge 0 ]] && [[ $compare_values -eq "1" ]]; then
   	      week_day=$(perl -e 'use Time::Local; my @months = ("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"); my($wday)=(localtime('$next_epoch'))[6];print $wday;');
 
              for week_day_list in $(echo "$autorun_day")
              do
                if [[ $week_day_list = $week_day ]]; then
		  echo -e ""
                  #perl -e 'use Time::Local; my @months = ("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"); my ($sec, $min, $hour, $day,$month,$year) = (localtime('$next_epoch'))[0,1,2,3,4,5];print "Next auto run starts on ".$months[$month]." ".$day.", ".($year+1900); print " ".$hour.":".$min.":".$sec."\n";';
                  perl -e 'use Time::Local; my @months = ("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"); my ($sec, $min, $hour, $day,$month,$year) = (localtime('$next_epoch'))[0,1,2,3,4,5];print "Next auto run starts on ".$months[$month]." ".$day.", ".($year+1900);printf(" %02d:%02d:%02d\n", $hour,$min,$sec);';  
                  br_out_loop=1
                  break;
                fi
              done
            fi
            if [[ $br_out_loop = 1 ]]; then break; fi
          done
          if [[ $br_out_loop = 1 ]]; then break; fi
        done
        if [[ $br_out_loop = 1 ]]; then break; fi
      done
      year=$(expr $year + 1)
      if [[ $br_out_loop = 1 ]]; then break; fi
    done
    IFS="$old_ifs"
    
    if [[ $br_out_loop = "0" ]]; then
      echo -e ""
      echo -e "${RED}AUTORUN_SCHEDULE is not configured properly.${NORM}"
    fi
    echo -e ""
    return
  else
    echo
    echo -e "${RED}Auto run is not configured. Please use ${program_name} -set AUTORUN_INTERVAL=<n[h|d]> to enable auto run.${NORM}"
    echo
    return
  fi

  if [ -z "$auto_interval_in_secs" ] ; then
    auto_interval_in_secs=86400 # Once every day
  fi

  get_dnow

  if [ ! -e "$RTEMPDIR_D/last_autorun_time" ] ; then
    d_start_time=$(cat $RTEMPDIR_D/daemon_start_time|sed 's/^\s*//g'|sed 's/\s*$//g')
    echo "ID=>${autorun_id} - $d_start_time" > $RTEMPDIR_D/last_autorun_time

    #cp $RTEMPDIR_D/daemon_start_time $RTEMPDIR_D/last_autorun_time
  else
    la_start_time=$(cat $RTEMPDIR_D/last_autorun_time|sed 's/^\s*//g'|sed 's/\s*$//g')      
    rm -f $RTEMPDIR_D/last_autorun_time
    echo "ID=>${autorun_id} - $l_start_time" > $RTEMPDIR_D/last_autorun_time
  fi

  dlast=$(cat $RTEMPDIR_D/last_autorun_time|cut -d'-' -f2|sed 's/^\s*//g'|sed 's/\s*$//g')
  #dlast=$(cat $RTEMPDIR_D/last_autorun_time)

  set_date_vars $dnow
  epoch_now=$(perl -e 'use Time::Local;print timelocal('$t_ss','$t_mi','$t_hh','$t_dd','$t_mm'-1,'$t_yr');')
  set_date_vars $dlast
  epoch_last=$(perl -e 'use Time::Local;print timelocal('$t_ss','$t_mi','$t_hh','$t_dd','$t_mm'-1,'$t_yr');')
  next_epoch=$(expr $epoch_last + $auto_interval_in_secs)

  echo
  #perl -e 'use Time::Local; my @months = ("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"); my ($sec, $min, $hour, $day,$month,$year) = (localtime('$next_epoch'))[0,1,2,3,4,5]; print "Next auto run starts on ".$months[$month]." ".$day.", ".($year+1900); print " ".$hour.":".$min.":".$sec."\n";';
  perl -e 'use Time::Local; my @months = ("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"); my ($sec, $min, $hour, $day,$month,$year) = (localtime('$next_epoch'))[0,1,2,3,4,5]; print "Next auto run starts on ".$months[$month]." ".$day.", ".($year+1900);printf(" %02d:%02d:%02d\n", $hour,$min,$sec);';
 
  echo
  #diff_epoch=`expr $next_epoch - $epoch_now` # dif in seconds
  #diff_hr=$(expr $diff_epoch / 3600)
  #echo "Will start a new run in $diff_hr hours"
  #if [[ $diff_hr -gt "24" ]] ; then
  #  diff_day=$(expr $diff_hr / 24)
  #  echo "Will start a new run in $diff_day days"
  #fi
}

function check_val_in_array ()
{
  val2check="$1"
  arr_values="$2"

  val_in_array=0
  if [ ! -n "$arr_values" ] ; then return; fi;

  if [ "$arr_values" = "*" ] ; then
    val_in_array=1;
    return;
  fi

  old_ifs=$IFS
  IFS=","
  for a_val in $arr_values
  do
    if [ -n "$a_val" ] ; then
      a_val_num=$(expr $a_val + 0)
      if [[ "$a_val_num" -eq "$val2check" ]] ; then 
        val_in_array=1
      fi
    fi
  done
  IFS="$old_ifs"

  if [ $val_in_array -eq "0" ] ; then
    if [ -e $cur_p_conf_file ]; then rm -f "$cur_p_conf_file" > /dev/null 2>&1; swap_p_conf_file "$store_p_conf_file"; fi;
  fi
}

#log_daemon "run_client_now=$run_client_now"

function start_auto_run ()
{
  if [ -e "$RTEMPDIR_D/commands" ] ; then return; fi

  OLD_SHELL=$SSHELL
  SSHELL="$SSHELL -o NumberOfPasswordPrompts=0"
  for hname in `cat $RTEMPDIR_D/.hosts.txt`
  do
    if [ $hname = $localnode ]
    then
      if [ -e $LOCKFIL ]
      then
        lockfile_pid_status=$(ps -ef |grep $(cat $LOCKFIL)|grep -v grep|wc -l)
        if [[ -n "$lockfile_pid_status" && $lockfile_pid_status -gt 0 ]]
        then
          log_daemon "Another instance of $program_name is running on $hname. Auto run instance is exiting." 
          return
        fi
      fi
    else
      remote_lock_file=$($SSHELL $hname "$bash_scr -c \"if [ -e $LOCKFIL ]; then cat $LOCKFIL|wc -l;fi\"")
      remote_lockfile_pid=$($SSHELL $hname "$bash_scr -c \"if [ -e $LOCKFIL ]; then cat $LOCKFIL|head -1;fi\"")
      remote_lockfile_pid_status=$($SSHELL $hname "$bash_scr -c \"if [ -e $LOCKFIL ]; then ps -ef |grep $remote_lockfile_pid|grep -v grep|wc -l;fi\"")
      if [[ -n "$remote_lock_file" && $remote_lock_file -eq 1 && -n "$remote_lockfile_pid_status" && $remote_lockfile_pid_status -gt 0 ]]
      then
        log_daemon "Another instance of $program_name is running on $hname.Auto run instance is exiting on $localnode.\n" 
        return
      fi
    fi
  done
  SSHELL=$OLD_SHELL

  curDateYear=$(date '+%Y')
  curDateMonth=$(date '+%m'|sed 's/^0//')
  curDateDay=$(date '+%d'|sed 's/^0//')
  curDateHour=$(date '+%H'|sed 's/^0//')
  curDateMin=$(date '+%H'|sed 's/^0//')

  check_multiple_autoruns "0"

  autorun_mode="none"
  autorun_time="" #mon,tue,wed:0130,1130
  #if [[ -f "$p_conf_file" && `grep -c "AUTORUN_INTERVAL" $p_conf_file` -gt "0" ]] ; then
  if [[ -f "$p_conf_file" && `grep -ic "AUTORUN_INTERVAL" $p_conf_file` -gt "0" ]] ; then
    read_conf "AUTORUN_INTERVAL"
    if [[ $p_conf_value -eq "0" ]] ; then return; fi
    auto_interval_in_mins=$(expr $p_conf_value \* 60)
    auto_interval_in_secs=$(expr $auto_interval_in_mins \* 60)
    autorun_mode="interval"
  #elif [[ -f "$p_conf_file" && `grep -c "AUTORUN_SCHEDULE" $p_conf_file` -gt "0" ]] ; then
  elif [[ -f "$p_conf_file" && `grep -ic "AUTORUN_SCHEDULE" $p_conf_file` -gt "0" ]] ; then
    read_conf "AUTORUN_SCHEDULE"
    if [[ -z "$p_conf_value" ]] ; then return; fi
    autorun_hrs=`echo "$p_conf_value"| awk '{print $1}'`
    autorun_dte=`echo "$p_conf_value"| awk '{print $2}'`
    autorun_mon=`echo "$p_conf_value"| awk '{print $3}'`
    autorun_day=`echo "$p_conf_value"| awk '{print $4}'`
    autorun_mode="time"
  else
    if [ -e $cur_p_conf_file ]; then rm -f "$cur_p_conf_file" > /dev/null 2>&1; swap_p_conf_file "$store_p_conf_file"; fi;
    return
  fi

  if [ -z "$auto_interval_in_secs" ] ; then
    auto_interval_in_secs=86400 # Once every day
  fi

  d_start_time=$(cat $RTEMPDIR_D/daemon_start_time|sed 's/^\s*//g'|sed 's/\s*$//g')
  if [ ! -e "$RTEMPDIR_D/last_autorun_time" ] ; then
    echo "ID=>${autorun_id} - $d_start_time" > $RTEMPDIR_D/last_autorun_time
  else
    #if [[ `cat "$RTEMPDIR_D/last_autorun_time"|grep -c "^ID=>"` -eq 0 ]]; then
    if [[ `grep -c "^ID=>" "$RTEMPDIR_D/last_autorun_time"` -eq 0 ]]; then
      la_start_time=$(cat $RTEMPDIR_D/last_autorun_time|sed 's/^\s*//g'|sed 's/\s*$//g')
      rm -f $RTEMPDIR_D/last_autorun_time
      echo "ID=>${autorun_id} - $la_start_time" > $RTEMPDIR_D/last_autorun_time
    else
      #if [[ `cat "$RTEMPDIR_D/last_autorun_time"|grep -c "^ID=>${autorun_ids} -"` -eq 0 ]]; then
      if [[ `grep -c "^ID=>${autorun_ids} -" "$RTEMPDIR_D/last_autorun_time"` -eq 0 ]]; then
        echo "ID=>${autorun_id} - $d_start_time" >> $RTEMPDIR_D/last_autorun_time
      fi
    fi
  fi

  #if [ ! -e "$RTEMPDIR_D/last_autorun_time" ] ; then # First auto run.
    #if [[ $autorun_mode = "interval" ]] ; then cp $RTEMPDIR_D/daemon_start_time $RTEMPDIR_D/last_autorun_time; 
    #else
    #  touch $RTEMPDIR_D/last_autorun_time
    #fi
    #cp $RTEMPDIR_D/daemon_start_time $RTEMPDIR_D/last_autorun_time;
  #fi

  get_dnow
  if [ -e "$RTEMPDIR_D/last_autorun_time" ] ; then
    #dlast=$(cat $RTEMPDIR_D/last_autorun_time|grep "^ID=>${autorun_id} -"|cut -d'-' -f2|sed 's/^\s*//g'|sed 's/\s*$//g')
    dlast=$(grep "^ID=>${autorun_id} -" $RTEMPDIR_D/last_autorun_time|cut -d'-' -f2|sed 's/^\s*//g'|sed 's/\s*$//g')
    #dlast=$(cat $RTEMPDIR_D/last_autorun_time)
    dlast_hr=0
    epoch_last=0
    if [ -n "$dlast" ] ; then
      set_date_vars $dlast
      epoch_last=$(perl -e 'use Time::Local;print timelocal('$t_ss','$t_mi','$t_hh','$t_dd','$t_mm'-1,'$t_yr');')
      dlast_mm=$t_mm
      dlast_dd=$t_dd
      dlast_hr=$t_hh
    fi
    set_date_vars $dnow
    epoch_now=$(perl -e 'use Time::Local;print timelocal('$t_ss','$t_mi','$t_hh','$t_dd','$t_mm'-1,'$t_yr');')
    diff_epoch=`expr $epoch_now - $epoch_last`

    if [[ -n "$RAT_DEBUG" && $RAT_DEBUG -eq "1" ]] ; then
      log_daemon "ID=$autorun_id diff_epoch=$diff_epoch auto_interval_in_secs=$auto_interval_in_secs dnow=$dnow dlast=$dlast dlast_hr=$dlast_hr t_hh=$t_hh"
      log_daemon "ID=$autorun_id autorun_mode=$autorun_mode autorun_days=$autorun_day, autorun_time=$autorun_time diff_epoch=$diff_epoch, t_day = $t_day"
    fi

    if [[ $autorun_mode = "interval" ]] ; then
      if [ -z "$diff_epoch" ] ; then swap_p_conf_file "$store_p_conf_file"; return; fi
      if [ $diff_epoch -lt $auto_interval_in_secs ] ; then
   	swap_p_conf_file "$store_p_conf_file"
        return
      fi
    #elif [[ $autorun_mode = "time" && $t_hh -ne $dlast_hr ]] ; then
    elif [[ $autorun_mode = "time" ]] ; then
      if [[ $t_hh -ne $dlast_hr ]] || [[ $t_hh -eq $dlast_hr && $dlast_dd -ne $t_dd ]] || [[ $t_hh -eq $dlast_hr && $dlast_dd -eq $t_dd && $t_mm -ne $dlast_mm ]] ; then
        run_client_now=0
        check_val_in_array "$t_hh" "$autorun_hrs"
        if [ $val_in_array -eq "0" ] ; then return; fi

        check_val_in_array "$t_dd" "$autorun_dte"
        if [ $val_in_array -eq "0" ] ; then return; fi
         
        check_val_in_array "$t_mm" "$autorun_mon"
        if [ $val_in_array -eq "0" ] ; then return; fi

        check_val_in_array "$t_dn" "$autorun_day"
        if [ $val_in_array -eq "0" ] ; then return; fi

        run_client_now=1
      else
        if [ -e $cur_p_conf_file ]; then rm -f "$cur_p_conf_file" > /dev/null 2>&1; swap_p_conf_file "$store_p_conf_file"; fi;
        return
      fi    
    else
      if [ -e $cur_p_conf_file ]; then rm -f "$cur_p_conf_file" > /dev/null 2>&1; swap_p_conf_file "$store_p_conf_file"; fi;
      return
    fi
  fi

  #echo $dnow > $RTEMPDIR_D/last_autorun_time
  sed "/^ID=>${autorun_id} - /d" $RTEMPDIR_D/last_autorun_time > $RTEMPDIR_D/last_autorun_time.tmp
  echo "ID=>${autorun_id} - $dnow" >> $RTEMPDIR_D/last_autorun_time.tmp
  mv $RTEMPDIR_D/last_autorun_time.tmp $RTEMPDIR_D/last_autorun_time

  started_autorun=1
  read_conf "AUTORUN_FLAGS"
  if [ -n "$p_conf_value" ] ; then
    #log_daemon "Started auto run $p_conf_value"
    echo "$p_conf_value" > $RTEMPDIR_D/commands
  else
    touch $RTEMPDIR_D/commands
  fi
  touch $RTEMPDIR_D/autorun
}

function ping_a_host ()
{
  hname=$1
  #if [ $platform = "SunOS" ]; then
  #  $PING -s $hname 5 5 >/dev/null 2>&1
  #elif [ $platform = "HP-UX" ]; then
  #  $PING $hname -n 5 -m 5 >/dev/null 2>&1
  #else
  #  $PING -c 1 $PING_W_FLAG $hname >/dev/null 2>&1
  #fi
  #ping_exitcode=`echo $?`
    
  test_node_reachability "$hname";
  if [ $el_node_ping -eq "1" ] ; then
    ping_exitcode=0;
  else
    ping_exitcode=1;
  fi
}

function get_dnow ()
{
  dnow=$(date '+%Y:%m:%d:%H:%M:%S:%w')
}

function write_dnow_init ()
{
  get_dnow
  echo "$dnow" > $RTEMPDIR_D/daemon_start_time
  echo "$dnow" > $RTEMPDIR_D/last_pchk_time
}

function check_daemon_passwords ()
{
  #if [[ -f "$p_conf_file" && `grep -c "PASSWORD_CHECK_INTERVAL" $p_conf_file` -gt "0" ]] ; then
  #if [[ -f "$p_conf_file" && `grep -ic "PASSWORD_CHECK_INTERVAL" $p_conf_file` -gt "0" ]] ; then
  #  read_conf "PASSWORD_CHECK_INTERVAL"
  #  if [[ $p_conf_value -eq "0" ]] ; then return; fi
  #  pchk_interval_in_mins=$(expr $p_conf_value \* 60)
  #  pchk_interval_in_secs=$(expr $pchk_interval_in_mins \* 60)
  #fi

  if [ -f "$p_conf_file" ]; then
    cnt=0
    for pchk in `grep -w "PASSWORD_CHECK_INTERVAL" $p_conf_file`
    do
      p_conf_value=$(echo "$pchk"| cut -d"=" -f2 | sed 's/ //g')

      if [[ $cnt -eq "0" ]]; then password_interval=$p_conf_value; fi
      if [[ $p_conf_value -lt $password_interval ]]; then password_interval=$p_conf_value;  fi

      cnt=`expr $cnt + 1`  
    done
    
    if [[ $cnt -gt 0 ]]
    then
      p_conf_value=$password_interval

      if [[ $p_conf_value -eq "0" ]] ; then return; fi
      pchk_interval_in_mins=$(expr $p_conf_value \* 60)
      pchk_interval_in_secs=$(expr $pchk_interval_in_mins \* 60)
    fi
  fi

  if [ -z "$pchk_interval_in_secs" ] ; then
    pchk_interval_in_secs=86400 # Once every day
  fi

  get_dnow
  if [ -e "$RTEMPDIR_D/last_pchk_time" ] ; then
    dlast=$(cat $RTEMPDIR_D/last_pchk_time)
    set_date_vars $dnow
    epoch_now=$(perl -e 'use Time::Local;print timelocal('$t_ss','$t_mi','$t_hh','$t_dd','$t_mm'-1,'$t_yr');')
    set_date_vars $dlast
    epoch_last=$(perl -e 'use Time::Local;print timelocal('$t_ss','$t_mi','$t_hh','$t_dd','$t_mm'-1,'$t_yr');')
    diff_epoch=`expr $epoch_now - $epoch_last`
    if [ -z "$diff_epoch" ] ; then return; fi
    #log_daemon "diff_epoch=$diff_epoch interval=$pchk_interval_in_secs dnow=$dnow dlast=$dlast"
    if [ $diff_epoch -lt $pchk_interval_in_secs ] ; then
      return
    fi
  fi
  echo $dnow > $RTEMPDIR_D/last_pchk_time

  log_daemon "Started checking passwords...."

  touch $RTEMPDIR_D/password_check.running

  if [[ -n "$rootYesNoint" && $rootYesNoint -ne 3 && $rootYesNoint -ne 2 ]] || [[ -z $rootYesNoint ]] ; then
    root_hostname_counter=0
    for root_hostname in `cat $RTEMPDIR_D/.hosts.txt 2>/dev/null`
    do
      ping_a_host $root_hostname
      if [[ -n "$ping_exitcode" && $ping_exitcode -eq "0" ]] ; then
	daemon_compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l "${root_user}" "$root_hostname" ls >/dev/null 2>&1;echo $?);
        if [[ -n "$daemon_compute_ssh_status" && $daemon_compute_ssh_status -ne 0 ]]
	then
          if [[ -n "$samerootpassword" && $samerootpassword -eq "0" ]] ; then
            checkUserPassword "$root_hostname" "${root_user}" "${a_compute_rootpassword[$root_hostname_counter]}" 1
          else
            checkUserPassword "$root_hostname" "${root_user}" "$compute_rootpassword" 1
          fi
          if [ $passwordCheckStatus -ne "0" ] ; then
            stop_daemon "${root_user}" "$root_hostname"
          fi
	fi
      fi
      root_hostname_counter=$(expr $root_hostname_counter + 1)
    done
  fi

  if [[ -n "$cell_password_status" && $cell_password_status -ne 3  ]] || [[ -z $cell_password_status ]] ; then   
    root_cell_counter=0
    cell_type="normal"
    if [[ -n " $is_exalogic_machine" &&  $is_exalogic_machine -eq "1" ]]
    then
      cell_type="zfscell"
    fi

    for cellname in `cat $RTEMPDIR_D/.cells.txt 2>/dev/null |cut -d\" -f2`
    do
      #cellPingStatus=$($PING -c 1 $PING_W_FLAG $cellname >/dev/null 2>&1;echo $?)
      test_node_reachability "$cellname" "$cell_ssh_user";
      if [ $el_node_ping -eq "1" ] ; then
        cellPingStatus=0;
      else
        cellPingStatus=1;
      fi

      if [[ -n "$cellPingStatus" && $cellPingStatus -eq 0 ]] ; then 
	daemon_cell_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l "$cell_ssh_user" "$cellname" ls >/dev/null 2>&1;echo $?);
	if [[ -n "$daemon_cell_ssh_status" && $daemon_cell_ssh_status -ne 0 ]]
	then
          if [[ -n "$cell_samerootpassword" && $cell_samerootpassword -eq "0" ]] ; then
            checkUserPassword "$cellname" "$cell_ssh_user" "${a_cell_rootpassword[$root_cell_counter]}" "1" $cell_type
          else
            checkUserPassword "$cellname" "$cell_ssh_user" "$cell_rootpassword" "1" $cell_type
          fi
          if [ $passwordCheckStatus -ne "0" ] ; then
            stop_daemon "$cell_ssh_user" "$cellname"
          fi
	fi
      fi
      root_cell_counter=$(expr $root_cell_counter + 1)
    done
  fi

  if [[ -n "$zfs_password_status" && $zfs_password_status -ne 3  ]] || [[ -z $zfs_password_status ]] ; then
    root_zfs_counter=0
    for zfsname in `cat $RTEMPDIR_D/.zfs.txt 2>/dev/null|cut -d= -f2|sed 's/"//g'`
    do
      #zfsPingStatus=$($PING -c 1 $PING_W_FLAG $zfsname >/dev/null 2>&1;echo $?)
      test_node_reachability "$zfsname" "$zfs_ssh_user";
      if [ $el_node_ping -eq "1" ] ; then
        zfsPingStatus=0;
      else
        zfsPingStatus=1;
      fi

      if [[ -n "$zfsPingStatus" && $zfsPingStatus -eq 0 ]] ; then
	daemon_zfs_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l "$zfs_ssh_user" "$zfsname" ls >/dev/null 2>&1;echo $?);
	if [[ -n "$daemon_zfs_ssh_status" && $daemon_zfs_ssh_status -ne 0 ]]
	then
          if [[ -n "$zfs_samerootpassword" && $zfs_samerootpassword -eq "0" ]] ; then
            checkUserPassword "$zfsname" "$zfs_ssh_user" "${a_zfs_rootpassword[$root_zfs_counter]}" "1" "zfscell"
          else
            checkUserPassword "$zfsname" "$zfs_ssh_user" "$zfs_rootpassword" "1" "zfscell"
          fi
          if [ $passwordCheckStatus -ne "0" ] ; then
            stop_daemon "$zfs_ssh_user" "$zfsname"
          fi
        fi
      fi
      root_zfs_counter=$(expr $root_zfs_counter + 1)
    done
  fi

  if [[ -n "$ibswitch_password_status" && $ibswitch_password_status -ne 3  ]] || [[ -z $ibswitch_password_status ]] ; then
    ib_root_counter=0
    for switchname in `cat $RTEMPDIR_D/.ibs.txt 2>/dev/null`
    do
      #$PING -c 1 $PING_W_FLAG $switchname >/dev/null 2>&1
      #switchping_status=$(echo $?)
      test_node_reachability "$switchname" "$ibswitch_user";
      if [ $el_node_ping -eq "1" ] ; then
        switchping_status=0;
      else
        switchping_status=1;
      fi

      if [ $switchping_status -eq 0 ] ; then
	daemon_ibs_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l "$ibswitch_user" "$switchname" ls >/dev/null 2>&1;echo $?);
        if [[ -n "$daemon_ibs_ssh_status" && $daemon_ibs_ssh_status -ne 0 ]]
	then
          if [[ -n "$ib_samerootpassword" && $ib_samerootpassword -eq "0" ]] ; then
            checkUserPassword "$switchname" "$ibswitch_user" "${a_ib_switch_root_password[$ib_root_counter]}" "1" "ibswitch"
          else
            checkUserPassword "$switchname" "$ibswitch_user" "$switch_rootpassword" "1" "ibswitch"
          fi
          if [ $passwordCheckStatus -ne "0" ] ; then
            stop_daemon "$ibswitch_user" "$switchname"
          fi
        fi
      fi
      ib_root_counter=$(expr $ib_root_counter + 1)
    done
  fi

  node_index=0 
  for hname in "${a_node_names[@]}"
  do
    ping_a_host $hname
    if [[ -n "$ping_exitcode" && $ping_exitcode -eq "0" ]] ; then
      daemon_node_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l "$usern" "$hname" ls >/dev/null 2>&1;echo $?)	
      if [[ -n "$daemon_node_ssh_status" && $daemon_node_ssh_status -ne 0 ]]
      then 
        checkUserPassword "$hname" "$usern" "${a_node_passwords[$node_index]}" "1"
        if [ $passwordCheckStatus -ne "0" ] ; then
          stop_daemon "$usern" "$hname"
        fi
      fi
    fi
    node_index=$(expr $node_index + 1)
  done
  log_daemon "Finished checking passwords...."
  rm -f $RTEMPDIR_D/password_check.running
}

function send_mail_using_cell ()
{
  root_cell_counter=0
  log_daemon "Sending email using cell"

  if [[ -n "$attachment" && "$attachment" -eq "1" ]]
  then
    bname_prev_report=$(basename "$prev_report")
    bname_html_report=$(basename "$html_report")
    bname_diff_report=$(basename "$diff_report")
    bname_mail_program=$(basename "$MAIL_PROGRAM")
        		
cat > $MAIL_PROGRAM <<EOF
#!/bin/env bash

mail_server_running=0
function check_if_mail_exists ()
{
  mail_cmd=$(which mail)
  if [ -z "\$mail_cmd" ] ; then mail_cmd=\$(which mailx); fi
  if [ -z "\$mail_cmd" ] ; then mail_cmd=\$(which sendmail); fi
  if [ -n "\$mail_cmd" ] ; then mail_server_running=1; fi
}

function send_email_with_attachment ()
{
  which uuencode >/dev/null 2>&1
  if [ \$(echo \$?) -eq 0 ]
  then
    if [[ `echo "$subject"|grep -ic "No differences"` -gt 0 || `echo "$subject"|grep -iwc "First"` -gt 0 ]]
    then
      uuencode $bname_html_report $bname_html_report >> mail.out
    else
      uuencode $bname_prev_report $bname_prev_report > mail.out
      uuencode $bname_html_report $bname_html_report >> mail.out
      uuencode $bname_diff_report $bname_diff_report >> mail.out
    fi
    echo "$matter" >> mail.out

    \$mail_cmd -s "$subject" $remail < mail.out >/dev/null 2>&1;
    rm -rf mail.out >/dev/null 2>&1;
  else
    which mutt >/dev/null 2>&1
    if [ \$(echo \$?) -eq 0 ]
    then
      echo "$matter" > mail.out

      if [[ `echo "$subject"|grep -ic "No differences"` -gt 0 || `echo "$subject"|grep -iwc "First"` -gt 0 ]]
      then
        mutt -s "$subject" -a "$bname_html_report" -- $remail < mail.out >/dev/null 2>&1;
      else
        mutt -s "$subject" -a "$bname_prev_report" -a "$bname_html_report" -a "$bname_diff_report" -- $remail < mail.out >/dev/null 2>&1; 
      fi 
      rm -rf mail.out >/dev/null 2>&1;
    else
      which sendmail >/dev/null 2>&1
      if [ \$(echo \$?) -eq 0 ]
      then
        from=""
        to="$remail"
        subject="$subject"
        boundary="ZZ_/afg6432dfgkl.94531q"
        body="$matter"
        declare -a attachments
        if [[ `echo "$subject"|grep -ic "No differences"` -gt 0 || `echo "$subject"|grep -iwc "First"` -gt 0 ]]
        then
          attachments=( "$bname_html_report" )
        else
	  attachments=( "$bname_prev_report" "$bname_html_report" "$bname_diff_report" )
        fi
{
        printf '%s\n' "From: $from
To: \$to
Subject: \$subject
Mime-Version: 1.0
Content-Type: multipart/mixed; boundary=\"\$boundary\"

--\${boundary}

\$body
"
        for file in "\${attachments[@]}"; do
          [ ! -f "\$file" ] && echo "Warning: attachment \$file not found, skipping" >&2 && continue
          mimetype=\$(file --mime "\$file"|cut -d: -f2|cut -d\; -f2|sed 's/ //g')

          printf '%s\n' "--\${boundary}
Content-Type: \$mimetype
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename=\"\$file\"
"
          base64 "\$file"
          echo
        done
        printf '%s\n' "--\${boundary}--"
} | sendmail -t -oi
      else
        echo "$matter" | \$mail_cmd -s "$subject" $remail
      fi
    fi
  fi
}

check_if_mail_exists 
if [[ -n "\$mail_server_running" && \$mail_server_running -eq "1" ]] ; then
  send_email_with_attachment
  exit 1
else
  exit 2    
fi	
EOF
  fi

  for cellname in `cat $RTEMPDIR_D/.cells.txt |sed '/^\s*$/d'|cut -d\" -f2|cut -d\; -f2`
  do
    if [[  -n "$cell_samerootpassword" && $cell_samerootpassword -eq "0" ]] ; then
      cell_rootpassword=${a_cell_rootpassword[$root_cell_counter]}
    fi
    root_cell_counter=$(expr $root_cell_counter + 1 )
    fixRootPassword "$cell_rootpassword"
    lle_cell_rootpassword=$fixedRootPassword

    #cellPingStatus=$($PING -c 1 $PING_W_FLAG $cellname >/dev/null 2>&1;echo $?)
    test_node_reachability "$cellname" "$cell_ssh_user";
    if [ $el_node_ping -eq "1" ] ; then
      cellPingStatus=0;
    else
      cellPingStatus=1;
    fi

    if [[ -n "$cellPingStatus" && $cellPingStatus -eq 0 ]]
    then
      log_daemon "cellname : $cellname"

      if [[ -n "$attachment" && "$attachment" -eq "1" ]]
      then
	$EXPECT -f - << IBEOF
	set timeout $passwordcheck_timeout
	set le_cell_rootpassword "$lle_cell_rootpassword"
	log_user 0
	if { "$RAT_EXPECT_DEBUG" == "-d" } {
	  exp_internal 1
	}
        spawn $SCOPY $MAIL_PROGRAM $prev_report $html_report $diff_report $cell_ssh_user@$cellname:$CELLTMPDIR
        match_max 100000
        expect {
          -nocase "permission denied *" {
	   exit 4;
          }
          -nocase "no)?" {
           send -- "yes\n"
          }
          -nocase "*?assword:*" {
           send -- "\$le_cell_rootpassword\n"
          }
          -nocase eof {
           exit
          }
        }
        expect {
          -nocase "*?assword:*" {
           send -- "\$le_cell_rootpassword\n"
          }
          -nocase eof {
           exit
          } 
	  -nocase timeout {
           send_error "Timed out while copying files to $cellname\n";
           exit
         }
       }
       expect -nocase eof
IBEOF

        $EXPECT -f - << IBEOF
        set timeout $passwordcheck_timeout
        set le_cell_rootpassword "$lle_cell_rootpassword"
        log_user 0
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }
        spawn $SSHELL $cell_ssh_user@$cellname "chmod 744 $CELLTMPDIR/$bname_mail_program;"
        match_max 100000
        expect {
          -nocase "permission denied *" {
	   exit 4;
          }
          -nocase "no)?" {
           send -- "yes\n"
          }
          -nocase "*?assword:*" {
           send -- "\$le_cell_rootpassword\n"
          }
          -nocase eof {
           exit
          }
        }
        expect {
          -nocase "*?assword:*" {
           send -- "\$le_cell_rootpassword\n"
          }
          -nocase eof {
           exit
          }
          -nocase timeout {
           send_error "Timed out while modifiying permissions on $cellname\n";
           exit
         }
       }
       expect -nocase eof
IBEOF
        		
        $EXPECT -f - >/dev/null 2>&1 << IBEOF
        log_user 1
	spawn -noecho $SSHELL $cell_ssh_user@$cellname $CELLTMPDIR/$bname_mail_program
        exp_internal 1
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }    
        set timeout 60
        set le_cell_rootpassword "$lle_cell_rootpassword"
        set i 0
        log_user 1
        while {\$i < 1000000} {
          match_max 100000
          expect {
            -nocase "permission denied *" {
	      exit 4;
            }
            -nocase "no)?" {
              send -- "yes\r"
             }
             -nocase "*?assword:*" {
               send -- "\$le_cell_rootpassword\n"
             }
             -nocase eof {
               exit 0
             }
          }
          sleep 1
        }
        set timeout 7200
        expect -nocase eof
        exit
IBEOF

        $EXPECT -f - << IBEOF
        set timeout $passwordcheck_timeout
        set le_cell_rootpassword "$lle_cell_rootpassword"
        log_user 0
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }
        spawn $SSHELL $cell_ssh_user@$cellname "rm -f $CELLTMPDIR/$bname_prev_report $CELLTMPDIR/$bname_html_report $CELLTMPDIR/$bname_diff_report $CELLTMPDIR/$bname_mail_program >/dev/null 2>&1"
        match_max 100000
        expect {
          -nocase "permission denied *" {
	   exit 4;
          }
          -nocase "no)?" {
           send -- "yes\n"
          }
          -nocase "*?assword:*" {
           send -- "\$le_cell_rootpassword\n"
          }
          -nocase eof {
           exit
          }
        }
        expect {
          -nocase "*?assword:*" {
           send -- "\$le_cell_rootpassword\n"
          }
          -nocase eof {
           exit
          }
          -nocase timeout {
           send_error "Timed out while removing files from $cellname\n";
           exit
         }
       }
       expect -nocase eof
IBEOF
      else
        $EXPECT -f - >/dev/null 2>&1 << IBEOF
        log_user 1
        spawn -noecho $SSHELL $cell_ssh_user@$cellname "echo \"$matter\" | $mail_cmd -s '$subject' $remail"
        exp_internal 1
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }    
        set timeout 60
        set le_cell_rootpassword "$lle_cell_rootpassword"
        set i 0
        log_user 1
        while {\$i < 1000000} {
          match_max 100000
          expect {
             -nocase "permission denied *" {
	      exit 4;
             }
            -nocase "no)?" {
              send -- "yes\r"
             }
             -nocase "*?assword:*" {
               send -- "\$le_cell_rootpassword\n"
             }
             -nocase eof {
               exit 0
             }
          }
          sleep 1
        }
        set timeout 7200
        expect -nocase eof
        exit
IBEOF
      fi
      break;
    fi
  done
  rm -f $MAIL_PROGRAM >/dev/null 2>&1
}

function run_client_script ()
{
  global_pass_prompt_ans="n"
  if [[ $root_all_prompt -eq "1" ]] ; then
    global_pass_prompt_ans="y"
  fi

  same_password_cell_ans="y"
  same_password_zfs_ans="y"
  same_password_node_ans="y"
  same_password_switch_ans="y"
  node_password_prompts=""
  if [[ -n "$cell_samerootpassword" && $cell_samerootpassword -eq "0" ]] ; then 
    same_password_cell_ans="n"; 
    root_cell_counter=0
    for cellname in `cat $RTEMPDIR_D/.cells.txt |cut -d\" -f2`
    do
      if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
      then
        cellname_full=$cellname
      else
        #cellname_full=$(cat /etc/hosts|grep -w "$cellname"|awk '{print $NF}'|cut -d'-' -f1)
        cellname_full=$(grep -w "$cellname" /etc/hosts|grep -v "^ *#"|awk '{print $NF}'|cut -d'-' -f1|head -1)
      fi
      cell_password_prompts="$cell_password_prompts
     \"Enter * password for STORAGE SERVER* $cellname_full :\" {
        send -- \"${a_cell_rootpassword[$root_cell_counter]}\\r\"
      }"
      root_cell_counter=$(expr $root_cell_counter + 1 )
    done
  fi

  if [[ -n "$zfs_samerootpassword" && $zfs_samerootpassword -eq "0" ]] ; then 
    same_password_zfs_ans="n"; 
    root_zfs_counter=0
    for zfsname in `cat $RTEMPDIR_D/.zfs.txt|cut -d= -f2|sed 's/"//g'`
    do
      zfs_password_prompts="$zfs_password_prompts
     \"Enter * password for*ZFS Storage Appliance* $zfsname :\" {
        send -- \"${a_zfs_rootpassword[$root_zfs_counter]}\\r\"
      }"
      root_zfs_counter=$(expr $root_zfs_counter + 1 )
    done
  fi

  if [[ -n "$samerootpassword" && $samerootpassword -eq "0" ]] ; then 
    same_password_node_ans="n"; 
    root_hostname_counter=0
    for root_hostname in `cat $RTEMPDIR_D/.hosts.txt`
    do
      node_password_prompts="$node_password_prompts
     \"Enter root password *$root_hostname :\" {
        send -- \"${a_compute_rootpassword[$root_hostname_counter]}\\r\"
      }"
      root_hostname_counter=$(expr $root_hostname_counter + 1)
    done
  fi

  if [[ -n "$ib_samerootpassword" && $ib_samerootpassword -eq "0" ]] ; then 
    same_password_switch_ans="n"; 
    ib_root_counter=0
    for switchname in `cat $RTEMPDIR_D/.ibs.txt`
    do
      switch_password_prompts="$switch_password_prompts
     \"Enter * password for*INFINIBAND SWITCH* $switchname :\" {
        send -- \"${a_ib_switch_root_password[$ib_root_counter]}\\r\"
      }
     \"Enter * password for* $switchname :\" {
        send -- \"${a_ib_switch_root_password[$ib_root_counter]}\\r\"
      }"
      ib_root_counter=$(expr $ib_root_counter + 1 )
    done
  fi


  db_os_auth_prompts=""
  mb_db_counter=0
  for db_name_to_check in "${mb_db_names[@]}"
  do
    if [[ -n "${mb_sysdba_user[$mb_db_counter]}" ]] ; then
      db_os_auth_prompts="$db_os_auth_prompts
      \"OS authentication is not enabled so please enter sysdba privileged user name for $db_name_to_check:\" {
        send -- \"${mb_sysdba_user[$mb_db_counter]}\\r\"
      }
      \"Enter password for ${mb_sysdba_user[$mb_db_counter]}@$db_name_to_check:\" {
        send -- \"${mb_sysdba_pswd[$mb_db_counter]}\\r\"
      }"
    fi
    mb_db_counter=$(expr $mb_db_counter + 1)
  done
  db_os_auth_prompts="$db_os_auth_prompts
     \"OS authentication is not enabled so please enter sysdba privileged user name for *\" {
        send -- \"\\r\"
      }
      \"Enter user name again for *:*\" {
        send -- \"\\r\"
      }
      \"Enter password for *@*\" {
        send -- \"\\r\"
      }"

  pdb_password_prompts=""
  mb_pdb_counter=0
  for pdb_name in "${mb_pdb_names[@]}"
  do
    pdb_password_prompts="$pdb_password_prompts
    \"Enter * user password for $pdb_name pluggable database\" {
      send -- \"${mb_pdb_sys_password[$mb_pdb_counter]}\\r\"
    }"
    mb_pdb_counter=$(expr $mb_pdb_counter + 1)
  done
  pdb_password_prompts="$pdb_password_prompts
    \"Enter * user password for * pluggable database\" {
      send -- \"\\r\"
    }"

  ssh_password_prompts=""
  node_index=0
  for hname in "${a_node_names[@]}"
  do
    ssh_password_prompts="$ssh_password_prompts
    \"Enter ${usern} *password on $hname * :\" {
      send -- \"${a_node_passwords[$node_index]}\\r\"
    }"
    node_index=$(expr $node_index + 1)
  done
  ssh_password_prompts="$ssh_password_prompts
    \"Enter ${usern} *password on * :\" {
      send -- \"\\r\"
    }"
  
  #echo "$cell_password_prompts"
  #echo "$zfs_password_prompts"
  #echo "$node_password_prompts"
  #echo "$switch_password_prompts"

  fixRootPassword "$cell_rootpassword"
	lle_cell_rootpassword=$fixedRootPassword	
  fixRootPassword "$switch_rootpassword"
	lle_switch_rootpassword=$fixedRootPassword
  fixRootPassword "$zfs_rootpassword"
	lle_zfs_rootpassword=$fixedRootPassword
  fixRootPassword "$global_root_password"
	lle_global_root_password=$fixedRootPassword
  fixRootPassword "$compute_rootpassword"
	lle_compute_rootpassword=$fixedRootPassword
  
  export RAT_CLIENT_RUN_LOG_INTERNAL=$RTEMPDIR_D/run.log

  $EXPECT -f - >> $RTEMPDIR_D/run.log 2>&1 << IBEOF
    log_user 1
    spawn -noecho $RTEMPDIR_D/run.sh
    if { "$RAT_EXPECT_DEBUG" == "-d" } {
      exp_internal 1
    }    
    set timeout 600
    set le_cell_rootpassword "$lle_cell_rootpassword"
    set le_switch_rootpassword "$lle_switch_rootpassword"
    set le_zfs_rootpassword "$lle_zfs_rootpassword"
    set le_global_root_password "$lle_global_root_password"
    set le_compute_rootpassword "$lle_compute_rootpassword"
    set i 0
    log_user 1
    while {\$i < 1000000} {
      match_max 100000
      expect {
        -nocase eof {
           exit
         }
        -nocase "permission denied *" {
	   exit 4;
         }
        -nocase "no)?" {
          send -- "yes\r"
         }
	 "Enter path for clusterware home*" {
	   send -- "$cHome\r"
	 }
         "CRS stack is running and CRS_HOME is not set. Do you want to set CRS_HOME*" {
           send -- "y\r"
         }
         "RDBMS binaries found at * and ORACLE_HOME not set. Do you want to set ORACLE_HOME to *" {
	   send -- "$setOHHome\r"
	 }
         "Select databases from list for checking best practices.*" {
           send -- "$db_to_check\r"
         }
         "Please indicate your selection from one of the above options for STORAGE SERVER*" {
           send -- "$cellssh_YesNo\r"
         }
	 "This computer is for*" {
	   send -- "$uip\r"
	 }
	 "*have Oracle software installed*" {
	   send -- "$ask_inv_loc\r"
	 }
         "Please indicate your selection from one of the above options for ZFS Storage Appliance*" {
           send -- "$zfsssh_YesNo\r"
         }
         "Please indicate your selection from one of the above options for root*" {
           send -- "$rootYesNo\r"
         }
         "Please indicate your selection from one of the above options for INFINIBAND SWITCH*" {
           send -- "$ibswitch_YesNo\r"
         }
         "Do you want to configure SSH for user*" {
           send -- "n\r"
         }
         "We can configure ssh only for this run and reverse the changes back. do you want to continue?*" {
           send -- "y\r"
         }
         "Is root password same on all components? *" {
           send -- "$global_pass_prompt_ans\r"
         }
         "Is * password same on all STORAGE SERVER" {
           send -- "$same_password_cell_ans\r"
         }
         "Is * password same on all ZFS Storage Appliance" {
           send -- "$same_password_zfs_ans\r"
         }
         "Is * password same on all*nodes" {
           send -- "$same_password_node_ans\r"
         }
         "Is * password same on all INFINIBAND SWITCH" {
           send -- "$same_password_switch_ans\r"
         }
         $ssh_password_prompts
         $cell_password_prompts
         $zfs_password_prompts
         $node_password_prompts
         $switch_password_prompts
         "Unable to determine nodes in cluster.  Do you want to enter manually.*" {
           send -- "$readNodeNames\r"
         }
         "Enter cluster node names *," {
           send -- "$nodeList\r"
         }
         "CRS binaries found at * Do you want to set CRS_HOME to *" {
           send -- "$setCRSHome\r"
         }
         "Enter value for ORA_CRS_HOME environment variable*" {
           send -- "$setCRSHome\r"
         }
         "Enter * password for STORAGE SERVER*" {
           send -- "\$le_cell_rootpassword\r"
         }
         "Enter * password for INFINIBAND SWITCH*" {
           send -- "\$le_switch_rootpassword\r"
         }
         "Enter * password for ZFS Storage Appliance*" {
           send -- "\$le_zfs_rootpassword\r"
         }
         "Enter root password*components*" {
           send -- "\$le_global_root_password\r"
         }
         "Enter root password*" {
           send -- "\$le_compute_rootpassword\r"
         }
         "Enter root  password*" {
           send -- "\$le_compute_rootpassword\r"
         }
         $db_os_auth_prompts
         $pdb_password_prompts
         "Do you want to continue*" {
           send -- "\r"
         }
         "Output directory to read for offline use is*" {
           send -- "\r"
         }
         "Press enter to  continue..*" {
           send -- "\r"
         }
         "*           Node name -*" {
           set timeout 7200
           expect eof
           exit
         }
         "*Checking Best Practice Recommendations*" {
           set timeout 7200
           expect eof
           exit
         }
      }
      sleep 1
    }
    set timeout 7200
    expect -nocase eof
    exit
IBEOF

}

function cleanup_client ()
{
  if [ -e "${RTEMPDIR}/${program_name}.pid" ] ; then 
    program_pid=$(cat ${RTEMPDIR}/${program_name}.pid)
  fi
  if [ -e "$RTEMPDIR_D/run.pid" ] ; then
    run_pid=$(cat $RTEMPDIR_D/run.pid)
  fi
  if [[ -n "$program_pid" && `ps -ef| grep -w "$program_pid" | grep -v grep| wc -l` -gt "0" ]] ; then
    kill -15  $program_pid
  fi
  if [[ -n "$run_pid" && `ps -ef| grep -w "$run_pid" | grep -v grep| wc -l` -gt "0" ]] ; then
    kill -15  $run_pid
  fi

  if [ -e "$RTEMPDIR_D/client.pid" ] ; then
    rm -f $RTEMPDIR_D/client.pid
  fi
}

function log_daemon ()
{
  echo -e "`date '+%a %b %d %H:%M:%S %Y'` - $1\n" >> $WRKDIR/${program_name}_daemon.log
}

function get_program_key ()
{
  PDIR=$(cd -P -- "$(dirname -- "$0")" && printf '%s\n' "$(pwd -P)")
  program_name=$(echo $(basename $0)|sed 's/[\.\/]//g')

  md5sum_program=$(which md5sum 2>/dev/null| grep -v "no md5sum in")
  if [ -n "$md5sum_program" ] ; then
    #program_key=$(md5sum $0 | awk '{print $1}')
    program_key=$(md5sum $PDIR/${program_name} | awk '{print $1}')
  else
    #program_key=$(ls -l $0 | awk '{print $5$6$7$8}')
    program_key=$(ls -l $PDIR/${program_name} | awk '{print $5$6$7$8}')
  fi
}

function killsub() 
{
  kill ${1} >/dev/null 2>/dev/null
  #wait ${1} 2>/dev/null
}
# TODO
# Check if request is from same user - done
# md5sum use full path instead of one in PATH
# when user process is killed, kill client also - done.. not allowing stop when active client exists

function handle_client_request ()
{
  #send_email "Started ${program_name} run" "Started exachk run"
  args=$(cat $RTEMPDIR_D/commands)

  autorun=0
  if [ -f "$RTEMPDIR_D/autorun" ] ; then
    autorun=1
  fi

  rm -f $RTEMPDIR_D/autorun

  if [[ $autorun -eq "1" ]] ; then
    log_daemon "Started ${program_name} execution : ID = $autorun_id args = $args"
  else
    log_daemon "Started ${program_name} execution : args = $args"
  fi

  #echo "starting to run $0 args = $args"

  export RAT_DAEMON_CLIENT=1

  get_program_key

  if [[ $program_key = $RAT_PROGRAM_KEY ]] ; then
    echo "#!$bash_scr" > $RTEMPDIR_D/run.sh

    #if [[ -n "$RAT_DAEMON_DEBUG" && $RAT_DAEMON_DEBUG -eq "1" ]] ; then echo "set -x" >> $RTEMPDIR_D/run.sh; export RAT_CLIENT_DEBUG=1; fi

    echo "$RAT_DEBUG_FLG" >> $RTEMPDIR_D/run.sh
    echo "echo \$\$ > $RTEMPDIR_D/run.pid" >> $RTEMPDIR_D/run.sh
    if [ -e "$RTEMPDIR_D/setenv.sh" ] ; then
      echo ". $RTEMPDIR_D/setenv.sh" >> $RTEMPDIR_D/run.sh
    fi

    #PDIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
    PDIR=$(cd -P -- "$(dirname -- "$0")" && printf '%s\n' "$(pwd -P)")
    program_name=$(echo $(basename $0)|sed 's/[\.\/]//g')
    if [[ -n "$RAT_DAEMON_DEBUG" && $RAT_DAEMON_DEBUG -eq "1" ]]
    then
      export RAT_CLIENT_DEBUG=1
      export RAT_REMOTE_MODE=1
      #export RAT_EXPECT_DEBUG="-d"

      PS4='$(date "+ $LINENO: + ")'

      timestamp=$(date '+%Y%m%d_%H%M%S')
      debugFileName=$(echo ${program_name}_debug_${timestamp}.log)
      if [[ -n $RAT_OUTPUT ]]; then
	debugFileName=${RAT_OUTPUT}/${debugFileName}
      fi

      export RAT_CLIENT_DEB_FIL=$debugFileName
      export RAT_DEBUG_FILENAME_INTERNAL=$debugFileName

      echo -e ""
      echo -e ""
      echo -e "Debug output file is $debugFileName";
      echo -e ""
      echo -e ""

      echo "$bash_scr -x ${PDIR}/${program_name} $args 2>$debugFileName" >> $RTEMPDIR_D/run.sh
    else
      echo "$bash_scr ${PDIR}/${program_name} $args" >> $RTEMPDIR_D/run.sh
    fi

    chmod +x $RTEMPDIR_D/run.sh
    run_client_script
    rm -f $RTEMPDIR_D/run.pid
  else
    #echo >>$RTEMPDIR_D/run.log
    echo > $RTEMPDIR_D/run_error.log
    echo -e "${RED}$0 is changed since daemon started. Restart(stop & start) daemon using new ${program_name}. You could also use -nodaemon option to ignore daemon. ex: ${program_name} -nodaemon <other options>.${NORM}" >> $RTEMPDIR_D/run_error.log
    echo >> $RTEMPDIR_D/run_error.log
    log_daemon "Failed to run ${program_name} as $0 is changed since daemon started. Restart(stop & start) daemon using new ${program_name}"
  fi

  if [ -f "$RTEMPDIR_D/client.pid" ] ; then
    cpid=$(cat $RTEMPDIR_D/client.pid)
    if [[ -n "$cpid" && `ps -ef |grep -w "$cpid"| grep -v grep|wc -l` -gt "0" ]] ; then
      log_daemon "Client pid : $cpid"
      tpid=$(ps -ef |grep -w $cpid|grep tail |grep -v grep |awk '{print $2}')
      if [ -n "$tpid" ] ; then
        #echo "killing using kill"
        killsub $tpid >/dev/null 2>&1
      else
        killtree $cpid 9 >/dev/null 2>&1
      fi
    fi
  fi
  if [ -e "$RTEMPDIR_D/commands" ]; then mv $RTEMPDIR_D/commands $RTEMPDIR_D/commands.done; fi;

  if [ -e "$RTEMPDIR_D/run.log" ]; then mv $RTEMPDIR_D/run.log $RTEMPDIR_D/run.log.done; fi;
  if [[ $autorun -eq "1" ]] ; then
    DIFF_RUN_REPORT=$RTEMPDIR_D/diff_run_report.txt
    html_report=$(grep "Detailed report (html)" $RTEMPDIR_D/run.log.done | awk '{print $NF}' | sed 's/\.html.*/.html/'|head -1)
    #log_daemon "autorun=1 checking for differences : $html_report"
    if [[ -n "$html_report" && -f "$html_report" ]] ; then
      #if [[ -f $RTEMPDIR_D/last_autorun_report ]] ; then
      if [[ -f $RTEMPDIR_D/last_autorun_report && `grep -c "^@ID:${autorun_id} - " $RTEMPDIR_D/last_autorun_report` -gt 0 ]] ; then
        #prev_report=$(cat $RTEMPDIR_D/last_autorun_report)
        prev_report=$(grep "^@ID:$autorun_id - " $RTEMPDIR_D/last_autorun_report|tail -1|sed 's/^@ID.* - //g'|sed 's/^\s*//g'|sed 's/\s*$//g')
        #log_daemon "$0 -diff $prev_report $html_report"
 
        b_prev_report=$(basename "$prev_report")
        b_html_report=$(basename "$html_report")

	p_total_checks=$(grep '<td>Total checks</td>' $prev_report|sed 's/[^0-9]//g')
	p_passed_checks=$(grep '<td>Passed checks</td>' $prev_report|sed 's/[^0-9]//g')
	p_failed_checks=$(grep '<td>Failed(fail/warn/info/skip) checks</td>' $prev_report|sed 's/[^0-9]//g')
        #p_shc_header=$(grep -o "System Health Score is [0-9]* out of [0-9]*" $prev_report)
        p_shc_header=$(perl -e 'open(INPUT,"'$prev_report'"); while(<INPUT>){ if ($_ =~ m/(System Health Score is [0-9]* out of [0-9]*)/g) { print $1; break;}}') 

	c_total_checks=$(grep '<td>Total checks</td>' $html_report|sed 's/[^0-9]//g')
	c_passed_checks=$(grep '<td>Passed checks</td>' $html_report|sed 's/[^0-9]//g')
	c_failed_checks=$(grep '<td>Failed(fail/warn/info/skip) checks</td>' $html_report|sed 's/[^0-9]//g')
        #c_shc_header=$(grep -o "System Health Score is [0-9]* out of [0-9]*" $html_report)
        c_shc_header=$(perl -e 'open(INPUT,"'$html_report'"); while(<INPUT>){ if ($_ =~ m/(System Health Score is [0-9]* out of [0-9]*)/g) { print $1; break;}}') 

	echo ""								> $DIFF_RUN_REPORT
        echo "$b_prev_report System Health Score"			>>$DIFF_RUN_REPORT
	echo "-----------------------------------------"		>>$DIFF_RUN_REPORT
	echo "$p_shc_header"						>>$DIFF_RUN_REPORT
	echo "Total checks                 	:  $p_total_checks"	>>$DIFF_RUN_REPORT
	echo "Passed checks                	:  $p_passed_checks" 	>>$DIFF_RUN_REPORT
	echo "Failed(fail/warn/info/skip) checks:  $p_failed_checks" 	>>$DIFF_RUN_REPORT
	echo ""								>>$DIFF_RUN_REPORT
	echo ""								>>$DIFF_RUN_REPORT
	echo ""								>>$DIFF_RUN_REPORT
        echo "$b_html_report System Health Score"			>>$DIFF_RUN_REPORT		
	echo "-----------------------------------------"		>>$DIFF_RUN_REPORT
	echo "$c_shc_header"						>>$DIFF_RUN_REPORT
	echo "Total checks                	:  $c_total_checks"	>>$DIFF_RUN_REPORT
	echo "Passed checks                	:  $c_passed_checks"	>>$DIFF_RUN_REPORT
	echo "Failed(fail/warn/info/skip) checks:  $c_failed_checks"	>>$DIFF_RUN_REPORT
        echo ""								>>$DIFF_RUN_REPORT
        echo ""								>>$DIFF_RUN_REPORT
        #$0 -diff $prev_report $html_report 				>>$DIFF_RUN_REPORT
        $PDIR/${program_name} -diff $prev_report $html_report 		>>$DIFF_RUN_REPORT

        tchks=$(grep '^Total' $DIFF_RUN_REPORT | grep -v 'checks' | awk '{print $NF}')
        schks=$(grep '^Same' $DIFF_RUN_REPORT | awk '{print $NF}')
        if [ ! -n "$tchks" ] ; then tchks=0; fi
        if [ ! -n "$schks" ] ; then schks=0; fi
        if [[ $RAT_DEBUG -eq "1" ]] ; then log_daemon "tchks=$tchks schks=$schks"; fi
        if [[ $tchks -ne $schks ]] ; then
          #subj="Differences found in $program_name run."
          subj="ID:${autorun_id} : Differences found in $program_name run."
        else
          #subj="No differences found in $program_name run."
          subj="ID:${autorun_id} : No differences found in $program_name run."
        fi
        matter=$(cat $DIFF_RUN_REPORT)
        diff_report=$(echo "$matter"|grep 'File comparison is complete'|sed 's/File comparison is complete. The comparison report can be viewed in: //g'|sed 's/^\s//g'|sed 's/\s$//g')
        #log_daemon "emailing diff"
        send_email "$subj" "$matter" "1"
      else
        b_html_report=$(basename "$html_report")

        c_total_checks=$(grep '<td>Total checks</td>' $html_report|sed 's/[^0-9]//g')
        c_passed_checks=$(grep '<td>Passed checks</td>' $html_report|sed 's/[^0-9]//g')
        c_failed_checks=$(grep '<td>Failed(fail/warn/info/skip) checks</td>' $html_report|sed 's/[^0-9]//g')
        #c_shc_header=$(grep -o "System Health Score is [0-9]* out of [0-9]*" $html_report)
   	c_shc_header=$(perl -e 'open(INPUT,"'$html_report'"); while(<INPUT>){ if ($_ =~ m/(System Health Score is [0-9]* out of [0-9]*)/g) { print $1; break;}}')
	
	echo ""								> $DIFF_RUN_REPORT
	echo "First run results"					>>$DIFF_RUN_REPORT
        echo ""                                                 	>>$DIFF_RUN_REPORT
        echo ""                                                 	>>$DIFF_RUN_REPORT
        echo "$b_html_report System Health Score"               	>>$DIFF_RUN_REPORT
        echo "-----------------------------------------"        	>>$DIFF_RUN_REPORT
        echo "$c_shc_header"                                    	>>$DIFF_RUN_REPORT
        echo "Total checks                 	:  $c_total_checks"  	>>$DIFF_RUN_REPORT
        echo "Passed checks               	:  $c_passed_checks" 	>>$DIFF_RUN_REPORT
        echo "Failed(fail/warn/info/skip) checks:  $c_failed_checks" 	>>$DIFF_RUN_REPORT
        echo ""                                                 	>>$DIFF_RUN_REPORT
        echo ""                                                 	>>$DIFF_RUN_REPORT
        matter=$(cat $DIFF_RUN_REPORT)

        #send_email "First $program_name run." "$matter" "1"
        send_email "ID:${autorun_id} : First $program_name run." "$matter" "1"
      fi
      purge_collections
    fi

    #out=`ls -l $html_report 2>&1`
    #log_daemon "check $out"

    if [[ -n "$html_report" && -f "$html_report" ]] ; then
      #log_daemon "writing $html_report to $RTEMPDIR_D/last_autorun_report"
      #echo "$html_report" > $RTEMPDIR_D/last_autorun_report
      echo "@ID:${autorun_id} - $html_report" >> $RTEMPDIR_D/last_autorun_report

      ar_collection=$(dirname "$html_report") 
      ar_collection=$(basename "$ar_collection")
      echo "@ID:${autorun_id} - $ar_collection" >> $autorun_list
    fi
  fi

  if [ -e "$RTEMPDIR_D/run.log.done" ]; 
  then 
    current_html_report=$(grep "Detailed report (html)" $RTEMPDIR_D/run.log.done | awk '{print $NF}' | sed 's/\.html.*/.html/'|head -1)
    current_html_report=$(basename "$current_html_report"|sed 's/.html//g')
    mv $RTEMPDIR_D/run.log.done $WRKDIR/$current_html_report.log; 
  fi

  rm -f $RTEMPDIR_D/client.pid

  if [ -e "$cur_p_conf_file" ]; then rm -f "$cur_p_conf_file" > /dev/null 2>&1; swap_p_conf_file "$store_p_conf_file"; fi;

  log_daemon "Finished ${program_name} execution"
}

#function to map ip address to switch name and find switch type for each(leaf or spine)
switch_ip_type_name_mapping ()
{
  o_ibnetdiscover_fil=$OUTPUTDIR/o_ibnetdiscover_${localnode}.out
  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]]; then o_ibnetdiscover_fil=$OUTPUTDIR/o_ibnetdiscover_exalogic_${localnode}.out; fi 

  if [[ -e $OUTPUTDIR/o_ibswitches_${localnode}.out && -e $o_ibnetdiscover_fil ]]
  then
    if [ -e $SWITCH_TYPE_FIL ]; then rm -rf $SWITCH_TYPE_FIL >/dev/null 2>&1;fi
    for switchip in `cat $OUTPUTDIR/o_ibswitches_${localnode}.out`
    do
      is_ibswitch_ip=$(echo $switchip|grep -c [A-Za-z])
      if [[ -n $is_ibswitch_ip && $is_ibswitch_ip -eq 0 ]]
      then
          ib_switch_name=$(nslookup $switchip|grep -iw name|awk '{print $NF}'|sed 's/\.$//')
      else
          ib_switch_name=$switchip
      fi
      short_ib_switch_name=$(echo $ib_switch_name|cut -d. -f1)
      ib_switch_type=$(grep -w "$short_ib_switch_name" $o_ibnetdiscover_fil|cut -d'|' -f2|sort -u|head -1)
      if [ -z "$ib_switch_type" ]; then ib_switch_type=$(grep -w "$ib_switch_name" $o_ibnetdiscover_fil|cut -d'|' -f2|sort -u|head -1);fi
      if [ -z "$ib_switch_type" ]; then ib_switch_type=$(grep -w "$switchip" $o_ibnetdiscover_fil|cut -d'|' -f2|sort -u|head -1);fi
      if [ -z "$ib_switch_type" ]; then ib_switch_type="unknown";fi
      echo "$switchip|$ib_switch_type|$ib_switch_name">>$SWITCH_TYPE_FIL
    done
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then 
      cp $SWITCH_TYPE_FIL $TMP_OUTPUT; 
      chmod 777 $SWITCH_TYPE_FIL; 
    else
      cp $SWITCH_TYPE_FIL $RTEMPDIR;
    fi
  fi
  unset is_ibswitch_ip
}

#function to download new exachk from MOS
function download_from_mos()
{
  return 1;
  PROCEED=1
  MOVE_CURRENT_VER=1
  DAYS_LIMIT=100		
  AUTOUPDATE=0
  
  if [[ $UPDATE_RUN -eq 1 ]]
  then
    if [[ "$TYP" != "-f" && "$TYP_S" != "-S" && "$TYP_S" != "-s" ]]
    then
      if [[ $daemon_running -ne "1" ]]
      then
      	if  [ -e $SCRIPTPATH/.cgrep/auto_downloader.pl ]
      	then
      	  if  [ -w $SCRIPTPATH ]
      	  then
      	    SUPPORT_HOST='support.oracle.com'
      	    platform=`uname -s`
      	    #if [ $platform = "Linux" ]
      	    #then
      	    #  PING="/bin/ping"
      	    #else
      	    #  PING="/usr/sbin/ping"
      	    #fi
      	    #if [ $platform = "SunOS" ]; then
      	    #  $PING -s $SUPPORT_HOST 5 5 >/dev/null 2>&1
      	    #elif [ $platform = "HP-UX" ]; then
      	    #  $PING $SUPPORT_HOST -n 5 -m 5 >/dev/null 2>&1
      	    #else
      	    #  $PING -c 1 $PING_W_FLAG $SUPPORT_HOST >/dev/null 2>&1
      	    #fi
      	    #exitcode=`echo $?`
            test_node_reachability "$SUPPORT_HOST";
            if [ $el_node_ping -eq "1" ] ; then
              exitcode=0;
            else
              exitcode=1;
            fi

      	    if [ $exitcode = 0 ]
      	    then
      	      AUTOUPDATE=1
      	    else
      	      echo ""
      	      echo -e $RED"MOS($SUPPORT_HOST) is not reachable.${NORM}";
      	      echo ""
      	      PROCEED=2
      	    fi
      	  else
      	    echo ""
      	    echo -e ${RED}"$SCRIPTPATH is read-only directory.$SCRIPTPATH must be writable to update $program_name.${NORM}";
      	    echo ""
      	    PROCEED=2
      	  fi
      	else
      	  echo ""
      	  echo -e ${RED}"Auto-update Component is missing.Please try to update $program_name manually.${NORM}";
      	  echo ""
      	  PROCEED=2
      	fi
      else
        echo ""
        echo -e ${RED}"Daemon is running in background.Please stop the daemon using $program_name -d start' and then try to update $program_name.${NORM}";
        echo ""
      	PROCEED=2
      fi
    else
      echo ""
      echo -e ${RED}"$program_name cannot be updated in offline/silent mode.${NORM}";
      echo ""
      PROCEED=2
    fi
  fi
  
  if [[ $AUTOUPDATE -eq 1 ]]
  then
    MOS_ATTEMPT=3
    if [[ ${program_name} = "raccheck" ]]
    then
      MOS_URL="https://support.oracle.com/epmos/faces/DocumentDisplay?id=1070954.1"
    elif [[ ${program_name} = "odacheck" ]]
    then
      MOS_URL="https://support.oracle.com/epmos/faces/DocumentDisplay?id=1070954.1"
    elif [[ ${program_name} = "exachk" ]]
    then
      MOS_URL="https://support.oracle.com/epmos/faces/DocumentDisplay?id=1070954.1"
    fi
    perl_exe=$(which perl);
    
    while [ $MOS_ATTEMPT -ge 1 ]
    do
      echo ""
      if [ $MOS_ATTEMPT -eq 3 ]
      then
        echo "Credentials required to login to My Oracle Support:"
      else
        echo "Please re-enter credentials correctly, $MOS_ATTEMPT tries remaining"
      fi
      
      exec 3<&2; exec 2<&0
      $READ -p "Enter Username:" MOS_USERNAME
      exec 2<&3

      tty -s && stty -echo
      exec 3<&2; exec 2<&0
      $READ -p "Enter Password:" MOS_PASSWORD
      exec 2<&3
      tty -s && stty echo

      echo ""
      chmod 744 $SCRIPTPATH/.cgrep/auto_downloader.pl >/dev/null 2>&1
      ade_status=`$perl_exe $SCRIPTPATH/.cgrep/auto_downloader.pl -u "$MOS_USERNAME" -p "$MOS_PASSWORD" -l "$MOS_URL" -b "$SCRIPTPATH/${program_name}_bundle.zip" -v "$show_version_envfile" 2>&1`;
      
      if [[ `echo "$ade_status"| grep -ci 'Error Code:2'` -eq 1 ]]
      then
        ade_status=`echo "$ade_status"|sed 's/\[Error Code:[0-9]*\]\s*//g'`;
        echo ""
        echo -e ${RED}"$ade_status ${NORM}";
        MOS_ATTEMPT=0
        PROCEED=2
      elif [[ `echo "$ade_status"| grep -ci 'Error Code:3'` -eq 1 ]]
      then
        echo -e ${RED}"Incorrect username or password. ${NORM}"
        MOS_ATTEMPT=$(expr $MOS_ATTEMPT - 1)		
        if [ $MOS_ATTEMPT -eq 0 ]
        then
          ade_status=`echo "$ade_status"|sed 's/\[Error Code:[0-9]*\]\s*//g'`;
          echo ""
          echo -e ${RED}"$ade_status ${NORM}";
          echo -e ${RED}"${program_name} update failed. ${NORM}"
          PROCEED=2
        fi
      elif [[ `echo "$ade_status"| grep -ci 'Info Code:4'` -eq 1 ]]
      then 
        ade_status=`echo "$ade_status"|sed 's/\[Info Code:[0-9]*\]\s*//g'`;
        echo ""
        echo -e $ade_status Proceeding with existing ${program_name}.
        echo ""
        MOS_ATTEMPT=0
        PROCEED=1		
      elif [[ `echo "$ade_status"| grep -ci 'Info Code:1'` -eq 1 ]]
      then
        ade_status=`echo "$ade_status"|sed 's/\[Info Code:[0-9]*\]\s*//g'`;
        echo ""
        echo -e "$ade_status. Restarting updated ${program_name}...."
        echo ""
        MOS_ATTEMPT=0
        PROCEED=3		
      else
        echo ""
        echo -e "Unexpected error occurred while updating ${program_name}."
        echo ""
        MOS_ATTEMPT=0
        PROCEED=2		
      fi
    done
    
    if [[ $PROCEED -eq 3 ]]
    then
      if [ `echo $argsaved | grep -cw 'update'` -gt "0" ] ; then
        argsaved=$(echo $argsaved | sed 's/-update//')
      fi
    
      c_pro_pid=$$;
      for _child in $(ps -o pid --no-headers --ppid ${c_pro_pid})
      do
        kill -9 ${_child} >/dev/null 2>&1
      done
    
      ./${SCRIPTPATH}/${program_name} ${argsaved}
      exit 1
    fi
  fi
  
  if [[ $PROCEED -eq 2 ]]
  then
    exec 3<&2; exec 2<&0
    $READ -p "Do you want to proceed with existing ${program_name}?[y/n][y]" E_PRO
    read_code=`echo $?`;
    exec 2<&3
    process_prompt "$read_code" "E_PRO" "y"
    echo ""
    case $E_PRO in
      y|Y|yes|YES|Yes)
      	MOVE_CURRENT_VER=1
        ;;
      n|N|No|NO)
      	MOVE_CURRENT_VER=0
        ;;
      *)
      	MOVE_CURRENT_VER=1
        ;;
    esac	
  fi
  
  if [[ $MOVE_CURRENT_VER -ne 1 ]]
  then
    exit 1;
  fi
}

remove_passwords_in_debug_called=0
# Cleanup the debug o/p to remove cell, switch, root, osuser, db passwords
function remove_passwords_in_debug()
{
  if [ $remove_passwords_in_debug_called -eq "1" ] ; then return; fi
  # Remove the passwords
  for a_password in $cell_rootpassword $switch_rootpassword $zfs_rootpassword $global_root_password $compute_rootpassword $node_rootpassword $global_cell_rootpassword $global_zfscell_rootpassword $global_switch_rootpassword ${a_cell_rootpassword[@]} ${a_zfs_rootpassword[@]} ${a_compute_rootpassword[@]} ${a_ib_switch_root_password[@]} ${mb_sysdba_pswd[@]} ${mb_pdb_sys_password[@]} ${a_node_passwords[@]}
  do
    if [ `echo "$a_password" | grep -c '[a-zA-Z]'` -gt "0" ] ; then
      a_password2=$(echo "$a_password"| $perl_exe -p -e 's/(.)/$1./g' |sed 's/.$//' |$perl_exe -p -e 's/([^A-Za-z0-9\\\.\n])/\\$1/g')
      a_password=$(echo "$a_password"| $perl_exe -p -e 's/([^A-Za-z0-9\n])/\\$1/g')
      remove_passwords_in_file $RAT_DEBUG_FILENAME_INTERNAL
      remove_passwords_in_file $OUTPUTDIR/log/watchdog.log
      for s_file in `ls $OUTPUTDIR/log/*.slave.log 2>/dev/null`
      do
        remove_passwords_in_file $s_file
      done
      if [[ -n "$RAT_DAEMONDEB_INTERNAL" && -f "$RAT_DAEMONDEB_INTERNAL" ]] ; then
        remove_passwords_in_file $RAT_DAEMONDEB_INTERNAL
      fi
      if [ -n "$RAT_CLIENT_RUN_LOG_INTERNAL" ] ; then
        remove_passwords_in_file $RAT_CLIENT_RUN_LOG_INTERNAL
      fi
    fi
  done
  remove_passwords_in_debug_called=1
}

function remove_passwords_in_file
{
  filen=$1
  $perl_exe -p -i -e "s/$a_password/${program_name}_password/g" $filen
  $perl_exe -p -i -e "s/$a_password2/${program_name}_password_slash/g" $filen
}

exit_status ()
{
  if [[ -n "$RAT_OUTPUT" && -n "$RAT_COPY_EM_XML_FILES" && $RAT_COPY_EM_XML_FILES -ge 1 ]];
  then
    let failed_checks=$G_FAIL_CHECKS+$G_WARN_CHECKS+$G_INFO_CHECKS
    let passed_checks=$G_TOTAL_CHECKS-$failed_checks
    if [[ $G_FAIL_CHECKS -gt 0 ]];
    then
      exit 3;	
    elif [[ $G_WARN_CHECKS -gt 0 && $G_INFO_CHECKS -gt 0 ]];
    then
      exit 2;
    elif [[ $G_WARN_CHECKS -le 0 && $G_INFO_CHECKS -gt 0 ]];
    then
      exit 1;
    elif [[ $passed_checks -eq $G_TOTAL_CHECKS ]];
    then
      exit 0;
    fi
  fi
}

function move_failed_to_skipped ()
{
  icode=$1
  imsg=$2
  idetail=$3
  ipchecks=$4

  #if [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 ]] && [[ -n $ipchecks && $ipchecks -eq "1" ]] && [[ -n $ipchecks && $ipchecks -eq "2" ]]; then
  if [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 ]] && [[ -n $ipchecks && $ipchecks -eq "1" ]]; then
    #Format:CheckId:Host:DBname:Returncode
   
    if [[ -n $PRET_STATUS && $PRET_STATUS -eq "0" ]]; then
      if [ -f "$t_PSQL_STAT" ]; then
        if [[ `grep -ic "^$CHECK_ID:$i:$db_name_to_check" "$t_PSQL_STAT"` -gt "0" ]]; then      
        #if [[ `grep -ic "$CHECK_ID:$i:$db_name_to_check" "$t_PSQL_STAT"` -gt "0" ]]; then      
          #if [[ $ipchecks -eq "2" ]] ; then
          #  status_line=$(grep "^Report:$CHECK_ID:$i:$db_name_to_check" "$t_PSQL_STAT"); 
          #else
          #  status_line=$(grep "^Execute:$CHECK_ID:$i:$db_name_to_check" "$t_PSQL_STAT"); 
          #fi
          status_line=$(grep "^$CHECK_ID:$i:$db_name_to_check" "$t_PSQL_STAT"); 

          #icode=$(echo "$status_line" | cut -d':' -f5)
          icode=$(echo "$status_line" | cut -d':' -f4)
          alvl=$(echo "$status_line" | cut -d':' -f5)

	  if [[ -n "$alvl" ]]; then ALVL=$alvl; fi
        
          if [[ -n $icode ]] ; then
            #if [[ $COMTYPE = "OS" || $COMTYPE = "SQL" || $COMTYPE = "SQL_COLLECT" ]] ; then
            if [[ $COMTYPE = "OS" || $COMTYPE = "SQL" ]]; then
              if [[ $icode -ne 0 ]]; then
                call_get_log_result=0;
                skip_this_version=1;

                let G_SKIP_CHECKS=$G_SKIP_CHECKS+1
                let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1; 
		validate_needs_running;
              fi
            fi
          fi
        fi
      fi
      return 
    else
      icode=$PRET_STATUS
    fi
  fi

  if [[ $icode -gt "100" ]] ; then
    reason_failed="was killed.";
  else
    reason_failed="failed with exit code $icode.";
  fi
  if [[ $icode -ne 0 ]];
  then
    call_get_log_result=0;			
    skip_this_version=1;
    if [[ -z "$3" ]];
    then
      if [[ -z "$2" ]];
      then
      	echo "skipping $audit_check_name(checkid:-$CHECK_ID) because audit check execution $reason_failed" >>$SKIPFIL
      else
      	echo "skipping $2 because audit check execution $reason_failed" >>$SKIPFIL
      fi
    else
      echo "[$idetail] skipping $audit_check_name(checkid:-$CHECK_ID) because audit check execution $reason_failed" >>$SKIPFIL
    fi
    let G_SKIP_CHECKS=$G_SKIP_CHECKS+1
    let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1; 
    validate_needs_running;
  fi
}

check_cascade_prompt ()
{
  echo -e "\n\nChecking for prompts in $PROFILE on $prompt_host for $usern user...\n\n"
  if [ "$prompt_host" = "$localnode" ]
  then
    chmod 744 $PRMPTORCLENVFIL >/dev/null 2>&1
    returncode=`. $PRMPTORCLENVFIL`
    returncode=$(echo $?)
   
  else
    $SCOPY $PRMPTORCLENVFIL $prompt_host:$RTEMPDIR >/dev/null 2>&1
    $SSHELL $prompt_host "chmod 744 $RTEMPDIR/prmpt_set_orcl_env_file.sh" >/dev/null 2>&1
    returncode=`$SSHELL $prompt_host "$RTEMPDIR/prmpt_set_orcl_env_file.sh"`
    returncode=$(echo $?)
  fi
    
  if [ $returncode -ne 0 ]
  then
    echo -e "${RED}There are prompts in $PROFILE on $prompt_host which will cause issues in $program_name successful execution. Please remove or comment all prompts in $PROFILE and run again\n\n"$NORM   
    exit 1 
  fi
}

check_hostname_mismatch ()
{
  #actual_hostname=$(hostname -s)
  actual_hostname=$(hostname|cut -d"." -f1)
  mgmt_hostname=$(grep -w `/sbin/ifconfig eth0|grep -w "inet"|awk '{print $2}'|cut -d: -f2` /etc/hosts|grep -v ^#|awk '{print $NF}'|cut -d. -f1|head -1)
  dns_hostname=$(/sbin/ifconfig eth0|grep -w "inet"|awk '{print $2}'|cut -d: -f2|nslookup 2>/dev/null|grep -w name|awk '{print $NF}'|cut -d. -f1)
  if [[ -n "$actual_hostname" && -n "$mgmt_hostname" && -n "$dns_hostname" && "$dns_hostname" = "$mgmt_hostname" && "$actual_hostname" != "$mgmt_hostname" ]]
  then
    echo -e "${RED}\n\nDefault hostname is not mapped to management network rather its mapped to client network.\n\nManagement network hostname = $mgmt_hostname\n\nDefault/client network hostnanme = $actual_hostname\n\n${program_name} is exiting.${NORM}\n\nrun ${program_name} with -clusternodes command line argument and specify comma separated management network hostnames.\n\neg ./${program_name} -clusternodes $mgmt_hostname,\n\n"
    exit 1
  else
    echo "value for check_hostname_mismatch actual_hostname=$actual_hostname mgmt_hostname=$mgmt_hostname dns_hostname=$dns_hostname">>$LOGFIL
  fi
}

update_location_file ()
{
  if [ ! -z "$MERGEFILES" ]; then return; fi;
  old_IFS=$IFS
  unset IFS
  locVersion=$(echo $modelVersion|tr -d ' ')
  for hname in `cat $HOSTLIST`
  do
    if [ $hname = $localnode ]
    then
      echo -e "#####${program_name} metadata#####" 2>>$ERRFIL  >$SIGNFIL
      echo -e "\ninstall node = ${localnode}" 2>>$ERRFIL  >>$SIGNFIL
      echo -e "\n${program_name} version = $locVersion" 2>>$ERRFIL >>$SIGNFIL
      echo -e "\nInstall location = $(dirname $ABSTPATH)" 2>>$ERRFIL >>$SIGNFIL
      echo -e "\nOutput location = ${WRKDIR}" 2>>$ERRFIL >>$SIGNFIL
      echo -e "\nLast run at = ${collection_date}" 2>>$ERRFIL >>$SIGNFIL
      if [[ -e $SIGNFIL && -e /tmp ]]; then mv -f $SIGNFIL /tmp/ >/dev/null 2>&1;fi
    else
      if [[ -e $SIGNFIL && -e /tmp ]]; then $SCOPY $SIGNFIL $hname:/tmp/ >/dev/null 2>&1;fi 
    fi 
  done
}

update_daemon_file ()
{
  old_IFS=$IFS
  unset IFS
  locVersion=$(echo $modelVersion|tr -d ' ')

  echo -e "">$DAEMONFIL
  echo -e "----------------------------------------------------------">>$DAEMONFIL
  echo -e "${program_name} daemon information">>$DAEMONFIL
  echo -e "----------------------------------------------------------">>$DAEMONFIL
  echo -e " \ninstall node = ${localnode}">>$DAEMONFIL
  echo -e " \n${program_name} daemon version = $locVersion">>$DAEMONFIL
  echo -e " \nInstall location = $(dirname $ABSTPATH)">>$DAEMONFIL
  echo -e " \nStarted at = $(date)">>$DAEMONFIL
}

function remove_preinitsetup ()
{
  if [ -e "$INITDMP" ]
  then
    assign_usern	
    for initentry in `cat $INITDMP`
    do
      rusern=$(echo "$initentry"|cut -d: -f2)
      rhostn=$(echo "$initentry"|cut -d: -f3)
  	
      if [ `echo "$initentry"|grep -ic "S:"` -gt 0 ]
      then
        dhostn=$localnode	
        $SSHELL -o StrictHostKeyChecking=no -x -l $rusern $rhostn "/bin/sh -c \"sed /$usern@$dhostn/d ~/.ssh/authorized_keys > ~/.ssh/authorized_keys.new; cp ~/.ssh/authorized_keys ~/.ssh/authorized_keys.initsetup.tmp; mv ~/.ssh/authorized_keys.new ~/.ssh/authorized_keys;\" >/dev/null 2>&1"
      elif [ `echo "$initentry"|grep -ic "P:"` -gt 0 ]
      then
        dhostn=$rhostn
        $SSHELL -o StrictHostKeyChecking=no -x -l $usern $rhostn "/usr/bin/ssh -o StrictHostKeyChecking=no -x -l $rusern $rhostn \"sed /$usern@$dhostn/d ~/.ssh/authorized_keys > ~/.ssh/authorized_keys.new; cp ~/.ssh/authorized_keys ~/.ssh/authorized_keys.initsetup.tmp; mv ~/.ssh/authorized_keys.new ~/.ssh/authorized_keys;\" >/dev/null 2>&1"
      fi
    done
  fi
}

function prepare_initsetup ()
{
  setup_status=1
  if [[ $OFFLINE -eq 0 ]]; then

  use_expect_for_ssh=0
  unset node_rootpassword
  unset passwordToCheck

  assign_usern
  
  usern2="$usern"
  usern="${root_user}"
  
  if [ `cat $HOSTLIST|wc -l` -gt 0 ] ; then echo -e "\n"; echo -e "Checking ssh user equivalency between $usern2 and $usern user on COMPUTE Nodes\n"; fi;

  if [[ -n "$RAT_COMPUTE_RUNMODE" && $RAT_COMPUTE_RUNMODE = "serial" ]]; then
  for hname in `cat $HOSTLIST`
  do
    platform=`uname -s`
    #if [ $platform = "Linux" ]
    #then
    #    PING="/bin/ping"
    #else
    #    PING="/usr/sbin/ping"
    #fi
    
    if [ $hname != $localnode ]
    then
      #if [ $platform = "SunOS" ]; then
      #   $PING -s $hname 5 5 >/dev/null 2>&1
      #elif [ $platform = "HP-UX" ]; then
      #     $PING $hname -n 5 -m 5 >/dev/null 2>&1
      #else
      #    $PING -c 1 $PING_W_FLAG $hname >/dev/null 2>&1
      #fi
      #exitcode=`echo $?`    
      test_node_reachability "$hname" "$usern";
      if [ $el_node_ping -eq "1" ] ; then
        exitcode=0;
      else
        exitcode=1;
      fi
    else
      exitcode=0
    fi

    if [[ $exitcode = 0 ]]
    then
      /usr/bin/ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -l $usern $hname ls 2>/dev/null 1>/dev/null
      ssh_setup_status=$?
      if [ $ssh_setup_status -ne 0 ]
      then
        if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]] || [[ -n "$is_bda_machine" && $is_bda_machine -eq 1 ]]
        then
          rsh_setup_status=1
        else
          rsh -l $usern $hname ls 2>/dev/null 1>/dev/null
          rsh_setup_status=$?
          if [ $rsh_setup_status -eq 0 ];then SSHELL=rsh;SCOPY=rcp;fi
        fi
      fi

      if [[ $ssh_setup_status -eq 0 || $rsh_setup_status -eq 0 ]]
      then
	echo -e $GREEN"$usern user equivalence is configured between $localnode and $hname." $NORM
      else
	if [[ $use_expect_for_ssh -eq 0 ]]
	then
	  echo -e ${RED}"\n$usern user equivalence is not setup between $localnode and $hname."${NORM}
	  exec 3<&2; exec 2<&0
	  $READ -p "Do you want to configure $usern user equivalence between $localnode and $hname [y/n][y]" AutoLoginCheck
	  read_code=`echo $?`;
	  exec 2<&3
	  process_prompt "$read_code" "AutoLoginCheck" "n"
	fi

        case $AutoLoginCheck in
	y|Y|YES|yes|Yes)
          if [[ -z "$compute_samerootpassword_YesNo" ]]
          then
            compute_samerootpassword_YesNo="y"
            echo -e "\n"
	    exec 3<&2; exec 2<&0
            $READ -p  "Is ${usern} password same on all COMPUTE Nodes?[y/n][y]" compute_samerootpassword_YesNo
	    read_code=`echo $?`;
	    exec 2<&3
	    process_prompt "$read_code" "compute_samerootpassword_YesNo" "y"
          fi

          case $compute_samerootpassword_YesNo in
          y|Y|Yes|YES|yes)
            compute_samerootpassword_YesNo="y"
            if [[ -z "$global_compute_rootpassword" ]]
            then
              printf  "Enter ${usern} password :- "
              tty -s && stty -echo
              $READ -r global_compute_rootpassword
              tty -s && stty echo
            fi

            printf "\n\nVerifying ${usern} password.\n\n. .\n";
            checkUserPassword "$hname" "$usern" "$global_compute_rootpassword" "3"
	      	
  	    if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
	    then
              func_setup_ssh -user $usern -hosts "$hname"
              if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
              then
                echo -e $RED"$hname: Failed to setup $usern user equivalency."$NORM;
                echo -e $RED"\nWithout user eqivalency, no $usern collections and audit checks will be executed on $hname\n"$NORM;
                setup_status=0
                return
              else
                global_compute_rootpassword=$passwordToCheck
                echo -e $GREEN"\n$usern user equivalence is not setup between $localnode and $hname\n"$NORM;
		echo "S:$usern:$hname" >> $INITDMP
              fi
            else
              echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
              echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
              setup_status=0
              return
            fi
	  ;;
          n|N|No|NO|no)
            compute_samerootpassword_YesNo="n"
            printf  "Enter ${hname} ${usern} password :- "
            tty -s && stty -echo
            $READ -r compute_rootpassword
            tty -s && stty echo
            printf "\n\nVerifying ${usern} password.\n\n. .\n";
            checkUserPassword "$hname" "$usern" "$compute_rootpassword" "3"

            if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
            then
              func_setup_ssh -user $usern -hosts "$hname"
              if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
              then
                echo -e $RED"$hname: Failed to setup $usern user equivalency."$NORM;
                echo -e $RED"\nWithout user eqivalency, no $usern collections and audit checks will be executed on $hname\n"$NORM;
                setup_status=0
                return
              else
                global_compute_rootpassword=$passwordToCheck
                echo -e $GREEN"\n$usern user equivalence is not setup between $localnode and $hname\n"$NORM;
		echo "S:$usern:$hname" >> $INITDMP
              fi
            else
              echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
              echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
              setup_status=0
              return
            fi
          ;;
          *)
            compute_samerootpassword_YesNo="y"
            if [[ -z "$global_compute_rootpassword" ]]
            then
              printf  "Enter ${usern} password :- "
              tty -s && stty -echo
              $READ -r global_compute_rootpassword
              tty -s && stty echo
            fi

            printf "\n\nVerifying ${usern} password.\n\n. .\n";
            checkUserPassword "$hname" "$usern" "$global_compute_rootpassword" "3"
	      	
  	    if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
	    then
              func_setup_ssh -user $usern -hosts "$hname"
              if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
              then
                echo -e $RED"$hname: Failed to setup $usern user equivalency."$NORM;
                echo -e $RED"\nWithout user eqivalency, no $usern collections and audit checks will be executed on $hname\n"$NORM;
                setup_status=0
                return
              else
                global_compute_rootpassword=$passwordToCheck
                echo -e $GREEN"\n$usern user equivalence is not setup between $localnode and $hname\n"$NORM;
		echo "S:$usern:$hname" >> $INITDMP
              fi
            else
              echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
              echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
              setup_status=0
              return
            fi
	  ;;
	esac
	;;
	n|N|NO|No|no)
          compute_samerootpassword_YesNo="n"
          echo -e $RED"\nWithout $usern user eqivalency, no $usern collections and audit checks will be executed on $hname\n"$NORM;
          setup_status=0
          return
	;;
	*)
          if [[ -z "$compute_samerootpassword_YesNo" ]]
          then
            compute_samerootpassword_YesNo="y"
            echo -e "\n"
	    exec 3<&2; exec 2<&0
            $READ -p  "Is ${usern} password same on all COMPUTE Nodes?[y/n][y]" compute_samerootpassword_YesNo
	    read_code=`echo $?`;
	    exec 2<&3
	    process_prompt "$read_code" "compute_samerootpassword_YesNo" "y"
          fi

          case $compute_samerootpassword_YesNo in
          y|Y|Yes|YES|yes)
            compute_samerootpassword_YesNo="y"
            if [[ -z "$global_compute_rootpassword" ]]
            then
              printf  "Enter ${usern} password :- "
              tty -s && stty -echo
              $READ -r global_compute_rootpassword
              tty -s && stty echo
            fi

            printf "\n\nVerifying ${usern} password.\n\n. .\n";
            checkUserPassword "$hname" "$usern" "$global_compute_rootpassword" "3"
	      	
  	    if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
	    then
              func_setup_ssh -user $usern -hosts "$hname"
              if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
              then
                echo -e $RED"$hname: Failed to setup $usern user equivalency."$NORM;
                echo -e $RED"\nWithout user eqivalency, no $usern collections and audit checks will be executed on $hname\n"$NORM;
                setup_status=0
                return
              else
                global_compute_rootpassword=$passwordToCheck
                echo -e $GREEN"\n$usern user equivalence is not setup between $localnode and $hname\n"$NORM;
		echo "S:$usern:$hname" >> $INITDMP
              fi
            else
              echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
              echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
              setup_status=0
              return
            fi
	  ;;
          n|N|No|NO|no)
            compute_samerootpassword_YesNo="n"
            printf  "Enter ${hname} ${usern} password :- "
            tty -s && stty -echo
            $READ -r compute_rootpassword
            tty -s && stty echo
            printf "\n\nVerifying ${usern} password.\n\n. .\n";
            checkUserPassword "$hname" "$usern" "$compute_rootpassword" "3"

            if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
            then
              func_setup_ssh -user $usern -hosts "$hname"
              if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
              then
                echo -e $RED"$hname: Failed to setup $usern user equivalency."$NORM;
                echo -e $RED"\nWithout user eqivalency, no $usern collections and audit checks will be executed on $hname\n"$NORM;
                setup_status=0
                return
              else
                global_compute_rootpassword=$passwordToCheck
                echo -e $GREEN"\n$usern user equivalence is not setup between $localnode and $hname\n"$NORM;
		echo "S:$usern:$hname" >> $INITDMP
              fi
            else
              echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
              echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
              setup_status=0
              return
            fi
          ;;
          *)
            compute_samerootpassword_YesNo="y"
            if [[ -z "$global_compute_rootpassword" ]]
            then
              printf  "Enter ${usern} password :- "
              tty -s && stty -echo
              $READ -r global_compute_rootpassword
              tty -s && stty echo
            fi

            printf "\n\nVerifying ${usern} password.\n\n. .\n";
            checkUserPassword "$hname" "$usern" "$global_compute_rootpassword" "3"
	      	
  	    if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
	    then
              func_setup_ssh -user $usern -hosts "$hname"
              if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
              then
                echo -e $RED"$hname: Failed to setup $usern user equivalency."$NORM;
                echo -e $RED"\nWithout user eqivalency, no $usern collections and audit checks will be executed on $hname\n"$NORM;
                setup_status=0
                return
              else
                global_compute_rootpassword=$passwordToCheck
                echo -e $GREEN"\n$usern user equivalence is not setup between $localnode and $hname\n"$NORM;
		echo "S:$usern:$hname" >> $INITDMP
              fi
            else
              echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
              echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
              setup_status=0
              return
            fi
	  ;;
	esac
	;;
	esac
      fi
    else
      echo ${RED}"Node $hname is not pingable so, no audit checks will be executed on $hname"${NORM}
    fi
  done
  else
  #parallel setup
  
  if [[ "$usern2" = "${root_user}" ]] 
  then
  for hname in `cat $HOSTLIST`
  do
    echo -e $GREEN"Node $hname is configured for ssh user equivalency between $usern2 and $usern user\n" $NORM
    echo -e ""
  done
  else
  for hname in `cat $HOSTLIST`
  do
    platform=`uname -s`
    #if [ $platform = "Linux" ]
    #then
    #    PING="/bin/ping"
    #else
    #    PING="/usr/sbin/ping"
    #fi
  
    PubkeyAuthentication="no"
    if [ $hname != $localnode ]
    then
      #if [ $platform = "SunOS" ]; then
      #   $PING -s $hname 5 5 >/dev/null 2>&1
      #elif [ $platform = "HP-UX" ]; then
      #     $PING $hname -n 5 -m 5 >/dev/null 2>&1
      #else
      #    $PING -c 1 $PING_W_FLAG $hname >/dev/null 2>&1
      #fi
      #exitcode=`echo $?`    
      test_node_reachability "$hname" "$usern";
      if [ $el_node_ping -eq "1" ] ; then
        exitcode=0;
      else
        exitcode=1;
      fi

      if [[ $exitcode = 0 ]]
      then
  	$SSHELL $usern2@$hname "/usr/bin/ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -l $usern $hname ls 2>/dev/null 1>/dev/null"
	ssh_setup_status=$?
        if [ $ssh_setup_status -ne 0 ]
        then
          if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]] || [[ -n "$is_bda_machine" && $is_bda_machine -eq 1 ]]
          then
            rsh_setup_status=1
          else
            $SSHELL $usern2@$hname "rsh -l $usern $hname ls 2>/dev/null 1>/dev/null"
            rsh_setup_status=$?
            if [ $rsh_setup_status -eq 0 ];then SSHELL=rsh;SCOPY=rcp;fi
          fi
        fi		
        if [[ $ssh_setup_status -eq 0 || $rsh_setup_status -eq 0 ]]
        then
          echo -e $GREEN"Node $hname is configured for ssh user equivalency between $usern2 and $usern user\n" $NORM
        else
          if [[ $use_expect_for_ssh -eq 0 ]]
          then
            echo -e $RED"$hname is not configured for ssh user equivalency between $usern2 and $usern user\n"$NORM;
	    exec 3<&2; exec 2<&0
            $READ -p "Do you want to configure SSH for between $usern2 and $usern user on $hname [y/n][y]" AutoLoginCheck
	    read_code=`echo $?`;
	    exec 2<&3
	    process_prompt "$read_code" "AutoLoginCheck" "n"
          fi

          case $AutoLoginCheck in
          y|Y|YES|yes|Yes)
            AutoLoginCheckYes=1 
	    use_expect_for_ssh=1

	    if [[ -z "$compute_samerootpassword_YesNo" ]]
            then
              compute_samerootpassword_YesNo="y"
    	      echo -e "\n"
	      exec 3<&2; exec 2<&0
	      $READ -p  "Is ${usern} password same on all COMPUTE Nodes?[y/n][y]" compute_samerootpassword_YesNo
	      read_code=`echo $?`;
	      exec 2<&3
	      process_prompt "$read_code" "compute_samerootpassword_YesNo" "y"
            fi

	    case $compute_samerootpassword_YesNo in
	    y|Y|Yes|YES|yes)
	      compute_samerootpassword_YesNo="y"
	      if [[ -z "$global_compute_rootpassword" ]]
              then
	        printf  "Enter ${usern} password :- "
	        tty -s && stty -echo
	        $READ -r global_compute_rootpassword
	        tty -s && stty echo
	      fi

	      printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      checkUserPassword "$hname" "$usern" "$global_compute_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
    	        echo -e "\n"
		$SSHELL $usern2@$hname "mkdir ${RTEMPDIR} >/dev/null 2>&1"
		$SCOPY $program_name $usern2@$hname:${RTEMPDIR} >/dev/null 2>&1
		$SSHELL $usern2@$hname "chmod 744 ${RTEMPDIR}/$program_name;"

                $EXPECT -f - << IBEOF
                log_user 0
                if { "$RAT_EXPECT_DEBUG" == "-d" } {
                  exp_internal 1
                }
                set timeout $watchdog_wakeup
                set le_compute_rootpassword "$passwordToCheck"
                spawn -noecho $SSHELL $usern2@$hname "${RTEMPDIR}/${program_name} -setupssh $usern $hname"
                match_max 100000
                expect {
                -nocase eof {
                        exit 0
                }
		-nocase "permission denied *" {
		   exit 4;
		}
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect {
                -nocase eof {
                        exit 0
                }
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect -nocase eof
                exit
IBEOF
		remoteStatus=$(echo $?)
		if [[ -n "$remoteStatus" && "$remoteStatus" -eq "2" ]]
                then
		  echo -e $GREEN"\nNode $hname has been configured for ssh user equivalency between $usern2 and $usern user\n"$NORM;
		  echo "P:$usern:$hname" >> $INITDMP
		else
            	  echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	          echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	  setup_status=0
	    	  return
		fi
	      else
            	echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	        echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	setup_status=0
	    	return
              fi
	    ;;
	    n|N|No|NO|no)
	      compute_samerootpassword_YesNo="n"
	      printf  "Enter ${hname} ${usern} password :- "
	      tty -s && stty -echo
	      $READ -r compute_rootpassword
	      tty -s && stty echo

	      printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      checkUserPassword "$hname" "$usern" "$compute_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
    	        echo -e "\n"
		$SSHELL $usern2@$hname "mkdir ${RTEMPDIR} >/dev/null 2>&1"
		$SCOPY $program_name $usern2@$hname:${RTEMPDIR} >/dev/null 2>&1
		$SSHELL $usern2@$hname "chmod 744 ${RTEMPDIR}/$program_name;"

                $EXPECT -f - << IBEOF
                log_user 0
                if { "$RAT_EXPECT_DEBUG" == "-d" } {
                  exp_internal 1
                }
                set timeout $watchdog_wakeup
                set le_compute_rootpassword "$passwordToCheck"
                spawn -noecho $SSHELL $usern2@$hname "${RTEMPDIR}/${program_name} -setupssh $usern $hname"
                match_max 100000
                expect {
                -nocase eof {
                        exit 0
                }
		-nocase "permission denied *" {
		   exit 4;
		}
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect {
                -nocase eof {
                        exit 0
                }
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect -nocase eof
                exit
IBEOF
		remoteStatus=$(echo $?)
		if [[ -n "$remoteStatus" && "$remoteStatus" -eq "2" ]]
                then
		  echo -e $GREEN"\nNode $hname has been configured for ssh user equivalency between $usern2 and $usern user\n"$NORM;
		  echo "P:$usern:$hname" >> $INITDMP
		else
            	  echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	          echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	  setup_status=0
	    	  return
		fi
	      else
            	echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	        echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	setup_status=0
	    	return
              fi
	    ;;
	    *)
	      compute_samerootpassword_YesNo="y"
	      if [[ -z "$global_compute_rootpassword" ]]
              then
	        printf  "Enter ${usern} password :- "
	        tty -s && stty -echo
	        $READ -r global_compute_rootpassword
	        tty -s && stty echo
	      fi

	      printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      checkUserPassword "$hname" "$usern" "$global_compute_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
    	        echo -e "\n"
		$SSHELL $usern2@$hname "mkdir ${RTEMPDIR} >/dev/null 2>&1"
		$SCOPY $program_name $usern2@$hname:${RTEMPDIR} >/dev/null 2>&1
		$SSHELL $usern2@$hname "chmod 744 ${RTEMPDIR}/$program_name;"

                $EXPECT -f - << IBEOF
                log_user 0
                if { "$RAT_EXPECT_DEBUG" == "-d" } {
                  exp_internal 1
                }
                set timeout $watchdog_wakeup
                set le_compute_rootpassword "$passwordToCheck"
                spawn -noecho $SSHELL $usern2@$hname "${RTEMPDIR}/${program_name} -setupssh $usern $hname"
                match_max 100000
                expect {
                -nocase eof {
                        exit 0
                }
		-nocase "permission denied *" {
		   exit 4;
		}
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect {
                -nocase eof {
                        exit 0
                }
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect -nocase eof
                exit
IBEOF
		remoteStatus=$(echo $?)
		if [[ -n "$remoteStatus" && "$remoteStatus" -eq "2" ]]
                then
		  echo -e $GREEN"\nNode $hname has been configured for ssh user equivalency between $usern2 and $usern user\n"$NORM;
		  echo "P:$usern:$hname" >> $INITDMP
		else
            	  echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	          echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	  setup_status=0
	    	  return
		fi
	      else
            	echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	        echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	setup_status=0
	    	return
              fi
	    ;;
	    esac
          ;;
          n|N|NO|No|no)
            echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	    setup_status=0
	    return
          ;;
          *)
            AutoLoginCheckYes=1 
	    use_expect_for_ssh=1

	    if [[ -z "$compute_samerootpassword_YesNo" ]]
            then
              compute_samerootpassword_YesNo="y"
    	      echo -e "\n"
	      exec 3<&2; exec 2<&0
	      $READ -p  "Is ${usern} password same on all COMPUTE Nodes?[y/n][y]" compute_samerootpassword_YesNo
	      read_code=`echo $?`;
	      exec 2<&3
	      process_prompt "$read_code" "compute_samerootpassword_YesNo" "y"
            fi

	    case $compute_samerootpassword_YesNo in
	    y|Y|Yes|YES|yes)
	      compute_samerootpassword_YesNo="y"
	      if [[ -z "$global_compute_rootpassword" ]]
              then
	        printf  "Enter ${usern} password :- "
	        tty -s && stty -echo
	        $READ -r global_compute_rootpassword
	        tty -s && stty echo
	      fi

	      printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      checkUserPassword "$hname" "$usern" "$global_compute_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
    	        echo -e "\n"
		$SSHELL $usern2@$hname "mkdir ${RTEMPDIR} >/dev/null 2>&1"
		$SCOPY $program_name $usern2@$hname:${RTEMPDIR} >/dev/null 2>&1
		$SSHELL $usern2@$hname "chmod 744 ${RTEMPDIR}/$program_name;"

                $EXPECT -f - << IBEOF
                log_user 0
                if { "$RAT_EXPECT_DEBUG" == "-d" } {
                  exp_internal 1
                }
                set timeout $watchdog_wakeup
                set le_compute_rootpassword "$passwordToCheck"
                spawn -noecho $SSHELL $usern2@$hname "${RTEMPDIR}/${program_name} -setupssh $usern $hname"
                match_max 100000
                expect {
                -nocase eof {
                        exit 0
                }
		-nocase "permission denied *" {
		   exit 4;
		}
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect {
                -nocase eof {
                        exit 0
                }
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect -nocase eof
                exit
IBEOF
		remoteStatus=$(echo $?)
		if [[ -n "$remoteStatus" && "$remoteStatus" -eq "2" ]]
                then
		  echo -e $GREEN"\nNode $hname has been configured for ssh user equivalency between $usern2 and $usern user\n"$NORM;
		  echo "P:$usern:$hname" >> $INITDMP
		else
            	  echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	          echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	  setup_status=0
	    	  return
		fi
	      else
            	echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	        echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	setup_status=0
	    	return
              fi
	    ;;
	    n|N|No|NO|no)
	      compute_samerootpassword_YesNo="n"
	      printf  "Enter ${hname} ${usern} password :- "
	      tty -s && stty -echo
	      $READ -r compute_rootpassword
	      tty -s && stty echo

	      printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      checkUserPassword "$hname" "$usern" "$compute_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
    	        echo -e "\n"
		$SSHELL $usern2@$hname "mkdir ${RTEMPDIR} >/dev/null 2>&1"
		$SCOPY $program_name $usern2@$hname:${RTEMPDIR} >/dev/null 2>&1
		$SSHELL $usern2@$hname "chmod 744 ${RTEMPDIR}/$program_name;"

                $EXPECT -f - << IBEOF
                log_user 0
                if { "$RAT_EXPECT_DEBUG" == "-d" } {
                  exp_internal 1
                }
                set timeout $watchdog_wakeup
                set le_compute_rootpassword "$passwordToCheck"
                spawn -noecho $SSHELL $usern2@$hname "${RTEMPDIR}/${program_name} -setupssh $usern $hname"
                match_max 100000
                expect {
                -nocase eof {
                        exit 0
                }
		-nocase "permission denied *" {
		   exit 4;
		}
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect {
                -nocase eof {
                        exit 0
                }
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect -nocase eof
                exit
IBEOF
		remoteStatus=$(echo $?)
		if [[ -n "$remoteStatus" && "$remoteStatus" -eq "2" ]]
                then
		  echo -e $GREEN"\nNode $hname has been configured for ssh user equivalency between $usern2 and $usern user\n"$NORM;
		  echo "P:$usern:$hname" >> $INITDMP
		else
            	  echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	          echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	  setup_status=0
	    	  return
		fi
	      else
            	echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	        echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	setup_status=0
	    	return
              fi
	    ;;
	    *)
	      compute_samerootpassword_YesNo="y"
	      if [[ -z "$global_compute_rootpassword" ]]
              then
	        printf  "Enter ${usern} password :- "
	        tty -s && stty -echo
	        $READ -r global_compute_rootpassword
	        tty -s && stty echo
	      fi

	      printf "\n\nVerifying ${usern} password.\n\n. .\n";
	      checkUserPassword "$hname" "$usern" "$global_compute_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
    	        echo -e "\n"
		$SSHELL $usern2@$hname "mkdir ${RTEMPDIR} >/dev/null 2>&1"
		$SCOPY $program_name $usern2@$hname:${RTEMPDIR} >/dev/null 2>&1
		$SSHELL $usern2@$hname "chmod 744 ${RTEMPDIR}/$program_name;"

                $EXPECT -f - << IBEOF
                log_user 0
                if { "$RAT_EXPECT_DEBUG" == "-d" } {
                  exp_internal 1
                }
                set timeout $watchdog_wakeup
                set le_compute_rootpassword "$passwordToCheck"
                spawn -noecho $SSHELL $usern2@$hname "${RTEMPDIR}/${program_name} -setupssh $usern $hname"
                match_max 100000
                expect {
                -nocase eof {
                        exit 0
                }
		-nocase "permission denied *" {
		   exit 4;
		}
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect {
                -nocase eof {
                        exit 0
                }
                -nocase "no)?" {
                        send -- "yes\r"
                }
                "Enter*password*:" {
                        send -- "\$le_compute_rootpassword\r"
                }
                "*Successfully setup SSH*" {
                        exit 2
                }
                "*SSH setup failed*" {
                        exit 3
                }
                -nocase timeout {
                   send_error "Timed out while setting up SSH equivalency between ${usern2} and ${usern} on $hname"
                   exit 4
                }
                }
                expect -nocase eof
                exit
IBEOF
		remoteStatus=$(echo $?)
		if [[ -n "$remoteStatus" && "$remoteStatus" -eq "2" ]]
                then
		  echo -e $GREEN"\nNode $hname has been configured for ssh user equivalency between $usern2 and $usern user\n"$NORM;
		  echo "P:$usern:$hname" >> $INITDMP
		else
            	  echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	          echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	  setup_status=0
	    	  return
		fi
	      else
            	echo -e $RED"$hname: Failed to setup ssh user equivalency between $usern2 and $usern."$NORM;
	        echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	 	setup_status=0
	    	return
              fi
	    ;;
	    esac
          ;;
          esac
	fi
      else
        echo ${RED}"Node $hname is not pingable so, no audit checks will be executed on $hname"${NORM}
      fi
    else
      /usr/bin/ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -l $usern $hname ls 2>/dev/null 1>/dev/null
      ssh_setup_status=$?
      if [ $ssh_setup_status -ne 0 ]
      then
        if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]] || [[ -n "$is_bda_machine" && $is_bda_machine -eq 1 ]]
        then
          rsh_setup_status=1
        else
          rsh -l $usern $hname ls 2>/dev/null 1>/dev/null
          rsh_setup_status=$?
          if [ $rsh_setup_status -eq 0 ];then SSHELL=rsh;SCOPY=rcp;fi
        fi
      fi
    
      if [[ $ssh_setup_status -eq 0 || $rsh_setup_status -eq 0 ]]
      then
        echo -e $GREEN"Node $hname is configured for ssh user equivalency between $usern2 and $usern user\n" $NORM
      else
        if [[ $use_expect_for_ssh -eq 0 ]]
        then
          echo -e $RED"$hname is not configured for ssh user equivalency between $usern2 and $usern user\n"$NORM;
	  exec 3<&2; exec 2<&0
          $READ -p "Do you want to configure SSH between $usern and $usern2 user on $hname [y/n][y]" AutoLoginCheck
	  read_code=`echo $?`;
	  exec 2<&3
	  process_prompt "$read_code" "AutoLoginCheck" "n"
        fi
  
	compute_samerootpassword_YesNo="y"
        case $AutoLoginCheck in
        y|Y|YES|yes|Yes)
          AutoLoginCheckYes=1 

    	  echo -e "\n"
	  exec 3<&2; exec 2<&0
	  $READ -p  "Is ${usern} password same on all COMPUTE Nodes?[y/n][y]" compute_samerootpassword_YesNo
	  read_code=`echo $?`;
	  exec 2<&3
	  process_prompt "$read_code" "compute_samerootpassword_YesNo" "y"

	  if [[ -z "$compute_samerootpassword_YesNo" ]]
          then
	    compute_samerootpassword_YesNo="y"
	  fi

          func_setup_ssh -user $usern -hosts "$hname" 
          if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
          then
            echo -e $RED"$hname: Failed to setup ssh user equivalency."$NORM;
            echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	    setup_status=0
	    return
	  else
	    global_compute_rootpassword=$passwordToCheck
	    echo -e $GREEN"\nNode $hname has been configured for ssh user equivalency between $usern2 and $usern user\n"$NORM;
 	    echo "S:$usern:$hname" >> $INITDMP
          fi
        ;;
        n|N|NO|No|no)
          echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	  setup_status=0
	  return
        ;;
        *)
          AutoLoginCheckYes=1 

    	  echo -e "\n"
	  exec 3<&2; exec 2<&0
	  $READ -p  "Is ${usern} password same on all COMPUTE Nodes?[y/n][y]" compute_samerootpassword_YesNo
	  read_code=`echo $?`;
	  exec 2<&3
	  process_prompt "$read_code" "compute_samerootpassword_YesNo" "y"

	  if [[ -z "$compute_samerootpassword_YesNo" ]]
          then
	    compute_samerootpassword_YesNo="y"
	  fi

          func_setup_ssh -user $usern -hosts "$hname" 
          if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
          then
            echo -e $RED"$hname: Failed to setup ssh user equivalency."$NORM;
            echo -e $RED"\nWithout ssh user eqivalency, no collections and audit checks will be executed on $hname\n"$NORM;
  	    setup_status=0
	    return
	  else
	    global_compute_rootpassword=$passwordToCheck
	    echo -e $GREEN"\nNode $hname has been configured for ssh user equivalency between $usern2 and $usern user\n"$NORM;
 	    echo "S:$usern:$hname" >> $INITDMP
          fi
        ;;
        esac
      fi
    fi
  done
  fi
  fi
  
  use_expect_for_ssh=0
  unset node_rootpassword
  unset passwordToCheck
  if [[ -z "$RAT_CELLS" && -n $snlist_file && -e "$snlist_file" ]]
  then
      for cellname in `cat $snlist_file`
      do
         echo "cell=\"$cellname\"">>$INPUTDIR/cellip.ora
      done
      CELLIP=$INPUTDIR/cellip.ora
  elif [ -z "$RAT_CELLS" ]
  then
      CELLIP=/etc/oracle/cell/network-config/cellip.ora
  else
      for cellname in `echo $RAT_CELLS`
      do
         echo "cell=\"$cellname\"">>$INPUTDIR/cellip.ora
      done
      CELLIP=$INPUTDIR/cellip.ora
  fi
  is_this_db_machine $localnode

  ask_cell_password=1 
  PubkeyAuthentication=""
  if [[ $db_machine_compute -eq 1  || $dbm_x2_2 -eq 1 || $dbm_x3_2 -eq 1  || $dbm_x2_8 -eq 1 || $dbm_v2 -eq 1 ]] && [ $TYP != "-p" ] && [[ -n "$skip_in_silent" && $skip_in_silent -eq 0 ]] && [ "$upgrade_mode" -ne "3" ] && [ $only_hacheck_run -eq 0 ] && [ $ask_cell_password -eq "1" ] && [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "0" ]] && [ -e "$CELLIP" ]
  then
    if [ -z "$RAT_CELL_SSH_USER" ];then cell_ssh_user="root"; else cell_ssh_user=$RAT_CELL_SSH_USER;fi
    usern=$cell_ssh_user
    cell_type="normal"
    
    if [[ -n " $is_exalogic_machine" &&  $is_exalogic_machine -eq "1" ]]
    then
      cell_type="zfscell"
    fi
  
    #sed '/^\s*$/d' $CELLIP > $CELLIP.new
    #mv -f $CELLIP.new $CELLIP
    if [ `cat $CELLIP|wc -l` -gt 0 ] ; then echo -e "\n\nChecking ssh user equivalency between $usern2 and $cell_ssh_user user on STORAGE Servers\n"; fi;
  
    for hname in `cat $CELLIP|sed '/^\s*$/d'|cut -d\" -f2|cut -d\; -f2`
    do
      #cellPingStatus=$($PING -c 1 $PING_W_FLAG $hname >/dev/null 2>&1;echo $?)
      test_node_reachability "$hname" "$cell_ssh_user";
      if [ $el_node_ping -eq "1" ] ; then
        cellPingStatus=0;
      else
        cellPingStatus=1;
      fi
    
      if [ $cellPingStatus -eq 0 ]
      then 
        cell_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $cell_ssh_user $hname ls >/dev/null 2>&1;echo $?);
	cell_password_status=0
        
        if [[ $cell_ssh_status -eq 0 ]]
        then
          echo -e $GREEN"$hname is configured for ssh user equivalency for $cell_ssh_user user\n" $NORM;
        else
          if [[ $use_expect_for_ssh -eq 0 ]]
          then
            echo -e $RED"$hname is not configured for ssh user equivalency for $cell_ssh_user user\n"$NORM;
	    exec 3<&2; exec 2<&0
            $READ -p "Do you want to configure SSH for user $cell_ssh_user on $hname [y/n][y]" AutoLoginCheck
	    read_code=`echo $?`;
	    exec 2<&3
	    process_prompt "$read_code" "AutoLoginCheck" "n"
          fi
          
          case $AutoLoginCheck in
          y|Y|YES|yes|Yes)
	    AutoLoginCheckYes=1
            if [[ -z "$cell_samerootpassword_YesNo" ]]
            then
              cell_samerootpassword_YesNo="y"
              echo -e "\n"
	      exec 3<&2; exec 2<&0
              $READ -p  "Is ${usern} password same on all STORAGE Servers?[y/n][y]" cell_samerootpassword_YesNo
	      read_code=`echo $?`;
	      exec 2<&3
	      process_prompt "$read_code" "cell_samerootpassword_YesNo" "y"
            fi

            case $cell_samerootpassword_YesNo in
            y|Y|Yes|YES|yes)
              cell_samerootpassword_YesNo="y"
              if [[ -z "$global_cell_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
                $READ -r global_cell_rootpassword
		read_code=`echo $?`;
                tty -s && stty echo
		process_prompt "$read_code" "global_cell_rootpassword" "y"
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
              checkUserPassword "$hname" "$usern" "$global_cell_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $cell_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
		  echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
                  global_cell_rootpassword=$passwordToCheck
                  cell_password_status=1
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $cell_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
		echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
            n|N|No|NO|no)
              cell_samerootpassword_YesNo="n"
              printf  "Enter ${hname} ${usern} password :- "
              tty -s && stty -echo
              $READ -r cell_rootpassword
              tty -s && stty echo

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
              checkUserPassword "$hname" "$usern" "$cell_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $cell_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
		  echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
                  global_cell_rootpassword=$passwordToCheck
                  cell_password_status=1
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $cell_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
		echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
	    *)
              cell_samerootpassword_YesNo="y"
              if [[ -z "$global_cell_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
                $READ -r global_cell_rootpassword
                tty -s && stty echo
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
              checkUserPassword "$hname" "$usern" "$global_cell_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $cell_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
		  echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
                  global_cell_rootpassword=$passwordToCheck
                  cell_password_status=1
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $cell_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
		echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
	    esac
          ;;
          n|N|NO|No|no)
            echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
	    setup_status=0
	    return
          ;;
          *)
	    AutoLoginCheckYes=1
            if [[ -z "$cell_samerootpassword_YesNo" ]]
            then
              cell_samerootpassword_YesNo="y"
              echo -e "\n"
	      exec 3<&2; exec 2<&0
              $READ -p  "Is ${usern} password same on all STORAGE Servers?[y/n][y]" cell_samerootpassword_YesNo
	      read_code=`echo $?`;
	      exec 2<&3
	      process_prompt "$read_code" "cell_samerootpassword_YesNo" "y"
            fi

            case $cell_samerootpassword_YesNo in
            y|Y|Yes|YES|yes)
              cell_samerootpassword_YesNo="y"
              if [[ -z "$global_cell_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
                $READ -r global_cell_rootpassword
                tty -s && stty echo
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
              checkUserPassword "$hname" "$usern" "$global_cell_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $cell_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
		  echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
                  global_cell_rootpassword=$passwordToCheck
                  cell_password_status=1
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $cell_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
		echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
            n|N|No|NO|no)
              cell_samerootpassword_YesNo="n"
              printf  "Enter ${hname} ${usern} password :- "
              tty -s && stty -echo
              $READ -r cell_rootpassword
              tty -s && stty echo
              printf "\n\nVerifying ${usern} password.\n\n. .\n";
              checkUserPassword "$hname" "$usern" "$cell_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $cell_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
		  echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
                  global_cell_rootpassword=$passwordToCheck
                  cell_password_status=1
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $cell_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
		echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
	    *)
              cell_samerootpassword_YesNo="y"
              if [[ -z "$global_cell_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
                $READ -r global_cell_rootpassword
		read_code=`echo $?`;
                tty -s && stty echo
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
              checkUserPassword "$hname" "$usern" "$global_cell_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $cell_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
		  echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
                  global_cell_rootpassword=$passwordToCheck
                  cell_password_status=1
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $cell_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
		echo -e $RED"$hname: Failed to setup ssh user equivalency for $cell_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
	    esac
          ;;
          esac
        fi
      else
        echo -e $RED"\nSTORAGE Server $hname is not pingable, no audit checks will be executed on $hname\n"$NORM;
      fi
    done
    
    if [[ -n "$cell_password_status" && $cell_password_status -eq 0 && "$cell_ssh_user" = "root" && -z "$RAT_IBSWITCHES" ]]
    then
      first_cell_ip=$(cat $CELLIP|cut -d\" -f2|cut -d\; -f2|head -1)
      $SSHELL $cell_ssh_user@$first_cell_ip "rm -rf ${CELLRTEMPDIR} >/dev/null 2>&1"
      $SSHELL $cell_ssh_user@$first_cell_ip "mkdir ${CELLRTEMPDIR} >/dev/null 2>&1"
      $SSHELL $cell_ssh_user@$first_cell_ip "ibswitches 2>/dev/null >${CELLRTEMPDIR}/o_ibswitches_full.out"
      $SSHELL $cell_ssh_user@$first_cell_ip "cellcli -e \"list cell attributes makeModel\" 2>/dev/null>${SYSTEM_DESC_FIL}"
      $SCOPY $cell_ssh_user@$first_cell_ip:${CELLRTEMPDIR}/o_ibswitches_full.out ${RTEMPDIR} >/dev/null 2>&1
      $SCOPY $cell_ssh_user@$first_cell_ip:${SYSTEM_DESC_FIL} ${RTEMPDIR} >/dev/null 2>&1
      $SSHELL $cell_ssh_user@$first_cell_ip rm -f ${CELLRTEMPDIR}/o_ibswitches_full.out ${SYSTEM_DESC_FIL} >/dev/null 2>&1
      $SSHELL $cell_ssh_user@$first_cell_ip "rmdir ${CELLRTEMPDIR}"
    elif [ -n  "$RAT_IBSWITCHES" ]
    then
      for switchname in `echo $RAT_IBSWITCHES`
      do
        echo $switchname >>${RTEMPDIR}/o_ibswitches_full.out
      done
    fi
  else
    cell_ssh_status=0
  fi
  
  use_expect_for_ssh=0 
  unset node_rootpassword
  unset passwordToCheck
  if [[ $is_ssc_machine -eq 2 || $is_exalogic_machine -eq 1 ]] && [[  $TYP != "-p"  && -n "$skip_in_silent" && $skip_in_silent -eq 0  && "$upgrade_mode" -ne "3" && $only_hacheck_run -eq 0 && $ask_zfs_password -eq "1" ]] && [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "0" ]] && [ -e "$CELLIP" ]
  then
    zfs_ssh_user="root"
    usern="$zfs_ssh_user"
    cell_type="zfscell"
  
    if [ $is_ssc_machine -eq 1 ];then discover_ssc_zfs_nodes;elif [ $is_exalogic_machine -eq 1 ];then ZFSIP=$CELLIP;fi
  
    sed '/^\s*$/d' $CELLIP > $CELLIP.new
    mv -f $CELLIP.new $CELLIP
    if [ `cat $CELLIP|wc -l` -gt 0 ] ; then echo -e "\n\nChecking ssh user equivalency between $usern2 and $zfs_ssh_user user on STORAGE Servers\n"; fi;
  
    for hname in `cat $ZFSIP|cut -d\" -f2|cut -d\; -f2`
    do
      #zfsPingStatus=$($PING -c 1 $PING_W_FLAG $hname >/dev/null 2>&1;echo $?)
      test_node_reachability "$hname" "$zfs_ssh_user";
      if [ $el_node_ping -eq "1" ] ; then
        zfsPingStatus=0;
      else
        zfsPingStatus=1;
      fi

      if [ $zfsPingStatus -eq 0 ]
      then 
        zfs_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $zfs_ssh_user $hname ls >/dev/null 2>&1;echo $?);
        
        if [[ $zfs_ssh_status -eq 0 ]]
        then
          echo -e $GREEN"$hname is configured for ssh user equivalency for $zfs_ssh_user user\n" $NORM;
        else
          if [[ $use_expect_for_ssh -eq 0 ]]
          then
            echo -e $RED"$hname is not configured for ssh user equivalency for $zfs_ssh_user user\n"$NORM;
	    exec 3<&2; exec 2<&0
            $READ -p "Do you want to configure SSH for user $zfs_ssh_user on $hname [y/n][y]" AutoLoginCheck
	    read_code=`echo $?`;
	    exec 2<&3
	    process_prompt "$read_code" "AutoLoginCheck" "n"
          fi

          case $AutoLoginCheck in
          y|Y|YES|yes|Yes)
	    AutoLoginCheckYes=1
            if [[ -z "$zfscell_samerootpassword_YesNo" ]]
            then
              zfscell_samerootpassword_YesNo="y"
              echo -e "\n"
	      exec 3<&2; exec 2<&0
              $READ -p  "Is ${usern} password same on all STORAGE Servers?[y/n][y]" zfscell_samerootpassword_YesNo
	      read_code=`echo $?`;
	      exec 2<&3
	      process_prompt "$read_code" "zfscell_samerootpassword_YesNo" "y"
            fi

            case $zfscell_samerootpassword_YesNo in
            y|Y|Yes|YES|yes)
              zfscell_samerootpassword_YesNo="y"
              if [[ -z "$global_zfscell_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
                $READ -r global_zfscell_rootpassword
                tty -s && stty echo
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
              checkUserPassword "$hname" "$usern" "$global_zfscell_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $zfs_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
                  global_zfscell_rootpassword=$passwordToCheck
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $zfs_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
            n|N|No|NO|no)
              zfscell_samerootpassword_YesNo="n"
              printf  "Enter ${hname} ${usern} password :- "
              tty -s && stty -echo
              $READ -r zfscell_rootpassword
              tty -s && stty echo
              printf "\n\nVerifying ${usern} password.\n\n. .\n";
              checkUserPassword "$hname" "$usern" "$zfscell_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $zfs_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
                  global_zfscell_rootpassword=$passwordToCheck
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $zfs_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
	    *)
              cell_samerootpassword_YesNo="y"
              if [[ -z "$global_zfscell_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
                $READ -r global_zfscell_rootpassword
                tty -s && stty echo
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
              checkUserPassword "$hname" "$usern" "$global_zfscell_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $zfs_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
                else
                  global_zfscell_rootpassword=$passwordToCheck
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $zfs_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
		  setup_status=0
		  return
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
	    esac
          ;;
          n|N|NO|No|no)
            echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
            setup_status=0
 	    return
          ;;
          *)
	    AutoLoginCheckYes=1
            if [[ -z "$zfscell_samerootpassword_YesNo" ]]
            then
              zfscell_samerootpassword_YesNo="y"
              echo -e "\n"
	      exec 3<&2; exec 2<&0
              $READ -p  "Is ${usern} password same on all STORAGE Servers?[y/n][y]" zfscell_samerootpassword_YesNo
	      read_code=`echo $?`;
	      exec 2<&3
	      process_prompt "$read_code" "zfscell_samerootpassword_YesNo" "y"
            fi

            case $zfscell_samerootpassword_YesNo in
            y|Y|Yes|YES|yes)
              zfscell_samerootpassword_YesNo="y"
              if [[ -z "$global_zfscell_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
                $READ -r global_zfscell_rootpassword
                tty -s && stty echo
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
              checkUserPassword "$hname" "$usern" "$global_zfscell_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $zfs_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
                  global_zfscell_rootpassword=$passwordToCheck
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $zfs_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
            n|N|No|NO|no)
              zfscell_samerootpassword_YesNo="n"
              printf  "Enter ${hname} ${usern} password :- "
              tty -s && stty -echo
              $READ -r zfscell_rootpassword
              tty -s && stty echo
              printf "\n\nVerifying ${usern} password.\n\n. .\n";
              checkUserPassword "$hname" "$usern" "$zfscell_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $zfs_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
                  global_zfscell_rootpassword=$passwordToCheck
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $zfs_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
	    *)
              cell_samerootpassword_YesNo="y"
              if [[ -z "$global_zfscell_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
                $READ -r global_zfscell_rootpassword
                tty -s && stty echo
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
              checkUserPassword "$hname" "$usern" "$global_zfscell_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
                func_setup_ssh -user $zfs_ssh_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
                  global_zfscell_rootpassword=$passwordToCheck
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $zfs_ssh_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $zfs_ssh_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
	    esac
          ;;
          esac
        fi
      else
        echo -e $RED"\nSTORAGE Server $hname is not pingable, no audit checks will be executed on $hname\n"$NORM;
      fi
    done
  else
    zfs_ssh_status=0
  fi
  
  use_expect_for_ssh=0 
  unset node_rootpassword
  unset passwordToCheck
  if [[ $is_exalogic_machine -eq 1 || $is_bda_machine -eq 1 ]] && [[ -n "$swlist_file" && -e "$swlist_file" ]]
  then
    sed '/^\s*$/d' $swlist_file > $swlist_file.new
    mv -f $swlist_file.new $swlist_file
    if [[ -e "$swlist_file" && `cat $swlist_file|wc -l` -ne 0 ]]
    then
      for switchname in `cat $swlist_file`
      do
        #$PING -c 1 $PING_W_FLAG $switchname >/dev/null 2>&1
        #switchping_status=$(echo $?)
        test_node_reachability "$switchname" "" "" "Infiniband switch";
        if [ $el_node_ping -eq "1" ] ; then
          switchping_status=0;
          echo $switchname>>${RTEMPDIR}/o_ibswitches.out
        else
          switchping_status=1;
          echo -e ${RED}"Infiniband switch $switchname is not reachable so its being skipped from checking best practicing"${NORM}
	  add_to_skipped_nodes "$switchname" "$tnr_note"
        fi

        #if [ $switchping_status -eq 0 ]
        #then
        #  echo $switchname>>${RTEMPDIR}/o_ibswitches.out
        #else
        #  echo -e ${RED}"Infiniband switch $switchname is not reachable so its being skipped from checking best practicing"${NORM}
        #fi
      done
      rm -f ${RTEMPDIR}/o_ibswitches_full.out >/dev/null 2>&1
      cp ${RTEMPDIR}/o_ibswitches.out $OUTPUTDIR >/dev/null 2>&1
    fi
  fi
  
  if [[ -e "${RTEMPDIR}/o_ibswitches_full.out" ]]
  then
    sed '/^\s*$/d' ${RTEMPDIR}/o_ibswitches_full.out > ${RTEMPDIR}/o_ibswitches_full.out.new
    mv -f ${RTEMPDIR}/o_ibswitches_full.out.new ${RTEMPDIR}/o_ibswitches_full.out 
  fi

  if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] && [[ $dbm_x2_2 -eq 1 || $dbm_x3_2 -eq 1 || $dbm_x2_8 -eq 1 || $dbm_v2 -eq 1 ]]; then
    if [[ -e "${RTEMPDIR}/o_ibswitches_full.out" && `cat ${RTEMPDIR}/o_ibswitches_full.out |wc -l` -eq 0 ]] || [[ ! -e "${RTEMPDIR}/o_ibswitches_full.out" ]]
    then
      first_compute_ip=$(cat $HOSTLIST|head -1);
      $SSHELL $usern@$first_compute_ip "mkdir ${RTEMPDIR} >/dev/null 2>&1"
      $SSHELL $usern@$first_compute_ip "ibswitches 2>/dev/null >${RTEMPDIR}/o_ibswitches_full.out 2>/dev/null"
      $SCOPY $usern@$first_compute_ip:${RTEMPDIR}/o_ibswitches_full.out ${RTEMPDIR} >/dev/null 2>&1

      if [[ -e "${RTEMPDIR}/o_ibswitches_full.out" && `cat ${RTEMPDIR}/o_ibswitches_full.out |wc -l` -eq 0 ]]
      then
        rm -rf "${RTEMPDIR}/o_ibswitches_full.out"  >/dev/null 2>&1
      fi
    fi  
  fi

  if [[ -e "${RTEMPDIR}/o_ibswitches_full.out" ]]
  then
    sed '/^\s*$/d' ${RTEMPDIR}/o_ibswitches_full.out > ${RTEMPDIR}/o_ibswitches_full.out.new
    mv -f ${RTEMPDIR}/o_ibswitches_full.out.new ${RTEMPDIR}/o_ibswitches_full.out 
  fi

  if [[ -e ${RTEMPDIR}/o_ibswitches_full.out && `cat ${RTEMPDIR}/o_ibswitches_full.out |wc -l|sed 's/ //g'` -ne 0 ]]
  then
    OIFS="${IFS}";
    NIFS=$'\n';
    IFS="${NIFS}";
    for switch_line in `cat ${RTEMPDIR}/o_ibswitches_full.out`
    do
      printf ". "
      switchname=$(echo "$switch_line"|grep -vwi gw|grep -vw localhost|grep -vi leaf|$AWK 'BEGIN { FS = "QDR " };{print $2}'|$AWK '{print $1}'|sed 's/"$//g')
      is_ibswitch_ip=$(echo $switchname|grep -c [A-Za-z])
  
      if [[ -n $is_ibswitch_ip && $is_ibswitch_ip -eq 0 ]]
      then
        switchname_ip=$switchname   
        switchname=$(echo "$switch_line"|grep -vwi gw|cut -d'"' -f2|awk {'print $(NF-1)}'|grep -vw localhost|grep -vi leaf|cut -d' ' -f1)
      fi   
      if [ -n "$switchname" ]
      then 
        test_node_reachability "$switchname" "root" $switchname_ip "Infiniband switch";
        if [ $el_node_ping -eq "1" ] ; then
          switchping_status=0;
	  echo $switchname>>${RTEMPDIR}/o_ibswitches.out
        else
          switchping_status=1;
	  add_to_skipped_nodes "$switchname" "$tnr_note"
        fi
      fi
    done
 
    IFS="${OIFS}";
    mv -f ${RTEMPDIR}/o_ibswitches_full.out $OUTPUTDIR>/dev/null 2>&1
    cp ${RTEMPDIR}/o_ibswitches.out $OUTPUTDIR >/dev/null 2>&1
  fi

  #if [[ -e ${RTEMPDIR}/o_ibswitches_full.out && `cat ${RTEMPDIR}/o_ibswitches_full.out |wc -l|sed 's/ //g'` -ne 0 ]]
  #then
  #  #for switchname in `cat ${RTEMPDIR}/o_ibswitches_full.out|grep -vwi gw|cut -d'"' -f2|awk {'print $NF}'|grep -vw localhost|grep -vi leaf|cut -d' ' -f1`
  #  for switchname in `cat ${RTEMPDIR}/o_ibswitches_full.out|grep -vwi gw|grep -vw localhost|grep -vi leaf|$AWK 'BEGIN { FS = "QDR " };{print $2}'|$AWK '{print $1}'|sed 's/"$//g'`
  #  do
  #    #$PING -c 1 $PING_W_FLAG $switchname >/dev/null 2>&1
  #    #switchping_status=$(echo $?)
  #    test_node_reachability $switchname "" "" "Infiniband switch";
  #    if [ $el_node_ping -eq "1" ] ; then
  #      switchping_status=0;
  #      echo $switchname>>${RTEMPDIR}/o_ibswitches.out
  #    else
  #      switchping_status=1;
  #      echo -e ${RED}"Infiniband switch $switchname is not reachable so its being skipped from checking best practicing"${NORM}
  #      add_to_skipped_nodes "$switchname" "$tnr_note"
  #    fi

  #    #if [ $switchping_status -eq 0 ]
  #    #then
  #    #  echo $switchname>>${RTEMPDIR}/o_ibswitches.out
  #    #else
  #    #  echo -e ${RED}"Infiniband switch $switchname is not reachable so its being skipped from checking best practicing"${NORM}
  #    #fi
  #  done
  #  rm -f ${RTEMPDIR}/o_ibswitches_full.out >/dev/null 2>&1
  #  cp ${RTEMPDIR}/o_ibswitches.out $OUTPUTDIR >/dev/null 2>&1
  #fi
  
  if [ -e "${RTEMPDIR}/o_ibswitches.out" ]
  then
    cell_type="ibswitch"
    sed '/^\s*$/d' ${RTEMPDIR}/o_ibswitches.out > ${RTEMPDIR}/o_ibswitches.out.new
    mv -f ${RTEMPDIR}/o_ibswitches.out.new ${RTEMPDIR}/o_ibswitches.out 

    assign_usern

    if [ `cat ${RTEMPDIR}/o_ibswitches.out|wc -l` -gt 0 ]
    then 
      if [ -z "$RAT_IBSWITCH_USER" ]
      then
	if [[ $is_exalogic_machine -eq 1 || $is_bda_machine -eq 1 ]]
	then
	  ibswitch_user="root"
	  ibswitch_user_noformat="root"
	else
         # If running is root then user to execute check on switch is set to root because mostly there will be passwordless ssh and one less prompt to answer
          if [ $usern = "${root_user}" ]
          then
	    ibswitch_user="root"
	    ibswitch_user_noformat=$ibswitch_user
          else
	    ibswitch_user="nm2user"
	    ibswitch_user_noformat=$ibswitch_user
          fi
           
	fi
      else
	ibswitch_user=$RAT_IBSWITCH_USER
      fi
      usern="$ibswitch_user"
      echo -e "\n\nChecking ssh user equivalency between $usern2 and $ibswitch_user user on INFINIBAND SWITCH\n"
      
      for hname in `cat ${RTEMPDIR}/o_ibswitches.out`
      do
        ibs_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $hname ls >/dev/null 2>&1;echo $?);
        
        if [[ $ibs_ssh_status -eq 0 ]]
        then
          echo -e $GREEN"$hname is configured for ssh user equivalency for $ibswitch_user user\n" $NORM;
        else
          if [[ $use_expect_for_ssh -eq 0 ]]
          then
            echo -e $RED"$hname is not configured for ssh user equivalency for $ibswitch_user user\n"$NORM;
	    exec 3<&2; exec 2<&0
            $READ -p "Do you want to configure SSH for user $ibswitch_user on $hname [y/n][y]" AutoLoginCheck
	    read_code=`echo $?`;
	    exec 2<&3
	    process_prompt "$read_code" "AutoLoginCheck" "n"
          fi
          
          case $AutoLoginCheck in
          y|Y|YES|yes|Yes)
            AutoLoginCheckYes=1
            if [[ -z "$switch_samerootpassword_YesNo" ]]
            then
              switch_samerootpassword_YesNo="y"
              echo -e "\n"
	      exec 3<&2; exec 2<&0
              $READ -p  "Is ${usern} password same on all IBSWITCHES?[y/n][y]" switch_samerootpassword_YesNo
	      read_code=`echo $?`;
	      exec 2<&3
	      process_prompt "$read_code" "switch_samerootpassword_YesNo" "y"
            fi

            case $switch_samerootpassword_YesNo in
            y|Y|Yes|YES|yes)
              switch_samerootpassword_YesNo="y"
              if [[ -z "$global_switch_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
                $READ -r global_switch_rootpassword
                tty -s && stty echo
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
              checkUserPassword "$hname" "$usern" "$global_switch_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
		func_setup_ssh -user $ibswitch_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
                  global_switch_rootpassword=$passwordToCheck
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $ibswitch_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
	    ;;
            n|N|No|NO|no)
              switch_samerootpassword_YesNo="n"
              printf  "Enter ${hname} ${usern} password :- "
              tty -s && stty -echo
              $READ -r switch_rootpassword
              tty -s && stty echo
              printf "\n\nVerifying ${usern} password.\n\n. .\n";
              checkUserPassword "$hname" "$usern" "$switch_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
		func_setup_ssh -user $ibswitch_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
                  global_switch_rootpassword=$passwordToCheck
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $ibswitch_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
	    *)
              switch_samerootpassword_YesNo="y"
              if [[ -z "$global_switch_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
		read_code=`echo $?`;
                tty -s && stty echo
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
              checkUserPassword "$hname" "$usern" "$global_switch_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
		func_setup_ssh -user $ibswitch_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
                  global_switch_rootpassword=$passwordToCheck
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $ibswitch_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
	    ;;
	    esac
          ;;
          n|N|NO|No|no)
            echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
            setup_status=0
	    return
          ;;
          *)
            AutoLoginCheckYes=1
            if [[ -z "$switch_samerootpassword_YesNo" ]]
            then
              switch_samerootpassword_YesNo="y"
              echo -e "\n"
	      exec 3<&2; exec 2<&0
              $READ -p  "Is ${usern} password same on all IBSWITCHES?[y/n][y]" switch_samerootpassword_YesNo
	      read_code=`echo $?`;
	      exec 2<&3
	      process_prompt "$read_code" "switch_samerootpassword_YesNo" "y"
            fi

            case $switch_samerootpassword_YesNo in
            y|Y|Yes|YES|yes)
              switch_samerootpassword_YesNo="y"
              if [[ -z "$global_switch_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
                $READ -r global_switch_rootpassword
                tty -s && stty echo
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
              checkUserPassword "$hname" "$usern" "$global_switch_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
		func_setup_ssh -user $ibswitch_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
                  global_switch_rootpassword=$passwordToCheck
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $ibswitch_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
	    ;;
            n|N|No|NO|no)
              switch_samerootpassword_YesNo="n"
              printf  "Enter ${hname} ${usern} password :- "
              tty -s && stty -echo
              $READ -r switch_rootpassword
              tty -s && stty echo
              printf "\n\nVerifying ${usern} password.\n\n. .\n";
              checkUserPassword "$hname" "$usern" "$switch_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
		func_setup_ssh -user $ibswitch_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
                  global_switch_rootpassword=$passwordToCheck
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $ibswitch_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
            ;;
	    *)
              switch_samerootpassword_YesNo="y"
              if [[ -z "$global_switch_rootpassword" ]]
              then
                printf  "Enter ${usern} password :- "
                tty -s && stty -echo
                $READ -r global_switch_rootpassword
                tty -s && stty echo
              fi

              printf "\n\nVerifying ${usern} password.\n\n. .\n";
              checkUserPassword "$hname" "$usern" "$global_switch_rootpassword" "3"

              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
		func_setup_ssh -user $ibswitch_user -hosts "$hname"
                if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
                then
                  echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                  echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		  setup_status=0
		  return
                else
                  global_switch_rootpassword=$passwordToCheck
                  echo -e $GREEN"\n$hname has been configured for ssh user equivalency for $ibswitch_user user\n"$NORM;
                  echo "S:$usern:$hname" >> $INITDMP
                fi
              else
                echo -e $RED"$hname: Failed to setup ssh user equivalency for $ibswitch_user user."$NORM;
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on $hname\n"$NORM;
		setup_status=0
		return
              fi
	    ;;
	    esac
          ;;
          esac
        fi
      done
    fi
  fi
  fi
  echo -e "\n"
  setup_status=1
  usern="$usern2"

  unset cell_type
  unset node_rootpassword
  unset passwordToCheck
}


func_remote_setup_ssh ()
{
  args=$(echo $* | sed 's/.*-setupssh//');
  usern=$(echo $args | awk '{print $1}');
  hname=$(echo $args | awk '{print $2}');

  func_setup_ssh -user $usern -hosts "$hname"

  if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
  then
    echo -e "SSH setup failed"	
  else
    echo -e "Successfully setup SSH"
  fi
}  

validate_user_home ()
{
  homedir=$($SSHELL $usern@$hname "echo \$HOME")
  if [[ -n "$homedir" && "$HOME" != "$homedir" ]]; then
    echo -e ${RED}"'$usern' user home directory is not same on $hname and $localnode. Please make sure that '$usern' user home directory is same on all nodes in cluster and then re-run ${program_name}."${NORM}      
    echo -e ${RED}"\n${program_name} is exiting..${NORM}\n"
    exit
  fi
}

check_tmp_status ()
{
  remote_hostname=$($SSHELL $hname hostname|tr "[A-Z]" "[a-z]"|cut -d'.' -f1);
  if [[ "$localnode" = "$remote_hostname" ]]; then return; fi;
  
  validate_user_home 

  cat > $TMPSTFILE <<EOF
#!$bash_scr
$bash_source
$RAT_DEBUG_FLG  
  
mount_check=1
if [ -e "$RTEMPDIR" ]; then
  del_rtempdir=0
  if [ -e $LOCKFIL ]; then
    lockfile_pid_status=\$(ps -ef |grep \$(cat $LOCKFIL)|grep -v grep|wc -l)
    if [[ -n "\$lockfile_pid_status" && \$lockfile_pid_status -gt 0 ]]; then
      del_rtempdir=0
    else
      del_rtempdir=1
    fi
  elif [ -f "$RTEMPDIR" ]; then
    del_rtempdir=1
  fi

  if [[ "\$del_rtempdir" -eq "1" ]]; then
    rm -rf $RTEMPDIR >/dev/null 2>&1;
    if [ \$(echo \$?) -ne 0 ]; then
      echo -e "\nTemporary files/directories of previous run exist on $hname at $RTEMPDIR. Delete them and re-run ${program_name}.\n\n${program_name} is exiting..\n"
      mount_check=0
    fi
  fi
fi

if [[ "\$mount_check" -eq "1" ]]; then
  \$(mount >/dev/null 2>&1)
  if [ \$(echo \$?) -eq 0 ]; then
    if [ \$(mount|grep -w "$TMPDIR"|grep -icw "noexec") -gt 0 ]; then
      echo -e "\nPlease change the entry for $TMPDIR in /etc/fstab file from 'noexec' to 'exec' on $hname and then re-run ${program_name}.\n\n${program_name} is exiting..\n"
    fi
  fi
fi
EOF
  
  tmp_status=$($SSHELL $hname "$bash_scr -c \"if [ ! -w '$TMPDIR' ]; then echo -e 'FAIL'; fi;\"");  

  if [[ -n "$tmp_status" && $tmp_status = "FAIL" ]]; then
    echo -e ${RED}"$TMPDIR directory is not writable on $hname.Please make sure that $TMPDIR is writable and then re-run ${program_name}"{NORM}
    echo -e ${RED}"\n${program_name} is exiting..${NORM}\n"
    exit 1
  else 
    $SCOPY $TMPSTFILE $hname:$TMPDIR >/dev/null 2>&1
    $($SSHELL -o NumberOfPasswordPrompts=0 $hname "chmod +x $TMPSTFILE >/dev/null");
    tmp_mount_status=$($SSHELL -o NumberOfPasswordPrompts=0 $hname $TMPSTFILE);
    $($SSHELL -o NumberOfPasswordPrompts=0 $hname "rm -f $TMPSTFILE >/dev/null");

    if [ `echo "$tmp_mount_status"|grep -ic "exiting"` -gt 0 ]; then
      echo -e ${RED}"$tmp_mount_status"${NORM}
      exit 1
    fi
  fi

  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then 
    unset tmp_status
    tmp_status=$($SSHELL $hname "$bash_scr -c \"if [ ! -e '$RAT_TMP_OUTPUT' ]; then echo -e 'FAIL'; fi;\"");
    if [[ -n "$tmp_status" && $tmp_status = "FAIL" ]]; then
      echo -e ${RED}"$RAT_TMP_OUTPUT directory does not exists.Please set the RAT_TMP_OUTPUT and then re-run ${program_name}"${NORM}
      echo "ex: export RAT_TMP_OUTPUT=/tmp"
      echo -e ${RED}"\n\n${program_name} is exiting..${NORM}\n"
      exit 1
    else
      unset tmp_status
      tmp_status=$($SSHELL $hname "$bash_scr -c \"if [ ! -w '$RAT_TMP_OUTPUT' ]; then echo -e 'FAIL'; fi;\"");
      if [[ -n "$tmp_status" && $tmp_status = "FAIL" ]]; then
	echo -e ${RED}"$RAT_TMP_OUTPUT directory must be writable by all users for creating runtime files.Please set the RAT_TMP_OUTPUT and then re-run ${program_name}"${NORM}
	echo "ex: export RAT_TMP_OUTPUT=/tmp"
        echo -e ${RED}"\n\n${program_name} is exiting..${NORM}\n"
        exit 1 
      else
	$SSHELL $hname "rm -f $TMP_OUTPUT >/dev/null 2>&1; mkdir $TMP_OUTPUT >/dev/null 2>&1; chmod -R 777 $TMP_OUTPUT;"
      fi
    fi
  fi
}

function purge_collections ()
{
  if [ -e $autorun_list ]; then
    if [[ `grep -c "^@ID:" $autorun_list` -eq 0 ]]; then
        sed -i -e "s/^/@ID:${program_name}.default - /" $autorun_list
    fi
  fi

  swap_p_conf_file "$cur_p_conf_file"

  if [[ -f "$p_conf_file" && `grep -ic "COLLECTION_RETENTION" $p_conf_file` -gt "0" ]] ; then
    read_conf "COLLECTION_RETENTION"
    purge_days=$p_conf_value

    if [[ -f "$autorun_list" ]] ; then
      log_daemon "Checking collections older than ${purge_days} days for purging"

      for pfile in $(find $WRKDIR -name "${program_name}_${localnode}*" -type d -mtime +${purge_days};find $WRKDIR -name "${program_name}_${localnode}*.zip" -type f -mtime +${purge_days};find $WRKDIR -name "${program_name}_${localnode}*.log" -type f -mtime +${purge_days};)
      do
	bpfile=$(basename "$pfile"|sed 's/.zip//g'|sed 's/.log//g')
	 
        #if [[ `grep -icw "$bpfile" "$autorun_list"` -gt 0 && -e "$pfile" ]] ; then 
 	if [[ `grep "^@ID:${autorun_id} - " "$autorun_list"|grep -icw "$bpfile"` -gt 0 && -e "$pfile" ]] ; then
	  rm -rf "$pfile" >/dev/null 2>&1 
	  deleted_list="${pfile}\n${deleted_list}"
        fi
      done
      if [ ! -z "$deleted_list" ] ; then
        log_daemon "Following collections has been purged-"
	log_daemon "\n$deleted_list"
      else
        log_daemon "Collections purged - none"
      fi
    fi
  fi
}

function is_SSH_blocked ()
{
  #Calling Format: is_SSH_blocked "nodename" "user" [password] [host type(compute/cell/switch)] 
  SSH_host="$1"
  SSH_user="$2"
  SSH_password="$3"
  SSH_host_type="$4"

  SSH_blocked=0
 
  if [[ -z $SSH_host_type ]] ; then
    SSH_dir=$RTEMPDIR
  elif [[ $SSH_host_type = 'CELL' ]]; then
    SSH_dir=$CELLRTEMPDIR
  elif [[ $SSH_host_type = 'SWITCH' ]]; then
    SSH_dir=$IBRTEMPDIR
  fi

  SSH_chk_file="$RTEMPDIR/SSH_chk_file.sh"

  if [[ ! -e $SSH_chk_file ]]; 
  then
    echo "#!$bash_scr" > $SSH_chk_file 
    echo "$bash_source" >> $SSH_chk_file
    echo "echo 'Script Executed Successfully'" >> $SSH_chk_file
  fi

  /usr/bin/ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -l "$SSH_user" "$SSH_host" ls 2>/dev/null 1>/dev/null
  if [[ $? -eq 0 ]]; then
    SSH_remote_dir=$($SSHELL -t $SSH_user@$SSH_host "if [[ -d $SSH_dir ]]; then echo '1'; else if [[ -f $SSH_dir ]]; then echo '2'; else echo '0'; fi; fi" 2>/dev/null)
    SSH_remote_dir=$(echo "$SSH_remote_dir" | grep -vi 'OpenSSH_' | tr -d '\r' | sed 's/ //g' | grep "^[0-9]$");

    if [[ -n $SSH_remote_dir && $SSH_remote_dir -eq "0" ]] || [[ -z "$SSH_remote_dir" ]]; then  
      $SSHELL $SSH_user@$SSH_host "mkdir ${SSH_dir} >/dev/null 2>&1;"    
    elif [[ -n $SSH_remote_dir && $SSH_remote_dir -eq "2" ]]; then
      $SSHELL $SSH_user@$SSH_host "rm -f ${SSH_dir} >/dev/null 2>&1;"    
      $SSHELL $SSH_user@$SSH_host "mkdir ${SSH_dir} >/dev/null 2>&1;"    
    fi
 
    $SCOPY $SSH_chk_file $SSH_user@$SSH_host:$SSH_dir >/dev/null 2>&1    

    /usr/bin/ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -l "$SSH_user" "$SSH_host" "chmod 755 $SSH_dir/SSH_chk_file.sh" 2>/dev/null 1>/dev/null
    SSH_return=$(/usr/bin/ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -t $SSH_user@$SSH_host $SSH_dir/SSH_chk_file.sh 2>&1)

    if [[ `echo "$SSH_return" | grep -ic "Script Executed Successfully"` -eq 0 ]]; then SSH_blocked=1; fi
  else
    if [[ -n $SSH_password ]]; then
      fixRootPassword "$SSH_password"

      SSH_remote_dir=$($EXPECT -f - << IBEOF
        set timeout $passwordcheck_timeout
        set le_extract_password "$fixedRootPassword"
        #log_user 0
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }
	spawn -noecho $SSHELL $SSH_user@$SSH_host "if test -d $SSH_dir; then echo '1'; else if test -f $SSH_dir; then echo '2'; else echo '0'; fi; fi"
        match_max 100000
         expect {
           -nocase "permission denied *" {
             exit 4;
           }
           -nocase "no)?" {
             send -- "yes\n"
           }
           -nocase "*?assword:*" {
             send -- "\$le_extract_password\n"
           }
           -nocase eof {
             exit
           }
         }
         expect {
           -nocase "*?assword:*" {
             send -- "\$le_extract_password\n"
           }
           -nocase eof {
             exit
           }
           -nocase timeout {
             send_error "Unable to determine temp directory on $SSH_host\n";
             exit
           }
         }
         expect {
           -nocase eof {
             exit
           }
           -nocase timeout {
             send_error "Unable to determine temp directory on $SSH_host\n";
             exit
           }
         }
IBEOF
)
      SSH_remote_dir=$(echo "$SSH_remote_dir" | grep -vi 'OpenSSH_' | grep -vi "password:" | tr -d '\r' | sed 's/ //g' | grep "^[0-9]$");      

      if [[ -n "$SSH_remote_dir" && $SSH_remote_dir -eq "0" ]] || [[ -z "$SSH_remote_dir" ]]; then  
        $EXPECT -f - << IBEOF
        set timeout $passwordcheck_timeout
        set le_extract_password "$fixedRootPassword"
        log_user 0
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }
	spawn -noecho $SSHELL $SSH_user@$SSH_host mkdir $SSH_dir
        match_max 100000
         expect {
           -nocase "permission denied *" {
             exit 4;
           }
           -nocase "no)?" {
             send -- "yes\n"
           }
           -nocase "*?assword:*" {
             send -- "\$le_extract_password\n"
           }
           -nocase eof {
             exit
           }
         }
         expect {
           -nocase "*?assword:*" {
             send -- "\$le_extract_password\n"
           }
           -nocase eof {
             exit
           }
           -nocase timeout {
             send_error "Unable to create temp directory on $SSH_host\n";
             exit
           }
         }
         expect {
           -nocase eof {
             exit
           }
           -nocase timeout {
             send_error "Unable to create temp directory on $SSH_host\n";
             exit
           }
         }
IBEOF
      elif [[ -n $SSH_remote_dir && $SSH_remote_dir -eq "2" ]]; then
        $EXPECT -f - << IBEOF
        set timeout $passwordcheck_timeout
        set le_extract_password "$fixedRootPassword"
        log_user 0
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }
	spawn -noecho $SSHELL $SSH_user@$SSH_host rm -f $SSH_dir
        match_max 100000
         expect {
           -nocase "permission denied *" {
             exit 4;
           }
           -nocase "no)?" {
             send -- "yes\n"
           }
           -nocase "*?assword:*" {
             send -- "\$le_extract_password\n"
           }
           -nocase eof {
             exit
           }
         }
         expect {
           -nocase "*?assword:*" {
             send -- "\$le_extract_password\n"
           }
           -nocase eof {
             exit
           }
           -nocase timeout {
             send_error "Unable to delete file on $SSH_host\n";
             exit
           }
         }
         expect {
           -nocase eof {
             exit
           }
           -nocase timeout {
             send_error "Unable to delete file on $SSH_host\n";
             exit
           }
         }
IBEOF

        $EXPECT -f - << IBEOF
        set timeout $passwordcheck_timeout
        set le_extract_password "$fixedRootPassword"
        log_user 0
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }
	spawn -noecho $SSHELL $SSH_user@$SSH_host mkdir $SSH_dir
        match_max 100000
         expect {
           -nocase "permission denied *" {
             exit 4;
           }
           -nocase "no)?" {
             send -- "yes\n"
           }
           -nocase "*?assword:*" {
             send -- "\$le_extract_password\n"
           }
           -nocase eof {
             exit
           }
         }
         expect {
           -nocase "*?assword:*" {
             send -- "\$le_extract_password\n"
           }
           -nocase eof {
             exit
           }
           -nocase timeout {
             send_error "Unable to create temp directory on $SSH_host\n";
             exit
           }
         }
         expect {
           -nocase eof {
             exit
           }
           -nocase timeout {
             send_error "Unable to create temp directory on $SSH_host\n";
             exit
           }
         }
IBEOF
      fi
      sleep 2;

      $EXPECT -f - << IBEOF
        set timeout $passwordcheck_timeout
        set le_extract_password "$fixedRootPassword"
        log_user 0
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }
        spawn $SCOPY $SSH_chk_file $SSH_user@$SSH_host:$SSH_dir
        match_max 100000
         expect {
           -nocase "permission denied *" {
             exit 4;
           }
           -nocase "no)?" {
             send -- "yes\n"
           }
           -nocase "*?assword:*" {
             send -- "\$le_extract_password\n"
           }
           -nocase eof {
             exit
           }
         }
         expect {
           -nocase "*?assword:*" {
             send -- "\$le_extract_password\n"
           }
           -nocase eof {
             exit
           }
           -nocase timeout {
             send_error "Timed out while copying $SSH_dir/SSH_chk_file.sh on $SSH_host\n";
             exit
           }
         }
         expect {
           -nocase eof {
             exit
           }
           -nocase timeout {
             send_error "Timed out while copying $SSH_dir/SSH_chk_file.sh on $SSH_host\n";
             exit
           }
         }
IBEOF

      $EXPECT -f - << IBEOF
        set timeout $passwordcheck_timeout
        set le_extract_password "$fixedRootPassword"
        log_user 0
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }
        spawn $SSHELL $SSH_user@$SSH_host chmod 755 $SSH_dir/SSH_chk_file.sh
        match_max 100000
          expect {
            -nocase "permission denied *" {
              exit 4;
            }
            -nocase "no)?" {
              send -- "yes\n"
            }
            -nocase "*?assword:*" {
              send -- "\$le_extract_password\n"
            }
            -nocase eof {
              exit
            }
          }
          # Look for passwd prompt
          expect {
            -nocase "*?assword:*" {
              send -- "\$le_extract_password\n"
            }
            -nocase eof {
              exit
            }
            -nocase timeout {
              send_error "Timed out while modifying permissions on $SSH_host\n";
              exit
            }
          }
         expect {
           -nocase eof {
             exit
           }
           -nocase timeout {
             send_error "Timed out while modifying permissions on $SSH_host\n";
             exit
           }
         }
IBEOF

      t_SSHELL=$(echo "$SSHELL" | sed 's/-q//g')

      SSH_return=$($EXPECT -f - 2>&1 << IBEOF
        set timeout $passwordcheck_timeout
        set le_extract_password "$fixedRootPassword"
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }
        log_user 1
        spawn -noecho $t_SSHELL -t $SSH_user@$SSH_host $SSH_dir/SSH_chk_file.sh
        match_max 100000
          expect {
            -nocase "permission denied *" {
              exit 4;
            }
            -nocase "no)?" {
              send -- "yes\n"
            }
            -nocase "*?assword:*" {
              send -- "\$le_extract_password\n"
            }
            -nocase eof {
              exit
            }
          }
          #Look for passwd prompt
          log_user 1
          set timeout $watchdog_wakeup_root
          expect {
            -nocase "*?assword:*" {
              send -- "\$le_extract_password\n"
            }
            -nocase eof {
              exit
            }
            -nocase timeout {
              send_error "Timed out while running $SSH_dir/SSH_chk_file.sh on $SSH_host\n";
              exit
            }
          }
          log_user 1
          expect {
            -nocase eof {
             exit
            }
            -nocase timeout {
              send_error "Timed out while running $SSH_dir/SSH_chk_file.sh on $SSH_host\n";
              exit
            }
          }
IBEOF
)
      if [[ `echo "$SSH_return" | grep -ic "Script Executed Successfully"` -eq 0 ]]; then SSH_blocked=1; fi
    fi
  fi 
}

function isDNSconfigured ()
{
  DNSconfigured=1
  
  is_IP "$1"
  if [[ $is_IPADDRESS -eq "1" ]]; then return; fi

  ssh_output=$(/usr/bin/ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -l "$2" "$1" ls 2>&1 | tr -d '\r')
  if [[ `echo "$ssh_output"|grep -ic 'failure in name resolution'` -gt 0 || `echo "$ssh_output"|grep -ic 'Name or service not known'` -gt 0 ]]
  then
    DNSconfigured=0
  fi
}

function check_ssh_speed () 
{
  ssh_go_ahead=1
  if [[ -n "$RAT_PASSWORDCHECK_TIMEOUT" && $RAT_PASSWORDCHECK_TIMEOUT -gt 1 ]]
  then
    passwordcheck_timeout=$RAT_PASSWORDCHECK_TIMEOUT
  else
    if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
    then
      passwordcheck_timeout=20
    else
      passwordcheck_timeout=10
    fi
  fi
  
  ssh_speed=$(/usr/bin/ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -o ConnectTimeout=$passwordcheck_timeout -l "$2" "$1" ls 2>&1 | tr -d '\r')
  if [[ `echo "$ssh_speed"|grep -ic 'Connection timed out'` -gt 0 || `echo "$ssh_speed"|grep -ic 'Name or service not known'` -gt 0 ]]
  then
    ssh_go_ahead=0
  fi
}

function format_cell_switch_files ()
{
  #$READ -p "$1 $2 $3"
  if [ "$3" = "cell" ]
  then   
    for shortFileName in $(ls $2/c_*out 2>/dev/null) 
    do
      SHORTFNAME=$(echo $shortFileName |$AWK 'BEGIN { FS = "/" } {printf $NF}')
      SHORTFNAME=$(echo $SHORTFNAME|sed 's/\.out//g')   
      SHORTFNAME1=$(echo $SHORTFNAME|cut -d _ -f1)
      SHORTFNAME2=$(echo $SHORTFNAME|cut -d _ -f2)
      SHORTFNAME3=$(echo $SHORTFNAME|sed s'/c_cbc_//g'|sed s'/c_cwc_//g'|sed s'/_report//g')
      if [ `echo $shortFileName|grep -c report` -gt 0 ]
      then
        cp $shortFileName $CELLDIR/${SHORTFNAME1}_${SHORTFNAME2}_${SHORTFNAME3}_${1}_report.out
      else
        cp $shortFileName $CELLDIR/${SHORTFNAME1}_${SHORTFNAME2}_${SHORTFNAME3}_${1}.out
      fi
      #$READ -p "$1 $2 $3"
    done
    mv -f $2 $CELLDIR >/dev/null 2>&1
  else
    for shortFileName in $(ls $2/s_*out 2>/dev/null) 
    do
      SHORTFNAME=$(echo $shortFileName |$AWK 'BEGIN { FS = "/" } {printf $NF}')
      SHORTFNAME=$(echo $SHORTFNAME|sed 's/\.out//g')   
      SHORTFNAME1=$(echo $SHORTFNAME|cut -d _ -f1)
      SHORTFNAME2=$(echo $SHORTFNAME|sed s'/^s_//g'|sed s'/_report//g')
      if [ `echo $shortFileName|grep -c report` -gt 0 ]
      then
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then cp $shortFileName $TMP_OUTPUT/${SHORTFNAME1}_${SHORTFNAME2}_${1}_report.out; fi
        cp $shortFileName $OUTPUTDIR/${SHORTFNAME1}_${SHORTFNAME2}_${1}_report.out
      else
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then cp $shortFileName $TMP_OUTPUT/${SHORTFNAME1}_${SHORTFNAME2}_${1}.out; fi
        cp $shortFileName $OUTPUTDIR/${SHORTFNAME1}_${SHORTFNAME2}_${1}.out
      fi
    done
    #deleting temporary directory created for each cell after format cell file names
    mv -f $2 $CELLDIR >/dev/null 2>&1
  fi
}

function parallel_sql () 
{
  perl_exe=$(which perl|tr -d '\r');

  if [[ -n "$RAT_PERL_DEBUG" && $RAT_PERL_DEBUG -eq 2 ]]
  then
    #Only if Devel::Trace Module is available
    perl_exe="$perl_exe -d:Trace"
  fi
 
  if [[ $OFFLINE -eq "0" ]]
  then
    ENVFIL="$MASTERFIL"
  else
    ENVFIL="$DUMPDIR/$CHKFIL"
  fi

  #if [[ -n "$RAT_DB_PAR_LIMIT" && `echo "$RAT_DB_PAR_LIMIT"|grep -Ec "[0-9]+$"` -gt 0 ]]; then num_sql_queries=$RAT_DB_PAR_LIMIT; fi
  if [[ -n "$RAT_DB_PAR_LIMIT" && `echo "$RAT_DB_PAR_LIMIT"|grep -c "^[0-9][0-9]*$"` -gt 0 ]]; then num_sql_queries=$RAT_DB_PAR_LIMIT; fi

  if [[ -z "$RAT_ROOT_RUN" ]]; then TMP_OUTPUT=$RTEMPDIR; fi

  #Remove Duplicates
  if [ -e $t_PSQL_INFIL ]; then cat $t_PSQL_INFIL|sort|uniq > $t_PSQL_INFIL.new; mv $t_PSQL_INFIL.new $t_PSQL_INFIL; fi

  PRET_STATUS=0;
  
  perl_cmd="
	$perl_exe $SCRIPTPATH/.cgrep/psqlplus 
	-c "$t_PSQL_METAFIL" 
	-d "$t_PSQL_INFIL" 
	-g "$t_PSQL_STAT"
	-o "$OUTPUTDIR" 
	-w "$OUTPUTDIR_NEW" 
	-i "$INPUTDIR" 
	-t "$RTEMPDIR" 
	-e "$ERRFIL"
        -p "$ENVFIL"	
	-u "$num_sql_queries"
	-m 1 
	-v "$CHECKS_TIMING"
        -f "$CHK_TIMINGS"
	-a "$ORCLENVFIL"
	-s $OFFLINE 
	-n "$localnode" 
	-r "$i" 
	-k 1
	-b 1
	-z "$SKIPFIL"
	-j "$TMP_OUTPUT"
"

  if [[ -n "$RAT_PERL_DEBUG"  ]]
  then
    echo "$perl_cmd" 
  fi
  if [ $RAT_DEBUG -eq 1 ]; then
    $perl_cmd
  else
    $perl_cmd 2>>$ERRFIL
  fi
  PRET_STATUS=`echo $?`;  

  if [[ -z "$RAT_ROOT_RUN" ]]; then unset TMP_OUTPUT; fi
}


function is_IP() {
  is_IPADDRESS=1
  if [[ `perl -e 'my $count=0; my @count = ("'$1'" =~ m/\./g); $count=@count; print $count;'` -ne 3 ]]; then
  #if [ `echo $1 | grep -o '\.' | wc -l` -ne 3 ]; then
    is_IPADDRESS=0
  elif [ `echo $1 | tr '.' ' ' | wc -w` -ne 4 ]; then
    is_IPADDRESS=0
  else
    for OCTET in `echo $1 | tr '.' ' '`; do
      if [[ `echo "$OCTET" | grep -ic "^[0-9][0-9]*$"` -le 0 ]]; then
        is_IPADDRESS=0
	break;
      elif [[ $OCTET -lt 0 || $OCTET -gt 255 ]]; then
        is_IPADDRESS=0
	break;		
      fi
    done
  fi
}

generate_recommendations_xml () {
  echo "    <Check id=\"$1\">"						>> $XMLRECFIL
  echo "        <Recommendation><![CDATA[$2]]></Recommendation>"	>> $XMLRECFIL
  echo "        <Links><![CDATA[$3]]></Links>"				>> $XMLRECFIL
  echo "    </Check>"							>> $XMLRECFIL
}

top_consumers () 
{
  perl_exe=$(which perl|tr -d '\r');
  $perl_exe - -f $CHK_TIMINGS -t 10 -r $OUTPUTDIR/${program_name}_consumers.html <<PERLEOF
    use strict;
    use warnings;
    use Getopt::Long;
    use Data::Dumper;
    
    my (\$CHKFILE);
    my (\$CHECKS);
    my (\$THTML) = "topconsumers.html";
    my (\$TLIMIT)= 10;
    my (\$UNIT)	 = "ms";
    
    sub usage {
      print "Usage: \$0 -f CHECK TIMINGS FILE -t NUMBER(Top n Checks) -r TIMING HTML\n";
      exit;
    }
    
    if ( \@ARGV == 0 ) {
      usage();
    }
    
    GetOptions( "f=s" => \\\$CHKFILE, "t=n" => \\\$TLIMIT, "r=s" => \\\$THTML ) or usage();
    
    sub process_line {
      my (\$line) = shift;
      my (\$process) = 1;    
    
      \$process = 0 if ( \$line =~ m/^\s*#/ );
      \$process = 0 if ( \$line =~ m/^\s*\$/ );
    
      return \$process;
    }
    
    sub get_checkid {
      my (\$line) = shift;
      \$line =~ s/^\[CHECK://g;
      \$line =~ s/\].*\$//g;
      \$line =~ s/\s*//g;
      return \$line;
    }
    
    sub get_time {
      my (\$line) = shift;
      \$line =~ s/^.*Time: //g;
      return \$line;
    }
    
    sub get_host {
      my (\$line) = shift;
      \$line =~ s/^.*\[HOST://g;
      \$line =~ s/\].*\$//g;
      \$line =~ s/\s*//g;
      return \$line;
    }
    
    sub get_type {
      my (\$line) = shift;
      \$line =~ s/^.*\[TYPE://g;
      \$line =~ s/\].*\$//g;
      \$line =~ s/\s*//g;
      return \$line;
    }
    
    sub get_tag1 {
      my (\$line) = shift;
    
      return "" if ( \$line !~ m/TAG1/ );
    
      \$line =~ s/^.*\[TAG1://g;
      \$line =~ s/\].*\$//g;
      \$line =~ s/\s*//g;
      return \$line;
    }
    
    sub get_tag2 {
      my (\$line) = shift;
    
      return "" if ( \$line !~ m/TAG2/ );
    
      \$line =~ s/^.*\[TAG2://g;
      \$line =~ s/\].*\$//g;
      \$line =~ s/\s*//g;
      return \$line;
    }
    
    sub get_cn {
      my (\$line) = shift;
      \$line =~ s/^.*\[COLLECTION_NAME://g;
      \$line =~ s/\].*\$//g;
      \$line =~ s/^\s*//g;
      \$line =~ s/\s*$//g;
      return \$line;
    }

    sub get_chkname {
      my (\$line) = shift;
      \$line =~ s/^.*\[AUDIT_CHECK_NAME://g;
      \$line =~ s/\].*\$//g;
      \$line =~ s/^\s*//g;
      \$line =~ s/\s*$//g;
      return \$line;
    }

    sub timings {
      my \$CHECKID 	= shift; 
      my \$HOST		= shift;
      my \$TYPE		= shift;
      my \$END_TIME	= shift;
      my \$START_TIME	= shift;
      my \$SECTION	= shift;
      my \$COL_NAME	= shift || "";
      my \$CHK_NAME     = shift || "";
      my \$TAG1		= shift || "";
      my \$TAG2		= shift || "";
    
      my \$DIFF = \$END_TIME - \$START_TIME;
    
      \$CHECKS->{"\$CHECKID:\$HOST:\$TYPE:\$START_TIME:\$END_TIME:\$COL_NAME:\$CHK_NAME:\$TAG1:\$TAG2"} = \$DIFF;
    }
    
    sub convert_format {
      my (\$duration);
      if ( \$UNIT eq 'ms' ) {
        my (\$Milliseconds) = shift;
    
        my (\$Hours)   = (\$Milliseconds/(1000*60*60))%24;
        my (\$Minutes) = (\$Milliseconds/(1000*60))%60;
        my (\$Seconds) = (\$Milliseconds/1000)%60;
    
        \$duration = \$Hours . " hrs, " . \$Minutes . " mins" . " and " . \$Seconds . " secs";
        if ( \$Hours == 0 ) {
          \$duration =~ s/^.*hrs, //g;
        }
        if ( \$Minutes == 0 && \$Hours == 0 ) {
          \$duration =~ s/^.*mins and //g;
        }
        if ( \$Seconds == 0 && \$Minutes == 0 && \$Hours == 0 ) {
          \$duration =~ s/^.*secs //g;
          \$duration = \$Milliseconds . " ms";
        }
      }
      elsif ( \$UNIT eq 'secs' ) {
        my (\$Seconds) = shift;
    
        my (\$Hours)   = (\$Seconds/(60*60))%24;
        my (\$Minutes) = (\$Seconds/60)%60;
        \$Seconds      = \$Seconds%60;
    
        \$duration = \$Hours . " hrs, " . \$Minutes . " mins" . " and " . \$Seconds . " secs";
        if ( \$Hours == 0 ) {
          \$duration =~ s/^.*hrs, //g;
        }
        if ( \$Minutes == 0 && \$Hours == 0 ) {
          \$duration =~ s/^.*mins and //g;
        }
      }
      return \$duration;
    }

    sub print_info {
      my (\$count) = 0;
      
      open ( my \$TCF, ">" , \$THTML ) || die \$!;
      print \$TCF "<a href=\"\#\" class=\"a_bgw\">Top</a>\n";
      print \$TCF "<a name=\"top_consumers\"></a>\n";
      print \$TCF "<h2>Top 10 Time Consuming Checks</h2>\n";
      print \$TCF "<p><b>NOTE:</b> This information is primarily used for helping Oracle optimize the run time of ${program_name}.<br></br>These timings are not necessarily indicative of any problem and may vary widely from one system to another.</p>\n";
      print \$TCF "<table summary=\"Top Time Consuming Checks\">\n";
      print \$TCF "<tr>\n";
      print \$TCF "<th scope=\"col\">Name</th>\n";
      print \$TCF "<th scope=\"col\">Type</th>\n";
      print \$TCF "<th scope=\"col\">Target</th>\n";
      print \$TCF "<th scope=\"col\">Execution Duration</th>\n";
      print \$TCF "</tr>\n";
    
      foreach my \$data (sort { \$CHECKS->{\$b} <=> \$CHECKS->{\$a} } keys %\$CHECKS) {
      if ( \$TLIMIT <= \$count ) { last; }
          
      my (@data) = split(':',\$data);
      my (\$checkid)	= \$data[0];
    
      my (\$name)	= \$data[5];
      if (!defined \$data[5] || \$data[5] =~ m/^\s*\$/ ) { \$name = \$data[6]; }
      
      my (\$target)	= \$data[1];
      if (defined \$data[7] && \$data[7] !~ m/^\s*\$/ ) { \$target .= ':'.\$data[7]; }
      if (defined \$data[8] && \$data[8] !~ m/^\s*\$/ ) { \$target .= ':'.\$data[8]; }
    
      my (\$duration)  = convert_format(\$CHECKS->{\$data});
    
      print \$TCF "<tr>\n";

      my (\$type)      = \$data[2];
      if ( \$type =~ m/SQL_COLLECT/ || \$type =~ m/OS_COLLECT/ ) {
        print \$TCF "<td scope=\"row\">\$name</td>\n";
      }
      else {
        print \$TCF "<td scope=\"row\"><a class=\"a_bgw\" href=\"\#".\$checkid."_details\">\$name</a></td>\n";
      }

      if ( \$type =~ m/SQL_COLLECT/ ) {
        print \$TCF "<td scope=\"row\" align=\"center\"> SQL Collection </td>\n";
      }
      elsif ( \$type =~ m/OS_COLLECT/ ) {
        print \$TCF "<td scope=\"row\" align=\"center\"> OS Collection </td>\n";
      }
      else {
        print \$TCF "<td scope=\"row\" align=\"center\"> \$type Check </td>\n";

      }
      print \$TCF "<td scope=\"row\" align=\"center\"> \$target </td>\n";
      print \$TCF "<td scope=\"row\" align=\"center\">".\$duration."</td>\n";
      print \$TCF "</tr>\n";
    
      \$count++;
      }
    
      print \$TCF "</table>";
    }
    
    my (\$EPOCH_TIME) = '`date +%s%3N`';
    if ( \$EPOCH_TIME =~ m/%3N$/ || \$EPOCH_TIME !~ m/^[0-9]*$/) { \$UNIT = "secs"; }

    if (-e \$CHKFILE) {
      open( my \$CTIME, "<", \$CHKFILE ) || die \$!;
      while ( my \$line = <\$CTIME> ) {
        if ( process_line(\$line) == 0 ) { next; } else { chomp(\$line); }	
        
        if ( \$line =~ m/Check Start Time/ ) {
          my \$CHECKID	= get_checkid(\$line);
          next if ( \$CHECKID eq "" );
          
          my \$TIME_st 	= get_time(\$line);
          my \$HOST	= get_host(\$line);
          my \$TYPE	= get_type(\$line);
          my \$COL_NAME   = get_cn(\$line);
          my \$CHK_NAME   = get_chkname(\$line);
      
          while ( my \$line = <\$CTIME> ) {
            if ( process_line(\$line) == 0 ) { next; } else { chomp(\$line); }	
      
            if ( \$line =~ m/Execution Start Time:/i && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
              my \$TIME_est 	= get_time(\$line);
      	      my \$TAG1 	= get_tag1(\$line);
      	      my \$TAG2 	= get_tag2(\$line);
      
              while ( my \$line = <\$CTIME> ) {
                if ( process_line(\$line) == 0 ) { next; } else { chomp(\$line); }
      
                if ( \$line =~ m/Check:get_log_result.*Start Time/i && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      	            my \$TIME_gst    = get_time(\$line);
      
                    while ( my \$line = <\$CTIME> ) {
                    if ( process_line(\$line) == 0 ) { next; } else { chomp(\$line); }
      
                    if ( \$line =~ m/Check:log_pass.*Start Time/ && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      	              my \$TIME_lpst = get_time(\$line);
      
                      while ( my \$line = <\$CTIME> ) {
                        if ( process_line(\$line) == 0 ) { next; } else { chomp(\$line); }
      
                        if ( \$line =~ m/Check:log_pass.*End Time/ && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      		          my \$TIME_lpet = get_time(\$line);
                          last;
                        }
                      }
                    }
                    if ( \$line =~ m/Check:log_fail.*Start Time/ && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      	              my \$TIME_lfst = get_time(\$line);
      
                      while ( my \$line = <\$CTIME> ) {
                        if ( process_line(\$line) == 0 ) { next; } else { chomp(\$line); }
      
                        if ( \$line =~ m/Check:fail.*End Time/ && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      		          my \$TIME_lfet = get_time(\$line);
                          last;
                        }
                      }
                    }
                    if ( \$line =~ m/Check:get_log_result.*End Time/i && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      	              my \$TIME_get = get_time(\$line);
                      last;
                    }
                  }
                }
                if ( \$line =~ m/Execution End Time:/i && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      	          my \$TIME_eet = get_time(\$line);
      	          timings(\$CHECKID, \$HOST, \$TYPE, \$TIME_eet, \$TIME_est, 'execution', "\$COL_NAME", "\$CHK_NAME", "\$TAG1", "\$TAG2");
      
                  last;
                }
              }
            }
            elsif ( \$line =~ m/Check:get_log_result.*Start Time/i && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
              my \$TIME_gst 	= get_time(\$line);
      	      my \$TAG1 	= get_tag1(\$line);
      	      my \$TAG2 	= get_tag2(\$line);
      
              while ( my \$line = <\$CTIME> ) {	        
                if ( process_line(\$line) == 0 ) { next; } else { chomp(\$line); }	
      
                if ( \$line =~ m/Execution Start Time:/i && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      	            my \$TIME_est = get_time(\$line);
      
                    while ( my \$line = <\$CTIME> ) {
                    if ( process_line(\$line) == 0 ) { next; } else { chomp(\$line); }	
      
                    if ( \$line =~ m/Check:log_pass.*Start Time/ && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      		        my \$TIME_lpst = get_time(\$line);
      
                        while ( my \$line = <\$CTIME> ) {
                        if ( process_line(\$line) == 0 ) { next; } else { chomp(\$line); }	
      
                        if ( \$line =~ m/Check:log_pass.*End Time/ && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      		          my \$TIME_lpet = get_time(\$line);
                          last;
                	  }	
                      }
                    }
                    if ( \$line =~ m/Check:log_fail.*Start Time/ && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      		      my \$TIME_lfst = get_time(\$line);
      
                      while ( my \$line = <\$CTIME> ) {
                        if ( process_line(\$line) == 0 ) { next; } else { chomp(\$line); }	
      
                        if ( \$line =~ m/Check:fail.*End Time/ && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      		          my \$TIME_lfet = get_time(\$line);
                          last;
                	}	
                      }
                    }
                    if ( \$line =~ m/Execution End Time:/i && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      		      my \$TIME_eet = get_time(\$line);
      		
      	              timings(\$CHECKID, \$HOST, \$TYPE, \$TIME_eet, \$TIME_est, 'execution', "\$COL_NAME", "\$CHK_NAME", "\$TAG1", "\$TAG2");
                      last;
                    }  
                  }
                }
                if ( \$line =~ m/Check:get_log_result.*End Time/i && \$line =~ m/\$CHECKID/ && \$line =~ m/\$HOST/i ) {
      	          my \$TIME_get = get_time(\$line);
                  last;
                }
              }
            }
      
            if ( \$line =~ m/Check End Time/ && \$line =~ m/\$CHECKID/ && \$line =~ m/\$TYPE/ ) {
              my \$TIME_et = get_time(\$line);
              last;
            }	
          }
        }
      }
      close(\$CTIME);
      print_info ();
    }
PERLEOF
}

#usage: get_current_epoch [1] 
get_current_epoch ()
{
  in_secs=$1

  t_epoch_time=$(date +%3N)
  epoch_time=$(date +%s)
  if [[ ${#t_epoch_time} -gt 3 ]];
  then
    t_epoch_time=$(echo "$t_epoch_time" | sed 's/^.*\(.\{3\}\)$/\1/')
    epoch_time=${epoch_time}${t_epoch_time}
  else
    epoch_time=$(date +%s%3N)
  fi

  #if [[ `echo "$epoch_time"|grep -c '%3N'` -gt 0 ]] || [[ -n $in_secs && $in_secs -eq "1" ]]
  if [[ `echo "$epoch_time"|grep -c '^[0-9]*$'` -eq "0" ]] || [[ -n $in_secs && $in_secs -eq "1" ]]
  then
    epoch_time=$(date +%s)
    #if [[ `echo "$epoch_time"|grep -c '%s'` -gt 0 ]]
    if [[ `echo "$epoch_time"|grep -c '^[0-9]*$'` -eq "0" ]] 
    then
      sysDateYear=$(date '+%Y')
      sysDateMonth=$(date '+%m'|sed 's/^0//')
      sysDateDay=$(date '+%d'|sed 's/^0//')
      sysDateHour=$(date '+%H'|sed 's/^0//')      
      #sysDateMin=$(date '+%H'|sed 's/^0//')      
      sysDateMin=$(date '+%M'|sed 's/^0//')      
      sysDateSec=$(date '+%S'|sed 's/^0//')      
      epoch_time=$(perl -e 'use Time::Local;print timelocal("'$sysDateSec'","'$sysDateMin'","'$sysDateHour'",'$sysDateDay','$sysDateMonth'-1,'$sysDateYear');') 
    fi  
  fi	
}

function swap_p_conf_file
{
  if [ -e "$1" ]
  then
    p_conf_file="$1"
  fi	
}

function extract_ibswitches
{
  if [[ $EM_PROBE_MODE -eq 1 && $em_probe_sudo_mode -eq 0 ]]
  then
    find_switch_root_password=$probe_root_password
  fi  

  first_compute_ip=$(cat $HOSTLIST|head -1)  
  if [[ -n "$compute_ssh_status" && $compute_ssh_status -ne 0 ]] || [[ $EM_PROBE_MODE -eq 1 && $em_probe_sudo_mode -eq 0 ]]
  then
    fixRootPassword "$find_switch_root_password"
    $EXPECT -f - << IBEOF
			   #set timeout 1
                           set timeout $passwordcheck_timeout
			   set le_find_switch_root_password "$fixedRootPassword"
			   log_user 0
			   if { "$RAT_EXPECT_DEBUG" == "-d" } {
			     exp_internal 1   
			   }
			   spawn -noecho $SSHELL ${root_user}@$first_compute_ip "ibswitches 2>/dev/null >${RTEMPDIR}/o_ibswitches_full.out"
			   match_max 100000
			   expect {
			   -nocase "permission denied *" {
				 exit 4;
				 }
			   -nocase "no)?" {
				 send -- "yes\n"
				 }
    			   -nocase "*?assword:*" {
                                 send -- "\$le_find_switch_root_password\n"
                                  }
			   -nocase eof {
				 exit
				 }
			   }
 			   expect {
                           -nocase "*?assword:*" {
                        	send -- "\$le_find_switch_root_password\n"
                           }
                           -nocase eof {
                                exit
                           } 
			   -nocase timeout {
                                send_error "Timed out while running ibswitches command \n";
                                exit
                           }
			   }
 			   expect {
                           -nocase eof {
                                exit
                           } 
			   -nocase timeout {
                                send_error "Timed out while running ibswitches command \n";
                                exit
                           }
			   }
IBEOF
  printf ". ";
  if [[ $first_compute_ip != $localnode ]]; then
    $EXPECT -f - << IBEOF
			   #set timeout 1
                           set timeout $passwordcheck_timeout
			   set le_find_switch_root_password "$fixedRootPassword"
			   log_user 0
			   if { "$RAT_EXPECT_DEBUG" == "-d" } {
			     exp_internal 1
			   }  
			   spawn $SCOPY ${root_user}@$first_compute_ip:${RTEMPDIR}/o_ibswitches_full.out ${RTEMPDIR}
			   match_max 100000
			   expect {
			   -nocase "permission denied *" {
				 exit 4;
				 }
			   -nocase "no)?" {
				 send -- "yes\n"
				 }
    			   -nocase "*?assword:*" {
                                 send -- "\$le_find_switch_root_password\n"
                                  }
			   -nocase eof {
				 exit
				 }
			   }
 			   expect {
                           -nocase "*?assword:*" {
                        	send -- "\$le_find_switch_root_password\n"
                           }
                           -nocase eof {
                                exit
                           } 
			   -nocase timeout {
                                send_error "Timed out while copying ${RTEMPDIR}/o_ibswitches_full.out from $first_compute_ip\n";
                                exit
                           }
			   }
 			   expect {
                           -nocase eof {
                                exit
                           } 
			   -nocase timeout {
                                send_error "Timed out while copying ${RTEMPDIR}/o_ibswitches_full.out from $first_compute_ip\n";
                                exit
                           }
			   }
IBEOF
  printf ". ";
  $EXPECT -f - << IBEOF
			   #set timeout 1
                           set timeout $passwordcheck_timeout
			   set le_find_switch_root_password "$fixedRootPassword"
			   log_user 0
			   if { "$RAT_EXPECT_DEBUG" == "-d" } {
			     exp_internal 1
			   }   
			   spawn $SSHELL ${root_user}@$first_compute_ip rm -f o_ibswitches_full.out
			   match_max 100000
			   expect {
			   -nocase "permission denied *" {
				 exit 4;
				 }
			   -nocase "no)?" {
				 send -- "yes\n"
				 }
    			   -nocase "*?assword:*" {
                                 send -- "\$le_find_switch_root_password\n"
                                  }
			   -nocase eof {
				 exit
				 }
			   }
 			   expect {
                           -nocase "*?assword:*" {
                        	send -- "\$le_find_switch_root_password\n"
                           }
                           -nocase eof {
                                exit
                           } 
			   -nocase timeout {
                                send_error "Timed out while removing o_ibswitches_full.out\n";
                                exit
                           }
			   }
 			   expect {
                           -nocase eof {
                                exit
                           } 
			   -nocase timeout {
                                send_error "Timed out while removing o_ibswitches_full.out\n";
                                exit
                           }
			   }
IBEOF
      printf ". ";
    fi
  else
    if [[ $EM_PROBE_MODE -eq 1 && $em_probe_sudo_mode -eq 1 ]]
    then
      $SSHELL $first_compute_ip "sudo ibswitches 2>/dev/null >${RTEMPDIR}/o_ibswitches_full.out 2>/dev/null 2>&1"

      if [[ $first_compute_ip != $localnode ]]; then
        $SCOPY $first_compute_ip:${RTEMPDIR}/o_ibswitches_full.out ${RTEMPDIR} >/dev/null 2>&1
        $SSHELL $first_compute_ip "sudo rm -f ${RTEMPDIR}/o_ibswitches_full.out>/dev/null 2>&1"
      fi
    else
      if [[ -n $db_root_ssh && $db_root_ssh -eq 0 ]]; then 
 	echo -e "No ${root_user} passsword and ssh to first compute node" >> $LOGFIL
	return; 
      fi

      $SSHELL ${root_user}@$first_compute_ip "ibswitches 2>/dev/null >${RTEMPDIR}/o_ibswitches_full.out 2>/dev/null 2>&1"
      if [[ $first_compute_ip != $localnode ]]; then
        $SCOPY ${root_user}@$first_compute_ip:${RTEMPDIR}/o_ibswitches_full.out ${RTEMPDIR} >/dev/null 2>&1
        $SSHELL ${root_user}@$first_compute_ip "rm -f ${RTEMPDIR}/o_ibswitches_full.out>/dev/null 2>&1"
      fi
    fi
    printf ". ";
  fi
}

function get_agentOwner
{
  if [ `uname -s` = "Linux" ]
  then
    agentOwner=$(stat -L -c "%U" $mb_emagent_home/bin/emctl 2>/dev/null >&1)
    if [ -z "$agentOwner" ]; then
      agentOwner=$(ls -l $mb_emagent_home/bin/emctl 2>/dev/null >&1|awk '{print $3}')
    fi
  else
    agentOwner=$(ls -l $mb_emagent_home/bin/emctl 2>/dev/null >&1|awk '{print $3}')
  fi
  if [ -n "$agentOwner" ]; then 
    agentGroup=$(groups "$agentOwner"|cut -d: -f2|awk '{print $1}'|sed 's/ //g');
  fi
}


function get_dbOwner
{
  localrun=1 
  if [[ -n $1 ]]; then
    if [[ $1 != $localnode ]]; then
      if [ -z $ORACLE_HOME ]; then
	localrun=1
      else
        localrun=0
        dbssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 $1 ls >/dev/null 2>&1;echo $?);
        if [[ -n "$dbssh_status" && $dbssh_status -eq 0 ]]; then 
	  t_flag="-T"
	  if [ `uname -s` = "Linux" ]
	  then
	    dbOwner=`$SSHELL $t_flag $1 "stat -L -c "%U" $ORACLE_HOME/bin/oracle 2>/dev/null >&1"`
	    if [ -z $dbOwner ]; then
	      dbOwner=`$SSHELL $t_flag $1 "ls -l $ORACLE_HOME/bin/oracle 2>/dev/null >&1|awk '{print \\$3}'"`
	    fi
	  else
	    dbOwner=`$SSHELL $t_flag $1 "ls -l $ORACLE_HOME/bin/oracle 2>/dev/null >&1|awk '{print \\$3}'"`
	  fi

	  if [ -n "$dbOwner" ]; then
	    dbGroup=`$SSHELL $t_flag $1 "groups "$dbOwner"|cut -d: -f2|awk '{print \\$1}'|sed 's/ //g'"`
	    dbhome_dir=`$SSHELL $t_flag $1 "cat /etc/passwd|grep -w "$dbOwner"|cut -d":" -f6"`
	  fi
	else
	  localrun=1
	fi
      fi
    fi	
  fi

  if [[ $localrun -eq 1 ]]; then 
    if [ -z $ORACLE_HOME ]; then
      dbOwner=$usern
      dbGroup=$(groups "$dbOwner"|cut -d: -f2|awk '{print $1}'|sed 's/ //g');
      dbhome_dir=$(cat /etc/passwd|grep -w "$dbOwner"|cut -d":" -f6);
    else
      if [ `uname -s` = "Linux" ]
      then
        dbOwner=$(stat -L -c "%U" $ORACLE_HOME/bin/oracle 2>/dev/null >&1)
        if [ -z "$dbOwner" ]; then
          dbOwner=$(ls -l $ORACLE_HOME/bin/oracle 2>/dev/null >&1|awk '{print $3}')
        fi
      else
        dbOwner=$(ls -l $ORACLE_HOME/bin/oracle 2>/dev/null >&1|awk '{print $3}')
      fi
      if [ -n "$dbOwner" ]; then 
        dbGroup=$(groups "$dbOwner"|cut -d: -f2|awk '{print $1}'|sed 's/ //g');
        dbhome_dir=$(cat /etc/passwd|grep -w "$dbOwner"|cut -d":" -f6);
      fi
    fi
  fi

  if [[ -e $dbhome_dir && -z $2 ]]; then 
    OLD_DIR=`pwd`
    cd "$dbhome_dir";
  fi
}

function finish_em_xml 
{
  update_probe_xml
  cat ${PROBE_XML};
  exit 0;
}

function save_crs ()
{
  if [ $is_windows -eq "0" ] ; then return; fi
  saved_CRS=$CRS
  unset CRS
  CRS=$saved_CRS
}

function ret_crs ()
{
  if [ $is_windows -eq "0" ] ; then return; fi
  export CRS
}


function update_probe_xml 
{
  XMODE="$1"
  XETYPE="$2"
  XEMSG="$3" 

  if [[ -z $XMODE ]]
  then
    echo "<questionnaire>" > ${PROBE_XML}.tmp.2
    
    if [[ -e ${PROBE_XML}.tmp ]]
    then
      if [[ `grep -c "id=\"${GID_EC}\"" ${PROBE_XML}.tmp` -gt 0 ]]; then
        echo "<group id=\"${GID_EC}\" groupHeader=\"${GID_EC_HDR}\">" >> ${PROBE_XML}.tmp.2
        sed -n "/<group id=\"${GID_EC}\" groupHeader=\"${GID_EC_HDR}\">/,/<\/group>/p" ${PROBE_XML}.tmp| grep -v "<group id=\"${GID_EC}\" groupHeader=\"${GID_EC_HDR}\"" |grep -v "</group>"  >> ${PROBE_XML}.tmp.2
        echo "</group>" >> ${PROBE_XML}.tmp.2
      fi
      
      if [[ `grep -c "id=\"${GID_DC}\"" ${PROBE_XML}.tmp` -gt 0 ]]; then
        echo "<group id=\"${GID_DC}\" groupHeader=\"${GID_DC_HDR}\">" >> ${PROBE_XML}.tmp.2
        sed -n "/<group id=\"${GID_DC}\" groupHeader=\"${GID_DC_HDR}\">/,/<\/group>/p" ${PROBE_XML}.tmp| grep -v "<group id=\"${GID_DC}\" groupHeader=\"${GID_DC_HDR}\"" |grep -v "</group>"  >> ${PROBE_XML}.tmp.2
        echo "</group>" >> ${PROBE_XML}.tmp.2
      fi

      if [[ `grep -c "id=\"${GID_CC}\"" ${PROBE_XML}.tmp` -gt 0 ]]; then
        echo "<group id=\"${GID_CC}\" groupHeader=\"${GID_CC_HDR}\">" >> ${PROBE_XML}.tmp.2
        sed -n "/<group id=\"${GID_CC}\" groupHeader=\"${GID_CC_HDR}\">/,/<\/group>/p" ${PROBE_XML}.tmp| grep -v "<group id=\"${GID_CC}\" groupHeader=\"${GID_CC_HDR}\"" |grep -v "</group>"  >> ${PROBE_XML}.tmp.2
        echo "</group>" >> ${PROBE_XML}.tmp.2
      fi
      
      if [[ `grep -c "id=\"${GID_SC}\"" ${PROBE_XML}.tmp` -gt 0 ]]; then
        echo "<group id=\"${GID_SC}\" groupHeader=\"${GID_SC_HDR}\">" >> ${PROBE_XML}.tmp.2
        sed -n "/<group id=\"${GID_SC}\" groupHeader=\"${GID_SC_HDR}\">/,/<\/group>/p" ${PROBE_XML}.tmp| grep -v "<group id=\"${GID_SC}\" groupHeader=\"${GID_SC_HDR}\"" |grep -v "</group>"  >> ${PROBE_XML}.tmp.2
        echo "</group>" >> ${PROBE_XML}.tmp.2
      fi
    fi
    
    echo "</questionnaire>" >> ${PROBE_XML}.tmp.2
    mv ${PROBE_XML}.tmp.2 ${PROBE_XML}.tmp

    esmodel=""
    estype=""

    if [[ -e $MASTERFIL ]]; then
      esmodel=`grep -iw COMPONENTS $MASTERFIL |grep -i "$localnode"|cut -d= -f2|cut -d: -f1|sed 's/ //g'`
      if [[ "$esmodel" = "NONE" ]]; then esmodel=`grep -iw COMPONENTS $MASTERFIL |grep -i "$localnode"|cut -d: -f2|sed 's/ //g'`; fi
      if [[ "$esmodel" = "EXADATA" ]]; then esmodel="V2"; fi

      if  [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]; then
	if [[ -n "$is_ssc_machine" && $is_ssc_machine -eq 1 ]]; then
          estype="SUPERCLUSTER"
	elif [[ "$is_avm_machine" &&  $is_avm_machine -eq 1 ]]; then
	  estype="RecoveryAppliance" 
	else
          estype="EXADATA"
	fi
      elif [[ -n " $is_exalogic_machine" &&  $is_exalogic_machine -eq "1" ]]; then
	assign_exalogic_module "$localnode"
	esmodel=`grep -iw COMPONENT $MASTERFIL |grep -i "$localnode"|cut -d= -f2|sed 's/NONE//g'|sed 's/ //g'|sed 's/^://g'|sed 's/:$//g'`
        estype="EXALOGIC"
      elif [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]]; then
        estype="EXALYTICS"
      elif [[ -n "$is_bda_machine" && $is_bda_machine -eq 1 ]]; then
        estype="BDA"
      elif [[ -n "$oda_machine" && $oda_machine -eq 1 ]]; then
        estype="OracleDatabaseAppliance"
      elif [[ "$is_avm_machine" && $is_avm_machine -eq 1 ]]; then
        estype="RecoveryAppliance"
      elif [[ $single_instance_run -eq 1 ]]; then
        estype="SingleInstance"
      elif [[ -n "$it_is_rac" && $it_is_rac -eq 1 ]]; then
  	estype="RACCHECK" 
      fi
    fi

    locVersion=$(echo $modelVersion|tr -d ' ')
    sed "s/PROGRAM_VERSION/$locVersion/g" $PROBE_XML > ${PROBE_XML}.tmp2
    mv ${PROBE_XML}.tmp2 $PROBE_XML
    sed "s/MACHINEMODEL/$esmodel/g" $PROBE_XML > ${PROBE_XML}.tmp2
    mv ${PROBE_XML}.tmp2 $PROBE_XML
    sed "s/MACHINETYPE/$estype/g" $PROBE_XML > ${PROBE_XML}.tmp2
    mv ${PROBE_XML}.tmp2 $PROBE_XML

    cat $PROBE_XML.tmp >> $PROBE_XML
  elif [[ $XMODE = "ERROR" ]]
  then
    if [[ $XETYPE = "GENERIC" ]]
    then
      cat >> $PROBE_XML << EOF
  <error id="$XETYPE">
    <message>
      $XEMSG
    </message>
  </error>
EOF
    elif [[ $XETYPE = "DAEMON" ]]
    then
      cat >> $PROBE_XML << EOF
  <error id="$XETYPE">
    <message>
      $XEMSG
    </message>
    <args>
      <arg id="location">$dloc</arg>	
      <arg id="version">$dversion</arg>	
    </args>
  </error>
EOF
    elif [[ $XETYPE = "ONEOFF_RUN" ]]
    then
      cat >> $PROBE_XML << EOF
  <error id="$XETYPE">
    <message>
      $XEMSG
    </message>
  </error>
EOF
    fi
    finish_em_xml 
  fi 

  cat >> $PROBE_XML <<EOF
</probeoutput>
EOF
  
  echo -e "\n\n"
  echo -e $GREEN"Probe Completed. Printing Probe Report"$NORM
  echo -e "\n\n"

  rm -f $PROBE_XML.tmp $PROBE_XML.tmp2 >/dev/null 2>&1;
}

function read_probe_xml
{
  op_search=$2
  qtype=0
  sline=$(echo "$EMXML" | grep -n "$1" | awk -F: '{print $1}' | sed 's/ //g')

  for (( i=$sline; i>=1; i-- ))
  do
    line=$(echo "$EMXML" | sed -n ${i}p)

    if [[ `echo "$line" | grep -c '<question '` -gt 0 ]];
    then
      xml_rvalue=$(echo "$line" | sed 's/^.*outcome="\(.*\)".*$/\1/')
      qtype=$(echo "$line" | grep -ic 'questionType="SECRET"')
      break
    fi
  done

  if [[ -n $op_search && $op_search -eq 1 ]]
  then
    sline=$(echo "$EMXML" | grep -n ">$xml_rvalue<" | awk -F: '{print $1}' | sed 's/ //g')
    for (( i=$sline; i>=1; i-- ))
    do
      line=$(echo "$EMXML" | sed -n ${i}p)

      if [[ `echo "$line" | grep -c '<option '` -gt 0 ]];
      then
        xml_rvalue=$(echo "$line" | sed 's/^.*id="\(.*\)".*$/\1/')
        break
      fi
    done
  fi

  unset tmp_xml_rvalue
  old_ifs=$IFS
  IFS=","
  for xvalue in $xml_rvalue
  do
    if [[ `echo "$EMXML" | grep -c "id=\"${xvalue}\""` -gt 0 ]]
    then
      tmp_xml_rvalue="${xvalue: -1}","${tmp_xml_rvalue}"
    fi
  done
  IFS=${old_ifs}

  if [[ -n $tmp_xml_rvalue ]]; then xml_rvalue=$(echo "$tmp_xml_rvalue" | sed 's/,$//g'); fi

  if [[ "$xml_rvalue" = 'True' ]] 
  then 
    xml_rvalue='Yes'; 
  elif [[ "$xml_rvalue" = 'False' ]] 
  then
    xml_rvalue='No'; 
  fi

  if [[ $qtype -eq 0 ]]
  then
    echo -e "$xml_rvalue\n";
  fi
}

move_files ()
{
  source_file="$1"
  target_file="$2"
  mode="$3"
  
  if [ -e "$source_file" ]; then
    if [[ -z $mode ]]; then
      cp "$source_file" "$target_file" >/dev/null 2>&1; 
    elif [[ "$mode" = "append" ]]; then
      cat "$source_file" >> "$target_file"
    fi
  fi
}

validate_tod ()
{
  if [ -e "$1" ]; then
    if [ ! -w "$1" ]; then
      echo -e ${RED}"$1 directory must be writable by all users for creating runtime files.Please set the RAT_TMP_OUTPUT and then re-run ${program_name}"${NORM}
      echo "ex: export RAT_TMP_OUTPUT=/tmp"
      echo -e ${RED}"\n\n${program_name} is exiting..${NORM}\n"
      exit 1 
    fi
  else
    echo -e ${RED}"$1 directory does not exists.Please set the RAT_TMP_OUTPUT and then re-run ${program_name}"${NORM}
    echo "ex: export RAT_TMP_OUTPUT=/tmp" 
    echo -e ${RED}"\n\n${program_name} is exiting..${NORM}\n"
    exit 1 
  fi

  rm -f $TMP_OUTPUT >/dev/null 2>&1; mkdir $TMP_OUTPUT >/dev/null 2>&1; chmod -R 777 $TMP_OUTPUT
}

set_rat_output ()
{
  if [ -z $RAT_OUTPUT ]; then
    if [[ `echo "$WRKDIR"|grep -c "/suptools$"` -gt 0 ]]; then
      oracle_home=$(echo "$WRKDIR"|sed "s/\/suptools$//g");
      orabasecmd=$oracle_home/bin/orabase
      if [[ -e $orabasecmd ]]; then
        export ORACLE_HOME=$oracle_home 
        ORACLE_BASE=`$orabasecmd`
        if [[ -e $ORACLE_BASE ]]; then
          if [[ ! -d $ORACLE_BASE/suptools/${program_name} ]]; then mkdir -p $ORACLE_BASE/suptools/${program_name}; fi 
          export RAT_OUTPUT=$ORACLE_BASE/suptools/${program_name}      
        fi
	unset ORACLE_HOME 
      fi
    fi
  fi
}

initialize ()
{
  assign_usern

  if [ -z "$RAT_ROOT_USER" ];then root_user="root"; else root_user=$RAT_ROOT_USER; fi
  user_uid=$(id $usern|awk '{print $1}'|sed 's/[^0-9]//g') 
  if [[ $usern = ${root_user} || $user_uid = "0" ]] ; then export RAT_ROOT_RUN=1; fi
  
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
    if [ -z $RAT_TMP_OUTPUT ]; then export RAT_TMP_OUTPUT='/tmp'; else export RAT_TMP_OUTPUT=$RAT_TMP_OUTPUT; fi; 
    TMP_OUTPUT=$RAT_TMP_OUTPUT/.${program_name}
  fi    

  #RPDIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
  RPDIR=$(cd -P -- "$(dirname -- "$0")" && printf '%s\n' "$(pwd -P)")
  if [[ -z $RAT_DB_PARALLEL ]] ; 
  then 
    export RAT_DB_PARALLEL=1; 
    SCRIPTPATH=$RPDIR
    #SCRIPTPATH=$(dirname $0)
    chmod 544 $SCRIPTPATH/.cgrep/psqlplus >/dev/null 2>&1
  fi
  
  export RAT_SCRIPT_DEBUG="$RAT_SCRIPT_DEBUG"
  if [[ ! -z $RAT_CLIENT_DEBUG ]] 
  then
    RAT_DEBUG_FLG="set -x";
    set -x
    PS4='$(date "+ $LINENO: + ")'
  fi
  
  if [[ ! -z $RAT_SCRIPT_DEBUG ]]
  then
    RAT_EXPECT_DEBUG="-d"
    RAT_DEBUG_FLG="set -x";
    set -x
    PS4='$(date "+ $LINENO: + ")'
    if [[ -z $RAT_REMOTE_MODE ]]; then
      timestamp=$(date '+%Y%m%d_%H%M%S')
  
      program_name=$(echo $(basename $0)|sed 's/[\.\/]//g')
      debugFileName=$(echo ${program_name}_debug_${timestamp}.log)
      if [[ -n $RAT_OUTPUT ]]; then
  	debugFileName=${RAT_OUTPUT}/${debugFileName}
      fi
      export RAT_REMOTE_MODE=1 
      export RAT_DEBUG_FILENAME_INTERNAL=${debugFileName}
      
      ${RPDIR}/${program_name} $@ 2>&1| tee $debugFileName

      set +x
      echo -e ""
      echo -e ""
      echo -e "Debug output file is $debugFileName";
      echo -e ""
      echo -e ""
  
      exit 0
    fi
  else
    RAT_DEBUG_FLG="";
  fi
  
  program_name=$(echo $(basename $0)|sed 's/[\.\/]//g')
  bash_found=$(which bash >/dev/null 2>&1;echo $?)
  SSH_PASS_STATUS=0
  
  #to disable strict bash settings
  set +u
  
  if [ $bash_found -ne 0 ]
  then
    echo -e "\n${RED}${program_name} requires the BASH shell. Please install bash and try again.${NORM}\n"
    exit 1;
  fi
 #display a deprecate message is somebody runs raccheck
  raccheck_deprecate_msg="RACcheck has been deprecated.  ORAchk provides the same functionality.  Please switch to using ORAchk from same directory.\n\nRACcheck will not be available after this (12.1.0.2.3) release.\n\nSee MOS Note \"RACcheck Configuration Audit Tool Statement of Direction - name change to ORAchk (Doc ID 1591208.1)\".\n"
  if [ "$program_name" = "raccheck" ]
  then 
      echo -e "\n${RED}$raccheck_deprecate_msg${NORM}\n"
  fi
  #if [ `uname -s` = "HP-UX" ]
  #then
  #   echo -e "\n${RED}The ${program_name} is not supported on `uname -s` platform yet.${NORM}\n"
  #fi
  
  export LC_ALL=C;
  NO_WRITE_PASS=0;
  ECHO=:
  DEBUG=:
  AUDITTAB=db_audit
  supported_modules="PREUPGR              
  POSTUPGR             
  NONE
  PREUPGRX3-8          
  POSTUPGRX3-2         
  EXALOGIC_DB          
  EXALOGIC_OVMM        
  EXALOGIC_EC          
  EXALOGIC_PC          
  EXALYTICS
  ODA                  
  PREUPGRX2-8          
  PREUPGRDBM           
  POSTUPGRX2-2         
  POSTUPGRX2-8         
  POSTUPGRDBM          
  EXALOGIC_VM          
  X3-8                 
  SIDB                 
  SIDBMAA              
  DBM                  
  MAA                  
  OVM                  
  OVS                  
  X2-2                 
  X2-8                 
  PREUPGRX2-2          
  POSTUPGRX3-8         
  X3-2                 
  EXALOGIC             
  RACCHECK             
  PREUPGRX3-2          
  SUPERCLUSTER         
  PREUPGRSUPERCLUSTER  
  POSTUPGRSUPERCLUSTER
  AVM
  BDAX2-2
  BDAX3-2
  X4-2
  EIGHTHX4-2
  PREUPGREIGHTHX4-2
  POSTUPGREIGHTHX4-2
  PREUPGRSIDB
  POSTUPGRSIDB
  "
  
  # Changes made by jrmullan 03/22/10
  if [ -n "$SUDOCMD" ]
  then
    # A valid sudo command was set up, this is specifically set for the Dell environment where they allow DBA's to
    # use sudo for specific files.  In this case /tmp/root_raccheck.sh
    echo ""
  else
    export SUDOCMD="/usr/bin/sudo"
  fi
  
  if [[ -n "$RAT_LOCALONLY" && $RAT_LOCALONLY -eq 1 ]]; then localonly=1;else localonly=0;fi
  
  trim="sed 's/^ *\(.*\) *$/\1/'"
  trim1="sed 's/^[[:space:]]*//g' | sed 's/[[:space:]]*$//g'"
  ltrim="sed 's/^[[:space:]]*//g'"
  rtrim="sed 's/[[:space:]]*$//g'"
  #AUDITTAB=bp_audit
  #location where raccheck.sh staged
  #CHECKHOME=$HOME/giri/stage
  #if [ ! -f $CHECKHOME/collections.dat ]
  #then
  #if [ `uname -s` = "Linux" ]
  #then
  #  CHECKHOME=$(readlink -f $0)
  #  CHECKHOME=$(dirname $CHECKHOME)
  #  CHECKHOME=$PWD
  #else
  #  CHECKHOME=$(dirname $0)
  #fi
  #$READ -p "CHECKHOME=$CHECKHOME"
  #fi
  #To fix bug reported by Srini to ignore ORACLE_SID when run in offline and create zip file at current working dir.
  
  CHECKHOME=$PWD
  
  PDIR=$PWD
  	
  V_PWD=$PWD
  if [ $is_windows -eq "1" ] ; then
    V_PWD=$(cygpath -w $PWD | sed 's/\\/\//g' )
  fi

  CHECKHOME=$V_PWD
  PDIR=$V_PWD

  if [ `echo $PWD|grep -iwc "suptools/${program_name}"` -ge 1 ]
  then
    if [ -f "$PWD/../../bin/orabase" ]; then
      nulstr="";
      result_string="${PDIR/suptools\/${program_name}/$nulstr}"
      PDIR=$result_string;
      export ORACLE_HOME="$PDIR";
      ADR_BASE=`$PWD/../../bin/orabase`;
      if [ ! -d "$ADR_BASE/${program_name}" ]; then
        mkdir $ADR_BASE/${program_name};
      fi
      if [ -d "$ADR_BASE/${program_name}" ]; then
        if [ -z "$RAT_OUTPUT" ]; then
          RAT_OUTPUT="$ADR_BASE/${program_name}";
          #echo "Output directory is $RAT_OUTPUT";
        fi
      fi
    fi
  fi
  
  #CHECKHOME_RELATIVE=$(dirname $0)
  
  if [[ -n "$ORACLE_SID" && $OFFLINE -eq 1 ]]
  #if [ -n "$ORACLE_SID" ]
  then
    WRKDIR=$CHECKHOME/$ORACLE_SID
  else
    WRKDIR=$CHECKHOME
  fi
  
  #Function to change old environment variable names to new standard environment names
  change_old_env_variables 

  set_rat_output
  
  #following check is to have output directory created at some diffrent local other than where we run raccheck from.
  if [ -z $RAT_OUTPUT ]; then WRKDIR=$WRKDIR; else WRKDIR=$RAT_OUTPUT; fi; 
  
  check_wrkdir;
  assign_usern
  
  SCRIPTPATH=$RPDIR
  #SCRIPTPATH=$(dirname $0)
  SCRIPTFIL=$SCRIPTPATH/$program_name
  REFFIL=$SCRIPTPATH/collections.dat
  REFFIL1=$SCRIPTPATH/rules.dat
  
  if [[ -n "$RAT_FDS_INTERNAL" ]] ; then # In slave mode, its set
    FDS=$RAT_FDS_INTERNAL
  else
    FDS=`date '+%m%d%y_%H%M%S'`
  fi
  
  SKIP_CRS_VAL=0
  PROBE_XML=${WRKDIR}/${program_name}_em_probe.xml
  INPUTDIR=${WRKDIR}/.input_${FDS}
  SQLFIL=$INPUTDIR/d_check.sql
  UPLOADFIL_VAR=$program_name
  UPLOADFIL=$WRKDIR/${UPLOADFIL_VAR}_$FDS
  OUTPUTDIR_VAR=$program_name
  OUTPUTDIR=$WRKDIR/${OUTPUTDIR_VAR}_$FDS
  SPOOLFIL=$OUTPUTDIR/d_check.out
  OSOUTFIL=$OUTPUTDIR/o_check
  UPDATEFIL=$OUTPUTDIR/db_update_$FDS.sql
  SQLLOGFIL=$OUTPUTDIR/sql.log
  LOGFIL=$OUTPUTDIR/${program_name}.log
  SKIPFIL=$OUTPUTDIR/${program_name}_skipped_checks.log
  REPFIL=$OUTPUTDIR/${program_name}.rep
  XMLREPFIL=$OUTPUTDIR/${program_name}_results.xml
  XMLSKIPFIL=$OUTPUTDIR/${program_name}_exceptions.xml
  XMLRECFIL=$OUTPUTDIR/${program_name}_recommendations.xml
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then  
    ERRFIL=$TMP_OUTPUT/${program_name}_error.log
    OLD_ERRFIL=$OUTPUTDIR/${program_name}_error.log
  else
    ERRFIL=$OUTPUTDIR/${program_name}_error.log
  fi
  HOSTLIST=$OUTPUTDIR/o_host_list.out
  MASTERFIL=$OUTPUTDIR/raccheck_env.out
  ORCLENVFIL=$INPUTDIR/set_orcl_env.sh
  SREPFIL=$OUTPUTDIR/${program_name}_summary.rep
  WRNDBPWD=0
  WATCHDOG=$INPUTDIR/watchdog.sh
  WATCHLOG=$OUTPUTDIR/watchdog.log
  EXESQL=$INPUTDIR/exec_raccheck_sqls.sh
  napply_missing_list=$OUTPUTDIR/o_napply_missing_list.out
  upload_raccheck_result_fil_base=$OUTPUTDIR/upload_${program_name}_result_base.sql
  upload_raccheck_result_fil=$OUTPUTDIR/upload_${program_name}_result.sql
  upload_raccheck_patch_result_fil=$OUTPUTDIR/upload_${program_name}_patch_result.sql
  REPFIL_PASS=$OUTPUTDIR/${program_name}_pass.rep
  REPFIL_FAIL=$OUTPUTDIR/${program_name}_fail.rep
  SREPFIL_PASS=$OUTPUTDIR/${program_name}_summary_pass.rep
  SREPFIL_FAIL=$OUTPUTDIR/${program_name}_summary_fail.rep
  CWCREPFIL_PASS=$OUTPUTDIR/${program_name}_cwc_pass.rep
  SCWCREPFIL_PASS=$OUTPUTDIR/${program_name}_cwc_summary_pass.rep
  CWCREPFIL_FAIL=$OUTPUTDIR/${program_name}_cwc_fail.rep
  SCWCREPFIL_FAIL=$OUTPUTDIR/${program_name}_cwc_summary_fail.rep
  PREPFIL=$OUTPUTDIR/${program_name}_patches.rep
  PSREPFIL=$OUTPUTDIR/${program_name}_patches_summary.rep
  CWSQLPARAM=$OUTPUTDIR/${program_name}_cw_sqlparam.out
  CWOSPARAM=$OUTPUTDIR/${program_name}_cw_osparam.out
  CWOSPKG=$OUTPUTDIR/${program_name}_cw_ospkg.out
  CWOSPATCH=$OUTPUTDIR/${program_name}_cw_ospatch.out
  CELLSREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_summary_pass.rep
  CELLSREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells_summary_fail.rep
  CELLREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_pass.rep
  CELLREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells__fail.rep
  IBSREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_summary_pass.rep
  IBSREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib_summary_fail.rep
  IBREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_pass.rep
  IBREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib__fail.rep
  CELLIBNTFILE=$OUTPUTDIR/cell_ib_count.out
  EL_GVM_FILE=$WRKDIR/el_guest_vms.out
  
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
    PSQL_INFIL=$TMP_OUTPUT/.db_data.out
    PSQL_METAFIL=$TMP_OUTPUT/.chk_metadata.out
    PSQL_STAT=$TMP_OUTPUT/.chk_stat.out
  else
    PSQL_INFIL=$INPUTDIR/.db_data.out
    PSQL_METAFIL=$INPUTDIR/.chk_metadata.out
    PSQL_STAT=$INPUTDIR/.chk_stat.out
  fi
  PROFILEONLY=$SCRIPTPATH/.cgrep/profile_only.dat
  COLLDIFFFIL=$WRKDIR/collection_diff_candidate.log
  CHECKSFILE=$WRKDIR/total_checks_summary.out


  if [ -z "$RAT_EXCLUDEFILE" ]
  then 
    if [ -r $SCRIPTPATH/exclude_checks.txt ]
    then 
      EXCLUDEFIL=$SCRIPTPATH/exclude_checks.txt
    else 
      EXCLUDEFIL=$SCRIPTPATH/excluded_check_ids.txt
    fi
  else
    EXCLUDEFIL=$RAT_EXCLUDEFILE 
  fi
  #Setting TMPDIR to /tmp for ODA as requested in 20212859 RAT_KEEP_SUDO_TMP=1 to have root script in /tmp
  if [[ -e /opt/oracle/oak/install/inittab && -w /tmp ]]; then RAT_TMPDIR=/tmp;RAT_KEEP_SUDO_TMP=1;fi
  if [ -n "$RAT_TMPDIR" ];then TMPDIR=$RAT_TMPDIR;else TMPDIR=$HOME;fi
  if [ -n "$RAT_CELL_TMPDIR" ];then CELLTMPDIR=$RAT_CELL_TMPDIR;else CELLTMPDIR="~";fi
  if [ -n "$RAT_IB_TMPDIR" ];then IBTMPDIR=$RAT_IB_TMPDIR;else IBTMPDIR="~";fi
  
  export TMPDIR

  EXCLUDELOG=$OUTPUTDIR/excluded_check_ids.log
  RTEMPDIR=$TMPDIR/.${program_name}
  CELLRTEMPDIR=$CELLTMPDIR/.${program_name}
  IBRTEMPDIR=$IBTMPDIR/.${program_name}
  RTEMPDIR_D=$TMPDIR/.${program_name}_${usern}_d
  SYSTEM_DESC_FIL=${CELLRTEMPDIR}/cell_system_description.out 
  SerialNumberFil=/var/log/cellos/SerialNumbers
  LOCKFIL=${RTEMPDIR}/${program_name}.pid
  AVMIDFIL=/opt/oracle.SupportTools/onecommand/databasemachine.xml
  SWITCH_TYPE_FIL=$OUTPUTDIR/switch_ip_type_name_mapping_detail.out
  SWITCH_TYPE_FIL_SHORT=switch_ip_type_name_mapping_detail.out
  TMPSTFILE=$TMPDIR/tmp_status.sh
  MAIL_PROGRAM=${RTEMPDIR_D}/mail_script.sh
  ROOTSCRPT="$INPUTDIR/root_${program_name}".sh
  ZFSAKSHSCRIPT="$SCRIPTPATH/.cgrep/exalogic_zfs_checks.aksh" 
  delete_lock_file=0
  no_patches=0
  num_sql_queries=0
  
  if [ -z "$RAT_SSHELL" ]
  then
    SSHELL="/usr/bin/ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o LogLevel=quiet -q"
    if [[ -n $RAT_SCRIPT_DEBUG && $RAT_SCRIPT_DEBUG -eq 1 ]] ; then
      SSHELL="/usr/bin/ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o LogLevel=quiet -v -q"
    fi
    #SSHELL_EL=$(echo ${SSHELL}t)
  else
    SSHELL=$RAT_SSHELL   
  fi
  SSHELL_EL=$(echo ${SSHELL} -t)

  if [ -z "$RAT_SCOPY" ]
  then
    SCOPY="/usr/bin/scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -q"
  else
    SCOPY=$RAT_SCOPY
  fi
  
  if [ -z "$RAT_EXPECT" ]
  then
    U_EXPECT=/usr/bin/expect
  else
    U_EXPECT=$RAT_EXPECT
  fi
  if [[ -n "$RAT_EXPECT_STRACE_DEBUG" && "$RAT_EXPECT_STRACE_DEBUG" = "strace" && `uname -s` = "Linux" ]]; 
  then 
    EXPECT="strace $U_EXPECT"
  else
    EXPECT=$U_EXPECT
  fi
  
  write_report_on_fail=1
  write_switchname_in_report=1
  write_cellname_in_report=1 
  noRootScriptNodeCount=0
  cgrep_platform=$(uname -s)
  COLLECT_TIMING=$OUTPUTDIR/${program_name}_collection_timings.out
  ROOT_COLLECT_TIMING=${RTEMPDIR}/o_root_collect_timing.out
  CHECKS_TIMING=$OUTPUTDIR/${program_name}_checks_timings.out
  RACCHECK_TIMING=$OUTPUTDIR/${program_name}_timings.out
  MISCCWCHECK=$OUTPUTDIR/o_misc_clusterwide_checks.out
  CHK_TIMINGS=$OUTPUTDIR/${program_name}_epoch_checks_timings.out
  EXADATA_CELL_COLLECTIONS=$TMPDIR/o_exadata_disk.out 
  CELLDIR="$OUTPUTDIR/.CELLDIR"
  fmt_line_header="---------------------------------------------------------------------------------"
  ROOT_LCKFIL=$RTEMPDIR/root_collection_running.dmp
  SIGNFIL=$TMPDIR/.${program_name}.loc
  DAEMONFIL=${RTEMPDIR_D}/.${program_name}_daemon.loc
  DAEMONDEB=$WRKDIR/${program_name}_daemon_debug.log
  ABSTPATH=$(cd -P -- "$(dirname -- "$0")" && printf '%s\n' "$(pwd -P)/$(basename -- "$0")")
  
  #this was unset because tr command does not work if LANG is set to on Solaris.reported by e-dialog
  unset LANG NLS_LANG
  
  # Defaults
  INITDMP="$WRKDIR/.${program_name}_initsetup.dmp"
  components=NONE
  upgrade_mode=0
  print_pass_on_screen=0
  TYP_S=""
  TYP="-a"
  ASREXACHK=asrexacheck #variable to store the name of asreaxchk script
  checkFlashCache=checkFlashCache.sh
  cross_node_checkids_counter=0 #variable to store index couter for cross_node_checkid
  process_cross_node_checks=0
  skip_maa_scorecard=0
  skip_hacheck=0
  run_profile=0;
  profiles2run=""
  exclude_profile=0;
  profiles2exclude=""
  is_ssc_machine=0
  is_exalogic_machine=0
  is_bda_machine=0
  print_pass_in_report=1
  print_score_in_report=1
  
  read_p2r=0
  p2r_org=""
  
  long_args=0
  
  daemon_mode=0
  daemon_command="";
  daemon_only=0
  setup_inittab=0
  remote_setup_ssh=0
  prepare_init=0
  
  argnew="$*"
  argsaved="$*"
  UPDATE_RUN=0
  run_args=""
  
  setting_conf=0
  options2set=""
  unset_conf=0
  options2unset=""
  p_conf_file="$WRKDIR/.${program_name}_conf.dmp"
  cur_p_conf_file="$RTEMPDIR_D/.${program_name}_cur_conf.dmp"
  autorun_list="$WRKDIR/.${program_name}_list.dmp"
  daemon_init_mode=0
  daemon_init_mode_sudo=0
  ebs32bit=0
  exalogic_hybrid=0
  phy_nodes=""
  set_db_par_limit=0
  autorun_id=${program_name}.default
  setting_autorun_id=0
  
  EM_PROBE_MODE=0
  EM_XMLD_MODE=0
  em_probe_sudo_mode=1
  
  if [[ -z $RAT_LT_VERCHECK && $program_name = "orachk" ]]; then
    lt_ver_check=1;
  elif [[ -n $RAT_LT_VERCHECK && $RAT_LT_VERCHECK = 0 ]]; then
    lt_ver_check=0;
  fi

  prompt_timeout=0
  is_exadata_dom0_machine=0
  is_ssc_localzone_machine=0
  is_ssc_globalzone_machine=0
  is_ssc_globalzone_dbmachine=0
  IBHOSTS=/usr/sbin/ibhosts
  ZONENAME=/usr/bin/zonename
  #if [ `echo "$argsaved" | grep -cw 'd *start'` -gt "0" ] ; then
  #  argsaved=$(echo "$argsaved" | sed 's/-d *start//')
  #  daemon_start="-d start"
  #  set " $daemon_start"
  #fi
}

re_initialize ()
{
  `echo "$EMXML" | grep '<export>' | sed 's/<export>/export /g' | sed 's/<\/export>//g'`
  initialize "$@"
}

unset_root_run ()
{
  unset RAT_ROOT_RUN
  ERRFIL=$OUTPUTDIR/${program_name}_error.log
  PSQL_INFIL=$INPUTDIR/.db_data.out
  PSQL_METAFIL=$INPUTDIR/.chk_metadata.out
  PSQL_STAT=$INPUTDIR/.chk_stat.out
}

update_ld_lib_path () 
{
  REPLACE_HOME=${ORACLE_HOME} 
  if [[ -n "$1" && "$1" = "CRS" ]]; then 
    REPLACE_HOME=${stack_asm_home[$stack_counter]}
    if [[ -n "$crs112" && $crs112 -ge 1 ]]; then REPLACE_HOME=$CRS; fi
  fi

  LD_LIBRARY_PATH=$(grep "^LD_LIBRARY_PATH=" $ORCLENVFIL | cut -d"=" -f2 |sed 's/ //g')
  sed  "/LD_LIBRARY_PATH/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
  
  echo "if [[ \"\${LD_LIBRARY_PATH:-unset}\"  = \"unset\" ]] ; then LD_LIBRARY_PATH=\"\"; fi">>$INPUTDIR/tmp_env_file.out
  if [[ `echo "$LD_LIBRARY_PATH" | grep -c "^${REPLACE_HOME}/lib:"` -eq 0 ]]; then
    echo "LD_LIBRARY_PATH=$REPLACE_HOME/lib:${LD_LIBRARY_PATH}" >>$INPUTDIR/tmp_env_file.out
    echo "export LD_LIBRARY_PATH=$REPLACE_HOME/lib:${LD_LIBRARY_PATH}">>$INPUTDIR/tmp_env_file.out
  else
    echo "LD_LIBRARY_PATH=${LD_LIBRARY_PATH}" >>$INPUTDIR/tmp_env_file.out
    echo "export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}">>$INPUTDIR/tmp_env_file.out
  fi
  
  cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
  rm $INPUTDIR/tmp_env_file.out
}

search_latest_version ()
{
  skip_search_latest_version=1
  running_from_home=0
  PROGDIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

  if [[ -n "$RAT_ORATAB_LOC" ]]
  then
   ORATAB=$RAT_ORATAB_LOC;
  else
   case `/bin/uname` in
     Linux) 
       ORATAB="/etc/oratab"
     ;;
     SunOS) 
       ORATAB="/var/opt/oracle/oratab" 
     ;;
     HP-UX) 
       ORATAB="/etc/oratab"
     ;;
     AIX)   
       ORATAB="/etc/oratab"
     ;;
     CYGWIN_NT-[0-9].[0-9])
       ORATAB="win_oratab.out"
     ;;
     *)
       /bin/echo "ERROR: Unknown Operating System"
     ;;
   esac
  fi
 
  if [ -f "$ORATAB" ]; then
    for spath in `grep ":/" $ORATAB |grep -v "^#"|cut -d: -f2`
    do
      program_dir=""
      if [ -d ${spath}/suptools ]; then 
	program_dir="${spath}/suptools"
	if [[ `echo "$RAT_SEARCH_LOC" | grep -c ",${program_dir}"` -eq 0 ]]; then RAT_SEARCH_LOC="${RAT_SEARCH_LOC},${program_dir}"; fi
      fi

      if [ -d ${spath}/suptools/${program_name} ]; then 
	program_dir="${spath}/suptools/${program_name}"; 
	if [[ `echo "$RAT_SEARCH_LOC" | grep -c ",${program_dir}"` -eq 0 ]]; then RAT_SEARCH_LOC="${RAT_SEARCH_LOC},${program_dir}"; fi
      fi
    done
    RAT_SEARCH_LOC="${RAT_SEARCH_LOC},${ORACLE_BASE}/DB_TOOLS/${program_name}"
    RAT_SEARCH_LOC=$(echo "$RAT_SEARCH_LOC"| sed 's/,,/,/g' | sed 's/^,//' | sed 's/,$//g') 

    old_ifs=$IFS
    IFS=","    
    for path in `echo "$RAT_SEARCH_LOC"` 
    do
      if [[ "$PROGDIR" = "$path" ]]; then running_from_home=1; break; fi
    done 
    IFS=$old_ifs

    if [[ -n $running_from_home && $running_from_home -eq "1" ]]; then skip_search_latest_version=0; else return; fi

    RAT_SEARCH_LOC=$(echo "$RAT_SEARCH_LOC"| sed "s|$RPDIR||g")
    RAT_SEARCH_LOC=$(echo "$RAT_SEARCH_LOC"| sed 's/,,/,/g' | sed 's/^,//' | sed 's/,$//g') 

    old_ifs=$IFS
    IFS=","    
    for path in `echo "$RAT_SEARCH_LOC"`
    do
      files_present=0
      if [[ -f ${path}/${program_name} && -f ${path}/collections.dat ]]; then
        files_present=1
      elif [ -f ${path}/${program_name}.zip ]; then
        cd ${path}
 	zip -o "$program_name.zip" >/dev/null 2>&1;
        if [[ $? -eq 0 && -f ${path}/${program_name} && -f ${path}/collections.dat ]]; then
	  files_present=1
        fi
        cd $PWD
      fi
      if [[ $files_present -eq 1 ]] ; then
	VERSION=`${path}/${program_name} -v`
        VERSION=$(echo "$VERSION" | grep -i ${program_name}| grep "VERSION" | cut -d':' -f2 | sed 's/ //g')
        versionmap=("${versionmap[@]}" $VERSION:$path);
      fi
    done 
    IFS=$old_ifs 

    LATEST_VERSION=`${RPDIR}/${program_name} -v`
    LATEST_VERSION=$(echo "$LATEST_VERSION" | grep -i ${program_name}| grep "VERSION" | cut -d':' -f2 | sed 's/ //g')
    LATEST_KIT_PATH="${RPDIR}"
    for mapping in ${versionmap[@]}
    do
      KIT_VERSION=${mapping%%:*}
      KIT_PATH=${mapping#*:} 

      t_LATEST_VERSION=$(echo "$LATEST_VERSION" | cut -d"_" -f2)
      t_KIT_VERSION=$(echo "$KIT_VERSION" | cut -d"_" -f2)

      if [[ $t_LATEST_VERSION -lt $t_KIT_VERSION ]]; then 
	LATEST_VERSION=${KIT_VERSION};
	LATEST_KIT_PATH=${KIT_PATH}; 
      fi
    done
    #if [[ "$LATEST_KIT_PATH" = "$PDIR" ]]; then unset LATEST_KIT_PATH; fi
  else
#    LATEST_VERSION=`${RPDIR}/${program_name} -v`
    LATEST_VERSION=`echo -e "\n$program_name  version: ${program_version}_${dataFIleYear}${dataFIleMonthNo}${dataFIleDay}"|tr "[a-z]" "[A-Z]"`
    LATEST_VERSION=$(echo "$LATEST_VERSION" | grep -i ${program_name}| grep "VERSION" | cut -d':' -f2 | sed 's/ //g')
    LATEST_KIT_PATH="${RPDIR}"
  fi
}

process_prompt ()
{
  prompt_code=$1
  var_name=$2
  var_value=$3

  if [[ $prompt_timeout -eq 1 ]]; then
    if [[ $prompt_code -ne 0 ]]; then
      eval "$var_name=\"$var_value\""
    fi
  fi
}

exalytics_reads_domains_xml ()
{
  if [[ -e /u01/app/oracle/product/exalytics/config/domains.xml && -z "$RAT_BI_HOMES" ]]
  then 
      exalytics_domains=$(grep -iw "oraclehome=" /u01/app/oracle/product/exalytics/config/domains.xml|gawk 'BEGIN{FS="oracleHome="}{print $2}'|cut -d\" -f2) 
      for exalytics_domain in $exalytics_domains
      do
          domain_short_path=$(dirname $(dirname $exalytics_domain))
          RAT_BI_HOMES=$(echo $RAT_BI_HOMES $domain_short_path) 
      done
  fi
}
#======================================================================================================================
#Set the defaults
#multilinemb_db_homes_fil 
#main scripts execution starts from here
#RAT_TMPDIR

#if [[ ${program_name} = "exachk" ]]; then TOOL_ID='ec'; else TOOL_ID='oc'; fi

initialize "$@"

for arg in "$@"
do
  remove_arg=0
  
  if [[ $read_p2r = "-profile" ]] ; then
    if [[ $arg = "-h" ]] ; then
      usage_profilesw;exit 1;
    fi
    p2r_org="$arg"
    #profiles2run=$(echo $arg| sed 's/,/ /g');
    profiles2run=$arg
    remove_arg=1
    run_args="$run_args -profile $arg"
  elif [[ $read_p2r = "-excludeprofile" ]] ; then
    p2r_org="$arg"
    profiles2exclude=$arg
    remove_arg=1
    run_args="$run_args -excludeprofile $arg"
  elif [[ $read_p2r = "-id" ]] ; then
    setting_autorun_id=1
    remove_arg=1
    autorun_id=$(echo "$arg" | sed 's/ //g')
    if [[ -z $autorun_id || `echo "$autorun_id" |grep -c "^\s*$"` -gt "0" ]] ; then usage_daemon; exit 1; fi;
  elif [[ $read_p2r = "-set" ]] ; then
    setting_conf=1
    remove_arg=1
    options2set="$arg"
  elif [[ $read_p2r = "-unset" ]] ; then
    unset_conf=1
    remove_arg=1
    options2unset="$arg"
  elif [[ $read_p2r = "-get" ]] ; then
    reading_conf=1
    remove_arg=1
    options2get="$arg"
  elif [[ $read_p2r = "-auto_restart" ]]; then
    if [[ $arg = "-h" ]] ; then
      usage_AR;exit 1;
    fi
  elif [[ $read_p2r = "-d" ]]; then
    if [[ $arg = "-h" ]] ; then
      usage_dopt;exit 1;
    fi
  elif [[ $read_p2r = "-dbparallel" ]] ; then
    if [[ `perl -e 'if ( "'$arg'" =~ m/[0-9]+$/ ) {print "1";} else {print "0";}'` -gt "0" ]]; then
    #if [[ `echo "$arg"|grep -Ec "[0-9]+$"` -gt 0 ]]; then
      export RAT_DB_PAR_LIMIT="$arg"
    fi
  elif [[ $read_p2r = "-clusternodes" ]] ; then
    export RAT_CLUSTERNODES="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-output" ]] ; then
    export RAT_OUTPUT="$arg"
    initialize
    remove_arg=1
  elif [[ $read_p2r = "-tag" ]] ; then
    TAG=_"$arg"
    remove_arg=1
  elif [[ $read_p2r = "-phy" ]] ; then
    if [ $exalogic_hybrid -eq "1" ] ; then
      phy_nodes="$arg"
      remove_arg=1
    fi
  elif [[ $read_p2r = "-vmguest" ]] ; then
    export RAT_EL_GVM="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-cells" ]] ; then
    export RAT_CELLS="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-zfsnodes" ]] ; then
    export RAT_ZFS_NODES="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-ibswitches" ]] ; then
    export RAT_IBSWITCHES="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-outfile" ]] ; then
    report3="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-targetversion" ]]; then
    targetversion="$arg" 
    remove_arg=1
  elif [[ $read_p2r = "-dbnames" ]] ; then
    export RAT_DBNAMES="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-systemtype" ]]; then
    export SYS_TYPE="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-orainst" ]]; then
    ask_inv_loc="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-merge" ]]; then
    export MERGEFILES="$arg"
    remove_arg=1
  #elif [[ $read_p2r = "-probe" ]]; then
  #  probe_root_password="$arg" 
  #  em_probe_sudo_mode=0 
  #  remove_arg=1
  elif [[ $read_p2r = "-auto_restart" ]]; then
   if [[ $arg = "-h" ]] ; then
    usage_AR;exit 1;
   fi
  elif [[ $read_p2r = "-d" ]]; then
   if [[ $arg = "-h" ]] ; then
    usage_dopt;exit 1;
   fi
  fi

  if [ $remove_arg -eq "1" ] ; then
    arg=$(echo "$arg"| sed 's/\*/\\\*/g')
    #argnew=$(echo "$argnew" | sed 's/'"$read_p2r"'//' | sed "s/$arg//")
    argnew=$(echo "$argnew" | sed 's|'"$read_p2r"'||' | sed "s|$arg||")
    long_args=1
  fi

  case $arg in 
  "-profile")
    run_profile=1;
    TYP="-b";
    read_p2r="$arg"
    ;;
  "-h")
    usage_granular $read_p2r;exit 1;
    ;;
  #"-diff")
  #  read_p2r="$arg"
  #  ;;
  "-dbserial")
    export RAT_DB_PARALLEL=0
    unset RAT_DB_PAR_LIMIT    
    read_p2r="$arg"
    remove_arg=2
    ;;
  "-dbparallel")
    export RAT_DB_PARALLEL=1    
    set_db_par_limit=1
    read_p2r="$arg"
    remove_arg=2
    ;;
  "-excludeprofile")
    exclude_profile=1;
    TYP="-b";
    read_p2r="$arg"
    ;;
  "-id")
    read_p2r="$arg"
    ;;
  "-set"|"-get"|"-unset")
    read_p2r="$arg"
    ;;
  "-clusternodes")
    read_p2r="$arg"
    ;;
  "-output")
    read_p2r="$arg"
    ;;
  "-tag")
    read_p2r="$arg"
    ;;
  "-phy")
    read_p2r="$arg"
    ;;
  "-force")
    read_p2r="$arg"
    SKIP_CRS_VAL=1 
    remove_arg=2
    ;;
  "-vmguest")
    read_p2r="$arg"
    ;;
  "-merge")
    TYP="-f"
    read_p2r="$arg"
    ;;
  "-dbnames")
    read_p2r="$arg"
    ;;
  "-cells")
    read_p2r="$arg"
    ;;
  "-zfsnodes")
    read_p2r="$arg"
    ;;
  "-ibswitches")
    read_p2r="$arg"
    ;;
  "-auto_restart")
    read_p2r="$arg"
    ;;
  "-localonly")
    read_p2r="$arg"
    localonly=1
    export RAT_LOCALONLY=1
    remove_arg=2
    ;;
  "-silentforce")
    read_p2r="$arg"
    prompt_timeout=1
    remove_arg=2
    ;;
  "-noupgrade")
    read_p2r="$arg"
    remove_arg=2
    no_upgrade=1
    ;;
  "-oracle_restart")
    read_p2r="$arg"
    export RAT_ORACLE_RESTART=1
    remove_arg=2
    ;;
  "-probe")
    read_p2r="$arg"
    EM_PROBE_MODE=1
    export RAT_EM_PROBE=1
    remove_arg=2
    ;;
  "-upgrade")
    set_upgrade=1
    read_p2r="$arg"
    ;;  
  "-debug")
    read_p2r="$arg"
    export RAT_SCRIPT_DEBUG=1

    insargs="$@"
    insargs=$(echo "$insargs"|sed 's/-debug//g')

    #PDIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )" 
    PDIR=$(cd -P -- "$(dirname -- "$0")" && printf '%s\n' "$(pwd -P)")
    ${PDIR}/${program_name} "$insargs"
    exit 0
    ;;
   "-a")
     read_p2r="$arg"
     ;;
   "-b")
     read_p2r="$arg"
     ;;
   "-v")
     read_p2r="$arg"
     ;;
   "-p")
     read_p2r="$arg"
     ;;
   "-m")
     read_p2r="$arg"
     ;;
   "-u")
     read_p2r="$arg"
     ;;
   "-f")
     read_p2r="$arg"
     ;;
   "-o")
     read_p2r="$arg"
     ;;
   "-clusternodes")
     read_p2r="$arg"
     ;;
   "-output")
     read_p2r="$arg"
     ;;
   "-dbnames")
     read_p2r="$arg"
     ;;
   "-c")
     read_p2r="$arg"
     ;;
   "-d")
     read_p2r="$arg"
     ;;
  "-dbnone")
    read_p2r="$arg"
    export RAT_DBNONE=1
    remove_arg=2
    ;;
  "-dball")
    read_p2r="$arg"
    export RAT_DBALL=1
    remove_arg=2
    ;;
  "-ebs32bit")
    read_p2r="$arg"
    ebs32bit=1
    remove_arg=2
    ;;
  "-hybrid")
    read_p2r="$arg"
    exalogic_hybrid=1
    remove_arg=2
    ;;
  "-initpresetup")
    read_p2r="$arg"
    prepare_init=1
    remove_arg=2
    ;;
  "-init")
    read_p2r="$arg"
    daemon_init_mode=1
    remove_arg=2
    ;;
  "-initsudo")
    read_p2r="$arg"
    daemon_init_mode=1
    daemon_init_mode_sudo=1
    remove_arg=2
    ;;
  "-initsetup")
    read_p2r="$arg"
    setup_inittab=1
    remove_arg=2
    ;;
  #"-initrestart")
  #  read_p2r="$arg"
  #  setup_inittab=2
  #  remove_arg=2
  #  ;;
  "-initcheck")
    read_p2r="$arg"
    setup_inittab=3
    remove_arg=2
    ;;
  "-initrmsetup")
    read_p2r="$arg"
    setup_inittab=10
    remove_arg=2
    ;;
  #"-update")
  #  read_p2r="$arg"
  #  UPDATE_RUN=1 
  #  remove_arg=2
  #  ;;
  "-nopass")
    read_p2r="$arg"
    print_pass_in_report=0
    remove_arg=2
    run_args="$run_args -nopass"
    export RAT_UPLOAD_PASS_CHECKS=0
    ;;
  "-noscore")
    read_p2r="$arg"
    print_score_in_report=0
    remove_arg=2
    run_args="$run_args -noscore"
    ;;
#  "-noupgrade")
#    read_p2r="$arg"
#    remove_arg=2
#    no_upgrade=1
#    run_args="$run_args -noupgrade"
#    ;;
  "-preupgrade")
    TYP="-u"
    upgrade_mode=1
    remove_arg=2
    argnew="-u -o pre"
    ;;
  "-postupgrade")
    TYP="-u"
    upgrade_mode=1
    remove_arg=2
    argnew="-u -o post"
    ;;
  "-targetversion")
    read_p2r="$arg"
    supportedTargetVersion="112030 112040 121010 121020 122010 122000"
    supportedTargetVersionPrint="11.2.0.3.0,11.2.0.4.0,12.1.0.1.0,12.1.0.2.0 or 12.2.0.1.0"
    ;;
  "-sf")
    #change this line before beta (scp)
    scp $2 me@mhost:/home/cgirdhar/test_reports
    exit 0
    ;;
  "-setupssh")
    remote_setup_ssh=1
    func_remote_setup_ssh $*
    exit 0
    ;;
  "-diff")
    compare_reports $*
    exit 0
    ;;
  "-exadiff")
    compare_exalogic_rack $*
    exit 0
    ;;
  #"-resetcrs")
  #  reset_crs $*
  #  exit
  #  ;;
  "-outfile")
    read_p2r="$arg"
    ;;
  "-nodaemon")
    read_p2r="$arg"
    opt_n=1;
    remove_arg=2
    ;;
  "-daemon")
    read_p2r="$arg"
    daemon_only=1;
    remove_arg=2
    ;;
  "-systemtype")
    read_p2r="$arg"
    ;;    
  "-orainst")
    read_p2r="$arg"
    ;;
  "-a")
    read_p2r="$arg"
    ;;
  "-b")
    read_p2r="$arg"
    ;;
  "-v")
    read_p2r="$arg"
    ;;
  "-p")
    read_p2r="$arg"
    ;;
  "-m")
    read_p2r="$arg"
    ;;
  "-u")
    read_p2r="$arg"
    ;;
  "-f")
    read_p2r="$arg"
    ;;
  "-o")
    read_p2r="$arg"
    ;;
  "-clusternodes")
    read_p2r="$arg"
    ;;
  "-output")
    read_p2r="$arg"
    ;;
  "-dbnames")
    read_p2r="$arg"
    ;;
  "-c")
    read_p2r="$arg"
    ;;
  "-d")
    read_p2r="$arg"
    ;;
  *)
    read_p2r="none"
    ;;
  esac

  if [ $remove_arg -eq "2" ] ; then
    read_p2r=$(echo "$read_p2r"| sed 's/\*/\\\*/g')
    argnew=$(echo $argnew | sed 's/'"$read_p2r"'//')
    long_args=1
  fi
done

if [ ! -n "$perl_exe" ] ; then perl_exe=$(which perl|tr -d '\r'); fi
tag_without_sp=$(echo "$TAG" | $perl_exe -p -e "s/[\W\s]//g")
if [[ -n "$TAG" && $TAG != "$tag_without_sp" ]] ; then
  echo -e ${RED}"Invalid tag"${NORM}
  usage_granular "-tag"
  echo -e "\n${RED}${program_name} is exiting..\n"${NORM}
  exit 1;
fi 

# Exit options not supported in windows
if [ $is_windows -eq "1" ] ; then
  if [[ $setup_inittab -eq "1" || $daemon_init_mode -eq 1 || $daemon_init_mode_sudo -eq "1" || $prepare_init -eq "1" ]] ; then
    echo 
    echo "The flag '$*' is not supported in windows.. exiting..";
    echo
    exit;
  fi
fi

#if [[ -n "$TAG" && `echo "$TAG"|sed 's/^_//g'|grep -cE "^[0-9a-zA-Z]+$"` -eq 0 ]]; then 
#  echo -e ${RED}"Invalid tag"${NORM}
#  usage_granular "-tag"
#  echo -e "\n${RED}${program_name} is exiting..\n"${NORM}
#  exit 1;
#fi 

if [[  $set_upgrade -eq "1" ]] ; then
  if [[ -n  "$RAT_UPGRADE_LOC" ]] ; then
    check_upgrade
    if [[ "$check_upgrade_ret_val" != "0" && "$check_upgrade_ret_val" != "-1" ]]
    then
      upgrade_orachk
    else
	if [ "$check_upgrade_ret_val" = "-1" ]
        then
                echo "
        unzip is not found. please install unzip, add it to the path and run again.
                ";
	else
		echo "
        No new version is available in RAT_UPGRADE_LOC.
      ";
        fi
    fi
  else
    echo "
	RAT_UPGRADE_LOC not set
    ";
  fi 
  exit 0
fi

argnew_afterlong=""
if [[ -n "$long_args" && $long_args -eq "1" ]] ; then
  argnew_afterlong=$(echo $argnew| sed 's/ //g')
  #if [[ -z "$argnew" || `echo "$argnew" | grep -ic '^ *$'` -gt "0" ]] ; then argnew="-b"; fi
  if [[ -z "$argnew" || `echo "$argnew" | grep -ic '^ *$'` -gt "0" ]] ; then argnew="-a"; fi
else
  argnew="$*"
  argnew_afterlong="$argnew"
fi
#To add current directory in PATH to execute cgrep from current location

#argnew=$(echo "$argnew"|sed "s/^\s*//g" | sed "s/\s*$//g")
argnew=$(echo "$argnew"|sed "s/^[ ]*//g" | sed "s/[ ]*$//g")

argnew_chk=`perl <<PERLEOF
if ( "$argnew" =~ m/[a-zA-Z]{2,}$/ ) {print "1";} else {print "0";}
PERLEOF
`

if [[ $argnew_chk -gt "0" ]] && [[ `echo "$argnew" | grep -c "\-d"` -le "0" ]] && [[ `echo "$argnew" | grep -c "\-o "` -le 0 ]] && [[ `echo "$argnew" | grep -c "\-c"` -le "0" ]]; then display_usage; exit 1; fi
#if [[ $argnew_chk -gt "0" ]] && [[ `echo "$argnew" | grep -c "\-d \|\-o "` -le 0 ]]; then display_usage; exit 1; fi
#if [[ `echo "$argnew" | grep -Ec "[a-zA-Z]{2,}$"` -gt 0 ]] && [[ `echo "$argnew" | grep -c "\-d \|\-o "` -le 0 ]]; then usage; fi

argsnum=$#
while getopts "abnvhpfmsuSo:c:t:d:" OPT $argnew
do
  case $OPT in
  a) 
     TYP="-a"
     run_args="$run_args $TYP"
     ;;
  b) 
     TYP="-b"
     run_args="$run_args $TYP"
     ;;
  p) 
     TYP="-p"
     run_args="$run_args $TYP"
     ;;
  f) 
     TYP="-f"
     ;;
  s) 
     TYP_S="-s"
     no_upgrade=1
     ;;
  t) 
     supportedTargetVersion="112030 112040 121010 121020 122010 122000"
     supportedTargetVersionPrint="11.2.0.3.0,11.2.0.4.0,12.1.0.1.0,12.1.0.2.0 or 12.2.0.1.0"
     if [ -n "$OPTARG" ]
     then
       targetversion=$OPTARG
     else
       echo "Invalid input for target version.";
       exit 1;
     fi
     ;;
  u) 
     TYP="-u"
     upgrade_mode=1
     opt_n=1
     supportedTargetVersion="112030 112040 121010 121020 122010 122000"
     supportedTargetVersionPrint="11.2.0.3.0,11.2.0.4.0,12.1.0.1.0,12.1.0.2.0 or 12.2.0.1.0"
     run_args="$run_args $TYP"
     ;;
  S)
     TYP_S="-S"
     no_upgrade=1
     ;;
  o)
     case $OPTARG in
     verbose|VERBOSE|Verbose|V|v)
       print_pass_on_screen=1
       ;;
     pre)
       if [[ -n "$upgrade_mode" && $upgrade_mode -eq 1 ]];then upgrade_mode=2;components=$(echo "${components}:PREUPGR");fi
       ;;
     post)
       if [[ -n "$upgrade_mode" && $upgrade_mode -eq 1 ]];then upgrade_mode=3;if [ -f "/opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP" ]; then components=$(echo "${components}:POSTUPGR");else components=$(echo "${components}:RACCHECK:MAA:POSTUPGR");fi;fi
       ;;
     *)
       echo "Invalid option : -o $OPTARG"
       exit 1;
       ;;
     esac
     ;;
  c)
     if [ -n "$OPTARG" ]
     then
       OPTARG=$(echo $OPTARG|tr "[A-Z]" "[a-z]")
       OPTARG=$(echo "$OPTARG"|sed 's/[:_,]/:/g')
       components=$OPTARG
       options_components=$OPTARG
       #$READ -p "options_components=$options_components"  
     fi
     ;;
  n)
     opt_n=1;
     ;;
  d)
     daemon_mode=1;
     daemon_command="start";
     if [ -n "$OPTARG" ]
     then
       OPTARG=$(echo $OPTARG|tr "[A-Z]" "[a-z]") 
       daemon_command="$OPTARG";
     fi
     ;;
  v)
     lt_ver_check=0
     TYP="-v"
     ;;
  m)
     TYP="-m"
     skip_maa_scorecard=1 
     run_args="$run_args $TYP"
     ;;
  r)
     TYP="-r"
     skip_hacheck=1 
     run_args="$run_args $TYP"
     ;;
  *) display_usage; exit 1;;
  esac
done

shift `expr $OPTIND`
#if [ $# -gt 5 ]
#then
# usage
#fi

#change this line before going beta 
program_version="12.1.0.2.3"

READ="read"
if [[ $prompt_timeout -eq 1 ]]
then
  if [[ -z $RAT_PROMPT_TIMEOUT ]]; then export RAT_PROMPT_TIMEOUT=0; fi
  READ="read -t $RAT_PROMPT_TIMEOUT"
fi

if [[ $EM_PROBE_MODE -eq 1 ]]
then
  #group ids
  #GID_EC='g1'; GID_EC_HDR="${program_name} Configuration";
  GID_EC='g1'; GID_EC_HDR="General Configuration";
  GID_DC='g2'; GID_DC_HDR="Database Configuration";
  GID_CC='g3'; GID_CC_HDR="Cell Cluster Configuration";
  GID_SC='g4'; GID_SC_HDR="Infiniband Configuration";

  EMINPUT=$(cat);

  for VALUES in `echo "$EMINPUT"`
  do
    if [[ `echo $VALUES| grep -ic "PASSWORD"` -gt 0 ]];
    then
      probe_root_password=$(echo "$VALUES"|grep -i 'PASSWORD'|cut -d'=' -f2|sed 's/ //g');
    else
      export $VALUES
    fi
  done

  initialize "$@"
  EM_PROBE_MODE=1
  
  if [[ -n $probe_root_password && `echo "$probe_root_password"|sed 's/ //g'` != "" ]] || [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then 
    em_probe_sudo_mode=0; 
  fi

  echo "<?xml version=\"1.0\" encoding=\"utf-8\"?>" > $PROBE_XML 
  #echo "<probeoutput ${program_name}Version=\"$program_version\" ESModel=\"MACHINEMODEL\" ESType=\"MACHINETYPE\">" >> $PROBE_XML
  echo "<probeoutput ${program_name}Version=\"PROGRAM_VERSION\" ESModel=\"MACHINEMODEL\" ESType=\"MACHINETYPE\">" >> $PROBE_XML

  echo "<exports>" >> $PROBE_XML
  env|grep "^RAT_" | grep -v 'RAT_EM_PROBE' | sed 's/^/  <export>/' | sed 's/$/<\/export>/' >> $PROBE_XML
  echo "</exports>" >> $PROBE_XML
fi

if [[ -n "$reading_conf" && $reading_conf -eq "1" || -n "$setting_conf" && $setting_conf -eq "1" || -n "$unset_conf" && $unset_conf -eq "1" ]]
then
  modify_conf_file
else
  if [[ -n "$setting_autorun_id" && $setting_autorun_id -eq "1" ]] && [[ -n "$daemon_mode" && $daemon_mode -ne "1" ]]
  then
    usage_daemon; exit 1;
  fi  
fi

#if [[ $# -lt 1 || -z "$TYP" ]]
if [[ $argsnum -lt 1 || -z "$TYP" ]]
then
  TYP="-a"
fi

if [[ -n "$RAT_DBNONE" && $RAT_DBNONE -eq "1" ]]; then dboption="none"; fi;
if [[ -n "$RAT_DBALL" && $RAT_DBALL -eq "1" ]]; then dboption="all"; fi;

if [[ -n "$reading_conf" && $reading_conf -eq "1" ]] ; then
  show_conf_file $options2get
  exit 0
fi

if [ -n "$MERGEFILES" ]
then
  TYP="-f"
  perl_exe=$(which perl|tr -d '\r');
  if [ -n "$perl_exe" ] ; then
    localhost=$(hostname|cut -d"." -f1)
    $perl_exe $SCRIPTPATH/.cgrep/merge_collections.pl -f ${MERGEFILES} -n $localhost -p ${program_name} -d ${WRKDIR} -o ${SKIP_CRS_VAL}
    mr_code=$(echo $?);

    if [ $mr_code -eq 5 ]
    then
      echo -e ""
      echo -e "Collections are not from same CLUSTER."
    
      for mergedir in `echo "$MERGEFILES"|sed 's/,/ /g'`
      do
	mergedir=$(echo "$mergedir"|sed 's/\.zip//g');
    	found_cluster_name=$(grep CLUSTER_NAME ${mergedir}/outfiles/check_env.out | awk -F"=" '{print $2}')
    	echo -e "  $mergedir : $found_cluster_name"	
      done	

      echo -e ${RED}"\nPlease use -force if candidate collections are from dom0 and domu or global and local zones like ./${program_name} -merge $MERGEFILES -force."${NORM}
      echo -e ${RED}"\n${program_name} is exiting.."${NORM}
      rm -rf $WRKDIR/.MERGED_COLLECTIONS >/dev/null 2>&1;
      exit 1;
    elif [ $mr_code -eq 4 ]
    then
      echo -e ""
      echo -e ${RED}"Please specify correct collections and re-run ${program_name}."${NORM}
      echo -e ${RED}"\n${program_name} is exiting.."${NORM}
      rm -rf $WRKDIR/.MERGED_COLLECTIONS >/dev/null 2>&1;
      exit 1
    fi
    NEW_MASTERFIL1=$WRKDIR/.MERGED_COLLECTIONS/check_env.out.merge
  fi
fi

if [[ "$TYP" = "-u" && $upgrade_mode -eq 1 ]]; then echo -e "\n${RED}specify -o pre or -o post option with -u argument like ./${program_name} -u -o pre\n\n${NORM}";display_usage;fi
user_components=$components

if [[ -n "$setting_conf" && $setting_conf -eq "1" ]] || [[ -n "$unset_conf" && $unset_conf -eq "1" ]] ; then
  update_conf_file
  if [ -z "$argnew_afterlong" ] ; then exit 1; fi
fi

daemon_running=0
if [[ -e "$RTEMPDIR_D/daemon.pid" ]] ; then # daemon is running
  dpid=$(cat $RTEMPDIR_D/daemon.pid)
  if [[ -n "$dpid" && `ps -ef | grep $dpid | grep -v grep | wc -l` -gt "0" ]] ; then
    daemon_running=1
  fi
fi

a_daemon_running=0
if [[ `ps -ef|grep -v 'grep'|grep "${program_name}"|grep -vw "$usern"|grep -ic '\-d start'` -gt "0" ]] ; then
  a_daemon_running=2
  a_daemon_user=$(ps -ef|grep -v 'grep'|grep "${program_name}"|grep -vw "$usern"|grep '\-d start'|cut -d' ' -f1|head -1|sed 's/ //g')
  A_RTEMPDIR_D="$TMPDIR/.${program_name}_${a_daemon_user}_d"
  if [[ -d "$A_RTEMPDIR_D" ]] ; then
    a_daemon_running=1
  else
    HDIR=$(cat /etc/passwd|grep -w "$a_daemon_user"|cut -d":" -f6);
    A_RTEMPDIR_D="$HDIR/.${program_name}_${a_daemon_user}_d"
    if [[ -d "$A_RTEMPDIR_D" ]] ; then
      a_daemon_running=1
    fi   
  fi
fi

if [[ $daemon_running -eq "0" && -n "$RTEMPDIR_D" && -d "$RTEMPDIR_D" ]] ; then
  rm -rf $RTEMPDIR_D
fi

# Dont use daemon for offline, silent or -S/-s
#if [[ "$TYP" = "-f" || "$TYP_S" = "S" || "$TYP_S" = "s" ]] ; then
if [[ "$TYP" = "-f" || "$TYP" = "-v" ]] ; then
  opt_n=1
fi

if [[ -n "$opt_n" && $opt_n -eq "1" ]] ; then
  daemon_running=0
  daemon_command=""
  daemon_mode=0
fi

if [[ $EM_PROBE_MODE -eq 1 ]] ; then
 d_running=0
 if [[ $a_daemon_running -eq "1" ]]
 then
    DAEMONFIL="${A_RTEMPDIR_D}/.${program_name}_daemon.loc" 
    d_running=1 
 elif [[ $daemon_running -eq "1" ]]
 then
    d_running=1 
 fi

 if [[ $d_running -eq "1" ]]; then
   if [ -r "$DAEMONFIL" ] ; then
     dloc=$(grep "Install location" $DAEMONFIL|cut -d'=' -f2|sed 's/ //g')   
     dversion=$(grep "${program_name} daemon version" $DAEMONFIL|cut -d'=' -f2|cut -d'_' -f1|sed 's/ //g')   
   fi 
   EMSG="$program_name is already running in daemon mode."
   update_probe_xml "ERROR" "DAEMON" "$EMSG"
   exit 1
 fi
fi

if [[ -n "$daemon_only" && $daemon_only -eq "1" && $daemon_running -eq "0" ]] ; then
  echo
  echo -e "${RED}$program_name daemon is not running. Please start it using '$program_name -d start'${NORM}";
  echo
  exit 1;
fi

if [[ -n "$daemon_command" && $daemon_command = "start_debug" ]]
then
  daemon_command="start"
  RAT_DAEMON_DEBUG=1
elif [[ -n "$daemon_command" && $daemon_command = "xml_start_debug" ]]
then
  EMXML=$(cat);
 
  re_initialize "$@"
  RAT_DAEMON_DEBUG=1
  EM_XMLD_MODE=1
  daemon_command="start"
  daemon_mode=1;
elif [[ -n "$daemon_command" && $daemon_command = "xml_start" ]]
then
  EMXML=$(cat);

  re_initialize "$@"
  EM_XMLD_MODE=1
  daemon_command="start"
  daemon_mode=1;
else
  if [[ -z $RAT_DAEMON_DEBUG ]]
  then
    RAT_DAEMON_DEBUG=0
  else
    RAT_DAEMON_DEBUG=$RAT_DAEMON_DEBUG
  fi
fi
export RAT_DAEMON_DEBUG="$RAT_DAEMON_DEBUG"

if [[ -n "$daemon_command" && $daemon_command != "start" && $daemon_command != "stop" && $daemon_command != "status" && $daemon_command != "nextautorun" && $daemon_command != "info" && $daemon_command != "stop_client" ]] ; then
  echo
  echo -e "${RED}Invalid daemon command $daemon_command. Valid options are start,start_debug,stop,status,info,stop_client,nextautorun${NORM}";
  echo
  exit 1;
fi

if [[ $daemon_running -eq "1" && -n "$daemon_command" && $daemon_command = "start" ]] ; then
  echo
  echo -e "${RED}Daemon is already running with PID $dpid${NORM}";
  echo
  exit 1;
fi

if [[ $a_daemon_running -eq "1" ]]
then
  echo
  if [[ -n "$daemon_command" && $daemon_command = "start" ]] ; then
    if [ -r "$A_RTEMPDIR_D/daemon.pid" ]
    then
      a_dpid=$(cat $A_RTEMPDIR_D/daemon.pid)
      echo -e "${RED}Daemon is already running with PID $a_dpid which is started by ${a_daemon_user} user${NORM}"; 
    else
      echo -e "${RED}Daemon is already running which is started by ${a_daemon_user} user${NORM}"; 
    fi
    echo
    exit 1;
  elif [[ -n "$daemon_command" && $daemon_command = "status" ]] ; then
    if [ -r "$A_RTEMPDIR_D/daemon.pid" ]
    then
      a_dpid=$(cat $A_RTEMPDIR_D/daemon.pid)
      echo -e "Daemon is running with PID $a_dpid which is started by ${a_daemon_user} user"
    else
      echo -e "Daemon is running which is started by ${a_daemon_user} user"; 
    fi
    echo
    exit 1;
  elif [[ -n "$daemon_command" && $daemon_command = "info" ]] ; then
    echo -e "Daemon is running which is started by ${a_daemon_user} user"; 

    A_DAEMONFIL="${A_RTEMPDIR_D}/.${program_name}_daemon.loc" 
    if [ -r "$A_DAEMONFIL" ] ; then
      cat $A_DAEMONFIL
    fi 
    echo
    exit 1;
  elif [[ -n "$daemon_command" && $daemon_command = "stop" ]] ; then
    if [ -r "$A_RTEMPDIR_D/daemon.pid" ]
    then
      a_dpid=$(cat $A_RTEMPDIR_D/daemon.pid)
      echo -e "${RED}Daemon is running with PID $a_dpid which is started by ${a_daemon_user} user.${NORM}"; 
    else
      echo -e "${RED}Daemon is running which is started by ${a_daemon_user} user.${NORM}"; 
    fi
    echo -e "${RED}Please login as ${a_daemon_user} user and then stop the daemon.${NORM}";
    echo
    exit 1;
  fi
elif [[ -n "$daemon_command" && $a_daemon_running -eq "2" ]]
then
  echo 
  if [[ -n "$daemon_command" && $daemon_command = "start" ]] ; then
    echo -e "${RED}Daemon is already running which is started by ${a_daemon_user} user${NORM}";
  elif [[ -n "$daemon_command" && $daemon_command = "status" ]] ; then
    echo -e "Daemon is running which is started by ${a_daemon_user} user";
  elif [[ -n "$daemon_command" && $daemon_command = "info" ]] ; then
    echo -e "Daemon is running which is started by ${a_daemon_user} user";
    echo -e "No more information available";
  elif [[ -n "$daemon_command" && $daemon_command = "stop" ]] ; then
    echo -e "${RED}Daemon is running which is started by ${a_daemon_user} user.${NORM}";
    echo -e "${RED}Please login as ${a_daemon_user} user and then stop the daemon.${NORM}";
  fi
  echo 
  exit 1;
fi


if [[ $daemon_running -eq "0" && $daemon_command = "nextautorun" ]] ; then
  echo
  echo -e "${RED}$program_name daemon is not running. Please start it using '$program_name -d start'${NORM}";
  echo
  exit 1;
elif [[ $daemon_command = "nextautorun" ]] ; then
  next_autorun_on
  exit 1 
fi

if [[ -n "$daemon_command" && $daemon_command = "info" ]] ; then
  if [[ $daemon_running -eq "1" ]] ; then
    if [ -e "$DAEMONFIL" ] ; then
      cat $DAEMONFIL
    else
      echo -e "${RED}No information available.${NORM}";
    fi
  else
    echo "$program_name daemon is not running.";
  fi
  echo
  exit 1;
fi

if [[ -n "$daemon_command" && $daemon_command = "start" &&  ! -e "$EXPECT" ]] ; then
  # expect should be there
  echo -e "${RED}Could not start ${program_name} in daemon mode because expect($EXPECT) is not available to supply ${root_user} passwords.${NORM}" 
  echo
  echo -e "${RED}NOTICE:  Installing the expect utility ($EXPECT) will allow ${program_name} to gather ${root_user} passwords at the beginning of the process and execute ${program_name} on all nodes in parallel speeding up the entire process. For more info - http://www.nist.gov/el/msid/expect.cfm.  Expect is available for all major platforms.  See User Guide for more details.${NORM}"
  echo;
  exit 1;
fi

if [[ $daemon_running -eq "1" && -n "$daemon_command" && $daemon_command = "stop" ]] ; then
  printf "Stopping $program_name daemon.. ";
  if [ -e "$RTEMPDIR_D/commands" ] ; then
    echo
    if [ -f "$RTEMPDIR_D/client.pid" ] ; then
      cpid=$(cat $RTEMPDIR_D/client.pid);
    else
      cpid=$(cat $RTEMPDIR_D/run.pid);
    fi
    echo -e "${RED}Failed to stop the $program_name daemon as there is an active client run (PID : $cpid)${NORM}"
    echo
    touch $RTEMPDIR_D/stop
    echo "$program_name daemon will be stopped once the active client run is finished.";
    echo
    exit 1;
  fi
  stop_daemon_actual
elif [[ $daemon_running -eq "0" && -n "$daemon_command" && $daemon_command = "stop" ]] ; then
  echo "$program_name daemon is not running"
  exit 1
fi

if [[ -n "$daemon_command" && $daemon_command = "stop_client" ]] ; then
  if [[ $daemon_running -eq "1" ]] ; then
     stop_daemon_client 
  else
     echo "$program_name daemon is not running.";
  fi
  echo
  exit 1;
fi

if [[ -n "$daemon_command" && $daemon_command = "status" ]] ; then
  if [[ $daemon_running -eq "1" ]] ; then
    echo "$program_name daemon is running. Daemon PID : $dpid";
  else
    echo "$program_name daemon is not running.";
  fi
  echo
  exit 1;
fi

# Client mode. just submit command and wait for daemon
if [ `echo $argsaved | grep -cw 'update'` -eq "0" ] 
then
  if [[ $daemon_running -eq "1" && -z "$daemon_command" && -z "$RAT_DAEMON_CLIENT" ]] 
  then
    if [[ -n "$setup_inittab" && $setup_inittab -ne "3" ]] 
    then
      if [ -e "$RTEMPDIR_D/commands" ] 
      then
        echo "Another $program_name instance is already in queue.. exiting";
        exit 1;
      fi
    fi
  
    if [[ `echo "$argsaved"|grep -ic 'initrmsetup'` -eq 0 && `echo "$argsaved"|grep -ic 'initcheck'` -eq 0 && `echo "$argsaved"|grep -ic 'initrestart'` -eq 0 && `echo "$argsaved"|grep -ic 'initsetup'` -eq 0 ]]
    then
      trap 'cleanup_client $USER_INTERRUPT' INT TERM EXIT
      echo "Sending commands to daemon (mypid $$) args : $argsaved"
  
      submit_client_run
    fi
  fi
fi

profileids2run=""
profileids2exclude=""

if [[ $run_profile -eq "1" && -z "$profiles2run" ]] || [[ $exclude_profile -eq "1" && -z "$profiles2exclude" ]] ; then
  echo -e "${RED}Profile name is missing${NORM}"
  echo;
  usage_profilesw; 
  exit 1;
elif [[ $exclude_profile -eq "1" ]]; then
  profile_db_checks=1
  profile_root_checks=1
  profile_cell_checks=1
  profile_zfs_checks=1
  profile_switch_checks=1
  profile_module_checks=1
  profile_cvm_only=1

  ex_selected_profiles=0
  old_ifs=$IFS
  IFS=","
  for aprofile in $profiles2exclude
  do
    aprofile_id=$(grep -i "^$aprofile|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2|sed 's/ //g')
    if [ -z "$aprofile_id" ] ; then
      echo -e "${RED}Selected excludeprofile $aprofile does not exists.. exiting ${NORM}"
      echo;
      IFS="$old_ifs"
      usage_profiles; 
      exit 1;
    elif [ ! -e "$SCRIPTPATH/.cgrep/profiles/$aprofile_id.prf" ] ; then
      echo -e "${RED}Selected excludeprofile $aprofile does not exists.. exiting ${NORM}"
      echo;
      IFS="$old_ifs"
      usage_profiles; 
      exit 1;
    fi
    if [ -n $aprofile_id ]; then 
      if [ -z $profileids2exclude ]; then 
        profileids2exclude=$aprofile_id
      else
        profileids2exclude="$profileids2exclude $aprofile_id"
      fi
    fi
    ex_selected_profiles=$(expr $ex_selected_profiles + 1)
  done

  cell_in_exprofile=$(echo "$profiles2exclude" | grep -icw storage_server)
  if [ $cell_in_exprofile -eq 0 ];then cell_in_exprofile=$(echo "$profiles2exclude" | grep -icw storage);fi
  
  switch_in_exprofile=$(echo "$profiles2exclude" | grep -icw switch)
  zfs_in_exprofile=$(echo "$profiles2exclude" | grep -icw zfs)
  ellite_in_exprofile=$(echo "$profiles2exclude" | grep -icw el_lite)
  elextensive_in_exprofile=$(echo "$profiles2exclude" | grep -icw el_extensive)

  dba_in_exprofile=$(echo "$profiles2exclude" | grep -icw dba)
  clusterware_in_exprofile=$(echo "$profiles2exclude" | grep -icw clusterware)
  sysadmin_in_exprofile=$(echo "$profiles2exclude" | grep -icw sysadmin)

  if [[ $ex_selected_profiles -ge "1" ]] && [[ $sysadmin_in_exprofile -ge "1" ]] 
  then
    profile_cell_checks=0
    profile_zfs_checks=0
    profile_switch_checks=0 
    profile_root_checks=0
  fi
  if [[ $ex_selected_profiles -ge "1" ]] && [[ $dba_in_exprofile -ge "1" ]]
  then
    profile_db_checks=0 
  fi
  if [[ $ex_selected_profiles -ge "1" ]] && [[ $cell_in_exprofile -ge "1" ]]
  then
    profile_cell_checks=0
    profile_zfs_checks=0
  fi
  if [[ $ex_selected_profiles -ge "1" ]] && [[ $switch_in_exprofile -ge "1" ]]
  then
    profile_switch_checks=0 
  fi
  
  IFS=$old_ifs
elif [[ $run_profile -eq "1" ]] ; then

  TYP="-b"
  profile_db_checks=0
  profile_root_checks=0
  profile_cell_checks=0
  profile_zfs_checks=0
  profile_switch_checks=0
  profile_module_checks=0
  selected_profiles=0

  old_ifs=$IFS
  IFS=","
  for aprofile in $profiles2run
  do
    if [[ -e $SCRIPTPATH/.cgrep/exalogic_zfs_checks_${aprofile}.aksh ]]; then ZFSAKSHSCRIPT=$SCRIPTPATH/.cgrep/exalogic_zfs_checks_${aprofile}.aksh; fi

    aprofile_id=$(grep -i "^$aprofile|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2)
    if [ -z "$aprofile_id" ] ; then
      echo -e "${RED}Selected profile $aprofile does not exists.. exiting ${NORM}"
      echo;
      IFS="$old_ifs"
      usage_profilesw; 
      exit 1;
    elif [ ! -e "$SCRIPTPATH/.cgrep/profiles/$aprofile_id.prf" ] ; then
      echo -e "${RED}Selected profile $aprofile does not exists.. exiting ${NORM}"
      echo;
      IFS="$old_ifs"
      usage_profilesw; 
      exit 1;
    fi
    profileids2run="$profileids2run $aprofile_id"
    pline=$(grep -i "^$aprofile|" $SCRIPTPATH/.cgrep/profiles.dat);
    db_checks=$(echo $pline | cut -d"|" -f3)
    root_checks=$(echo $pline | cut -d"|" -f4)
    cell_checks=$(echo $pline | cut -d"|" -f5)
    zfs_checks=$(echo $pline | cut -d"|" -f5)
    switch_checks=$(echo $pline | cut -d"|" -f6)
    module_checks=$(echo $pline | cut -d"|" -f7)

    ccnt_file=$(wc -l $SCRIPTPATH/.cgrep/profiles/$aprofile_id.prf | awk '{print $1}')
    
    selected_profiles=$(expr $selected_profiles + 1)

    if [ -n "$db_checks" ] ; then
      profile_db_checks=$(expr $profile_db_checks + $db_checks)
    fi

    if [ -n "$root_checks" ] ; then
      profile_root_checks=$(expr $profile_root_checks + $root_checks)
    fi
    if [ -n "$cell_checks" ] ; then
      profile_cell_checks=$(expr $profile_cell_checks + $cell_checks)
    fi
    if [ -n "$zfs_checks" ] ; then
      profile_zfs_checks=$(expr $profile_zfs_checks + $zfs_checks)
    fi
    if [ -n "$switch_checks" ] ; then
      profile_switch_checks=$(expr $profile_switch_checks + $switch_checks)
    fi
    if [ -n "$comp_checks" ] ; then
      profile_module_checks=$(expr $profile_comp_checks + $comp_checks)
    fi

    if [[ -n "$pline" && `echo "$pline" | grep -ic "EXALOGIC_CVM="` -gt "0" ]]
    then
      cvm_ccnt=$(echo $pline | sed 's/.*EXALOGIC_CVM=//' | sed 's/|.*//'| sed 's/:.*//')
      if [[ -n "$ccnt_file" && -n "$cvm_ccnt" && $cvm_ccnt -eq $ccnt_file ]] ; then
        profile_cvm_only=1
      fi
    fi
  done
  IFS=$old_ifs

  #echo "selected_profiles=$selected_profiles profile_cell_checks=$profile_cell_checks";
  cell_in_profile=$(echo "$profiles2run" | grep -icw storage_server)
  if [ $cell_in_profile -eq 0 ];then cell_in_profile=$(echo "$profiles2run" | grep -icw storage);fi
  switch_in_profile=$(echo "$profiles2run" | grep -icw switch)

  zfs_in_profile=$(echo "$profiles2run" | grep -icw zfs)
  ellite_in_profile=$(echo "$profiles2run" | grep -icw el_lite)
  elextensive_in_profile=$(echo "$profiles2run" | grep -icw el_extensive)

  # Set RAT_LOCALONLY if we are running on cell or switch
  if [ $selected_profiles -eq "1" ] && [[ $cell_in_profile -gt "0" || $switch_in_profile -gt "0" || $zfs_in_profile -gt "0" ]] ; then
    RAT_LOCALONLY=1
    localonly=1;
  elif  [[ $selected_profiles -eq "2" && $cell_in_profile -gt "0"  &&  $switch_in_profile -gt "0" ]] ; then
    RAT_LOCALONLY=1
    localonly=1;
  elif  [[ $selected_profiles -eq "2" && $switch_in_profile -gt "0" && $zfs_in_profile -gt "0" ]] ; then
    RAT_LOCALONLY=1
    localonly=1;
  fi
  # Ask root password in case cell is not selected and root count=0
  if [[ $switch_in_profile -gt "0"  && $profile_cell_checks -eq "0" && $profile_root_checks -eq "0" ]] ; then
    profile_root_checks=1
  fi

  if [ $selected_profiles -eq "1" ] && [ $cell_in_profile -gt "0" ]
  then
    profile_root_checks=0
  fi # ignore cell root

  #if [[ $profile_switch_checks -gt "0"  && $profile_cell_checks -eq "0" ]] ; then
  #  profile_cell_checks=1
  #  if [[ $selected_profiles -eq "1"  ]] ; then profile_root_checks=0; fi
  #fi
fi

# Target version
if [ -n "$targetversion" ]
then
  read_targetversion_count=1
  correct_target_version=0

  targetversion=$(echo $targetversion|sed 's/[A-Za-z]//g')
  targetversion=$(echo $targetversion|sed 's/\.//g') 
  if [ `echo $targetversion|wc -c` -ne 7 ] || [ `echo $supportedTargetVersion|grep -icw $targetversion` -lt 1 ]
  then 
    echo -e "${RED}\nInvalid upgrade target version format or upgrade version not yet supported.${NORM}\n"
    correct_target_version=0
  else 
    correct_target_version=1
  fi
  while [[ $read_targetversion_count -le 2 && $correct_target_version -eq 0 ]]
  do
    read_targetversion
    read_targetversion_count=$(expr $read_targetversion_count + 1)
  done
  if [ $correct_target_version -ne 1 ]; then cleanup;exit -1;fi
fi

if [ ! -e $REFFIL ]
then
  #this reference file drives the entire script  if we can't find it then no use proceeding
  echo -e $RED"The reference data file cannot be found."$NORM
  echo -e $RED"Expected location - "${REFFIL}${NORM}
  exit 1
fi

#Following section to copy right executable at working directory
data_file_type=$(grep -ic FILE_ID $REFFIL)
DECRYPT_VDAT=0
if [ ! -e $EXADATA_CELL_COLLECTIONS ]; then touch $EXADATA_CELL_COLLECTIONS >/dev/null 2>&1;fi
if [[ -n "$data_file_type" && $data_file_type -le 0 ]]
then 
  cgrep_platform=$(uname -s)
  if [ -e $SCRIPTPATH/.cgrep/cgrep ]
  then
    cp $SCRIPTPATH/.cgrep/cgrep $WRKDIR/cgrep >/dev/null 2>&1
    chmod 744 $WRKDIR/cgrep
  elif [ $cgrep_platform = "Linux" ]
  then 
    if [ -e /etc/redhat-release ] 
    then
      #os_version=$(cat /etc/redhat-release|grep -v ^#|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      os_version=$(grep -v ^# /etc/redhat-release|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      if [ $os_version -eq 3 ]
      then
        cp $SCRIPTPATH/.cgrep/lcgrep3 $WRKDIR/cgrep >/dev/null 2>&1
      elif [ $os_version -eq 4 ]
      then
        cp $SCRIPTPATH/.cgrep/lcgrep4 $WRKDIR/cgrep >/dev/null 2>&1
      elif [ $os_version -eq 5 ]
      then
        cp $SCRIPTPATH/.cgrep/lcgrep5 $WRKDIR/cgrep >/dev/null 2>&1
      elif [ $os_version -ge 6 ]
      then
        if [ $(uname -p) = "s390x" ]
        then
          cp $SCRIPTPATH/.cgrep/zlcgrep6 $WRKDIR/cgrep >/dev/null 2>&1
        else
          cp $SCRIPTPATH/.cgrep/lcgrep6 $WRKDIR/cgrep >/dev/null 2>&1
        fi
      fi    
      #$READ -p "what_os=$what_os is_exalogic_machine=$is_exalogic_machine and os_version=$os_version"
    elif [ -e /etc/SuSE-release ] 
    then
      #os_version=$(cat /etc/SuSE-release|grep -v ^#|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      #if [ -z "$os_version" ]; then os_version=$(cat /etc/SuSE-release|grep -i version|awk '{print $3}');fi
      os_version=$(grep -v ^# /etc/SuSE-release|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
      if [ -z "$os_version" ]; then os_version=$(grep -i version /etc/SuSE-release|awk '{print $3}');fi
      if [ $os_version -eq 9 ]
      then
        cp $SCRIPTPATH/.cgrep/lcgreps9 $WRKDIR/cgrep >/dev/null 2>&1    
      elif [ $os_version -eq 10 ]
      then
        cp $SCRIPTPATH/.cgrep/lcgreps10 $WRKDIR/cgrep >/dev/null 2>&1
      elif [ $os_version -ge 11 ]
      then 
        if [ $(uname -p) = "s390x" ]
        then
          cp $SCRIPTPATH/.cgrep/zlcgreps11 $WRKDIR/cgrep >/dev/null 2>&1
        else
          cp $SCRIPTPATH/.cgrep/lcgreps11 $WRKDIR/cgrep >/dev/null 2>&1
        fi
      fi
    fi
    chmod 744 $WRKDIR/cgrep >/dev/null 2>&1
  elif [ $cgrep_platform = "SunOS" ]
  then
    if [ `uname -p` = "sparc" ]
    then
      cp $SCRIPTPATH/.cgrep/scgrep $WRKDIR/cgrep >/dev/null 2>&1
    elif [ `uname -p|grep -ic 86` -ge 1 ]
    then
      cp $SCRIPTPATH/.cgrep/scgrepx86 $WRKDIR/cgrep >/dev/null 2>&1
    fi 
    chmod 744 $WRKDIR/cgrep
  elif [ $cgrep_platform = "AIX" ]
  then 
    cp $SCRIPTPATH/.cgrep/acgrep $WRKDIR/cgrep >/dev/null 2>&1
    chmod 744 $WRKDIR/cgrep
  elif [ $cgrep_platform = "HP-UX" ]
  then
    cp $SCRIPTPATH/.cgrep/hiacgrep $WRKDIR/cgrep >/dev/null 2>&1
    chmod 744 $WRKDIR/cgrep
  #else
  # echo -e "\n${RED}Error RC-001- Unable to read driver files. Please report this error to your Oracle representative for action.\n\nExiting .....\n${NORM}"
  # exit 1;
  #elif [[ $cgrep_platform = "CYGWIN_NT-6.3" || $cgrep_platform = "CYGWIN_NT-6.1" ]]
  elif [[ $cgrep_platform = "CYGWIN_NT-6.3" || $cgrep_platform = "CYGWIN_NT-6.2" || $cgrep_platform = "CYGWIN_NT-6.1" || $cgrep_platform = "CYGWIN_NT-5.2" ]]
  then
    win_v=$(echo $cgrep_platform | sed 's/CYGWIN_NT-//' | sed 's/\.//');
    if [[ "$win_v" = "62" || "$win_v" = "52" ]]; then win_v=63; fi
    cp $SCRIPTPATH/.cgrep/cgrepwin$win_v $WRKDIR/cgrep >/dev/null 2>&1
    chmod 744 $WRKDIR/cgrep
  fi
  #cgrep_perm=$(ls -l cgrep |awk '{ print $1}'|grep -ic x)
  #if [ $cgrep_perm -le 0 ];then echo -e "\n${RED}Error RC-002 - cgrep is not executable. Please change permission to 755 for cgrep and run agian.\n\nExiting .....\n${NORM}";exit 1;fi;
  if [ ! -e $WRKDIR/cgrep ]
  then
    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      EMSG="RC-001- Unable to read driver files.  Please refer to the section for this error code in \"Appendix A - Troubleshooting Scenarios\" of the ${program_name} User Guide"
      update_probe_xml "ERROR" "GENERIC" "$EMSG"
    fi
    echo -e "\n${RED}RC-001- Unable to read driver files.  Please refer to the section for this error code in "Appendix A - Troubleshooting Scenarios" of the "${program_name} User Guide".\n\n ${program_name} exiting .....\n${NORM}"
    exit 1;
  fi
  export PATH=$PATH:. 
  cgrep_test=$($WRKDIR/cgrep FILE_ID $REFFIL>/dev/null 2>&1)
  if [ $? -ne 0 ]
  then
    #$READ -p "grep =$GREP cgrep_test=$cgrep_test"
    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      EMSG="RC-002- Unable to read driver files.  Please refer to the section for this error code in \"Appendix A - Troubleshooting Scenarios\" of the ${program_name} User Guide"
      update_probe_xml "ERROR" "GENERIC" "$EMSG" 
    fi
    echo -e "\n${RED}RC-002- Unable to read driver files.  Please refer to the section for this error code in "Appendix A - Troubleshooting Scenarios" of the "${program_name} User Guide".\n\n ${program_name} exiting .....\n${NORM}"
    exit 1;
  fi
  GREP=$WRKDIR/cgrep
  DECRYPT_VDAT=1
else 
  GREP=/bin/grep
fi

au_checked=0
show_version

if [ "$TYP" = "-v" ]
then 
  echo -e "\n$program_name  version: ${program_version}_${dataFIleYear}${dataFIleMonthNo}${dataFIleDay}"|tr "[a-z]" "[A-Z]"
  cleanup
  exit 0
else
  show_version_envfile=$(echo "${program_name}_version = ${program_version}_${dataFIleYear}${dataFIleMonthNo}${dataFIleDay}"|tr "[a-z]" "[A-Z]")  
  modelVersion=$(echo $show_version_envfile | awk -F"=" '{print $2}')
  if [[ $UPDATE_RUN -eq 0 ]]; then validate_datafile_date;fi
  #modelVersion=$(echo "${dataFIleYear}${dataFIleMonthNo}${dataFIleDay}"|tr "[:lower:]"  "[:upper:]")
fi

if [[ -n $lt_ver_check  && $lt_ver_check -eq "1" ]]; then
  search_latest_version

  if [[ -n $skip_search_latest_version && $skip_search_latest_version -eq "0" ]]; then
    echo -e ""
    echo -e "Running ${program_name}"
    echo -e "----------------------------------------------------------"
    printf "%-30s" "PATH"
    printf "%-31s\n" ": ${LATEST_KIT_PATH}"
    printf "%-30s" "VERSION"
    printf "%-31s\n" ": ${LATEST_VERSION}"
    printf "%-30s" "COLLECTIONS DATA LOCATION"
    printf "%-31s\n" ": $WRKDIR"
    echo -e "----------------------------------------------------------"

    echo -e ""

    t_argsaved="$argsaved -noupgrade"
    export RAT_LT_VERCHECK=0
    if [ -d $LATEST_KIT_PATH ]; then ${LATEST_KIT_PATH}/${program_name} $t_argsaved; exit 0; fi
  fi
fi

#Auto Downloader
if [[ "$au_checked" = "0" ]]
then
  download_from_mos
fi

#follwoing check is to not to run non storage server
if [ "$TYP" != "-f"  ]
then
  if [ -f "/opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP" ]
  then 
    if [ -e  /opt/oracle/cell/cellsrv/deploy/config/cellinit.ora ]
    then
      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
        EMSG="Running ${program_name} on Storage server is not supported.Please run it from compute node"
        update_probe_xml "ERROR" "GENERIC" "$EMSG"
      fi
      echo -e "${RED}Running ${program_name} on Storage server is not supported.Please run it from compute node.${NORM}"
      exit 1
    fi
  fi
fi 
#######

components=$(echo $components|tr "[a-z]" "[A-Z]")
components=$(echo "$components"|sed 's/[:_,]/:/g'|sed 's/ /:/g')
#$READ -p "components=$components"
loop_components=$(echo $components|sed 's/:/ /g')
for loop_component in $loop_components
do
  if [ `echo $supported_modules| grep -ic $loop_component` -lt 1 ]
  then
    echo -e "${RED}${components} is not supported component. ${program_name} will run generic checks for components identified from environment${NORM}"
    unset options_components user_components
    if [[ -n "$setup_inittab" ]] && [[ $setup_inittab -ne "3" && $setup_inittab -ne "10" ]] ; then
      if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]] || [[ $EM_PROBE_MODE -eq 0 ]]; then 
	exec 3<&2; exec 2<&0; 
 	$READ -p "Press any key to continue ..."; 
	exec 2<&3; 
      fi
    fi
    components=NONE
  fi
done

if [ "$upgrade_mode" -eq "2" ]
then
  read_targetversion_count=0
  while [[ $read_targetversion_count -le 2 && $correct_target_version -eq 0 ]]
  do
    read_targetversion
    read_targetversion_count=$(expr $read_targetversion_count + 1)  
  done
  if [ $correct_target_version -ne 1 ]; then cleanup;exit -1;fi
  user_components=PREUPGR 
elif [ "$upgrade_mode" -eq "3" ]
then
  user_components="RACCHECK:MAA:POSTUPGR"
fi 

#$READ -p "print_pass=$print_pass_on_screen and components=$user_components type=$TYP"
if [ "$TYP_S" = "-s" ]
then
  NOQUESTION="1"
  DOROOT="1"
  #TYP="-a"
  rootYesNoint=2
elif [ "$TYP_S" = "-S" ]
then
  NOQUESTION="1"
  DOROOT="0"
  #TYP="-a"
  rootYesNoint=3
  #if [ -z "$RAT_CELL_SSH_USER" ];then RAT_CELL_SSH_USER=cellmonitor;fi
  #if [ -e $CELLIP ]; then checkCellSshConfig "$RAT_CELL_SSH_USER";fi
else
  NOQUESTION="0"
fi

skip_in_silent=1
if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]] ; then skip_in_silent=0; fi
if [[ -n "$NOQUESTION" && $NOQUESTION -eq 1 && $daemon_running -eq "1" ]] ; then skip_in_silent=0; fi

if [ -f "$REFFIL1" ]
then
  SILENT="0"
else
  SILENT="1"
  UPLOADFIL=$WRKDIR/${UPLOADFIL_VAR}_collect_${FDS}
  #in case of SILENT mode, force $TYP to -a, 
  #ignore whatever command line argument the use may have used
  if [ "$TYP" != "-u" ]; then TYP="-a";fi
fi

#To unset ORACLE_HOME and CRS_HOME if  its running in non-interactive mode
if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]]; then unset CRS_HOME ORACLE_HOME; fi;
#Code to set debug=0 if no environment varaiable is found 

if [ -z "$RAT_DEBUG" ]
then
  RAT_DEBUG=0
else
  RAT_DEBUG=1
fi

#change this line before beta
#RAT_DEBUG=1
#following line to print info pass also in screen
RAT_INFOPASS=1
#########################################################################################
#To generate a text file in output directory. this text file will have node names in
#cluster and will be used to run the script in offline mode
#########################################################################################
#if [ $UID -eq 0 ]
#then
#   echo -e $RED"Script should not be executed as root user.rather its prefered to execute using software owner\n"$NORM
#   exit 1;
#fi

html_rack_type="Cluster";

#to find out what kind of data files will be processed either small or big one
file_mode=$(grep -c "DB_VERSION" $REFFIL)
if [[ -n "$file_mode" && $file_mode -ge 1 ]] 
then
  DBVERSION=$(grep "DB_VERSION" $REFFIL|awk '{print $3}')
  op_mode=0
else
  op_mode=1
fi

#Condition: -f
if [ $TYP = "-f" ]
then
  OFFLINE=1
  CURRDIR=`pwd`
  if [ -z $RAT_OUTPUT ]; then CURRDIR=$CURRDIR; else CURRDIR=$RAT_OUTPUT; fi; 
  DUMPDIR=`ls -ltr $CURRDIR|grep ^d|grep ${program_name}|tail -1|awk {' print $9'}`
  DUMPDIR=$CURRDIR/$DUMPDIR
  CHKFIL=`basename $MASTERFIL`
  #echo "$%%%%%%%%%%%%%DUMPDIR=$DUMPDIR%%%%%%%%%%%%%%%%%%%%"
  #$READ -p  "$DUMPDIR $MASTERFIL and $CHKFIL"
  if [ -n "$MERGEFILES" ]
  then
    echo -e ""
    echo -e "Merging following collections:"
    echo -e ""
    
    dirarr=$(echo "$MERGEFILES" |tr "," "\n");
    d_index=0;
    for xdir in $dirarr
    do
      if [ $d_index -eq 0 ];
      then
        DUMPDIR=`basename $xdir`;
        DUMPDIR=$(echo $DUMPDIR|sed 's/\.zip//g');
      fi
      echo -e "  $xdir"
      d_index=$(expr $d_index + 1);
    done
    DUMPDIR=$WRKDIR/.MERGED_COLLECTIONS/$DUMPDIR;
    COLLECT_TIMING=$DUMPDIR/${program_name}_collection_timings.out
    #CELLIBNTFILE=$DUMPDIR/cell_ib_count.out
    CELLIBNTFILE=$WRKDIR/.MERGED_COLLECTIONS/cell_ib_count.out.merge
  else
    #if [ $# -gt 2 ] && [[ "$3" = "app" || "$3" = "App" || "$3" = "APP" ]]
    if [ $argsnum -gt 2 ] && [[ "$3" = "app" || "$3" = "App" || "$3" = "APP" ]]
    then
      echo "" > /dev/null 2&>1
    elif [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]] ; then
      if [[ -n "$RAT_COMPUTEPASSWORD_INTERNAL" &&  $RAT_COMPUTEPASSWORD_INTERNAL -ne "3" && $UID -ne "0" ]] ; then
        $READ -r -s -p "Enter root password:" root_pass
        $READ -s -p "Start the run:" run_start
      fi
    else
      find $DUMPDIR -name $MASTERFIL 2> /dev/null
      if [ `find $DUMPDIR -name $CHKFIL |wc -l` -ne 1 ]
      then
        if [ `find $DUMPDIR -name check_env.out |wc -l` -ne 1 ]
        then
          echo ""
          exec 3<&2; exec 2<&0
          $READ -p "Please specify the directory which has all files from customer site:-" DUMPDIR
          exec 2<&3
        fi
      fi
      if [ -d "$DUMPDIR" ]
      then
        if [ -z "$MERGEFILES" ]
        then 
      	  exec 3<&2; exec 2<&0
          $READ -p  "Output directory to read for offline use is ${DUMPDIR} Is this correct[y/n][y]" ynoutputdir
	  read_code=`echo $?`;
      	  exec 2<&3
	  process_prompt "$read_code" "ynoutputdir" "y" 

          case  $ynoutputdir in
            y|Y|yes|YES|Yes)
            ;;  
            n|N|No|NO)
              echo ""  
              exec 3<&2; exec 2<&0
              $READ -p "Please specify the directory which has all files from customer site:-" DUMPDIR
              exec 2<&3
              ;;
            *)
              ;;
          esac
        fi
      else
        echo -e "Directory $DUMPDIR does not exists\n"
        exit 1;
      fi
    fi
  fi

  #following statement is to copy files from all directories to OUTPUTDIR to support offline. At the end, it will move files back to directories
  if [ -e $DUMPDIR/.CELLDIR ]; then cp -r $DUMPDIR/.CELLDIR $TMPDIR/ >/dev/null 2>&1;fi
  find $DUMPDIR -name '*.*' -type f -exec mv -f {} $DUMPDIR  \; >/dev/null 2>&1
  if [ -e $TMPDIR/.CELLDIR ] ;then mv -f $TMPDIR/.CELLDIR $DUMPDIR >/dev/null 2>&1;fi
  if [ -e $DUMPDIR/check_env.out ]; then mv $DUMPDIR/check_env.out $DUMPDIR/raccheck_env.out;fi
  outfilefds1=$(basename $DUMPDIR|cut -d_ -f2)
  outfilefds2=$(basename $DUMPDIR|cut -d_ -f3)
  outfilefds3=$(basename $DUMPDIR|cut -d_ -f4)
  outfilefds4=$(basename $DUMPDIR|cut -d_ -f5)
  if [ -n "$outfilefds4" ] ; then outfilefds3="${outfilefds3}_${outfilefds4}"; fi

  UPLOADFIL=$WRKDIR/${UPLOADFIL_VAR}_${outfilefds1}_${outfilefds2}_${outfilefds3}
  #$READ -p "${UPLOADFIL} is the correct directory to analyze?[y/n][y]"
  HOSTLIST=$DUMPDIR/o_host_list.out
  OUTPUTDIR=$DUMPDIR
  SPOOLFIL=$OUTPUTDIR/d_check.out
  OSOUTFIL=$OUTPUTDIR/o_check
  UPDATEFIL=$OUTPUTDIR/db_update_$FDS.sql
  SQLLOGFIL=$OUTPUTDIR/sql.log
  CHK_TIMINGS=$OUTPUTDIR/${program_name}_epoch_checks_timings.out
  napply_missing_list=$OUTPUTDIR/o_napply_missing_list.out
  if [[ -z "$RAT_RUNMODE_INTERNAL" ]] ; then
    LOGFIL=/dev/null
    SKIPFIL=/dev/null
    REPFIL=/dev/null
    XMLREPFIL=/dev/null
    XMLSKIPFIL=/dev/null
    XMLRECFIL=/dev/null
    SREPFIL=/dev/null
    REPFIL_PASS=/dev/null
    SREPFIL_PASS=/dev/null
    REPFIL_FAIL=/dev/null
    SREPFIL_FAIL=/dev/null
    PREPFIL=/dev/null
    PSREPFIL=/dev/null
    CWCREPFIL_PASS=/dev/null
    SCWCREPFIL_PASS=/dev/null
    CWCREPFIL_FAIL=/dev/null
    SCWCREPFIL_FAIL=/dev/null
    CWSQLPARAM=/dev/null
    CWOSPARAM=/dev/null
    CWOSPKG=/dev/null
    CWOSPATCH=/dev/null
    MISCCWCHECK=/dev/null
  elif [[ $RAT_RUNMODE_INTERNAL = "slave" ]] ; then
    hostname | cut -d"." -f1 > $HOSTLIST
    #LOGFIL=$OUTPUTDIR/${program_name}.log
  fi
  OGGHOMESVERSIONFIL=$OUTPUTDIR/ogg_homes_version.out
  CELLSREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_summary_pass.rep
  CELLSREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells_summary_fail.rep
  CELLREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_pass.rep
  CELLREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells__fail.rep
  IBSREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_summary_pass.rep
  IBSREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib_summary_fail.rep
  IBREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_pass.rep
  IBREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib__fail.rep
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then
    ERRFIL=$TMP_OUTPUT/${program_name}_error.log
    OLD_ERRFIL=$OUTPUTDIR/${program_name}_error.log
  else
    ERRFIL=$OUTPUTDIR/${program_name}_error.log
  fi
  ASM_HOME=`grep ASM_HOME $DUMPDIR/$CHKFIL |awk '{print $3}'`
  RUNMODE=`grep SILENT $DUMPDIR/$CHKFIL |awk '{print $3}'`
  RUNSWITCH=`grep -w SWITCH $DUMPDIR/$CHKFIL |awk '{print $3}'`
  RUNFILEID=`grep FILE_ID $DUMPDIR/$CHKFIL |awk '{print $3}'`
  get_winpath "REFFIL"
  get_winpath "REFFIL1"
  FILEID=`$GREP FILE_ID $REFFIL |awk '{print $3}'`
  FILEDATE=`$GREP FILE_DATE $REFFIL |awk '{print $3}'`
  FILEID2=`$GREP FILE_ID $REFFIL1 |awk '{print $3}'|head -1`
  restore_winpath "REFFIL"
  restore_winpath "REFFIL1"
  FILESIG=`grep FILE_SIG $DUMPDIR/$CHKFIL|awk '{print $3 }'`
  crs_installed=`grep CRS_INSTALLED $DUMPDIR/$CHKFIL |awk '{print $3}'`
  rdbms_installed=`grep RDBMS_INSTALLED $DUMPDIR/$CHKFIL |awk '{print $3}'`
  crs_up=`grep CRS_UP $DUMPDIR/$CHKFIL |awk '{print $3}'`
  db_up=`grep ${ORACLE_SID}_UP $DUMPDIR/$CHKFIL |awk '{print $3}'`
  somdb_up=`grep SOMEDB_UP $DUMPDIR/$CHKFIL |awk '{print $3}'`
  localnode=`grep LOCALNODE $DUMPDIR/$CHKFIL |awk '{print $3}'|tr -d '\r'`
  rootYesNoint=`grep ROOT_OPTION $DUMPDIR/$CHKFIL |awk '{print $3}'`
  multiple_db=$(grep MULTIPLE_DATABASE $DUMPDIR/$CHKFIL |awk '{print $3}')
  components=$(grep ${localnode}.COMPONENTS $DUMPDIR/$CHKFIL |awk '{print $3}')
  if [[ -n "$RUNSWITCH" && $RUNSWITCH = "-u" ]]; then upgrade_mode=$(grep UPGRADE_MODE $DUMPDIR/$CHKFIL |awk '{print $3}');fi
  CRS=$(grep CRS_HOME $DUMPDIR/$CHKFIL |awk '{print $3}')
  ibswitch_password_status=$(grep IBSWITCH_PASSWORD_OPTION $DUMPDIR/$CHKFIL |awk '{print $3}')
  cell_password_status=$(grep CELL_PASSWORD_OPTION $DUMPDIR/$CHKFIL |awk '{print $3}')
  zfs_password_status=$(grep ZFS_PASSWORD_OPTION $DUMPDIR/$CHKFIL |awk '{print $3}')
  current_exadata_version=$(grep CURRENT_EXADATA_VERSION $DUMPDIR/$CHKFIL |awk '{print $3}')
  print_score_in_report=$(grep PRINT_SCORE_IN_REPORT $DUMPDIR/$CHKFIL |awk '{print $3}')
  offline_counter=0
  wrong_customer_id_tries=0
  mb_db_counter=0
  CELLDIR="$OUTPUTDIR/.CELLDIR"
  CELLIP="$CELLDIR/cellip.ora"   
  ZFSIP="$CELLDIR/zfsip.ora"   
  is_exalogic_machine=`grep IS_EXALOGIC_MACHINE $DUMPDIR/$CHKFIL | awk '{print $3}'` 
  if [ ! -n "$is_exalogic_machine" ] ; then is_exalogic_machine=0; fi
  in_ec_exalogic=`grep IS_EXALOGIC_EC_MACHINE $DUMPDIR/$CHKFIL | awk '{print $3}'`
  exalogic_version=`grep EXALOGIC_VERSION $DUMPDIR/$CHKFIL | awk '{print $3}'`
  exalogic_version_actual=`grep EXALOGIC_ACTUAL_VERSION $DUMPDIR/$CHKFIL | awk '{print $3}'`
  RackIdentifier=`grep EXALOGIC_RACK_IDENTIFIER $DUMPDIR/$CHKFIL | sed 's/EXALOGIC_RACK_IDENTIFIER = //'`
  is_exalytics_machine=`grep IS_EXALYTICS_MACHINE $DUMPDIR/$CHKFIL | awk '{print $3}'`
  exalytics_version=`grep EXALYTICS_VERSION $DUMPDIR/$CHKFIL | awk '{print $3}'`
  RackIdentifier=`grep EXALYTICS_RACK_IDENTIFIER $DUMPDIR/$CHKFIL | sed 's/EXALYTICS_RACK_IDENTIFIER = //'`
  crs112=`grep CRS_ACTIVE_VERSION $DUMPDIR/$CHKFIL | head -1 |grep -c "11.2"`
  crs121=`grep CRS_ACTIVE_VERSION $DUMPDIR/$CHKFIL | head -1 |grep -c "12.1"`
  crs122=`grep CRS_ACTIVE_VERSION $DUMPDIR/$CHKFIL | head -1 |grep -c "12.2"`
  is_bda_machine=`grep IS_BDA_MACHINE $DUMPDIR/$CHKFIL | awk '{print $3}'`
  bda_version=`grep BDA_VERSION $DUMPDIR/$CHKFIL | awk '{print $3}'`
  bda_actual_version=`grep BDA_ACTUAL_VERSION $DUMPDIR/$CHKFIL | awk '{print $3}'`
  bda_identifier=`grep BDA_IDENTIFIER $DUMPDIR/$CHKFIL | awk '{print $3}'`
  is_exalogic_guest_vm=`grep IS_EXALOGIC_GUEST_VM $DUMPDIR/$CHKFIL | awk '{print $3}'`
  exalogic_hybrid=`grep IS_EXALOGIC_HYBRID $DUMPDIR/$CHKFIL | awk '{print $3}'`
  phy_nodes=`grep PHYSICAL_NODES $DUMPDIR/$CHKFIL | awk '{print $3}'`
  exclude_profile=`grep EXCLUDE_PROFILE_RUN $DUMPDIR/$CHKFIL | awk '{print $3}'`
  profiles2exclude=`grep EXCLUDE_PROFILE_NAMES $DUMPDIR/$CHKFIL | awk '{print $3}'`
  profileids2exclude=`grep EXCLUDE_PROFILES $DUMPDIR/$CHKFIL | awk '{print $3}'`

  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_bda_machine" && $is_bda_machine -eq "1" ]] || [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]; then
    unset_root_run;
  else
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then validate_tod "$RAT_TMP_OUTPUT"; fi
  fi

  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
    root_user_allowed=1
    oumask=$(umask)
    umask 0000
    if [[ -e $OUTPUTDIR ]]; then chmod -R 777 $OUTPUTDIR; fi
    if [[ -e $INPUTDIR ]]; then chmod -R 777 $INPUTDIR; fi
    if [ -e $ERRFIL ]; then rm -f $ERRFIL; fi; touch $ERRFIL; chmod 777 $ERRFIL;
  fi
 
  #function to discover and support mixed hardware type storage servers
  mixed_hardware_cells_discovery 
  if [[ -n "$crs121" && $crs121 -gt 0 ]]; then  crs112=`grep CRS_ACTIVE_VERSION $DUMPDIR/$CHKFIL | head -1 |grep -c "12.1"`;fi
  if [[ -n "$crs122" && $crs122 -gt 0 ]]; then  crs112=`grep CRS_ACTIVE_VERSION $DUMPDIR/$CHKFIL | head -1 |grep -c "12.2"`;fi

  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_bda_machine" && $is_bda_machine -eq "1" ]]
  then
    func_init_arrays
    multiple_db=0
    mb_running_host[0]=0;
  fi
  if [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq "1" ]]
  then
    func_init_arrays
    multiple_db=0
    mb_running_host[0]=0;
    read_exalytics_bi_env
    set_exalytics_tt_env
  fi

  single_instance_run=`grep SINGLE_INSTANCE_RUN $DUMPDIR/$CHKFIL | awk '{print $3}'`
  O_IFS=$IFS
  IFS=$'\n'
  #for db_name_to_check in `cat $DUMPDIR/$CHKFIL|grep -i DB_NAME|awk '{print $3}'|cut -d'|' -f1`
  #for db_name_to_check in `cat $DUMPDIR/$CHKFIL|grep -i DB_NAME|cut -d'|' -f1|awk -F'=' '{print $2}'|sed 's/^ *//;s/ *$//'`	
  for db_name_to_check in `grep -i DB_NAME $DUMPDIR/$CHKFIL|cut -d'|' -f1|awk -F'=' '{print $2}'|sed 's/^ *//;s/ *$//'`	
  do
    mb_db_names[$mb_db_counter]=$db_name_to_check
    mb_database_role[$mb_db_counter]=$(grep -w "${db_name_to_check}.DATABASE_ROLE" $DUMPDIR/$CHKFIL|awk '{print $3}')
    mb_database_type[$mb_db_counter]=$(grep -w "${db_name_to_check}.DATABASE_TYPE" $DUMPDIR/$CHKFIL|awk '{print $3}')
    mb_database_global_name[$mb_db_counter]=$(grep -w "${db_name_to_check}.GLOBAL_NAME" $DUMPDIR/$CHKFIL|awk '{print $3}')
    mb_running_host[$mb_db_counter]=$(grep -w "${db_name_to_check}.CHECKED_NODE" $DUMPDIR/$CHKFIL|awk '{print $3}')
    #echo "${mb_database_role[$mb_db_counter]}"
    mb_db_counter=$(expr $mb_db_counter + 1 )
  done
  mb_db_counter=0 
  #$READ -p "stop"
  IFS=$O_IFS;

  olsnodes_ssh_disabled=`grep -ic "OLSNODES_SSH_DISABLED" $DUMPDIR/$CHKFIL`;
  if [[ $olsnodes_ssh_disabled -eq 1 ]];
  then
    for node in `cat $HOSTLIST`
    do	
      rnoden=`grep -i 'MAP:' $DUMPDIR/$CHKFIL|grep -i "$node"|awk '{print $1}'|sed 's/MAP://g'`
      echo "$rnoden" >> $HOSTLIST.new
    done
    mv -f $HOSTLIST.new $HOSTLIST		
  fi

  for node in `cat $HOSTLIST`
  do
    crs_installed[$offline_counter]=`grep -i "$node.CRS_INSTALLED" $DUMPDIR/$CHKFIL |awk '{print $3}'`
    rdbms_installed[$offline_counter]=`grep -i "$node.RDBMS_INSTALLED" $DUMPDIR/$CHKFIL |awk '{print $3}'`
    asm_installed[$offline_counter]=`grep -i "$node.ASM_INSTALLED" $DUMPDIR/$CHKFIL |awk '{print $3}'`
    stack_crs_up[$offline_counter]=`grep -i "$node.CRS_STATUS" $DUMPDIR/$CHKFIL |awk '{print $3}'`
    stack_crs_version[$offline_counter]=`grep -i "$node.CRS_ACTIVE_VERSION" $DUMPDIR/$CHKFIL |awk '{print $3}'`
    stack_asm_up[$offline_counter]=`grep -i "$node.ASM_STATUS" $DUMPDIR/$CHKFIL |awk '{print $3}'`
    stack_asm_sid[$offline_counter]=`grep -i "$node.ASM_INSTANCE" $DUMPDIR/$CHKFIL |awk '{print $3}'`
    stack_asm_home[$offline_counter]=`grep -i "$node.ASM_HOME" $DUMPDIR/$CHKFIL |awk '{print $3}'`
    stack_acfs_up[$offline_counter]=`grep -i "$node.ACFS_STATUS" $DUMPDIR/$CHKFIL |awk '{print $3}'`

    if [[ -n "$multiple_db" && $multiple_db -eq 1 ]]
    then
      db_status_counter=0
      mb_db_counter_local=0
      stack_db_instances[$offline_counter]=`grep -i "$node" $DUMPDIR/$CHKFIL|grep INSTANCE_NAME|awk '{print $3}'`
      #echo "instances on $node ${stack_db_instances[$offline_counter]}"
      for db_name_to_check in "${mb_db_names[@]}"
      do
        if [ $node = ${mb_running_host[$mb_db_counter_local]} ]
        then #remote_database_code
          stack_db_status[$mb_db_counter_local]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $DUMPDIR/$CHKFIL|awk '{print $3}'`
          stack_local_db_inst[$mb_db_counter_local]=`grep -i "$node.${db_name_to_check}.INSTANCE_NAME" $DUMPDIR/$CHKFIL|awk '{print $3}'`
          #stack_db_name[$db_status_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
          #echo "$db_name_to_check instance is  ${stack_local_db_inst[$db_status_counter]}"
          db_status_counter=$(expr $db_status_counter + 1)
        fi
        mb_db_counter_local=$(expr $mb_db_counter_local + 1)
      done
      db_status_counter=0
    else
      stack_dbinst_name[$offline_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_NAME" $DUMPDIR/$CHKFIL|awk '{print $3}'`
      if [[ -n "${mb_running_host[$mb_db_counter_local]}" && $node = ${mb_running_host[$mb_db_counter_local]} ]]
      then
        stack_db_status[$db_status_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $DUMPDIR/$CHKFIL|awk '{print $3}'`
        #$READ -p " stack_db_status=${stack_db_status[$db_status_counter]}"
      fi;
      stack_dbinst_up[$offline_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $DUMPDIR/$CHKFIL|awk '{print $3}'`
    fi
    offline_counter=`expr $offline_counter + 1`  
  done

  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
  then
    func_init_arrays
    components=EXALOGIC
  elif [[ -n "$is_bda_machine" && $is_bda_machine -eq "1" ]]
  then
    func_init_arrays
    components="Big Data Appliance"
  fi

  mb_set_oracle_home_version_distinct
  #is_this_db_machine
  write_db_machine_info_to_envfile $localnode
  GetMachineRole
  is_this_oda

  if [[ `echo $components|grep -icw dbm` -ge 1 && `echo $components|grep -ic rdbms` -lt 1 && $db_machine_compute -eq 1 ]]
  then
    components=EXADATA
  fi
  #$READ -p "components=$components at 8490"
  #echo "${mb_oracle_homes_distinct[@]} ${mb_oracle_versions_distinct[@]} ${mb_oracle_homes_version_distinct[@]}"
  #$READ -p "see it"
  offline_counter=0
  if [ $op_mode -eq 1 ]
  then
    func_create_small_files
  fi

  if [[ $RUNSWITCH != "-p" && ${stack_dbinst_up[$offline_counter]} -ne 0 ]]
  then
    DB=$(grep -i "DB_NAME" $DUMPDIR/$CHKFIL |awk '{print $3}'|cut -d'|' -f1|cut -d'|' -f1)
    #DB=`grep db_name $SPOOLFIL |awk {'print $3'}`
  fi
  #FILESIG=`echo $FILESIG |sed -e 's/ /g'`
  if [ $RUNMODE -eq "1" ]
  then
    MISCCWCHECK=$OUTPUTDIR/o_misc_clusterwide_checks.out
    REPFIL=$OUTPUTDIR/${program_name}.rep
    XMLREPFIL=$OUTPUTDIR/${program_name}_results.xml
    XMLSKIPFIL=$OUTPUTDIR/${program_name}_exceptions.xml
    XMLRECFIL=$OUTPUTDIR/${program_name}_recommendations.xml
    SREPFIL=$OUTPUTDIR/${program_name}_summary.rep
    REPFIL_PASS=$OUTPUTDIR/${program_name}_pass.rep
    REPFIL_FAIL=$OUTPUTDIR/${program_name}_fail.rep
    SREPFIL_PASS=$OUTPUTDIR/${program_name}_summary_pass.rep
    SREPFIL_FAIL=$OUTPUTDIR/${program_name}_summary_fail.rep
    CWCREPFIL_PASS=$OUTPUTDIR/${program_name}_cwc_pass.rep
    SCWCREPFIL_PASS=$OUTPUTDIR/${program_name}_cwc_summary_pass.rep
    CWCREPFIL_FAIL=$OUTPUTDIR/${program_name}_cwc_fail.rep
    SCWCREPFIL_FAIL=$OUTPUTDIR/${program_name}_cwc_summary_fail.rep
    PREPFIL=$OUTPUTDIR/${program_name}_patches.rep
    PSREPFIL=$OUTPUTDIR/${program_name}_patches_summary.rep
    CWSQLPARAM=$OUTPUTDIR/${program_name}_cw_sqlparam.out
    CWOSPARAM=$OUTPUTDIR/${program_name}_cw_osparam.out
    CWOSPKG=$OUTPUTDIR/${program_name}_cw_ospkg.out
    CWOSPATCH=$OUTPUTDIR/${program_name}_cw_ospatch.out
    CELLSREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_summary_pass.rep
    CELLSREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells_summary_fail.rep
    CELLREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_pass.rep
    CELLREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells__fail.rep
    IBSREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_summary_pass.rep
    IBSREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib_summary_fail.rep
    IBREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_pass.rep
    IBREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib__fail.rep
    SKIPFIL=$OUTPUTDIR/${program_name}_skipped_checks.log
     
    #to fix the bug reported by Srini. if user runs raccheck in offline for more than, report will have data for more than 1
    if [ -f $REPFIL ]; then rm $REPFIL;fi;
    if [ -f $XMLREPFIL ]; then rm $XMLREPFIL;fi;
    if [ -f $XMLSKIPFIL ]; then rm $XMLSKIPFIL;fi;   
    if [ -f $SREPFIL ]; then rm $SREPFIL; fi;
    if [ -f $SCWCREPFIL_FAIL  ]; then rm $SCWCREPFIL_FAIL; fi;
    if [ -f $SREPFIL_FAIL ]; then rm $SREPFIL_FAIL; fi;
    if [ -f $SCWCREPFIL_PASS ]; then rm $SCWCREPFIL_PASS; fi;
    if [ -f $SREPFIL_PASS ]; then rm $SREPFIL_PASS; fi;
    if [ -f $CWCREPFIL_FAIL ]; then rm $CWCREPFIL_FAIL; fi;
    if [ -f $REPFIL_FAIL ]; then rm $REPFIL_FAIL; fi;
    if [ -f $CWCREPFIL_PASS ]; then rm $CWCREPFIL_PASS; fi;
    if [ -f $REPFIL_PASS ]; then rm $REPFIL_PASS; fi;
    if [ -f $PREPFIL ]; then rm $PREPFIL; fi;
    if [ -f $PSREPFIL ]; then rm $PSREPFIL; fi;
    if [ -f $CWSQLPARAM ]; then rm $CWSQLPARAM; fi;
    if [ -f $CWOSPARAM ]; then rm $CWOSPARAM; fi;
    if [ -f $CWOSPKG ]; then rm $CWOSPKG; fi;
    if [ -f $CWOSPATCH ]; then rm $CWOSPATCH; fi;
    if [ -f $MISCCWCHECK ]; then rm $MISCCWCHECK; fi;
    if [ -f $CELLSREPFIL_PASS ]; then rm $CELLSREPFIL_PASS;fi
    if [ -f $CELLSREPFIL_FAIL ]; then rm $CELLSREPFIL_FAIL;fi
    if [ -f $CELLREPFIL_PASS ]; then rm $CELLREPFIL_PASS;fi
    if [ -f $CELLREPFIL_FAIL ]; then rm $CELLREPFIL_FAIL;fi
    if [ -f $IBSREPFIL_PASS ]; then rm $IBSREPFIL_PASS;fi
    if [ -f $IBSREPFIL_FAIL ]; then rm $IBSREPFIL_FAIL;fi
    if [ -f $IBREPFIL_PASS ]; then rm $IBREPFIL_PASS;fi
    if [ -f $IBREPFIL_FAIL ]; then rm $IBREPFIL_FAIL;fi
    if [ -f $SKIPFIL ]; then rm $SKIPFIL;fi
  fi

  echo  "RUNFILEID=$RUNFILEID FILEID=$FILEID AND FILEID2=$FILEID2">>$LOGFIL
  #$READ -p  "RUNFILEID=$RUNFILEID FILEID=$FILEID AND FILEID2=$FILEID2"
  #$READ -p "check fileids"
  if [ "$RUNFILEID" !=  "$FILEID" ]
  then
    echo -e "$RED Data file $REFFIL is not same file which was used for online run.$NORM"
    exit -1;
  fi
  if [ "$RUNFILEID" !=  "$FILEID2" ]
  then
    echo -e "$RED Data file $REFFIL1 is not same file which should be used with this collection.$NORM"
    exit -1;
  fi
  stack_counter=0
  no_patch_rollup=0 
  no_patch_rollup=`grep -ic "NO Patch rollup selected" $REFFIL1`
  if [ $no_patch_rollup -gt 0 ]
  then
    no_patches=1
  fi

  #code for entering correct custmer id in racrx_env.
  #if [ $RUNMODE -eq 1 ] && [ "$FILESIG" = "46C40115700EFB00E0401490CACF67C6" -o "$FILESIG" = "632427F6919907D9E0401490CACF59F0" ] 
  #if [ $# -gt 2 ] && [[ "$3" = "app" || "$3" = "App" || "$3" = "APP" ]]
  if [ $argsnum -gt 2 ] && [[ "$3" = "app" || "$3" = "App" || "$3" = "APP" ]]
  then
    echo "" > /dev/null 2&>1
  else
    if [ "$FILESIG" = "46C40115700EFB00E0401490CACF67C6" -o "$FILESIG" = "632427F6919907D9E0401490CACF59F0" ] && [ 1 -eq 0 ]
    then
      exec 3<&2; exec 2<&0
      $READ -p "Enter Customer ID from RAT Customer page (Customer Tab > Customer Details region):- " customerid
      exec 2<&3
      while true
      do
        if [ `echo $customerid|wc -c` -ne 33 ]
        then
        echo -e "${RED}Customer ID is not correct.Enter Customer ID from RAT Customer page (Customer Tab > Customer Details region):-${NORM}"
        $READ customerid
        fi
        wrong_customer_id_tries=$(expr $wrong_customer_id_tries + 1)
        if [[ $wrong_customer_id_tries -gt 1 || `echo $customerid|wc -c` -eq 33 ]];then break;fi;
      done
      custfile="$DUMPDIR/$CHKFIL" 
      sed "s/$FILESIG/$customerid/" $custfile > $DUMPDIR/fileid.out
      cp $DUMPDIR/fileid.out $custfile
      rm $DUMPDIR/fileid.out
    fi
  fi
  #echo "$%%%%%%%%%%%%%RUNMODE=$RUNMODE%%%%%%%%%%%%%%%%%%%%" 
  #echo "$%%%%%%%%%%%%%FREPFIL=$FREPFIL%%%%%%%%%%%%%%%%%%%%" 
else 
  #Exalogic check
  OFFLINE=0
  if [[ ! -n "$RAT_GLOBAL_RUNMODE" ]] ; then RAT_GLOBAL_RUNMODE="parallel"; fi; 

  is_exalogic_guest_vm=0
  if [[ ! -z "$RAT_EL_GVM" ]]
  then
    rm -rf $EL_GVM_FILE >/dev/null 2>&1
    for el_guest_file in `echo $RAT_EL_GVM|sed 's/,/ /g'`
    do 	
      if [ -e "$el_guest_file" ]
      then
        cat $el_guest_file >> $EL_GVM_FILE
      fi
    done
    
    if [ -e "$EL_GVM_FILE" ]
    then
      is_exalogic_guest_vm=1
      el_guest_counter=0
      for el_vm_guest in `cat $EL_GVM_FILE|sort|uniq`
      do
      	el_guest_vms[$el_guest_counter]=$el_vm_guest
      	el_guest_counter=$(expr $el_guest_counter + 1)
      done
    else
      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
	EMSG="Specified exalogic VM guest file(s) does not exist. Please provide correct filenames and then re-run ${program_name}"
	update_probe_xml "ERROR" "GENERIC" "$EMSG"
      fi
      echo -e "\n${RED}Specified exalogic VM guest file(s) does not exist. Please provide correct filenames and then re-run ${program_name}.${NORM}\n";
      echo -e "${RED}${program_name} is exiting...  ${NORM}\n";
      exit 1;	
    fi

    if [ $el_guest_counter -eq 0 ]
    then
      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
	EMSG="Specified exalogic VM guest file(s) are empty"
	update_probe_xml "ERROR" "GENERIC" "$EMSG"
      fi
      echo -e "\n${RED}Specified exalogic VM guest file(s) are empty.${NORM}\n";
      echo -e "${RED}${program_name} is exiting...  ${NORM}\n";
      exit 1;	
    fi 
  fi

  if [[ -e /etc/ovs-release && -e /opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP ]];then is_exadata_dom0_machine=1;fi
  if [[ $(uname -p 2>/dev/null) = "sparc" && -e /opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP ]]; then ssczonetype=$($ZONENAME) ;fi
  if [[ -n "$ssczonetype" && "$ssczonetype" != "global" ]];then is_ssc_localzone_machine=1;fi
  if [[ $(uname -p 2>/dev/null) = "sparc" && -e /opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP && ! -e /etc/oracle/cell/network-config/cellip.ora && "$ssczonetype" = "global" ]]
  then
       is_ssc_globalzone_machine=1
  fi
  if [[ $(uname -p 2>/dev/null) = "sparc" && -e /opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP && -e /etc/oracle/cell/network-config/cellip.ora && "$ssczonetype" = "global" ]]
  then
       is_ssc_globalzone_dbmachine=1
  fi
  check_if_bda
  check_if_exalytics
  check_if_exalogic

  if [[ $is_exalogic_machine -eq "1" || $is_bda_machine -eq "1" || $is_exalytics_machine -eq "1" ]] ; then 
    unset_root_run; 
  else 
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then validate_tod "$RAT_TMP_OUTPUT"; fi;
  fi

  #moved this validation from top to here is because Solaris express is supported in EL
  if [[ $is_exalogic_machine -eq 0 && "`uname -v`" = "snv_151a" ]]
  then
    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      EMSG="The ${program_name} is not supported on Solaris 11 Express."
      update_probe_xml "ERROR" "GENERIC" "$EMSG"
    fi
    echo -e "\n${RED}The ${program_name} is not supported on Solaris 11 Express. ${NORM}\n"
    exit 1;
  fi

  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" && $usern != "${root_user}" ]]
  then
    #privilegechk=`/usr/sbin/imageinfo 2>/dev/null |grep -iw "image version"`
    if [ `uname -s` = "Linux" ] ; then
      privilegechk=`/sbin/ifconfig | grep -w "inet" | awk '{print $2}'|cut -d: -f1 | head -1`
    else
      /sbin/ifconfig -a >/dev/null 2>&1
      if [ $? -eq "0" ] ; then privilegechk="addr"; fi
    fi
  fi 

  if [[ $EM_PROBE_MODE -eq 1 || $EM_XMLD_MODE -eq 1 ]]; then
    if [[ $is_exalogic_machine -eq "1" && $user_uid != "0" ]] && [[ -z $privilegechk || "$privilegechk" != "addr" ]]
    then
      EMSG="*********** Error: User must be privileged user"
      update_probe_xml "ERROR" "GENERIC" "$EMSG"
      exit 1;
    elif [[ $is_exalytics_machine -eq "1" && $usern != "${root_user}" ]] 
    then
      EMSG="*********** Error: User must be ${root_user} "
      update_probe_xml "ERROR" "GENERIC" "$EMSG"
      exit 1;
    elif [[ $is_bda_machine -eq "1" && $usern != "${root_user}" ]]
    then
      EMSG="*********** Error: User must be ${root_user} " 
      update_probe_xml "ERROR" "GENERIC" "$EMSG"
      exit 1;
    elif [[ $is_exalogic_machine -eq "1" || $is_bda_machine -eq "1" ]]
    then
      echo ""
    fi
  else
    if [[ $is_exalogic_machine -eq "1" && $user_uid != "0" ]] && [[ -z $privilegechk || "$privilegechk" != "addr" ]]
    then
      #then
      #  EMSG="*********** Error: User must be privileged user"
      #  update_probe_xml "ERROR" "GENERIC" "$EMSG"
      #fi
      echo "*********** Error: User must be privileged user"
      exit 1;
    elif [[ $is_exalytics_machine -eq "1" && $USER != "${root_user}" ]] 
    then
      #if [[ $EM_PROBE_MODE -eq 1 ]]
      #then
      #  EMSG="*********** Error: User must be ${root_user} "
      #  update_probe_xml "ERROR" "GENERIC" "$EMSG"
      #fi
      echo "*********** Error: User must be ${root_user} "
      exit 1;
    elif [[ $is_bda_machine -eq "1" && $USER != "${root_user}" ]]
    then
      #if [[ $EM_PROBE_MODE -eq 1 ]]
      #then
      #  EMSG="*********** Error: User must be ${root_user} " 
      #  update_probe_xml "ERROR" "GENERIC" "$EMSG"
      #fi
      echo "*********** Error: User must be ${root_user} "
      exit 1;
    elif [[ $is_exalogic_machine -eq "1" || $is_bda_machine -eq "1" ]]
    then
      #echo "*********** Running in a exalogic machine and user is fine"
      echo ""
    fi
  fi

  stack_counter=0
  if [ ! -d "$WRKDIR" ]
  then
    mkdir -p $WRKDIR
  fi

  touch $COLLDIFFFIL >/dev/null 2>&1  
  touch $CHECKSFILE >/dev/null 2>&1

  if [[ `echo "$argsaved"|grep -ic 'initrmsetup'` -gt 0 || `echo "$argsaved"|grep -ic 'initcheck'` -gt 0 || `echo "$argsaved"|grep -ic 'initrestart'` -gt 0 || `echo "$argsaved"|grep -ic 'initsetup'` -gt 0 ]]
  then
    RUNSWITCH="-a"
  else
    #if [ $# -lt 1 ]; then RUNSWITCH="-a"; else RUNSWITCH=$1;fi
    if [ $argsnum -lt 1 ]; then RUNSWITCH="-a"; else RUNSWITCH=$TYP;fi
  fi

  mkdir $INPUTDIR
  mkdir $OUTPUTDIR
  if [ ! -d $RTEMPDIR ]; then mkdir $RTEMPDIR >/dev/null 2>&1;fi

  if [[ ! -z "$RAT_EL_GVM" ]]
  then
    rm -rf $EL_GVM_FILE >/dev/null 2>&1
    for el_guest_file in `echo $RAT_EL_GVM|sed 's/,/ /g'`
    do
      if [ -e "$el_guest_file" ]
      then
        cp $el_guest_file $OUTPUTDIR  
      fi
    done
  fi

  if [[ $OFFLINE -eq "0" ]] || [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "master" ]] ; then
    if [ -e "$RTEMPDIR" ]; then
      del_rtempdir=0
      if [ -e $LOCKFIL ]; then
        lockfile_pid_status=$(ps -ef |grep $(cat $LOCKFIL)|grep -v grep|wc -l)
        if [[ -n "$lockfile_pid_status" && $lockfile_pid_status -gt 0 ]]; then
      	del_rtempdir=0
        else
      	del_rtempdir=1
        fi
      elif [ -f "$RTEMPDIR" ]; then
         del_rtempdir=1
      fi
      
      if [[ "$del_rtempdir" -eq "1" ]]; then
        rm -rf $RTEMPDIR >/dev/null 2>&1;
        if [ `echo $?` -ne 0 ]; then
          if [[ $EM_PROBE_MODE -eq 1 ]]
          then
	    EMSG="Temporary files/directories of previous run exist at $RTEMPDIR. Delete them and re-run ${program_name}."
	    update_probe_xml "ERROR" "GENERIC" "$EMSG"
          fi
          echo -e ${RED}"\nTemporary files/directories of previous run exist at $RTEMPDIR. Delete them and re-run ${program_name}"${NORM}. 
          echo -e "\n${program_name} is exiting..\n"
          exit 1
        fi
      fi
    fi

    if [ -w "$TMPDIR" ]
    then
      mount >/dev/null 2>&1
      if [ `echo $?` -eq 0 ] 
      then
        #if [ `mount|grep -w "tmp"|grep -icw "noexec"` -gt 0 ]
        if [ `mount|grep -w "$TMPDIR"|grep -icw "noexec"` -gt 0 ]
        then
          if [[ $EM_PROBE_MODE -eq 1 ]]
          then
	    EMSG="Please change the entry for $TMPDIR in /etc/fstab file from 'noexec' to 'exec' and then re-run ${program_name}"
	    update_probe_xml "ERROR" "GENERIC" "$EMSG"
          fi
          echo -e ${RED}"Please change the entry for $TMPDIR in /etc/fstab file from 'noexec' to 'exec' and then re-run ${program_name}"${NORM}
          echo -e ${RED}"\n\n${program_name} is exiting..${NORM}\n"
          exit 1
        fi
      fi
    else
      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
	EMSG="$TMPDIR directory is not writable.Please make sure that $TMPDIR is writable and then re-run ${program_name}"
	update_probe_xml "ERROR" "GENERIC" "$EMSG"
      fi
      echo -e ${RED}"$TMPDIR directory is not writable.Please make sure that $TMPDIR is writable and then re-run ${program_name}"${NORM}
      echo -e ${RED}"\n\n${program_name} is exiting..${NORM}\n"
      exit 1
    fi
  fi

  if [ ! -d $RTEMPDIR ]; then mkdir -p $RTEMPDIR>/dev/null 2>&1;fi
  fmt_timing_lines="--------------------------------------------------------------------------------"
  echo -e "$fmt_timing_lines\n" >>$RACCHECK_TIMING
  echo -e "`date '+%a %b %d %H:%M:%S %Y'` - ${program_name} execution started\n">>$RACCHECK_TIMING
  trap 'cleanup;exit $USER_INTERRUPT' INT TERM EXIT
  localnode=`hostname | tr "[A-Z]" "[a-z]"|cut -d. -f1|tr -d '\r'`
  userid=$UID

  if [[ $op_mode -eq 1 && -z "$RAT_OS" ]] 
  then  
    func_what_platform
    if [[  -z "$os_name" || -z "$os_arch" || -z "$os_bit" || -z "$os_version" ]]
    then 
      echo -e "\n${RED}${program_name} could not find enough information about Operating system. Please set RAT_OS environment variable as following and re-run it.${NORM}"
      echo -e "\nValue in RAT_OS for Oracle Enterprise Linux 5 will be like LINUXX8664OELRHEL5 or for Solaris 10 on Sparc will be SOLARISSPARC6410"
      echo -e "\nTo construct correct value for RAT_OS, use following piece of OS information"
      echo -e "\nOS Name=LINUX \nOS Architecture=X86 or IA \nBits either 32 or 64 OS version=4 \nOS type in case of Linux like RHELOEL or SUSE etc"
      exit 1
    fi
    if [[ -n "$os_bit" && -n "$os_name" && "$os_name" = "Linux" && $os_bit -eq 32 ]]
    then
      if [[ -n "$ebs32bit" && $ebs32bit -eq 1 && $(ps -ef|grep -v grep |grep -ci ora_pmon_) -gt 0 ]] 
      then
        echo "Running on ${os_bit}-bit on $os_name because ebs32bit is $ebs32bit and atleast one database is running">>$LOGFIL
      else
        if [[ $EM_PROBE_MODE -eq 1 ]]
        then
	  EMSG="${program_name} is not supported on ${os_bit}-bit ${os_name}.\nTo run ${program_name} for EBS 32-bit database on Linux,use -ebs32bit command line option."
	  update_probe_xml "ERROR" "GENERIC" "$EMSG"
        fi
        echo -e "\n${RED}${program_name} is not supported on ${os_bit}-bit ${os_name}.\n\nTo run ${program_name} for EBS 32-bit database on Linux,use -ebs32bit command line option.\n\n${program_name} is exiting...${NORM}\n\n"  
        exit 1
      fi 
    fi  
  else
    what_os=$RAT_OS 
  fi
fi

if [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]] ; then
  cp $DUMPDIR/../.input*/*.dat $DUMPDIR/
  WATCHDOG=$DUMPDIR/watchdog.sh
  WATCHLOG=$DUMPDIR/watchdog.log
  REFFIL=$DUMPDIR/collections.dat
  userid=$UID
  LOGFIL=$DUMPDIR/${program_name}.log
  LOGFIL=$DUMPDIR/${program_name}.log
  SKIPFIL=$DUMPDIR/${program_name}_skipped_checks.log
  REPFIL=$DUMPDIR/${program_name}.rep
  XMLREPFIL=$DUMPDIR/${program_name}_results.xml
  XMLSKIPFIL=$DUMPDIR/${program_name}_exceptions.xml
  XMLRECFIL=$DUMPDIR/${program_name}_recommendations.xml
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then
    ERRFIL=$TMP_OUTPUT/${program_name}_error.log
    OLD_ERRFIL=$DUMPDIR/${program_name}_error.log
  else
    ERRFIL=$DUMPDIR/${program_name}_error.log
  fi
  COLLECT_TIMING=$DUMPDIR/${program_name}_collection_timings.out
  CHECKS_TIMING=$DUMPDIR/${program_name}_checks_timings.out
  RACCHECK_TIMING=$DUMPDIR/${program_name}_timings.out
  MISCCWCHECK=$DUMPDIR/o_misc_clusterwide_checks.out
fi
if [ -n "$raccheck_deprecate_msg" ]; then echo -e "\n${raccheck_deprecate_msg}\n">>$LOGFIL;fi 
log_env_varaibles "RAT_TIMEOUT" "$RAT_TIMEOUT"
log_env_varaibles "RAT_ROOT_TIMEOUT" "$RAT_ROOT_TIMEOUT"
log_env_varaibles "RAT_SQL_TIMEOUT" "$RAT_SQL_TIMEOUT"
log_env_varaibles "RAT_UPLOAD_CONNECT_STRING" "$RAT_UPLOAD_CONNECT_STRING"
log_env_varaibles "RAT_UPLOAD_TABLE" "$RAT_UPLOAD_TABLE"
log_env_varaibles "RAT_ZIP_UPLOAD_TABLE" "$RAT_ZIP_UPLOAD_TABLE"
log_env_varaibles "RAT_PATCH_UPLOAD_TABLE" "$RAT_PATCH_UPLOAD_TABLE"
log_env_varaibles "RAT_UPLOAD_USER" "$RAT_UPLOAD_USER"
log_env_varaibles "RAT_UPLOAD_PASSWORD" "$RAT_UPLOAD_PASSWORD"
log_env_varaibles "RAT_UPLOAD_ORACLE_HOME" "$RAT_UPLOAD_ORACLE_HOME"
log_env_varaibles "RAT_CRS_HOME" "$RAT_CRS_HOME"
log_env_varaibles "RAT_INV_LOC" "$RAT_INV_LOC"
log_env_varaibles "RAT_ORACLE_HOME" "$RAT_ORACLE_HOME"
log_env_varaibles "RAT_ASM_HOME" "$RAT_ASM_HOME"
log_env_varaibles "RAT_OS" "$RAT_OS"
log_env_varaibles "RAT_DB" "$RAT_DB"
log_env_varaibles "RAT_DBNAMES" "$RAT_DBNAMES" "1"
log_env_varaibles "RAT_PDBNAMES" "$RAT_PDBNAMES" "1"
log_env_varaibles "RAT_DBHOMES" "$RAT_DBHOMES" 
log_env_varaibles "RAT_OUTPUT" "$RAT_OUTPUT"
log_env_varaibles "RAT_TMP_OUTPUT" "$RAT_TMP_OUTPUT"
log_env_varaibles "RAT_DEBUG" "$RAT_DEBUG"
log_env_varaibles "RAT_INFOPASS" "$RAT_INFOPASS"
log_env_varaibles "RAT_SCOPY" "$RAT_SCOPY"
log_env_varaibles "RAT_SSHEL" "$RAT_SSHELL"
log_env_varaibles "RAT_LOCAL" "$RAT_LOCAL"
log_env_varaibles "RAT_CELLS" "$RAT_CELLS" "1"
log_env_varaibles "RAT_ZFS_NODES" "$RAT_ZFS_NODES" "1"
log_env_varaibles "RAT_CLUSTERNODES" "$RAT_CLUSTERNODES" "1"
log_env_varaibles "RAT_IBSWITCHES" "$RAT_IBSWITCHES" "1"
log_env_varaibles "RAT_CELL_SSH_USER" "$RAT_CELL_SSH_USER"
log_env_varaibles "RAT_IBSWITCH_USER" "$RAT_IBSWITCH_USER"
log_env_varaibles "RAT_ROOT_USER" "$RAT_ROOT_USER"
log_env_varaibles "RAT_EXPECT_STRACE_DEBUG" "$RAT_EXPECT_STRACE_DEBUG"
log_env_varaibles "RAT_EXPECT_DEBUG" "$RAT_EXPECT_DEBUG"
log_env_varaibles "RAT_PDB_USER" "$RAT_PDB_USER"
log_env_varaibles "RAT_BDA" "$RAT_BDA"
log_env_varaibles "RAT_PASSWORDCHECK_TIMEOUT" "$RAT_PASSWORDCHECK_TIMEOUT"

if [ -f "$RTEMPDIR" ]; then rm -f "$RTEMPDIR"; fi

#writing to log file here because where these variables are assigned, LOGFIL variable does not exists
echo -e "is_exadata_dom0_machine = $is_exadata_dom0_machine \n is_ssc_localzone_machine = $is_ssc_localzone_machine \n is_ssc_globalzone_machine = $is_ssc_globalzone_machine \n is_ssc_globalzone_dbmachine = $is_ssc_globalzone_dbmachine">>$LOGFIL

assign_scr_switches;
if [[ $OFFLINE -eq "0" ]] || [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]] ; then
  #following code is to generate watcher script
  if [ -f "/opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP" ];then watchdog_dbm_root=1;else watchdog_dbm_root=0;fi 
  if [ -z "$RAT_TIMEOUT" ]
  then
    if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] ; then
      watchdog_wakeup=150
    elif [[ -n "$is_bda_machine" && $is_bda_machine -eq "1" ]] ; then
      watchdog_wakeup=150
    else
      watchdog_wakeup=`grep RACCHECK_TIMEOUT $REFFIL|awk '{print $3}'` 
      if [ -z "$watchdog_wakeup" ]; then watchdog_wakeup=90;fi
    fi
  else
    watchdog_wakeup=$RAT_TIMEOUT    
  fi 
  if [ -z "$RAT_ROOT_TIMEOUT" ]
  then
    if [ -e /opt/oracle/oak/install/inittab ]
    then 
        watchdog_wakeup_root=600
    else             
        watchdog_wakeup_root=450
    fi
  else
    watchdog_wakeup_root=$RAT_ROOT_TIMEOUT
  fi
  if [ -z "$RAT_SQL_TIMEOUT" ]
  then
    watchdog_wakeup_sql=180
  else
    watchdog_wakeup_sql=$RAT_SQL_TIMEOUT
  fi 
  echo -e "RAT_TIMEOUT=$RAT_TIMEOUT watchdog_wakeup=$watchdog_wakeup watchdog_wakeup_root=$watchdog_wakeup_root watchdog_wakeup_sql=$watchdog_wakeup_sql">>$LOGFIL
  #watchlogdate=$(date '+%a %b %d %H:%M:%S %Y')
  touch $RTEMPDIR/nowatch.pid
  echo "#!$bash_scr" > $WATCHDOG  
  echo "watchdog_wakeup=$watchdog_wakeup">>$WATCHDOG
  echo "watchdog_wakeup_root=$watchdog_wakeup_root">>$WATCHDOG
  echo "watchdog_wakeup_sql=$watchdog_wakeup_sql">>$WATCHDOG
  echo "wakeup_count=1">>$WATCHDOG
  echo "watchdog_dbm_root=$watchdog_dbm_root">>$WATCHDOG
  echo "watchdog_long_wakeup=1">>$WATCHDOG
  echo "ppid=$$">>$WATCHDOG
  echo "mypid=\$\$">>$WATCHDOG
  echo "function killtree() {" >> $WATCHDOG #http://stackoverflow.com/questions/392022/best-way-to-kill-all-child-processes
  echo "  local _pid=\$1" >> $WATCHDOG
  echo "  local _sig=\${2-TERM}" >> $WATCHDOG
  echo "  kill -stop \${_pid}" >> $WATCHDOG
  #echo "  for _child in \$(ps -o pid --no-headers --ppid \${_pid}); do " >> $WATCHDOG
  echo "  for _child in \$(ps -ef |awk '\$3 == '\${_pid}' {print \$2}'); do " >> $WATCHDOG
  echo "    killtree \${_child} \${_sig}" >> $WATCHDOG
  echo "  done" >>$WATCHDOG
  echo "  kill -\${_sig} \${_pid}" >> $WATCHDOG
  echo "}" >> $WATCHDOG
  echo "echo \"\`date '+%a %b %d %H:%M:%S %Y'\` started watcher\" >$WATCHLOG">>$WATCHDOG
  #echo "echo \" mypid=\$mypid\"">>$WATCHDOG
  #echo "echo \"Process id of gracrx is \$ppid and log file is $WATCHLOG\"">>$WATCHDOG     
  echo "while [ 1 ]">>$WATCHDOG
  echo "do">>$WATCHDOG
  #echo "  lpid=\$(ps -p \$ppid|grep -v PID|awk '{print \$1}')">>$WATCHDOG
  ps -o pid >/dev/null 2>&1
  ps_o_ret=$?
  if [[ -n "$ps_o_ret" && $ps_o_ret -eq 0 ]] ; then
    echo "  lpid=\$(ps -o pid -p \$ppid|grep -v PID)">>$WATCHDOG
  else
    echo "  lpid=\$(ps -f -p  \$ppid|grep -v PID | awk '{print \$2}')">>$WATCHDOG
  fi
  echo "  if [ -z \$lpid ]">>$WATCHDOG
  echo "  then">>$WATCHDOG
  #echo "      echo -e \"Darwin is not running\\nexiting...\">>$WATCHLOG">>$WATCHDOG 
  echo "      for inputrmfile in \$(ls $INPUTDIR/* >/dev/null 2>&1|grep -v watchdog.sh)">>$WATCHDOG 
  echo "      do">>$WATCHDOG 
  echo "        rm -f \$inputrmfile >/dev/null 2>&1">>$WATCHDOG 
  echo "      done">>$WATCHDOG 
  echo "      exit 0">>$WATCHDOG
  echo "  else">>$WATCHDOG
  #echo "     if [[ -n \"\$opid\"  && \$opid -gt 1 ]]">>$WATCHDOG
  echo "     if [ -n \"\$opid\" ]">>$WATCHDOG
  echo "     then">>$WATCHDOG
  echo "     if [ \`echo \$opid|wc -w\` -gt 1 ];then opid=\$(echo \$opid|awk '{print \$1}');fi">>$WATCHDOG
  #echo "         spid=\$(ps -o pid -p \$opid >>$WATCHLOG 2>/dev/null|grep -v PID|sed 's/^ *\(.*\) *$/\1/')">>$WATCHDOG
  if [[ -n "$ps_o_ret" && $ps_o_ret -eq 0 ]] ; then
    echo "         spid=\$(ps -o pid -p \$opid|grep -v PID |sed 's/^ *\(.*\) *$/\1/')">>$WATCHDOG
  else
    echo "         spid=\$(ps -f -p \$opid|grep -v PID |  awk '{print \$2}' | sed 's/^ *\(.*\) *$/\1/')">>$WATCHDOG
  fi
  echo "         if [[ -n \"\$spid\" && \"\$spid\" -eq \"\$opid\" && \`grep -wc \"\$spid\" $RTEMPDIR/nowatch.pid 2>/dev/null\` -eq 0 ]] ">>$WATCHDOG
  echo "         then">>$WATCHDOG
  #echo "             scmd=\$(ps -ef|grep \$opid|grep -v grep|awk ' { print \$8 }')">>$WATCHDOG
  echo "             echo \"\`date '+%a %b %d %H:%M:%S %Y'\` candidate pid opid=\$opid still found as spid=\$spid\">>$WATCHLOG">>$WATCHDOG
  echo "             for cpid in \$(ps -ef |awk '\$3 == '\${spid}' {print \$2}') ">>$WATCHDOG        
  echo "             do">>$WATCHDOG
  echo "               if [[ \`grep -wc \"\$cpid\" $RTEMPDIR/nowatch.pid 2>/dev/null\` -eq 0 ]] ">>$WATCHDOG
  echo "               then">>$WATCHDOG
  echo "                  if [ \"$(/bin/uname -s)\" = \"Linux\" ]">>$WATCHDOG
  echo "                  then">>$WATCHDOG
  echo "                      scmd=\$(ps -o command -p \$opid |grep -v COMMAND)">>$WATCHDOG
  echo "                      ccmd=\$(ps -o command -p \$cpid |grep -v COMMAND)">>$WATCHDOG
  echo "                  fi">>$WATCHDOG
  echo "                  echo \"\`date '+%a %b %d %H:%M:%S %Y'\` Stuck child pid \$cpid  of parent \$spid\">>$WATCHLOG">>$WATCHDOG
  echo "                  echo \"\`date '+%a %b %d %H:%M:%S %Y'\` Stuck child command is \$ccmd\">>$WATCHLOG">>$WATCHDOG
  echo "                  killtree \$cpid 9 >>$WATCHLOG 2>&1">>$WATCHDOG
  echo "               fi">>$WATCHDOG
  echo "             done">>$WATCHDOG
  echo "             echo \"\`date '+%a %b %d %H:%M:%S %Y'\` killing stuck command \$scmd . Operating system process ID \$opid \">>$WATCHLOG">>$WATCHDOG
  echo "             kill -9 \$spid >>$WATCHLOG 2>&1">>$WATCHDOG
  echo "         fi">>$WATCHDOG
  echo "     fi">>$WATCHDOG
  echo "  fi">>$WATCHDOG
  echo "  if [ -e $WATCHLOG ];then  echo \"\`date '+%a %b %d %H:%M:%S %Y'\` running watcher \$wakeup_count \" >>$WATCHLOG;fi">>$WATCHDOG
  echo "  wakeup_count=\`expr \$wakeup_count + 1\`">>$WATCHDOG  
  #echo "  for opid in \`ps -ef|grep -v \"watchdog.sh\"| awk '\$3 == '\${ppid}' { print \$2 }'\`">>$WATCHDOG
  #echo "  opid=\$(ps -ef|grep -v \${mypid}|grep -v sleep |grep -v compute| awk '\$3 == '\${ppid}' { print \$2 }')">>$WATCHDOG
   echo "  opid_long=\"\";opid=\"\";for oop in \$(ps -ef|grep -v \${mypid}|grep -v sleep |grep -v compute| awk '\$3 == '\${ppid}' { print \$2 }'); do if [[ \`grep -wc \"\$oop\" $RTEMPDIR/nowatch.pid 2>/dev/null\` -eq "0" ]] ; then opid=\"\$opid \$oop\"; if [ -z \"\$opid_long\" ] ; then opid_long=\$oop; fi; fi; done">>$WATCHDOG
  #echo "  opid_long=\$(ps -ef|grep -v \${mypid}|grep -v sleep |grep -v compute | awk '\$3 == '\${ppid}' { print \$2 }'|head -1)">>$WATCHDOG
  echo "                  if [ \"$(/bin/uname -s)\" = \"Linux\" ]">>$WATCHDOG
  echo "                  then">>$WATCHDOG
  echo "  if [ -n \"\$opid\" ]; then ocomm_name=\$( ps -p \$opid_long -o command 2>/dev/null|grep -vi command|awk -F/ '{print \$NF}');fi">>$WATCHDOG
  echo "                  else">>$WATCHDOG
  echo "  if [ -n \"\$opid\" ]; then ocomm_name=\$( ps -ef |awk '\$2 == '\${opid_long}' {print \$0}');fi">>$WATCHDOG
  echo "                  fi">>$WATCHDOG
  #echo "  echo ocomm_name=\$ocomm_name">>$WATCHDOG
  echo "  if [ -e $WATCHLOG ]; then echo \"\`date '+%a %b %d %H:%M:%S %Y'\` candidate child pid for killing is \$opid - \$ocomm_name \" >>$WATCHLOG;fi">>$WATCHDOG
  #echo "  do">>$WATCHDOG 
  #echo "     opid=\$opid">>$WATCHDOG
  #echo "  done">>$WATCHDOG
  echo "  found_raccheck_sql=\$(echo \$ocomm_name|grep -c \"exec_raccheck_sqls\")">>$WATCHDOG
  echo "  found_raccheck_root=\$(echo \$ocomm_name|grep -c \"root_${program_name}\")">>$WATCHDOG
  echo "  found_raccheck_cells=\$(echo \$ocomm_name|grep -c \"${program_name}_cells\")">>$WATCHDOG
  echo "  found_raccheck_root_samepassword=\$(echo \$ocomm_name|grep -c \"expect -f\")">>$WATCHDOG
  echo "  if [ -e \"$ROOT_LCKFIL\" ]; then found_raccheck_root=1;fi">>$WATCHDOG
  echo "  if [[ -n \"\$found_raccheck_sql\" && \$found_raccheck_sql -ge 1 && \$watchdog_long_wakeup -eq 1 ]]">>$WATCHDOG
  echo "  then">>$WATCHDOG
  #echo "      watchdog_long_wakeup=0">>$WATCHDOG
  #echo "      echo \$watchdog_wakeup_sql">>$WATCHDOG
  echo "if [ -e $WATCHLOG ]; then echo \"\`date '+%a %b %d %H:%M:%S %Y'\` watcher sleeping for \$watchdog_wakeup_sql seconds \" >>$WATCHLOG;fi">>$WATCHDOG
  echo "       sleep \$watchdog_wakeup_sql">>$WATCHDOG
  #echo "  elif [[ \$watchdog_long_wakeup -eq 1 && \$watchdog_dbm_root -eq 1 ]] && [[ -n \"\$found_raccheck_root\" && \$found_raccheck_root -ge 1 || -n \"\$found_raccheck_root_samepassword\" && \$found_raccheck_root_samepassword -ge 1 ]]">>$WATCHDOG
  echo "  elif [[ -n \"\$found_raccheck_root\" && \$found_raccheck_root -ge 1 || -n \"\$found_raccheck_root_samepassword\" && \$found_raccheck_root_samepassword -ge 1 || -n \"\$found_raccheck_cells\" && \$found_raccheck_cells -ge 1 ]]">>$WATCHDOG
  echo "  then">>$WATCHDOG
  #echo "      watchdog_long_wakeup=0">>$WATCHDOG
  #echo "      echo \$watchdog_wakeup_root">>$WATCHDOG
  echo " if [ -e $WATCHLOG ]; then echo \"\`date '+%a %b %d %H:%M:%S %Y'\` watcher sleeping for \$watchdog_wakeup_root seconds \" >>$WATCHLOG;fi">>$WATCHDOG
  echo "      sleep \$watchdog_wakeup_root">>$WATCHDOG
  echo "  else">>$WATCHDOG
  #echo "      echo \$watchdog_wakeup">>$WATCHDOG
  echo " if [ -e $WATCHLOG ]; then echo \"\`date '+%a %b %d %H:%M:%S %Y'\` watcher sleeping for \$watchdog_wakeup seconds \" >>$WATCHLOG;fi">>$WATCHDOG
  echo "      sleep \$watchdog_wakeup">>$WATCHDOG
  echo "  fi">>$WATCHDOG
  echo "done">>$WATCHDOG
  chmod 544 $WATCHDOG  
  #$READ -p "see $WATCHDOG"
  #bash -x $WATCHDOG  >>watchdoglog.out 2>&1 & 
  $WATCHDOG &
  watchdog_pid=$! 
  #port specicifc commands are determined here and used in rest of the scipt
  case `/bin/uname` in
    Linux) 
      bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`
      PROFILE="$HOME/.bash_profile"
      if [ ! -f $PROFILE ]; then PROFILE="$HOME/.profile";fi 
      v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $8}'|head -1)
      usern=`whoami`
      if [[ -n "$RAT_ORATAB_LOC" ]]
      then
	ORATAB=$RAT_ORATAB_LOC
      else
      	ORATAB=/etc/oratab  
      fi
    ;;
    SunOS) 
      bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $9'}`
      v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $9}'|head -1)
      if [ `echo $v_crs_home_bin|grep -ic bin` -lt 1 ]; then v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $8}'|head -1);fi
      if [ -z "$bgproc" ]
      then
        bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`
      fi
      PROFILE="$HOME/.profile"
      #usern=`who am i|awk {'print $1}'`
      usern=`id|awk '{print $1}'|cut -d'(' -f2|cut -d')' -f1`
      if [[ -n "$RAT_ORATAB_LOC" ]]
      then
        ORATAB=$RAT_ORATAB_LOC
      else
	ORATAB="/var/opt/oracle/oratab" 
      fi
    ;;
    HP-UX) 
      PROFILE="$HOME/.profile"
      usern=`whoami`
      bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $9'}`
      v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $9}'|head -1) 
      if [ -z "$bgproc" ]
      then
        bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`
        v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $8}'|head -1) 
      fi
      if [[ -n "$RAT_ORATAB_LOC" ]]
      then
        ORATAB=$RAT_ORATAB_LOC
      else
        ORATAB=/etc/oratab
      fi
    ;;
    AIX)   
      bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $9'}`
      v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $9}'|head -1) 
      if [ -z "$bgproc" ]
      then
        bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`
        v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $8}'|head -1) 
      fi
      PROFILE="$HOME/.profile"
      usern=`whoami`
      if [[ -n "$RAT_ORATAB_LOC" ]]
      then
        ORATAB=$RAT_ORATAB_LOC
      else
        ORATAB=/etc/oratab
      fi
    ;;
    CYGWIN_NT-[0-9].[0-9])
      perl_exe=$(which perl|tr -d '\r');
      if [[ ! -n "$perl_exe" && -f "windiscover.out" ]] ; then
         v_home1=`grep HOME= windiscover.out | head -1 | sed 's/.*HOME=//' | sed 's/\|.*//'`;
         if [ -n "$v_home1" ] ; then
           perl_exe="$v_home1/perl/bin/perl"
         fi
      fi
      if [ -z "$perl_exe" ] ; then
        echo "";
        echo "Failed to find perl exectable in PATH. Discovery needs perl. Please set PATH and run again.";
        echo "";
        exit;
      fi
      $perl_exe $SCRIPTPATH/.cgrep/readreg.pl "$OUTPUTDIR"
      win_services=$OUTPUTDIR/win_services.out
      windiscover=$OUTPUTDIR/windiscover.out
	if [[ -n "$RAT_ORATAB_LOC" ]]
        then
          ORATAB=$RAT_ORATAB_LOC
	else
	  ORATAB=$OUTPUTDIR/win_oratab.out
	fi
      bgproc=`cat $win_services | grep OracleService |head -1 | sed 's/.*OracleService//'`;
      bgproc="ora_pmon_$bgproc";
      PROFILE="$HOME/.bash_profile"
      if [ ! -f $PROFILE ]; then PROFILE="$HOME/.profile";fi
      v_crs_home_bin=$(grep CRS_HOME= $windiscover | sed 's/CRS_HOME=//')
      v_crs_home_bin="$v_crs_home_bin/bin/crsd.exe"
      usern=`whoami`
      cp $windiscover . >/dev/null 2>&1
    ;;
    *)
      /bin/echo "ERROR: Unknown Operating System"
      exit -1
    ;;
  esac
  #watcher script code entds here
fi

if [[ $OFFLINE -eq "0" ]] ; then
  # Node list
  # start -init
  if [[ -n "$setup_inittab" ]] && [[ $setup_inittab -ne "3" && $setup_inittab -ne "10" ]] ; 
  then    
    if [ $is_bda_machine -eq "1" ]
    then
     generate_bda_node_info
    fi
    if [ $is_exalogic_machine -eq "1" ]
    then
      generate_exalogic_node_info
    fi
    if [ $is_exalytics_machine -eq "1" ]
    then
      generate_exalytics_node_info
    fi
    is_crs_up
    single_instance_run=0
    if [[ ${crs_up} -ne 1 || $oracle_restart -eq 1 ]]
    then
      is_db_up;
      if [[ -n "$somedb_up" && $somedb_up -eq "1" && $is_exalogic_machine -eq "0" && $is_exalytics_machine -eq 0 && $is_bda_machine -eq 0 ]]
      then
        single_instance_run=1
      elif [[ $is_exalogic_machine -eq "0" && $is_exalytics_machine -eq 0 && $is_bda_machine -eq 0 && ! -e "/opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP" ]] ; then
        attempt_cnt=3
        while [[ $attempt_cnt -ge "0" ]] ; do
          if [ -z $SYS_TYPE ]
          then
       	    printf "This computer is for [S]ingle instance database or part of a [C]luster to run RAC database [S|C] [C]:"

            if [[ $EM_PROBE_MODE -eq 1 ]]
            then
              cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="SINGLE_SELECT" defaultId="q${PROBE_QUES_CNT}o2" outcome="No">
    <text nls_id="orhc_exadata_n16_nlsid">
      This computer is for [S]ingle instance database or part of a [C]luster to run RAC database [S|C] [C]
    </text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1">
        <text nls_id="orhc_exadata_n39_nlsid">S</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n40_nlsid">C</text>
      </option>
    </options>
  </question>	
</group>
EOF
	      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
              single_instance_run=0	      
	    elif [[ $EM_XMLD_MODE -eq 1 ]]
	    then
	      read_probe_xml "This computer is for [S]ingle instance database or part of a [C]luster to run RAC database [S|C] [C]"
	      uip=$xml_rvalue
            else
              $READ uip
	      read_code=`echo $?`;
	      process_prompt "$read_code" "uip" "C"
              case "$uip" in
                C|c) single_instance_run=0;;
                S|s) single_instance_run=1;;
                *) single_instance_run=0;;
              esac
            fi
          else
       	    single_instance_run=0;
       	    if [ `echo $SYS_TYPE |grep -ic 'single'` -gt 0 ]
       	    then
       	      single_instance_run=1;
       	    fi	
          fi

          if [[ $single_instance_run -eq "2" ]] ; then
            echo "Invalid input. Try again ($attempt_cnt attempts remaining)"
            attempt_cnt=$(expr $attempt_cnt - 1)
          else
            attempt_cnt=-1
          fi
        done
        if [[ $single_instance_run -eq "2" ]] ; then
          single_instance_run=0
          echo "Running as a cluster node";
        fi
      fi
   
     if [[ $single_instance_run -eq "1" ]] ; then   
      case `/bin/uname` in
       Linux)
         v_crs_home_bin=$(ps -ef |grep ocssd.bin|grep -v grep|awk '{print $8}'|head -1)
       ;; 
       SunOS)
         v_crs_home_bin=$(ps -ef |grep ocssd.bin|grep -v grep|awk '{print $9}'|head -1)
         if [ `echo $v_crs_home_bin|grep -ic bin` -lt 1 ]; then v_crs_home_bin=$(ps -ef |grep ocssd.bin|grep -v grep|awk '{print $8}'|head -1);fi
       ;;
       HP-UX)
         v_crs_home_bin=$(ps -ef |grep ocssd.bin|grep -v grep|awk '{print $9}'|head -1)
         if [ `echo $v_crs_home_bin|grep -ic bin` -lt 1 ]
         then
           v_crs_home_bin=$(ps -ef |grep ocssd.bin|grep -v grep|awk '{print $8}'|head -1)
         fi
       ;;
       AIX)
         v_crs_home_bin=$(ps -ef |grep ocssd.bin|grep -v grep|awk '{print $9}'|head -1)
         if [ `echo $v_crs_home_bin|grep -ic bin` -lt 1 ]
         then
           v_crs_home_bin=$(ps -ef |grep ocssd.bin|grep -v grep|awk '{print $8}'|head -1)
         fi
       ;;
       CYGWIN_NT-[0-9].[0-9])
         windiscover=$OUTPUTDIR/windiscover.out
         v_crs_home_bin=$(grep CRS_HOME= $windiscover | sed 's/CRS_HOME=//')
         v_crs_home_bin="$v_crs_home_bin/bin/crsd.exe"
       ;;
       *)
         /bin/echo "ERROR: Unknown Operating System"
         exit -1
       ;;
      esac 
     fi

      if [[ $single_instance_run -eq "1" && $upgrade_mode -eq 0 ]] ; then
        DOROOT=0
        components="SIDB:SIDBMAA"
        echo "$localnode" > $HOSTLIST
         
        #if [[ "$usern" = "root" || $userid -eq 0 ]]
        #then
        #  if [[ $EM_PROBE_MODE -eq 1 ]]
        #  then
	#    EMSG="Running ${program_name} as root user is not required so not supported for single instance database."
        #    update_probe_xml "ERROR" "GENERIC" "$EMSG"
        #  fi
        #  echo -e "\n\n${RED}running ${program_name} as root user is not required so not supported for single instance database.\n\n${program_name} is exiting...${NORM}\n\n"
        #  exit 1
        #fi
      fi

      #echo "components=$components"
      if [[ $single_instance_run -eq "1" &&  $upgrade_mode -gt 0 ]]
      then
        DOROOT=0
        echo "$localnode" > $HOSTLIST
        if [ $upgrade_mode -eq 2 ]
        then 
          components="PREUPGRSIDB"
        elif  [ $upgrade_mode -eq 3 ]
        then 
          components=$(echo ${components}|sed 's/POSTUPGR://g'|sed 's/:POSTUPGR//g'|sed 's/:POSTUPGR://g'|sed 's/POSTUPGR//g')
          components=$(echo ${components}:POSTUPGRSIDB)
          components=$(echo ${components}|sed 's/RACCHECK://g'|sed 's/:RACCHECK//g'|sed 's/:RACCHECK://g'|sed 's/RACCHECK//g')
          components=$(echo ${components}:SIDB)
          components=$(echo ${components}|sed 's/MAA://g'|sed 's/:MAA//g'|sed 's/:MAA://g'|sed 's/MAA//g')
          components=$(echo ${components}:SIDBMAA)
        fi
      fi
    fi

    #$READ -p "stop"     
    if [ -n "$ORA_CRS_HOME" ]
    then
      CRS=$ORA_CRS_HOME
    elif [ -n "$CRS_HOME" ]
    then
      CRS=$CRS_HOME
    elif [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "0" && -n "$single_instance_run" && $single_instance_run -eq 0 && -n "$is_bda_machine" && $is_bda_machine -eq "0" && -n "$single_instance_run" && $single_instance_run -eq 0 && $is_exadata_dom0_machine -eq 0 &&  $is_ssc_globalzone_machine -eq 0 ]] || [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]]
    then
      if [ ${crs_up} -eq 1 ]
      then
        v_crs_home_bin=$(dirname $v_crs_home_bin 2>/dev/null)
        v_crs_home=$(echo $v_crs_home_bin|sed 's/\/bin//g')
        echo ""
        if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 && -f ${v_crs_home_bin}/crsd.$BIN && $daemon_init_mode -eq 0 ]]
        then   
          if [[ -n "$setup_inittab" && $setup_inittab -gt "0" ]] || [[ -n "$prepare_init" && $prepare_init -eq "1" ]]; then
            setCRSHome=Yes
          else
            if [[ $EM_PROBE_MODE -eq 1 ]]
            then
              cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <text nls_id="orhc_exadata_n41_nlsid">
        CRS stack is running and CRS_HOME is not set 
      </text>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n17_nlsid">
      Do you want to set CRS_HOME to {1}
    </text>
    <tokens>
      <token index="1">$v_crs_home</token>
    </tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2" qid="q${PROBE_QUES_CNT}o2q1">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o2q1" questionType="TEXT" defaultId="$v_crs_home" outcome="No">
    <text nls_id="orhc_exadata_n23_nlsid">
      Enter path for clusterware home
    </text>
  </question>
</group>
EOF
	      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

              echo -e "CRS stack is running and CRS_HOME is not set. Do you want to set CRS_HOME to "$v_crs_home"?[y/n][y]"
	      setCRSHome='Yes'
	    elif [[ $EM_XMLD_MODE -eq 1 ]]
	    then
              echo -e "CRS stack is running and CRS_HOME is not set. Do you want to set CRS_HOME to "$v_crs_home"?[y/n][y]"

	      read_probe_xml "Do you want to set CRS_HOME to"
	      setCRSHome=$xml_rvalue
	    else
              if [ $program_name != "exachk" ]
              then 
		  exec 3<&2; exec 2<&0
		  $READ -p "CRS stack is running and CRS_HOME is not set. Do you want to set CRS_HOME to "$v_crs_home"?[y/n][y]" setCRSHome
		  read_code=`echo $?`;
		  exec 2<&3
		  process_prompt "$read_code" "setCRSHome" "y"
              else
                  setCRSHome=Yes 
              fi
            fi
          fi
        elif [[ -n "$NOQUESTION" && $NOQUESTION -eq 1 && -f ${v_crs_home_bin}/crsd.$BIN ]] || [ $daemon_init_mode -eq 1 ]
        then
          setCRSHome=Yes
        else
          setCRSHome=No
        fi 
        case $setCRSHome in
          y|Y|yes|YES|Yes)
            export CRS=$v_crs_home
            ;;
          n|N|No|NO)
	    if [[ $EM_XMLD_MODE -eq 1 ]]
	    then
              echo -e "Enter path for clusterware home: "

	      read_probe_xml "Enter path for clusterware home"
	      cHome=$xml_rvalue
	    else
              echo ""
              exec 3<&2; exec 2<&0
              $READ -p "Enter path for clusterware home:  " cHome
              exec 2<&3
	    fi
            export CRS=$cHome
            ;;
          *)
            export CRS=$v_crs_home
            ;;
        esac
      elif [ -n "$local_invntr_CH" ]
      then
        if [[ $EM_PROBE_MODE -eq 1 ]]
        then
          cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n25_nlsid">
        CRS binaries found at {1}
      </text>
      <tokens>
        <token index="1">$local_invntr_CH</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n17_nlsid">
      Do you want to set CRS_HOME to {1}
    </text>
    <tokens>
      <token index="1">$local_invntr_CH</token>
    </tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o2q1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o2q1" questionType="TEXT" outcome="No">
    <text nls_id="orhc_exadata_n24_nlsid">
      Enter value for ORA_CRS_HOME environment variable
    </text>
  </question>
</group>
EOF
	  PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

          echo -e "CRS binaries found at $local_invntr_CH. Do you want to set CRS_HOME to "$local_invntr_CH"?[y/n][y]"
	  setCRSHome="Yes"
	elif [[ $EM_XMLD_MODE -eq 1 ]]
	then
          echo -e "CRS binaries found at $local_invntr_CH. Do you want to set CRS_HOME to "$local_invntr_CH"?[y/n][y]"

	  read_probe_xml "Do you want to set CRS_HOME to"
	  setCRSHome=$xml_rvalue
	else
          exec 3<&2; exec 2<&0
          $READ -p "CRS binaries found at $local_invntr_CH. Do you want to set CRS_HOME to "$local_invntr_CH"?[y/n][y]" setCRSHome
	  read_code=`echo $?`;
          exec 2<&3
	  process_prompt "$read_code" "setCRSHome" "y"
        fi
        case $setCRSHome in
          y|Y|yes|YES|Yes)
            export CRS=$local_invntr_CH
            ;;
          n|N|No|NO)
	    if [[ $EM_XMLD_MODE -eq 1 ]]
	    then
              echo -e "Enter value for ORA_CRS_HOME environment variable: "

	      read_probe_xml "Enter value for ORA_CRS_HOME environment variable"
	      cHome=$xml_rvalue
	    else
              echo ""
              exec 3<&2; exec 2<&0
              $READ -p "Enter value for ORA_CRS_HOME environment variable:  " cHome
              exec 2<&3
	    fi
            export CRS=$cHome
            ;;
          *)
            export CRS=$local_invntr_CH
            ;;
        esac
      else    
        #echo -e $RED"Clusterware home not set so CRS related audit check will be skipped.\n"$NORM
        echo "Clusterware home not set so CRS related audit check will be skipped.\n" >>$LOGFIL
      fi
    fi 

    save_crs
    if [ ${crs_up} -eq 1 ]
    then
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
        OLD_OH=$ORACLE_HOME
        ORACLE_HOME=$CRS
        get_dbOwner
        ORACLE_HOME=$OLD_OH
        if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
          check_crs_stat=`su $dbOwner -c "$CRS/bin/crsctl status resource -t >/dev/null 2>&1";echo $?`
        else
          check_crs_stat=`su $dbOwner -c "$CRS/bin/crs_stat -t >/dev/null 2>&1";echo $?`
        fi
        cd $OLD_DIR
        unset OLD_DIR
      else
        if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
          check_crs_stat=`$CRS/bin/crsctl status resource -t >/dev/null 2>&1;echo $?`
        else
          check_crs_stat=`$CRS/bin/crs_stat -t  >/dev/null 2>&1;echo $?`
        fi
      fi
      #check_crs_stat=$($CRS/bin/crs_stat -t >/dev/null 2>&1;echo $?)
      if [ $check_crs_stat -eq 0 ]
      then
        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
          OLD_OH=$ORACLE_HOME
          ORACLE_HOME=$CRS
          get_dbOwner
          ORACLE_HOME=$OLD_OH
          crs112=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c '11.2'"`
          crs121=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c '12.1'"`
          crs122=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c '12.2'"`
          if [[ -n "$crs121" && $crs121 -gt 0 ]]; then  crs112=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c '12.1'"`;fi
          if [[ -n "$crs122" && $crs122 -gt 0 ]]; then  crs112=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c '12.2'"`;fi
          cd $OLD_DIR
          unset OLD_DIR
        else
          crs112=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "11.2"`
          crs121=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "12.1"`
          crs122=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "12.2"`
          if [[ -n "$crs121" && $crs121 -gt 0 ]]; then  crs112=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "12.1"`;fi
          if [[ -n "$crs122" && $crs122 -gt 0 ]]; then  crs112=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "12.2"`;fi
        fi
      fi
    fi

    if [[ -z "$RAT_CLUSTERNODES" && $is_exalogic_machine -eq "0" && $single_instance_run -eq "0" && $is_exalytics_machine -eq 0 && $is_bda_machine -eq "0"  && $is_exadata_dom0_machine -eq "0" && $is_ssc_globalzone_machine -eq 0 ]]; then
      if [ ${crs_up} -eq 1 ]
      then 
        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
          OLD_OH=$ORACLE_HOME
          ORACLE_HOME=$CRS
          get_dbOwner
          ORACLE_HOME=$OLD_OH
          check_crs_stat=$(su $dbOwner -c "$CRS/bin/crs_stat -t >/dev/null 2>&1";echo $?)
	  cd $OLD_DIR
	  unset OLD_DIR
	else
          check_crs_stat=$($CRS/bin/crs_stat -t >/dev/null 2>&1;echo $?)
	fi
        if [ $check_crs_stat -eq 0 ] 
        then  
          if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
            OLD_OH=$ORACLE_HOME
            ORACLE_HOME=$CRS
            get_dbOwner
            ORACLE_HOME=$OLD_OH
            crs112=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c '11.2'"`
            crs121=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c '12.1'"`
            crs122=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c '12.2'"`
            if [[ -n "$crs121" && $crs121 -gt 0 ]]; then  crs112=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c '12.1'"`;fi
            if [[ -n "$crs122" && $crs122 -gt 0 ]]; then  crs112=`su $dbOwner -c "$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c '12.2'"`;fi

            for i in `su $dbOwner -c "$CRS/bin/olsnodes"`
            do   
             echo $i|tr "[A-Z]" "[a-z]">>$HOSTLIST
            done
            cd $OLD_DIR
            unset OLD_DIR
          else
            crs112=`$CRS/bin/crsctl query $crs_version_switch|sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "11.2"`
            crs121=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "12.1"`
            crs122=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "12.2"`
            if [[ -n "$crs121" && $crs121 -gt 0 ]]; then  crs112=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "12.1"`;fi
            if [[ -n "$crs122" && $crs122 -gt 0 ]]; then  crs112=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "12.2"`;fi

            for i in `$CRS/bin/olsnodes`
            do   
             echo $i|tr "[A-Z]" "[a-z]">>$HOSTLIST
            done
	  fi
        else
          if [[ -n "$localonly" && $localonly -eq 1 ]] 
          then
            echo `hostname|cut -d. -f1`>$HOSTLIST 
          else    
            nodelist_without_olsnodes
          fi
        fi
      else
        if [[ -n "$localonly" && $localonly -eq 1 ]] 
        then
          echo `hostname|cut -d. -f1`>$HOSTLIST 
        else    
          nodelist_without_olsnodes
        fi  
      fi
    elif [[ -z "$RAT_CLUSTERNODES" ]] && [[ $is_exadata_dom0_machine -eq 1 || $is_ssc_globalzone_machine -eq 1 ]]
    then
      $IBHOSTS 2>/dev/null|$AWK '{if ( / S [0-9.,]* HCA\-/ ) print $6;}' |tr -d '"'|sort -u >>$HOSTLIST
    elif [[ ! -z "$RAT_CLUSTERNODES" ]]
    then
      rm -f $HOSTLIST
      #Reassging localnode when node names are diffrent from hostname command and passed using clusternodes. fix for bug 18601262 
      orig_localnode=$localnode
      localnode=$(echo "$RAT_CLUSTERNODES"|awk '{print $1}')
      for nodename in `echo $RAT_CLUSTERNODES`
      do
       echo $nodename>>$HOSTLIST
      done  
    fi
    ret_crs

    #following code is to change the running node as first node in first and make it driving node
    #saved_localnode="$localnode"
    saved_localnode="$orig_localnode"

    if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "0" ]]    
    then
      localnode=$(grep -iw "${localnode}" $HOSTLIST| head -1)
      if [ -z "$localnode" ] ; then localnode="$saved_localnode"; fi;

      if [[ `cat $HOSTLIST|head -1` != $localnode ]]
      then
        #sed "/${localnode}/Id" $HOSTLIST > $INPUTDIR/tmp_hostlist.out
        cat $HOSTLIST|sed 's/'${localnode}'//g'> $INPUTDIR/tmp_hostlist.out
        rm $HOSTLIST
        echo $localnode >$HOSTLIST
        cat $INPUTDIR/tmp_hostlist.out|sed '/^$/d' >>$HOSTLIST
        rm $INPUTDIR/tmp_hostlist.out
      fi
    else
      echo "$saved_localnode" >$HOSTLIST	
      for guestvm in "${el_guest_vms[@]}"
      do
        echo "$guestvm" >> $HOSTLIST
      done
    fi

    orig_localnode_fullname=$(hostname)
    hostmap=("${hostmap[@]}" $localnode:$orig_localnode_fullname);

    if [[ -n "$localonly" && $localonly -eq 1 ]]
    then
      localonly_nodename=$(cat $HOSTLIST|head -1)
      rm $HOSTLIST >/dev/null 2>&1
      echo $localonly_nodename >$HOSTLIST
    fi

    cat $HOSTLIST|sort|uniq > $HOSTLIST.2
    mv $HOSTLIST.2 $HOSTLIST
    #ends here

    #Following code is change from top to here for handling user defined storage servers rather than reading from default cellip.ora
    if [[ -z "$RAT_CELLS" && -n $snlist_file && -e "$snlist_file" ]] 
    then # exalogic machine. list if already in file.
      for cellname in `cat $snlist_file`
      do
        echo "cell=\"$cellname\"">>$INPUTDIR/cellip.ora
      done
      CELLIP=$INPUTDIR/cellip.ora
    elif [[ -z "$RAT_CELLS" && $is_exadata_dom0_machine -eq 0 && $is_ssc_globalzone_machine -eq 0 ]]
    then
      CELLIP=/etc/oracle/cell/network-config/cellip.ora   
    elif [[ $is_exadata_dom0_machine -eq 1 || $is_ssc_globalzone_machine -eq 1 ]] && [[ -z "$RAT_CELLS" ]]
    then 
         $IBHOSTS 2>/dev/null|$AWK '{if ( / C[ 0-9.,]* HCA\-/ ) print "cell = " $6 "\"";}'|sort -u >>$INPUTDIR/cellip.ora 
        CELLIP=$INPUTDIR/cellip.ora
    else
      for cellname in `echo $RAT_CELLS`
      do
        echo "cell=\"$cellname\"">>$INPUTDIR/cellip.ora
      done
      CELLIP=$INPUTDIR/cellip.ora
    fi
    if [[ -e $CELLIP && ! -e $CELLDIR ]];then mkdir $CELLDIR >/dev/null 2>&1;fi; 
  fi 
  # end -init
fi

if [ $OFFLINE -eq 0 ]
then
  #what type of check are we doing?
  #echo "DEBUG MSG - CHECK TYPE = "$TYP
  #if [ $userid -eq 0 ]
  #then
  #  echo -e $RED"\nYou can not run using root user.Login as Oracle software owner and run it again"$NORM
  #  echo "\nYou can not run using root user.Login as Oracle software owner and run it again">>$LOGFIL
  #  exit -1
  #fi
  #record localnode name to execute checks without ssh on localnode
  #Below code is to remoe all control-M from both data files
  if [[ -f $REFFIL && `echo $GREP|grep -ci cgrep` -lt 1 ]]
  then
    ##CONTROLM    sed  's///g' $REFFIL > $INPUTDIR/collections.dat
    cat $REFFIL | tr -d '\r' > $INPUTDIR/collections.dat
    if [ -n "$RAT_OUTPUT" ]
    then
      cp $INPUTDIR/collections.dat $RAT_OUTPUT
      REFFIL=$RAT_OUTPUT/collections.dat
    else
      cp $INPUTDIR/collections.dat $REFFIL
    fi
    rm $INPUTDIR/collections.dat
  fi
  if [[ -f $REFFIL1 && `echo $GREP|grep -ci cgrep` -lt 1 ]] 
  then
    ##CONTROLM    sed  's///g' $REFFIL1 > $INPUTDIR/rules.dat
    cat $REFFIL1|tr -d '\r' > $INPUTDIR/rules.dat
    if [ -n "$RAT_OUTPUT" ]
    then
      cp $INPUTDIR/rules.dat $RAT_OUTPUT
      REFFIL1=$RAT_OUTPUT/rules.dat
    else
      cp $INPUTDIR/rules.dat $REFFIL1  
    fi 
    rm $INPUTDIR/rules.dat
  fi
  #check inventory to see if this is a 10g or 11g database
  #version=v`grep "<COMP NAME=\"oracle.server\" VER=\"1" $ORACLE_HOME/inventory/ContentsXML/comps.xml |awk {'print $3'}`
  #echo $version

  #if [ "$version" = "v" ]
  #then
  #    echo -e $RED"The inventory in the current oracle_home indicates that the"$NORM
  #    echo "The inventory in the current oracle_home indicates that the" >>$LOGFIL
  #    echo -e $RED"database is an earlier version than 10g which is not supported"$NORM
  #    echo "database is an earlier version than 10g which is not supported" >>$LOGFIL
  #    echo -e $RED"by this utility.  please check your environment and try again."$NORM
  #    echo "by this utility.  please check your environment and try again." >>$LOGFIL
  #    exit 1
  #fi
  #ssh setup starts from here and not to change 
  if [[ `echo "$argsaved"|grep -ic 'initrmsetup'` -eq 0 && `echo "$argsaved"|grep -ic 'initcheck'` -eq 0 ]]; 
  then
    if [[ $single_instance_run -eq "0" && $is_exalytics_machine -eq 0 ]] ; then
      echo -e "\nChecking ssh user equivalency settings on all nodes in cluster\n"|tee -a $LOGFIL
    fi
    #calling check_hostname_mismatch to check if default hostname is not mapped to management network in Exadata
    if [[ -f "/opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP" && -z "$RAT_CLUSTERNODES" && `uname -p 2>/dev/null` != "sparc"  && $is_exadata_dom0_machine -eq 0 ]]
    then
         check_hostname_mismatch
    fi
    #echo -e "Checking ssh autologin settings on all nodes in cluster\n">> $LOGFIL
    arr=0

    if [[ ! -z "$phy_nodes" ]]
    then
      cat $HOSTLIST|sort|uniq > $HOSTLIST.new
      mv $HOSTLIST.new $HOSTLIST

      sed /$localnode/d $HOSTLIST > $HOSTLIST.new
      rm -rf $HOSTLIST
      echo "$localnode" > $HOSTLIST
      cat $HOSTLIST.new >> $HOSTLIST
      rm -rf $HOSTLIST.new
    fi

    use_expect_for_ssh=0
    for hname in `cat $HOSTLIST`
    do
      is_IP "$hname"
      print_hname="$hname"

      if [[ -z $is_exalogic_machine ]] || [[ -n "$is_exalogic_machine" && $is_exalogic_machine -ne "1" ]] ; then
        use_expect_for_ssh=0
        unset passwordToCheck
      fi

      platform=`uname -s`
      #if [ $platform = "Linux" ]
      #then
      #  PING="/bin/ping"
      #else
      #  PING="/usr/sbin/ping"
      #fi
      if [ $hname != $localnode ]
      then
        #if [ $platform = "SunOS" ]; then
        #  $PING -s $hname 5 5 >/dev/null 2>&1
        #elif [ $platform = "HP-UX" ]; then
        #  $PING $hname -n 5 -m 5 >/dev/null 2>&1
        #else
        #  $PING -c 1 $PING_W_FLAG $hname >/dev/null 2>&1
        #fi
        #exitcode=`echo $?`
        test_node_reachability $hname $usern;
        if [ $el_node_ping -eq "1" ] ; then
          exitcode=0;
        else
          exitcode=1;
        fi

        #if [[ -n "$exitcode" && $exitcode -eq 0 ]] 
        #then
        #  check_ssh_speed $usern $hname
        #  if [[ -n $ssh_go_ahead && $ssh_go_ahead = 0 ]] ; then exitcode=255; fi
        #fi
      fi
      if [[ $exitcode = 0 && $hname != $localnode ]]
      then   
        /usr/bin/ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -l $usern $hname ls 2>/dev/null 1>/dev/null
        ssh_setup_status=$?
        if [ $ssh_setup_status -ne 0 ]
        then
          if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]] || [[ -n "$is_bda_machine" && $is_bda_machine -eq 1 ]]
          then #takes too long
            rsh_setup_status=1
          else
           rsh -l $usern $hname ls 2>/dev/null 1>/dev/null 
           rsh_setup_status=$? 
           if [ $rsh_setup_status -eq 0 ];then SSHELL=rsh;SCOPY=rcp;fi
          fi
        fi
        echo "ssh_setup_status=$ssh_setup_status rsh_setup_status=$rsh_setup_status">>$LOGFIL
        if [[ $ssh_setup_status -eq 0 || $hname = $localnode || $rsh_setup_status -eq 0 ]]
        then
          hostfullname=$($SSHELL $hname hostname)
          hostmap=("${hostmap[@]}" $hname:$hostfullname);

          if [[ -n $is_IPADDRESS && $is_IPADDRESS = 1 ]]; then print_hname="$hname ($hostfullname)"; fi
 
          echo -e $GREEN"Node $print_hname is configured for ssh user equivalency for $usern user\n" $NORM
          echo "$hname is configured for ssh user equivalency for $usern user" >>$LOGFIL
        else
          if [[ $use_expect_for_ssh -eq 0 ]] ; then
            echo -e $RED"Node $hname is not configured for ssh user equivalency and the script uses ssh to execute checks on remote nodes.\n\nWithout this facility the script cannot run audit checks on the remote nodes. \n\nIf necessary due to security policies the script can be run individually on each node.\n"$NORM
            echo -e "Node $hname is not configured for ssh user equivalency and the script uses ssh to execute checks on remote nodes.\n\nWithout this facility the script cannot run audit checks on the remote nodes. \n\nIf necessary due to security policies the script can be run individually on each node.\n">>$LOGFIL

	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
	      echo -e "\n\n"
	      emhostlist=("${emhostlist[@]}" $hname);
	      AutoLoginCheck="Yes" 
	    elif [[ $EM_XMLD_MODE -eq 1 ]]
	    then
              echo -e "Do you want to configure SSH for user $usern on $hname [y/n][y]"

	      read_probe_xml "Do you want to setup SSH equivalency on all nodes in cluster"
	      AutoLoginCheck=$xml_rvalue 
	    else 
              exec 3<&2; exec 2<&0
              $READ -p "Do you want to configure SSH for user $usern on $hname [y/n][y]" AutoLoginCheck
	      read_code=`echo $?`;
              exec 2<&3
	      process_prompt "$read_code" "AutoLoginCheck" "n"
	    fi
          fi
          case $AutoLoginCheck in
          y|Y|YES|yes|Yes)
            AutoLoginCheckYes=1 
	
	    if [[ $EM_PROBE_MODE -eq 0 ]]
	    then
              func_setup_ssh -user $usern -hosts "$hname" 
              if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
              then
                sed  "s/$hname//g" $HOSTLIST >$INPUTDIR/o_host_list.out
                cp $INPUTDIR/o_host_list.out $HOSTLIST
                rm $INPUTDIR/o_host_list.out
                add_to_skipped_nodes "$hname" "Failed to setup ssh user equivalency as password entered is incorrect.";
              else
                hostfullname=$($SSHELL $hname hostname)
                hostmap=("${hostmap[@]}" $hname:$hostfullname);

                if [[ -n $is_IPADDRESS && $is_IPADDRESS = 1 ]]; then print_hname="$hname ($hostfullname)"; fi
 
                echo -e $GREEN"\nNode $print_hname has been configured for ssh user equivalency for $usern user\n" $NORM
              fi
	    else
                sed  "s/$hname//g" $HOSTLIST >$INPUTDIR/o_host_list.out
                cp $INPUTDIR/o_host_list.out $HOSTLIST
                rm $INPUTDIR/o_host_list.out
	    fi
            ;;
          n|N|NO|No|no)
	    if [[ $EM_XMLD_MODE -eq 1 ]]; then
	      tmpSshConf='No'
	    else 
              if [[ $use_expect_for_ssh -eq 0 ]] ; then
                exec 3<&2; exec 2<&0
                $READ -p "We can configure ssh only for this run and reverse the changes back. do you want to continue?[y/n][y] " tmpSshConf
		read_code=`echo $?`;
                exec 2<&3
		process_prompt "$read_code" "tmpSshConf" "n"
              fi
	    fi
            case $tmpSshConf in
            y|Y|YES|yes|Yes)
              func_setup_ssh -user $usern -hosts "$hname" 
              if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
              then
                sed  "s/$hname//g" $HOSTLIST >$INPUTDIR/o_host_list.out
                cp $INPUTDIR/o_host_list.out $HOSTLIST
                rm $INPUTDIR/o_host_list.out
                add_to_skipped_nodes "$hname" "Failed to setup ssh user equivalency as password entered is incorrect.";
              else
                hostfullname=$($SSHELL $hname hostname)
                hostmap=("${hostmap[@]}" $hname:$hostfullname);

                if [[ -n $is_IPADDRESS && $is_IPADDRESS = 1 ]]; then print_hname="$hname ($hostfullname)"; fi 
 
                echo -e $GREEN"\nNode $print_hname has been configured for ssh user equivalency for $usern user for this run\n" $NORM
                hnameArr[$arr]=$hname
                arr=`expr $arr + 1`
              fi
              ;;
            n|N|NO|No)
              if [ $hname = $localnode ]
              then
                echo -e $RED"\nWithout ssh user equivalency, collections and audit checks will be executed only on localnode ${localnode}\n"$NORM
                echo -e $RED"\nWithout ssh user equivalency, collections and audit checks will be executed only on localnode ${localnode}\n">>$LOGFIL
                echo $localnode >$HOSTLIST
              else
                echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on ${hname}\n"$NORM
                echo -e "\nWithout ssh user equivalency, no audit check will be executed on ${hname}\n">>$LOGFIL
                sed  "s/$hname//g" $HOSTLIST >$INPUTDIR/o_host_list.out
                cp $INPUTDIR/o_host_list.out $HOSTLIST
                rm $INPUTDIR/o_host_list.out
                add_to_skipped_nodes "$hname" "User chose not to setup ssh user equivalency.";
              fi
              ;;
            *)
              func_setup_ssh -user $usern -hosts "$hname"
              if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
              then
                sed  "s/$hname//g" $HOSTLIST >$INPUTDIR/o_host_list.out
                cp $INPUTDIR/o_host_list.out $HOSTLIST
                rm $INPUTDIR/o_host_list.out
                add_to_skipped_nodes "$hname" "Failed to setup ssh user equivalency as password entered is incorrect.";
              else
                hostfullname=$($SSHELL $hname hostname)
                hostmap=("${hostmap[@]}" $hname:$hostfullname);

        	if [[ -n $is_IPADDRESS && $is_IPADDRESS = 1 ]]; then print_hname="$hname ($hostfullname)"; fi
 
                echo -e $GREEN"\nNode $print_hname has been configured for ssh user equivalency for $usern user for this run\n" $NORM
                hnameArr[$arr]=$hname
                arr=`expr $arr + 1`
              fi
              ;;
            esac
            ;;
          *)
            AutoLoginCheckYes=1
            func_setup_ssh -user $usern -hosts "$hname" 
            if [[ $? -ne 0 || $SSH_PASS_STATUS -eq 1 ]]
            then
              sed  "s/$hname//g" $HOSTLIST >$INPUTDIR/o_host_list.out
              cp $INPUTDIR/o_host_list.out $HOSTLIST
              rm $INPUTDIR/o_host_list.out
              add_to_skipped_nodes "$hname" "Failed to setup ssh user equivalency as password entered is incorrect.";
       	    else
              hostfullname=$($SSHELL $hname hostname)
              hostmap=("${hostmap[@]}" $hname:$hostfullname);
              echo -e $GREEN"\nNode $hname has been configured for ssh user equivalency for $usern user\n" $NORM
            fi
          ;;
          esac
        fi
      elif [ $hname != $localnode ]
      then
        sed  "s/$hname//g" $HOSTLIST >$INPUTDIR/o_host_list.out
        cp $INPUTDIR/o_host_list.out $HOSTLIST
        rm $INPUTDIR/o_host_list.out

        if [[ $ssh_go_ahead = 0 ]]
        then
          add_to_skipped_nodes "$hname" "Network latency issue: Node is pingable but ssh took too long";
          echo "Node $hname is pingable but ssh took too long so removing from host list">>$LOGFIL
        else
          add_to_skipped_nodes "$hname" "Node is not pingable";
          echo "Node $hname is not pingable so removing from host list">>$LOGFIL
        fi
      fi
    done
  else
    touch $HOSTLIST
  fi

  if [[ $EM_PROBE_MODE -eq 1 ]]
  then
    if [[ $single_instance_run -eq "0" && $is_exalytics_machine -eq 0 && ${#emhostlist[@]} -gt 0 ]] ; then
      cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <text nls_id="orhc_exadata_n42_nlsid">
      Do you want to setup SSH equivalency on all nodes in cluster
    </text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o1q1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
EOF
    
      if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
      then
	cat >> ${PROBE_XML}.tmp <<EOF
  <question id="q${PROBE_QUES_CNT}o1q1" questionType="BOOLEAN" outcome="No">
    <context id="q${PROBE_QUES_CNT}o1q1c">
      <text nls_id="orhc_exadata_n74_nlsid">
	We can configure ssh on all nodes without prompting for password	
      </text>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n75_nlsid">Is {1} user password same on all nodes</text>
    <tokens><token index="1">$usern</token></tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1q1o1" qid="q${PROBE_QUES_CNT}o1q1o1q1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o1q1o2" qid="q${PROBE_QUES_CNT}o1q1o2q1">
         <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1o1q1" questionType="SECRET" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n67_nlsid">Common {1} user password on nodes</text>
    <tokens><token index="1">$usern</token></tokens>
    </tokenizedtext>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1o2q1" questionType="MULTIPART_QUESTION" outcome="No">
    <context id="q${PROBE_QUES_CNT}o1q1o2q1c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n43_nlsid">
        Setup SSH user({1}) equivalency on following nodes in cluster 
      </text>
      <tokens>
        <token index="1">$usern</token>
      </tokens>
      </tokenizedtext>
    </context>
    <text nls_id="orhc_exadata_n44_nlsid">
      Enter passwords for the following nodes 
    </text>
    <multipart-question>
EOF
      else
	cat >> ${PROBE_XML}.tmp <<EOF
  <question id="q${PROBE_QUES_CNT}o1q1" questionType="MULTIPART_QUESTION" outcome="No">
    <context id="q${PROBE_QUES_CNT}o1q1c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n43_nlsid">
        Setup SSH user({1}) equivalency on following nodes in cluster 
      </text>
      <tokens>
        <token index="1">$usern</token>
      </tokens>
      </tokenizedtext>
    </context>
    <text nls_id="orhc_exadata_n44_nlsid">
      Enter passwords for the following nodes 
    </text>
    <multipart-question>
EOF
      fi

      host_counter=1
      for hname in ${emhostlist[@]}
      do 
	if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
	then
          cat >> ${PROBE_XML}.tmp <<EOF
      <question id="q${PROBE_QUES_CNT}o1q1o2q1q${host_counter}" questionType="SECRET" outcome="No">
        <text>$hname</text>
      </question>
EOF
	else
          cat >> ${PROBE_XML}.tmp <<EOF
      <question id="q${PROBE_QUES_CNT}o1q1q${host_counter}" questionType="SECRET" outcome="No">
        <text>$hname</text>
      </question>
EOF
	fi
        host_counter=$(expr ${host_counter} + 1);
      done

      cat >> ${PROBE_XML}.tmp <<EOF
    </multipart-question>
  </question>
</group>
EOF
      PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
    fi
  fi
#Moving space check functionlality before copying check_tmp_status.sh to remote node
 func_check_space
  #$READ -p "space_status=$space_status and space_fail_msg=$space_fail_msg space_pass_msg=$space_pass_msg"
  if [ $space_status -eq 1 ]
  then 
    if [[ -n "$daemon_init_mode" && $daemon_init_mode -eq 1 ]]
    then
      echo -e "$space_fail_msg \n"
      echo -e "Please make at least 10MB space available at above location and re-run"
      echo -e ${RED}"${program_name} is exiting.."${NORM}
      exit 1
    fi
    if [[ $EM_PROBE_MODE -eq 1 ]]
    then
      EMSG="Please make at least 10MB space available at above location and re-run"
      update_probe_xml "ERROR" "GENERIC" "$EMSG"
      exit 1
    fi

    while [ $space_status -eq 1 ]
    do
      echo -e "$space_fail_msg"
      exec 3<&2; exec 2<&0
      $READ -p "Please make at least 10MB space available at above location and retry to continue.[y/n][y]?" spaceYesNo
      read_code=`echo $?`;
      exec 2<&3
      process_prompt "$read_code" "spaceYesNo" "n"
      case $spaceYesNo in
          yes|Yes|Y|y|YES)
            func_check_space
          ;;
          no|No|N|NO|n)
            exit -1
          ;;
          *)
            func_check_space
         ;;
     esac
    done
  else
    echo $space_pass_msg >> $LOGFIL
  fi

#space checking ends here
  for hname in `cat $HOSTLIST`
  do
    if [ $hname != $localnode ]
    then
      check_tmp_status
    fi
  done

  RATENV_FIL=$TMPDIR/.${program_name}.env.tmpl
  TMP_RATENV_FIL=$TMPDIR/.env.tmpl
  if [[ -n "$prepare_init" && $prepare_init -eq "1"  ]]
  then 
    prepare_initsetup
  
    if [[ -n "$setup_status" && "$setup_status" -eq "0" ]]
    then
      echo -e ${RED}"\n$usern user equivalence is not setup on $hname"${NORM}
      echo -e ${RED}"\n\n${program_name} is exiting..\n"${NORM}

      remove_preinitsetup
      if [ -e "$INITDMP" ]; then rm -f $INITDMP >/dev/null 2>&1; fi;
    else
      echo -e "\n\nPre installation successfully completed on $localnode"
    fi
    exit 0;
  fi

  if [[ -n "$setup_inittab" && $setup_inittab -gt "0" ]] ; then
    if [ -z "$localnode" ]; then localnode=`hostname | tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r'`; fi
  
    case `/bin/uname` in
      Linux)
        inittab_string="hock:35:respawn:/etc/init.d/init.$program_name run >/dev/null 2>\&1 </dev/null"
        init_dir=/etc/init.d
      ;;
      SunOS)
        inittab_string="hock:3:respawn:/etc/init.d/init.$program_name run >/dev/null 2>\&1 </dev/null"
        init_dir=/etc/init.d
      ;;
      HP-UX)
        inittab_string="hock:35:respawn:/sbin/init.d/init.$program_name run >/dev/null 2>\&1 </dev/null"
        init_dir=/sbin/init.d
      ;;
      AIX)
        inittab_string="hock:2:respawn:/etc/init.$program_name run >/dev/null 2>\&1 </dev/null"
        init_dir=/etc
      ;;
      *)
        echo -e "\nPlatform not supported.. exiting\n\n";
        exit 1;
      ;;
    esac
  fi

  #if [[ -n "$setup_inittab" && $setup_inittab -eq "10" ]] ; then
  #  localnode=`hostname | tr "[A-Z]" "[a-z]" |cut -d. -f1`
  #  if [ ! -e "$init_dir/init.$program_name" ] ; then
  #    echo -e "\nAuto restart facility is not setup. Use -initsetup flag to setup.\n\n";
  #    exit
  #  fi
  #  $SSHELL root@$localnode "/bin/sh $init_dir/init.$program_name shutdown; rm -f $init_dir/init.$program_name"
  #  echo "Removed $program_name from inittab"
  #  exit;
  #fi

  initexit=0
  if [[ -n "$setup_inittab" && $setup_inittab -eq "10" ]]
  then
    SYSTEMD_USED=0 
    SYSTEMD_USED=`ps -ef |grep systemd|grep -v grep|head -1|awk '{print $2}'|sed 's/ //g'`
    if [[ -n $SYSTEMD_USED && $SYSTEMD_USED -gt 0 ]]; then RESTART_TYPE="systemd"; else RESTART_TYPE="inittab"; fi 

    if [[ ! -z "$RAT_CLUSTERNODES" ]]
    then
      rm -f $HOSTLIST
      orig_localnode=$localnode
      localnode=$(echo "$RAT_CLUSTERNODES"|awk '{print $1}')
      for nodename in `echo $RAT_CLUSTERNODES`
      do
       echo $nodename>>$HOSTLIST
      done
    else
      if [[ -f "/opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP" && `uname -p 2>/dev/null` != "sparc" ]];then check_hostname_mismatch;fi
      localnode=`hostname | tr "[A-Z]" "[a-z]" |cut -d. -f1|tr -d '\r'`
    fi

    if [ ! -r "$init_dir" ] ; then
      unset root_ssh_setup_status
      /usr/bin/ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -l ${root_user} $localnode ls 2>/dev/null 1>/dev/null
      root_ssh_setup_status=$?
      if [ $root_ssh_setup_status -ne 0 ]
      then
        echo -e "\nAuto restart functionality is not configured. Use -initsetup flag to configure.\n\n";
        initexit=-1
        exit 1;		   	
      else
        $SSHELL ${root_user}@$localnode "if [ ! -e "$init_dir/init.$program_name" ] ; then  echo -e \"Auto restart functionality is not configured. Use -initsetup flag to configure.\"; else /bin/sh $init_dir/init.$program_name shutdown; rm -f $init_dir/init.$program_name;  if [ -e "${TMP_RATENV_FIL}" ]; then rm -f ${TMP_RATENV_FIL} >/dev/null 2>&1;fi; if [ -e "${RATENV_FIL}" ]; then rm -f ${RATENV_FIL} >/dev/null 2>&1;fi; echo \"Removed $program_name from ${RESTART_TYPE}\"; fi;"

        echo -e "\n"
        initexit=1	
      fi
    else
      if [ ! -e "$init_dir/init.$program_name" ] ; then
        echo -e "\nAuto restart functionality is not configured. Use -initsetup flag to configure.\n\n";
        initexit=-1
        exit 1
      fi
      $SSHELL ${root_user}@$localnode "/bin/sh $init_dir/init.$program_name shutdown; rm -f $init_dir/init.$program_name;"
      echo "Removed $program_name from ${RESTART_TYPE}"
      initexit=1	
    fi	    

    #remove ssh equivalency setup configured via initsetup
    #if [[ "$initexit" -eq "1" ]]
    #then
    remove_preinitsetup
    if [ -e "$INITDMP" ]; then rm -f $INITDMP >/dev/null 2>&1; fi;
    exit 0
    #fi
  fi

  #if [[ -n "$setup_inittab" && $setup_inittab -eq "2" ]] ; then
  #  if [ ! -e "$init_dir/init.$program_name" ] ; then
  #    echo -e "\nAuto restart functionality is not configured. Use -initsetup flag to configure.\n\n";
  #    exit
  #  fi
  #  $SSHELL root@$localnode "/bin/sh $init_dir/init.$program_name restart"
  #  exit;
  #fi
    
  if [[ -n "$setup_inittab" && $setup_inittab -eq "3" ]]
  then
    #if [ ! -e "$init_dir/init.$program_name" ] ; then
    #  echo -e "\nAuto restart facility is not setup. Use -initsetup flag to setup.\n\n";
    #  exit
    #fi
    if [ ! -r "$init_dir" ] ; then
      unset root_ssh_setup_status
      /usr/bin/ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -l ${root_user} $localnode ls 2>/dev/null 1>/dev/null
      root_ssh_setup_status=$?
      if [ $root_ssh_setup_status -ne 0 ]
      then
        echo -e "\nAuto restart funtionality is not configured. Use -initsetup flag to configure.\n\n";
        initexit=-1
        exit 1
      else
        checkstatus=0
        checkstatus=`$SSHELL ${root_user}@$localnode "if [ ! -e "$init_dir/init.$program_name" ] ; then echo '1'; fi;"`
        if [[ "$checkstatus" -eq "1" ]] ; then
          echo -e "\nAuto restart functionality is not configured. Use -initsetup flag to configure.\n\n";
          initexit=-1
          exit 1
        fi	
      fi
    else
      if [ ! -e "$init_dir/init.$program_name" ] ; then
        echo -e "\nAuto restart functionality is not configured. Use -initsetup flag to configure.\n\n";
        exit 1
      fi
    fi
  
    echo -e "\nAuto restart functionality is configured.\n\n";
    if [[ $daemon_running -eq "1" ]] ; then
      echo -e "$program_name daemon is running. PID : $dpid\n\n";
    else
      echo -e "$program_name daemon is not running.\n\n";
    fi
    exit 1;
  fi
    
  if [[ -n "$setup_inittab" && $setup_inittab -eq "1" ]] ; then
    if [[ -f "$RTEMPDIR_D/daemon.pid" ]] 
    then
      echo -e ${RED}"\n${program_name} daemon is already running. Please stop daemon and run $program_name -initsetup again.\n"${NORM}
      echo -e ${RED}"\n${program_name} is exiting..\n"${NORM}

      exit 1
    fi

    prepare_init=1
    prepare_initsetup

    if [[ -n "$setup_status" && "$setup_status" -eq "0" ]]
    then
      echo -e ${RED}"\n$usern user equivalence is not setup on $hname"${NORM}
      echo -e ${RED}"\n\n${program_name} is exiting..\n"${NORM}

      remove_preinitsetup
      if [ -e "$INITDMP" ]; then rm -f $INITDMP >/dev/null 2>&1; fi;
      exit 0
    fi

    SYSTEMD_USED=0 
    SYSTEMD_USED=`ps -ef |grep systemd|grep -v grep|head -1|awk '{print $2}'|sed 's/ //g'`
    if [[ -n $SYSTEMD_USED && $SYSTEMD_USED -gt 0 ]]; then RESTART_TYPE="systemd"; else RESTART_TYPE="inittab"; fi 

    echo -e "\nSetting up $program_name auto restart functionality using ${RESTART_TYPE}\n\n";

    #include exported varaibles
    #echo  "echo export RAT_TIMEOUT=$RAT_TIMEOUT > $RATENV_FIL" > $TMP_RATENV_FIL 
    #echo  "echo export RAT_ROOT_TIMEOUT=$RAT_ROOT_TIMEOUT >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_SQL_TIMEOUT=$RAT_SQL_TIMEOUT >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_UPLOAD_CONNECT_STRING="\"$RAT_UPLOAD_CONNECT_STRING\"">> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_UPLOAD_TABLE=$RAT_UPLOAD_TABLE >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_ZIP_UPLOAD_TABLE=$RAT_ZIP_UPLOAD_TABLE >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_PATCH_UPLOAD_TABLE=$RAT_PATCH_UPLOAD_TABLE >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_UPLOAD_USER=$RAT_UPLOAD_USER >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_UPLOAD_PASSWORD=$RAT_UPLOAD_PASSWORD >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_UPLOAD_ORACLE_HOME=$RAT_UPLOAD_ORACLE_HOME >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_CRS_HOME=$RAT_CRS_HOME >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_INV_LOC=$RAT_INV_LOC >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_ORACLE_HOME=$RAT_ORACLE_HOME >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_ASM_HOME=$RAT_ASM_HOME >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_OS=$RAT_OS >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_DB=$RAT_DB >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_DBNAMES=$RAT_DBNAMES >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_PDBNAMES=$RAT_PDBNAMES >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_DBHOMES=$RAT_DBHOMES >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_OUTPUT=$RAT_OUTPUT >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_DEBUG=$RAT_DEBUG >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_INFOPASS=$RAT_INFOPASS >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_SCOPY=$RAT_SCOPY >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_SSHEL=$RAT_SSHELL >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_LOCAL=$RAT_LOCAL >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_CELLS=$RAT_CELLS >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_ZFS_NODES=$RAT_ZFS_NODES >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_CLUSTERNODES=$RAT_CLUSTERNODES >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_IBSWITCHES=$RAT_IBSWITCHES >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_CELL_SSH_USER=$RAT_CELL_SSH_USER >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_IBSWITCH_USER=$RAT_IBSWITCH_USER >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_EXPECT_STRACE_DEBUG=$RAT_EXPECT_STRACE_DEBUG >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_EXPECT_DEBUG=$RAT_EXPECT_DEBUG >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_PDB_USER=$RAT_PDB_USER >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_BDA=$RAT_BDA >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_EXADATA_VERSION=$RAT_EXADATA_VERSION >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_GLOBAL_RUNMODE=$RAT_GLOBAL_RUNMODE >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_COMPUTE_RUNMODE=$RAT_COMPUTE_RUNMODE >> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_IBSWITCH_RUNMODE"=$RAT_IBSWITCH_RUNMODE">> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_CELL_RUNMODE=$RAT_CELL_RUNMODE>> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_SCRIPT_DEBUG=$RAT_SCRIPT_DEBUG>> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_PASSWORDCHECK_TIMEOUT=$RAT_PASSWORDCHECK_TIMEOUT>> $RATENV_FIL" >> $TMP_RATENV_FIL
    #echo  "echo export RAT_DAEMON_DEBUG="$RAT_DAEMON_DEBUG">> $RATENV_FIL" >> $TMP_RATENV_FIL

    SED_RATENV_FIL=$(echo "$RATENV_FIL"|sed s/\\//\\\\\\//g)
     
    env|grep "^RAT_"|grep -v "^RAT_UPLOAD_CONNECT_STRING"| sed 's/^/echo export /'|sed "s/$/ >>$SED_RATENV_FIL/g" > $TMP_RATENV_FIL
    echo  "echo export RAT_UPLOAD_CONNECT_STRING="\"$RAT_UPLOAD_CONNECT_STRING\"">> $RATENV_FIL" >> $TMP_RATENV_FIL

    echo  "export RATENV_FIL=$RATENV_FIL" >> $TMP_RATENV_FIL
    echo  "sed -e 's/RAT_UPLOAD_CONNECT_STRING=/RAT_UPLOAD_CONNECT_STRING=\"/g' -e 's/^.*RAT_UPLOAD_CONNECT_STRING.*$/&\"/g' $RATENV_FIL > $RATENV_FIL.new" >> $TMP_RATENV_FIL
    echo  "mv $RATENV_FIL.new $RATENV_FIL" >> $TMP_RATENV_FIL
    echo  "" >> $TMP_RATENV_FIL
    
    head -1 $TMP_RATENV_FIL |sed 's/>>/> /g' > ${TMP_RATENV_FIL}.2
    sed 1d $TMP_RATENV_FIL >> ${TMP_RATENV_FIL}.2
    mv ${TMP_RATENV_FIL}.2 ${TMP_RATENV_FIL}

    # create init.orachk
    install_loc=$(dirname $ABSTPATH)
    orachk_flags=$(echo "$argsaved" | sed 's/-initsetup//' | sed 's/-d *start//g')
    sed 's|ORACHK_HOME=edit|ORACHK_HOME='$install_loc'|' $install_loc/.cgrep/init.tmpl | sed 's/PROGRAM_NAME=edit/PROGRAM_NAME='$program_name'/' | sed 's/USER_NAME=edit/USER_NAME='$usern'/' | sed "s|ORACHK_FLAGS=edit|ORACHK_FLAGS=\"$orachk_flags\"|" | sed "s|INITTAB_STRING=edit|INITTAB_STRING=\"$inittab_string\"|" | sed 's|ORACHK_WRKDIR=edit|ORACHK_WRKDIR='$WRKDIR'|' | sed 's|TMPDIR=edit|TMPDIR='$TMPDIR'|' > $TMPDIR/$$.init.tmpl

    echo "#!/bin/sh" > $TMPDIR/$$.init.tmpl.new
    cat $TMP_RATENV_FIL $TMPDIR/$$.init.tmpl >> $TMPDIR/$$.init.tmpl.new
    mv $TMPDIR/$$.init.tmpl.new $TMPDIR/$$.init.tmpl
  
    $SSHELL ${root_user}@$localnode "cp $TMPDIR/$$.init.tmpl $init_dir/init.$program_name; chmod 744 $init_dir/init.$program_name; /bin/sh $init_dir/init.$program_name start"
    rm -f $TMPDIR/$$.init.tmpl
    rm -f $TMP_RATENV_FIL
    exit 0;
  fi

  if [[ ! -z "$phy_nodes" ]]
  then
    phy_nodes_hostname=""
    for mapping in ${hostmap[@]}
    do
      management_host=${mapping%%:*}
      client_host=${mapping#*:}

      if [ `echo "$phy_nodes"| grep -icw "$management_host"` -gt 0 ]
      then
        client_host=$(echo "$client_host"| tr "[A-Z]" "[a-z]" |cut -d. -f1)
        phy_nodes_hostname="${phy_nodes_hostname},${client_host}"
      fi	
    done
    phy_nodes_hostname=$(echo "$phy_nodes_hostname" | sed 's/,,/,/g' | sed 's/^,//g' | sed 's/,$//g');

    sed /phy_nodes/d $EAOUT > $EAOUT.new
    echo "phy_nodes=$phy_nodes_hostname" >> $EAOUT.new
    mv $EAOUT.new $EAOUT

    phy_nodes=$phy_nodes_hostname;

    echo "PHYSICAL_NODES = $phy_nodes" >> $MASTERFIL
    printf ". "
  fi
	
  if [[ -n "$is_bda_machine" && $is_bda_machine -eq "1"  ]];
  then
    if [ -z "$RAT_IBSWITCHES" ];
    then
      TMP_SL="$OUTPUTDIR/tmp_slist";
      SWITCH_CMD="echo SPINE_NAME/@bash@ | cat - /opt/oracle/bda/BdaDeploy.json | json-select; echo LEAF1_NAME/@bash@ | cat - /opt/oracle/bda/BdaDeploy.json | json-select; echo LEAF2_NAME/@bash@ | cat - /opt/oracle/bda/BdaDeploy.json | json-select";
      rm -f $swlist_file;
      touch $swlist_file;
      for hname in `cat $HOSTLIST`
      do
        swlist=""
        if [ $hname = $localnode ];
        then
          (echo SPINE_NAME/@bash@ | cat - /opt/oracle/bda/BdaDeploy.json | json-select; echo LEAF1_NAME/@bash@ | cat - /opt/oracle/bda/BdaDeploy.json | json-select; echo LEAF2_NAME/@bash@ | cat - /opt/oracle/bda/BdaDeploy.json | json-select) >> $TMP_SL
        else
          ($SSHELL $hname $SWITCH_CMD) >> $TMP_SL
        fi
      done
      cat $TMP_SL|sort|uniq > $swlist_file
    fi
  fi

  if [[ -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" ]] && [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "0" ]]; then
    for hname in `cat $HOSTLIST`
    do # get actual names
      unset noden
      if [ $hname = $localnode ]
      then
        node=`hostname | tr "[A-Z]" "[a-z]" |cut -d. -f1`
      else
        noden=`$SSHELL $hname hostname | tr "[A-Z]" "[a-z]" |cut -d. -f1`
	isDNSconfigured "$noden" "$usern"
	if [[ $DNSconfigured -eq 0 ]]; then noden=$hname; fi
      fi

      node_pingable $noden
      if [[ $pingable -eq "0" ]] ; then
        noden="$hname"
      else # Change association
	if [[ -z $noden ]]; then noden=$node; fi

        case "$hname" in 
          "$ea_db_node") ea_db_node=$noden;;
          "$ea_ec1_node") ea_ec1_node=$noden;;
          "$ea_ovmm_node") ea_ovmm_node=$noden;;
          "$ea_pc1_node") ea_pc1_node=$noden;;
          "$ea_pc2_node") ea_pc2_node=$noden;;
        esac
      fi
      echo "$noden" >> $HOSTLIST.new
    done
    mv -f $HOSTLIST.new $HOSTLIST
  fi

  #Following code is check that other instance of tool is not running in cluster
  for hname in `cat $HOSTLIST`
  do
    if [ $hname = $localnode ]
    then
      if [ -e $LOCKFIL ]
      then
        lockfile_pid_status=$(ps -ef |grep $(cat $LOCKFIL)|grep -v grep|wc -l) 
        if [[ -n "$lockfile_pid_status" && $lockfile_pid_status -gt 0 ]]
        then
	  if [[ $EM_PROBE_MODE -eq 1 ]]
	  then
	    EMSG="Another instance of $program_name is running on $hname. Please allow it finish before initiating probe mode."
	    update_probe_xml "ERROR" "ONEOFF_RUN" "$EMSG"
	  fi
          echo -e "${RED}Another instance of $program_name is running on $hname. please allow it finish before you run it.\n${NORM}"
          delete_lock_file=1
          exit 1
        else
          echo $$>$LOCKFIL
        fi
      fi
    else
      remote_lock_file=$($SSHELL $hname "$bash_scr -c \"if [ -e $LOCKFIL ]; then cat $LOCKFIL|wc -l;fi\"")
      remote_lockfile_pid=$($SSHELL $hname "$bash_scr -c \"if [ -e $LOCKFIL ]; then cat $LOCKFIL|head -1;fi\"")
      remote_lockfile_pid_status=$($SSHELL $hname "$bash_scr -c \"if [ -e $LOCKFIL ]; then ps -ef |grep $remote_lockfile_pid|grep -v grep|wc -l;fi\"")
      if [[ -n "$remote_lock_file" && $remote_lock_file -eq 1 && -n "$remote_lockfile_pid_status" && $remote_lockfile_pid_status -gt 0 ]]
      then
	if [[ $EM_PROBE_MODE -eq 1 ]]
	then
	  EMSG="Another instance of $program_name is running on $hname. Please allow it finish before initiating probe mode."
	  update_probe_xml "ERROR" "ONEOFF_RUN" "$EMSG"
	fi
        echo -e "${RED}Another instance of $program_name is running on $hname.please allow it finish on $hname before you run it on $localnode.\n${NORM}"
        delete_lock_file=1
        exit 1
      elif [[ -n "$remote_lock_file" && $remote_lock_file -eq 1 ]] 
      then
        $SSHELL $hname "touch $LOCKFIL"
        if [ `echo $?` -ne 0 ]; then
	  if [[ $EM_PROBE_MODE -eq 1 ]]
	  then
	    EMSG="Temporary files/directories of previous run exist on $hname at $RTEMPDIR. Delete them and re-run ${program_name}."
	    update_probe_xml "ERROR" "GENERIC" "$EMSG"
	  fi
          echo -e ${RED}"\nTemporary files/directories of previous run exist on $hname at $RTEMPDIR. Delete them and re-run ${program_name}"${NORM}.
          echo -e "\n${program_name} is exiting..\n"
          exit 0
        else
          $SSHELL $hname "echo $$>$LOCKFIL"
        fi
      fi
    fi
  done

  if [[ -n "$localonly" && $localonly -eq 1 ]];then echo "localonly=$localonly">$LOCKFIL;fi
  echo $$>$LOCKFIL
  ####

  echo "PRINT_SCORE_IN_REPORT = $print_score_in_report">>$MASTERFIL
  echo "CURRENT_USER = $usern">>$MASTERFIL

  create_rtemp_dir # gadiga Creates /tmp/.program in all nodes to store temp files

  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then 
    root_user_allowed=1
    oumask=$(umask)
    umask 0000
    chmod -R 777 $OUTPUTDIR
    chmod -R 777 $INPUTDIR
    if [ -e $ERRFIL ]; then rm -f $ERRFIL; fi; touch $ERRFIL; chmod 777 $ERRFIL;
  fi

  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "0" ]] && [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq "0" ]] && [[ -n "$is_bda_machine" && $is_bda_machine -eq "0"  && $is_exadata_dom0_machine -eq 0  && $is_ssc_globalzone_machine -eq 0 ]]
  then #skip space check, stack check for exalogic 
    olsnodes_ssh_disabled=0
    #if [[ ! -z "$RAT_CLUSTERNODES" && `echo $RAT_CLUSTERNODES|grep -icw $localnode` -lt 1 ]]
    if [[ ! -z "$RAT_CLUSTERNODES" && `echo $RAT_CLUSTERNODES|grep -icw "$orig_localnode"` -lt 1 ]]
    then
      olsnodes_ssh_disabled=1
      echo "OLSNODES_SSH_DISABLED = 1" >>$MASTERFIL
      if [ ${crs_up} -eq 1 ];then 
 	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then	
	  OLD_OH=$ORACLE_HOME
	  ORACLE_HOME=$CRS
	  get_dbOwner
	  ORACLE_HOME=$OLD_OH
	  olsnodes_ssh_disabled_nodes=$(su $dbOwner -c "$CRS/bin/olsnodes");
	  cd $OLD_DIR
	  unset OLD_DIR
	else
	  olsnodes_ssh_disabled_nodes=$($CRS/bin/olsnodes);
	fi
      fi  

      old_localnode=$(cat $HOSTLIST| head -1)    
      #RAT_COMPUTE_RUNMODE=serial;
    fi
    if [[ $olsnodes_ssh_disabled -eq 1 ]]
    then
      for hname in `cat $HOSTLIST`
      do
        #if [ $hname != $localnode ];
        if [ $hname != "$orig_localnode" ];
        then
          echo $hname >> $HOSTLIST.new
        fi
      done
      rm -rf $HOSTLIST
      mv $HOSTLIST.new $HOSTLIST

      for mapping in ${hostmap[@]}
      do
        management_host=${mapping%%:*}
        client_host=${mapping#*:}

        echo "MAP:$management_host = $client_host" >> $MASTERFIL
      done
      localnode=$(cat $HOSTLIST| head -1)
    fi

    if [ $single_instance_run -eq "0" ] ; then
      is_crs_installed
      is_asm_installed_crs
      #is_rdbms_installed
      is_rdbms_installed_crs
    fi

    if [[ $single_instance_run -eq "1" ]] ; then
      search_invntr_platform
      is_rdbms_installed_si
      if [ $oracle_restart -eq "1" ] ; then
        is_asm_installed
      fi
      is_rdbms_installed_crs
    else
      echo SINGLE_INSTANCE_RUN = 0 >> $MASTERFIL
    fi

    #echo "PRINT_SCORE_IN_REPORT = $print_score_in_report">>$MASTERFIL
    #echo "CURRENT_USER = $usern">>$MASTERFIL
    echo "TARGET_VERSION = $targetversion">>$MASTERFIL
    offline_counter=0

    for node in `cat $HOSTLIST`
    do
      crs_installed[$offline_counter]=`grep -i "$node.CRS_INSTALLED" $MASTERFIL |awk '{print $3}'`
      rdbms_installed[$offline_counter]=`grep -i "$node.RDBMS_INSTALLED" $MASTERFIL |awk '{print $3}'`
      asm_installed[$offline_counter]=`grep -i "$node.ASM_INSTALLED" $MASTERFIL |awk '{print $3}'`
      stack_crs_up[$offline_counter]=`grep -i "$node.CRS_STATUS" $MASTERFIL|awk '{print $3}'`
      stack_asm_up[$offline_counter]=`grep -i "$node.ASM_STATUS" $MASTERFIL|awk '{print $3}'`
      stack_asm_sid[$offline_counter]=`grep -i "$node.ASM_INSTANCE" $MASTERFIL|awk '{print $3}'`
      stack_asm_home[$offline_counter]=`grep -i "$node.ASM_HOME" $MASTERFIL|awk '{print $3}'`
      stack_acfs_up[$offline_counter]=`grep -i "$node.ACFS_STATUS" $MASTERFIL|awk '{print $3}'`
      stack_dbinst_up[$offline_counter]=`grep -i "$node.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
      stack_dbinst_name[$offline_counter]=`grep -i "$node.INSTANCE_NAME" $MASTERFIL|awk '{print $3}'`
      offline_counter=`expr $offline_counter + 1`  
    done
    offline_counter=0

    if [[ ${crs_installed[$stack_counter]} -eq 0 || ${rdbms_installed[$stack_counter]} -eq 0 ]] && [[ $TYP = "-a" || $TYP = "-p" ]]
    then
      if [[ ${crs_installed[$stack_counter]} -eq 0 && $single_instance_run -eq "0" ]] ; then
        echo -e $RED"Since no CRS and RDBMS binaries could be found, the script will check only `uname` best practices. Oracle patch checking will also be skipped. $NORM \n"
        TYP="-b"
        old_typ=$TYP
       fi
    fi

    #fi # this if was a kind of problem and because of this, complete offline run was breaking
    #check ORACLE_HOME, ORACLE_SID and ORA_CRS_HOME settings.
    if [[ -z "$CRS" && -n "$local_invntr_CH" ]]
    then
      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
	cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n25_nlsid">
        CRS binaries found at {1}
      </text>
      <tokens>
        <token index="1">$local_invntr_CH</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n17_nlsid">
      Do you want to set CRS_HOME to {1}
    </text>
    <tokens>
      <token index="1">$local_invntr_CH</token>
    </tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o2q1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o2q1" questionType="TEXT" outcome="No">
    <text nls_id="orhc_exadata_n24_nlsid">
      Enter value for ORA_CRS_HOME environment variable
    </text>
  </question>
</group>
EOF
	PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

        echo -e "CRS binaries found at $local_invntr_CH. Do you want to set CRS_HOME to "$local_invntr_CH"?[y/n][y]"
        setCRSHome="Yes"
      elif [[ $EM_XMLD_MODE -eq 1 ]]
      then
        echo -e "CRS binaries found at $local_invntr_CH. Do you want to set CRS_HOME to "$local_invntr_CH"?[y/n][y]"

	read_probe_xml "Do you want to set CRS_HOME to"
	setCRSHome=$xml_rvalue
      else
        exec 3<&2; exec 2<&0
        $READ -p "CRS binaries found at $local_invntr_CH. Do you want to set CRS_HOME to "$local_invntr_CH"?[y/n][y]" setCRSHome
	read_code=`echo $?`;
        exec 2<&3
	process_prompt "$read_code" "setCRSHome" "y"
      fi
      case $setCRSHome in
        y|Y|yes|YES|Yes)
          export CRS=$local_invntr_CH
          ;;
        n|N|No|NO)
          if [[ $EM_XMLD_MODE -eq 1 ]]
          then
            echo -e  "Enter value for ORA_CRS_HOME environment variable:  "

	    read_probe_xml "Enter value for ORA_CRS_HOME environment variable"
	    cHome=$xml_rvalue
	  else
            echo ""
            exec 3<&2; exec 2<&0
            $READ -p "Enter value for ORA_CRS_HOME environment variable:  " cHome
            exec 2<&3
	  fi
          export CRS=$cHome
          ;;
        *)
          export CRS=$local_invntr_CH
          ;;
      esac
    fi

    if [[ $somedb_up -eq 1 && -z $ORACLE_HOME ]] || [[ ${rdbms_installed[$stack_counter]} -eq 1 &&  -z "$ORACLE_HOME" ]]
    then 
      echo ""
      if [ -n "$RAT_ORACLE_HOME" ] 
      then
	if [[ $EM_PROBE_MODE -eq 1 ]]
        then
          cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n81_nlsid">
        RDBMS binaries found at {1} and ORACLE_HOME not set.
      </text>
      <tokens>
        <token index="1">$RAT_ORACLE_HOME</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n20_nlsid">
      Do you want to set ORACLE_HOME to "{1}" 
    </text>
    <tokens>
      <token index="1">$RAT_ORACLE_HOME</token>
    </tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o2q1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o2q1" questionType="TEXT" outcome="No">
    <text nls_id="orhc_exadata_n21_nlsid">
      Enter value for ORACLE_HOME environment variable
    </text>
  </question>
</group>
EOF
	  PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

          echo -e "RDBMS binaries found at $RAT_ORACLE_HOME and ORACLE_HOME not set. Do you want to set ORACLE_HOME to "$RAT_ORACLE_HOME"?[y/n][y]"
	  setOHHome="Yes"
        elif [[ $EM_XMLD_MODE -eq 1 ]]
        then
          echo -e "RDBMS binaries found at $RAT_ORACLE_HOME and ORACLE_HOME not set. Do you want to set ORACLE_HOME to "$RAT_ORACLE_HOME"?[y/n][y]"

	  read_probe_xml "Do you want to set ORACLE_HOME to"
	  setOHHome=$xml_rvalue
	else
          exec 3<&2; exec 2<&0
          $READ -p "RDBMS binaries found at $RAT_ORACLE_HOME and ORACLE_HOME not set. Do you want to set ORACLE_HOME to "$RAT_ORACLE_HOME"?[y/n][y]" setOHHome
	  read_code=`echo $?`;
          exec 2<&3
	  process_prompt "$read_code" "setOHHome" "y"
	fi
      else
	if [[ $EM_PROBE_MODE -eq 1 ]]
	then
          cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n45_nlsid">
        RDBMS binaries found at {1} and ORACLE_HOME not set
      </text>
      <tokens>
        <token index="1">$local_invntr_OH</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n20_nlsid">
      Do you want to set ORACLE_HOME to "{1}"
    </text>
    <tokens>
      <token index="1">$local_invntr_OH</token>
    </tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o2q1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o2q1" questionType="TEXT" outcome="No">
    <text nls_id="orhc_exadata_n21_nlsid">
      Enter value for ORACLE_HOME environment variable
    </text>
  </question>
</group>
EOF
 	  PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

          echo -e "RDBMS binaries found at $local_invntr_OH and ORACLE_HOME not set. Do you want to set ORACLE_HOME to "$local_invntr_OH"?[y/n][y]"
	  setOHHome="Yes"
        elif [[ $EM_XMLD_MODE -eq 1 ]]
        then
          echo -e "RDBMS binaries found at $local_invntr_OH and ORACLE_HOME not set. Do you want to set ORACLE_HOME to "$local_invntr_OH"?[y/n][y]"

	  read_probe_xml "Do you want to set ORACLE_HOME to"
	  setOHHome=$xml_rvalue
	else
          exec 3<&2; exec 2<&0
          $READ -p "RDBMS binaries found at $local_invntr_OH and ORACLE_HOME not set. Do you want to set ORACLE_HOME to "$local_invntr_OH"?[y/n][y]" setOHHome
	  read_code=`echo $?`;
          exec 2<&3
	  process_prompt "$read_code" "setOHHome" "y"
	fi
      fi
      case $setOHHome in
        y|Y|yes|YES|Yes) 
          if [ -n "$RAT_ORACLE_HOME" ]; then export ORACLE_HOME=$RAT_ORACLE_HOME; else export ORACLE_HOME=$local_invntr_OH;fi;
          ;;
        n|N|No|NO)
          if [[ $EM_XMLD_MODE -eq 1 ]]
          then
            echo -e "Enter value for ORACLE_HOME environment variable:  "

	    read_probe_xml "Enter value for ORACLE_HOME environment variable"
	    oHome=$xml_rvalue
	  else
            echo ""
            exec 3<&2; exec 2<&0
            $READ -p "Enter value for ORACLE_HOME environment variable:  " oHome
            exec 2<&3
	  fi
          export ORACLE_HOME=$oHome
          ;;
        *)
          if [ -n "$RAT_ORACLE_HOME" ]; then export ORACLE_HOME=$RAT_ORACLE_HOME; else export ORACLE_HOME=$local_invntr_OH;fi;
          ;;
      esac          
    fi
    #$READ -p "DBVERSION=$DBVERSION"
    #$READ -p "Check the files now"
    #is_db_up 

    #following 19 lines of code were mode from up to here to accomdate DBVERSION variable
    RDBMS_INVENTORY=$ORACLE_HOME/inventory/ContentsXML/comps.xml
    CRS_INVENTORY=$CRS/inventory/ContentsXML/comps.xml
    g112=`echo  $DBVERSION | grep -c 11.2`
    #$READ -p "g112=$g112 and DBVERSION=$DBVERSION"
    #remove this after this run
    #g112=1 
    #$READ -p "g112=$g112 and DBVERION=$DBVERSION"
    if [[ ${crs_up} = 1 && $check_crs_stat -eq 0 ]] 
    then
      if [[ -n "$crs112" && $crs112 -ge 1 ]]
      then
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  OLD_OH=$ORACLE_HOME
	  ORACLE_HOME=$CRS
	  get_dbOwner
	  ORACLE_HOME=$OLD_OH
          ASM_HOME=`su $dbOwner -c "$CRS/bin/srvctl$BAT config asm |head -1|cut -d: -f2"`
	  cd $OLD_DIR
	  unset OLD_DIR
	else
          ASM_HOME=`$CRS/bin/srvctl$BAT config asm |head -1|cut -d: -f2`
	fi
        #To trim the blank spaces before path
        ASM_HOME=`echo $ASM_HOME | sed 's/^ *\(.*\) *$/\1/'`
        ASM_HOME="" 
        unset ASM_HOME
      else
	if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	  OLD_OH=$ORACLE_HOME
	  ORACLE_HOME=$CRS
	  get_dbOwner
	  ORACLE_HOME=$OLD_OH
          ASM_HOME=$(su $dbOwner -c "$CRS/bin/srvctl$BAT config asm | grep "ASM home:"|sed 's/ //g'|sed 's/ASMhome://g'")
	  cd $OLD_DIR
	  unset OLD_DIR
	else
          ASM_HOME=$($CRS/bin/srvctl$BAT config asm | grep "ASM home:"|sed 's/ //g'|sed 's/ASMhome://g')
	fi
        ASM_INVENTORY=$ASM_HOME/inventory/ContentsXML/comps.xml
      fi
      echo "ASM_HOME=$ASM_HOME">>$LOGFIL 
    fi

    #if [[ $somedb_up -eq 1 && -z "$ORACLE_SID"  && ${rdbms_installed[$stack_counter]} -eq 1 && -z "$RAT_DBNAME" ]]
    if [[ ${rdbms_installed[$stack_counter]} -eq 1 && -z "$RAT_DBNAMES"   ]]
    then
      if [[ $db_counter -le 1 && -n "$db_name_to_check"  && $NOQUESTION -eq 0 && `cat $running_db_list|wc -l` -gt 1 ]] 
      then
	if [[ $EM_PROBE_MODE -eq 1 ]]
	then
          cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="BOOLEAN" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n46_nlsid">
        $program_name found database {1} registered in OCR. 
      </text>
      <tokens>
        <token index="1">$db_name_to_check</token>
      </tokens>
      </tokenizedtext>
    </context>
    <text nls_id="orhc_exadata_n47_nlsid">
      Is this the database to check best practices for
    </text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
</group>
EOF
	  PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);

          echo -e "$program_name found database $db_name_to_check registered in OCR. Is this the database to check best practices for?[y/n][y]"
	  ask_db_name_to_check="Yes"
        elif [[ $EM_XMLD_MODE -eq 1 ]]
        then
          echo -e "$program_name found database $db_name_to_check registered in OCR. Is this the database to check best practices for?[y/n][y]"

	  read_probe_xml "Is this the database to check best practices for"
	  ask_db_name_to_check=$xml_rvalue
	else
          echo ""
          exec 3<&2; exec 2<&0
          $READ -p "$program_name found database $db_name_to_check registered in OCR. Is this the database to check best practices for?[y/n][y]" ask_db_name_to_check
	  read_code=`echo $?`;
          exec 2<&3
	  process_prompt "$read_code" "ask_db_name_to_check" "y"
	fi
        #ports_find_sid
        case $ask_db_name_to_check in
           y|Y|yes|YES|Yes)
             #ports_find_sid
             if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
               OLD_OH=$ORACLE_HOME
               ORACLE_HOME=$CRS
               get_dbOwner
               ORACLE_HOME=$OLD_OH
	       oSID=$(su $dbOwner -c "$CRS/bin/srvctl$BAT status database -d $db_name_to_check|grep $localnode|awk '{print \$2}'")
               cd $OLD_DIR
               unset OLD_DIR
	     else
               oSID=$($CRS/bin/srvctl$BAT status database -d $db_name_to_check|grep $localnode|awk '{print $2}')
	     fi
             export ORACLE_SID=$oSID
             ;;
           n|N|No|NO)
             echo ""
             echo -e "${program_name} could not determine database to check best practices from OCR. So set environment variable RAT_DBNAMES to name of the database to analyse and re-run."
             exit 1;
             ;;
           *)
             if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
               OLD_OH=$ORACLE_HOME
               ORACLE_HOME=$CRS
               get_dbOwner
               ORACLE_HOME=$OLD_OH
	       oSID=$(su $dbOwner -c "$CRS/bin/srvctl$BAT status database -d $db_name_to_check|grep $localnode|awk '{print \$2}'")
               cd $OLD_DIR
               unset OLD_DIR
	     else
               oSID=$($CRS/bin/srvctl$BAT status database -d $db_name_to_check|grep $localnode|awk '{print $2}')
	     fi
             export ORACLE_SID=$oSID
             #ports_find_sid
             #export ORACLE_SID=$oSID
             ;;
        esac
      else
        echo "Database pickedup for checking = $db_name_to_check">>$LOGFIL
        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
          OLD_OH=$ORACLE_HOME
          ORACLE_HOME=$CRS
          get_dbOwner
          ORACLE_HOME=$OLD_OH
          oSID=$(su $dbOwner -c "$CRS/bin/srvctl$BAT status database -d $db_name_to_check 2>/dev/null|grep $localnode|awk '{print \$2}'")
          cd $OLD_DIR
          unset OLD_DIR
	else
          oSID=$($CRS/bin/srvctl$BAT status database -d $db_name_to_check 2>/dev/null|grep $localnode|awk '{print $2}')
	fi
        export ORACLE_SID=$oSID
        #ports_find_sid
        #export ORACLE_SID=$oSID
      fi
    else
      #db_name_to_check=$RAT_DBNAME
      #ports_find_sid
      #ORACLE_SID=$oSID
      #if [ -n "$CRS" ]; then oSID=$($CRS/bin/srvctl status database -d $db_name_to_check|grep $localnode|awk '{print $2}');fi;
      #export ORACLE_SID=$oSID
      #multiple_db=0
      echo "Database pickedup for checking = $db_name_to_check ORACLE_HOME=$ORACLE_HOME and ORACLE_SID=$ORACLE_SID">>$LOGFIL
    fi

    #$READ -p "ORACLE_HOME=$ORACLports_find_sidE_HOME and ORACLE_SID=$ORACLE_SID db_name_to_check=$db_name_to_check"
    #ports_find_sid
    #is_db_up
    #if [ $db_up -eq 1 ];  then checksysdba; fi

    if [[ `grep -ic "CRS_HOME =" $MASTERFIL` -eq "0" ]]; then echo "CRS_HOME = $CRS" >>$MASTERFIL; fi

    func_stack_status

    if [[ -n "$crs112" && $crs112 -gt 0 ]] || [[ -n "$crs121" && $crs121 -gt 0 ]] || [[ -n "$crs122" && $crs122 -gt 0 ]]; then gi112=1;else gi112=0;fi

    if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then gi112=0; fi

    if [[ `uname -s` = "AIX" || `uname -s` = "HP-UX" ]]
    then
      func_stack_print_aix
    else
      func_stack_print
    fi

    if [[ $set_db_par_limit -eq 1 && -z $RAT_DB_PAR_LIMIT && $OFFLINE -eq 0 ]]
    then
      export RAT_DB_PAR_LIMIT=${#mb_db_names[@]}
    fi

    if [[ $OFFLINE -eq 0 && $upgrade_mode -gt 0 ]]; then func_print_homes; fi
    if [ $op_mode -eq 1 ] 
    then 
      if [ -z "$RAT_DB" ]
      then
        func_what_db
        if [[ -z  "$what_db" || -z "$DBVERSION" ]] 
        then 
	  if [[ $EM_PROBE_MODE -eq 1 ]]
          then
	    EMSG="${program_name} could not find database version from enviornment so set RAT_DB environment varaiable to database version like 11.2.0.1.0 and re-run it."
	    update_probe_xml "ERROR" "GENERIC" "$EMSG"
          fi
          echo -e "$RED ${program_name} could not find database version from enviornment so set RAT_DB environment varaiable to database version like 11.2.0.1.0 and re-run it.$NORM"
          exit 1
        fi
      else
        DBVERSION=$RAT_DB
        what_db=$(echo $RAT_DB|sed 's/\.//g')
      fi
      func_create_small_files
    fi

    #if [ "$usern" != "root" ]; then write_asm_version_master;else echo "Not calling write_asm_version_master for root user">>$LOGFIL;fi
    write_asm_version_master

    copy_utl_script_to_tmp
    
    #generate an environment file and copy file to all hosts in cluster
    echo "#!$bash_scr">>$ORCLENVFIL
    #echo "$bash_source">>$ORCLENVFIL
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
      cat >> $ORCLENVFIL << EOF
PROFILE="\$HOME/.profile"
case `/bin/uname` in
  Linux)  PROFILE="\$HOME/.bash_profile"  ;;
  CYGWIN_NT-[0-9].[0-9]) PROFILE="\$HOME/.bash_profile" ;;
esac
if [ -e "\$PROFILE" ]; then . \$PROFILE>/dev/null 2>&1;fi
EOF
    else
      echo "if [ -e $PROFILE ]; then . $PROFILE>/dev/null 2>&1;fi">>$ORCLENVFIL
    fi
    echo "export ORACLE_HOME=$ORACLE_HOME">>$ORCLENVFIL
    echo "export ORACLE_SID=$ORACLE_SID">>$ORCLENVFIL
    echo "export CRS_HOME=$CRS">>$ORCLENVFIL
    echo "export OUTPUTDIR=$OUTPUTDIR">>$ORCLENVFIL 
    get_winpath "TMPDIR"
    get_winpath "RTEMPDIR"
    echo "export TMPDIR=$TMPDIR">>$ORCLENVFIL 
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then echo "export TMP_OUTPUT=$TMP_OUTPUT">>$ORCLENVFIL; fi
    echo "export RTEMPDIR=$RTEMPDIR">>$ORCLENVFIL 
    restore_winpath "TMPDIR"
    restore_winpath "RTEMPDIR"
     
    #echo "export ORA_CRS_HOME=$CRS">>$ORCLENVFIL
    if [ -n "$TNS_ADMIN" ]; then echo "export TNS_ADMIN=$TNS_ADMIN">>$ORCLENVFIL;fi;
    echo "if [[ \"\${LD_LIBRARY_PATH:-unset}\"  = \"unset\" ]] ; then LD_LIBRARY_PATH=\"\"; fi">>$ORCLENVFIL
    echo "LD_LIBRARY_PATH=\${LD_LIBRARY_PATH}:$ORACLE_HOME/lib" >>$ORCLENVFIL
    echo "export LD_LIBRARY_PATH=\$LD_LIBRARY_PATH:$ORACLE_HOME/lib:$CRS/lib">>$ORCLENVFIL
  elif [[ $is_exadata_dom0_machine -eq 1 || $is_ssc_globalzone_machine -eq 1 ]]
  then
      is_this_db_machine $localnode
      check_maa_scorecard
      check_hacheck
      func_init_arrays
      add_maa_scorecard
      add_hacheck
      #write_db_machine_info_to_envfile $localnode
      echo "export OUTPUTDIR=$OUTPUTDIR">>$ORCLENVFIL
      echo "export TMPDIR=$TMPDIR">>$ORCLENVFIL
      func_create_small_files
      copy_utl_script_to_tmp
      echo "export OUTPUTDIR=$OUTPUTDIR">>$ORCLENVFIL
      echo "export TMPDIR=$TMPDIR">>$ORCLENVFIL
      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then echo "export TMP_OUTPUT=$TMP_OUTPUT">>$ORCLENVFIL; fi  
  else
    func_init_arrays
    #func_check_space
    #func_check_another_instance
    # create_rtemp_dir # gadiga Creates /tmp/.program in all nodes to store temp files
    echo "export OUTPUTDIR=$OUTPUTDIR">>$ORCLENVFIL 
    echo "export TMPDIR=$TMPDIR">>$ORCLENVFIL 
    func_create_small_files
    copy_utl_script_to_tmp 
    echo "export OUTPUTDIR=$OUTPUTDIR">>$ORCLENVFIL 
    echo "export TMPDIR=$TMPDIR">>$ORCLENVFIL 
    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then echo "export TMP_OUTPUT=$TMP_OUTPUT">>$ORCLENVFIL; fi
  fi #is_exalogic_machine

  #Code to discover Oracle Golden Gate Homes and Versions
  OGGHOMESVERSIONFIL=$OUTPUTDIR/ogg_homes_version.out
  DISCOVEROGGHOMES=$RTEMPDIR/ggdiscovery.sh
  if [ -e $SCRIPTPATH/.cgrep/ggdiscovery.sh ]; then cp -r $SCRIPTPATH/.cgrep/ggdiscovery.sh $RTEMPDIR >/dev/null 2>&1;fi
  if [ "$bash_scr" != "/bin/env bash" ] ; then
    chmod +w $RTEMPDIR/ggdiscovery.sh
    cp -f $RTEMPDIR/ggdiscovery.sh $RTEMPDIR/ggdiscovery.sh.org
    sed 's%/bin/env bash%'$bash_scr'%' $RTEMPDIR/ggdiscovery.sh.org > $RTEMPDIR/ggdiscovery.sh
    rm -f $RTEMPDIR/ggdiscovery.sh.org
  fi
  echo "if [[ \"\${LD_LIBRARY_PATH:-unset}\"  = \"unset\" ]] ; then LD_LIBRARY_PATH=\"\"; fi">>$DISCOVEROGGHOMES
  echo "LD_LIBRARY_PATH=\${LD_LIBRARY_PATH}:$ORACLE_HOME/lib" >>$DISCOVEROGGHOMES
  echo "export LD_LIBRARY_PATH=\$LD_LIBRARY_PATH:$ORACLE_HOME/lib:$CRS/lib">>$DISCOVEROGGHOMES
  if [ -n "$RAT_OGG_HOMES" ]; then echo "export RAT_OGG_HOMES=\"$RAT_OGG_HOMES\"" >>$DISCOVEROGGHOMES;fi
  echo "findogghome4">>$DISCOVEROGGHOMES

  for ogg_hosts in `cat $HOSTLIST`
  do
    if [ "$ogg_hosts" = "$localnode"  ]
    then
      chmod 744 $DISCOVEROGGHOMES >/dev/null 2>&1
      $bash_scr -c " $DISCOVEROGGHOMES >$OUTPUTDIR/ogg_homes_version_$ogg_hosts.out"
      #if [ -e $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out ]; then cat $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out|grep -w RAT_OGG_HOMES >>$OGGHOMESVERSIONFIL;fi
      if [ -e $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out ]; then grep -w RAT_OGG_HOMES $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out >>$OGGHOMESVERSIONFIL;fi
      if [ `grep -wic prompt $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out` -ge 1 ]
      then
        echo -e "${program_name} did not find GoldenGate homes for all running manager processes on $ogg_hosts"

        if [[ $EM_PROBE_MODE -eq 1 ]]
	then
          cat >> ${PROBE_XML}.tmp << EOF
<group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="TEXT" defaultId="" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n48_nlsid">
        ${program_name} did not find GoldenGate homes for all running manager processes on {1}
      </text>
      <tokens>
        <token index="1">$ogg_hosts</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n49_nlsid">
      Enter GoldenGate Homes installed on {1} separted by comman like /u01/ogg_home1, /u01/ogg_home2 etc
    </text>
    <tokens>
      <token index="1">$ogg_hosts</token>
    </tokens>
    </tokenizedtext>
  </question>
</group>
EOF
          echo -e "Enter GoldenGate Homes installed on $ogg_hosts separted by comman like /u01/ogg_home1, /u01/ogg_home2 etc"

 	  PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
        elif [[ $EM_XMLD_MODE -eq 1 ]]
        then
          echo -e "Enter GoldenGate Homes installed on $ogg_hosts separted by comman like /u01/ogg_home1, /u01/ogg_home2 etc"

	  read_probe_xml "${program_name} did not find GoldenGate homes for all running manager processes on {1}"
	  RAT_OGG_HOMES=$xml_rvalue
	else
          exec 3<&2; exec 2<&0
          $READ -p "Enter GoldenGate Homes installed on $ogg_hosts separted by comman like /u01/ogg_home1, /u01/ogg_home2 etc" RAT_OGG_HOMES
          exec 2<&3
	fi
        echo "export RAT_OGG_HOMES=$RAT_OGG_HOMES" >>$DISCOVEROGGHOMES
        $bash_scr -c "$DISCOVEROGGHOMES >$OUTPUTDIR/ogg_homes_version_$ogg_hosts.out"
        #if [ -e $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out ]; then cat $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out|grep -w RAT_OGG_HOMES >>$OGGHOMESVERSIONFIL;fi
        if [ -e $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out ]; then grep -w RAT_OGG_HOMES $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out >>$OGGHOMESVERSIONFIL;fi
      fi
    else
      $SCOPY $DISCOVEROGGHOMES $ogg_hosts:$RTEMPDIR >/dev/null 2>&1
      $SSHELL $ogg_hosts "$bash_scr -c \"chmod 744 $DISCOVEROGGHOMES >/dev/null 2>&1\""
      $SSHELL $ogg_hosts "$bash_scr -c \"$DISCOVEROGGHOMES >$RTEMPDIR/ogg_homes_version_$ogg_hosts.out\""
      $SCOPY $ogg_hosts:$RTEMPDIR/ogg_homes_version_$ogg_hosts.out $OUTPUTDIR >/dev/null 2>&1
      #if [ -e $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out ]; then cat $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out|grep -w RAT_OGG_HOMES >>$OGGHOMESVERSIONFIL;fi
      if [ -e $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out ]; then grep -w RAT_OGG_HOMES $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out >>$OGGHOMESVERSIONFIL;fi
      if [[ -e $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out && `grep -wic prompt $OUTPUTDIR/ogg_homes_version_$ogg_hosts.out` -ge 1 ]]
      then
        echo -e "${program_name} did not find GoldenGate homes for all running manager processes on $ogg_hosts"

        if [[ $EM_PROBE_MODE -eq 1 ]]
	then
          cat >> ${PROBE_XML}.tmp << EOF
<group id="${GID_EC}" groupHeader="${GID_EC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="TEXT"  defaultId="" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <tokenizedtext>
      <text nls_id="orhc_exadata_n48_nlsid">
        ${program_name} did not find GoldenGate homes for all running manager processes on {1}
      </text>
      <tokens>
        <token index="1">$ogg_hosts</token>
      </tokens>
      </tokenizedtext>
    </context>
    <tokenizedtext>
    <text nls_id="orhc_exadata_n49_nlsid">
      Enter GoldenGate Homes installed on {1} separted by comman like /u01/ogg_home1, /u01/ogg_home2 etc
    </text>
    <tokens>
      <token index="1">$ogg_hosts</token>
    </tokens>
    </tokenizedtext>
  </question>
</group>
EOF
          echo -e "Enter GoldenGate Homes installed on $ogg_hosts separted by comman like /u01/ogg_home1, /u01/ogg_home2 etc"

 	  PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
        elif [[ $EM_XMLD_MODE -eq 1 ]]
        then
          echo -e "Enter GoldenGate Homes installed on $ogg_hosts separted by comman like /u01/ogg_home1, /u01/ogg_home2 etc"

	  read_probe_xml "${program_name} did not find GoldenGate homes for all running manager processes on {1}"
	  RAT_OGG_HOMES=$xml_rvalue
	else
          exec 3<&2; exec 2<&0
          $READ -p "Enter GoldenGate Homes installed on $ogg_hosts separted by comman like /u01/ogg_home1, /u01/ogg_home2 etc" RAT_OGG_HOMES
          exec 2<&3
	fi
        echo "export RAT_OGG_HOMES=$RAT_OGG_HOMES" >>$DISCOVEROGGHOMES
        $SCOPY $DISCOVEROGGHOMES $ogg_hosts:$RTEMPDIR >/dev/null 2>&1
        $SSHELL $ogg_hosts "chmod 744 $DISCOVEROGGHOMES >/dev/null 2>&1"
        $SSHELL $ogg_hosts "$bash_scr -c \"$DISCOVEROGGHOMES >$RTEMPDIR/ogg_homes_version_$ogg_hosts.out\""
        $SCOPY $ogg_hosts:$RTEMPDIR/ogg_homes_version_$ogg_hosts.out $OUTPUTDIR >/dev/null 2>&1
      fi
    fi
  done
  #Code to discover Oracle Golden Gate Homes and Versions ends here

  if [[ $OFFLINE -eq 0 && `echo $components|grep -icw dbm` -ge 1 && $db_machine_compute -eq 0  && $is_exalogic_machine -eq 0 ]] && [ $components != "RDBMS" ]
  then
    echo -e "\nDBM module not applicable on this cluster. ${program_name} will run without any module specific\n"|tee -a $LOGFIL
    components=NONE
    it_is_rac=1  
    if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]] ; then 
      exec 3<&2; 
      exec 2<&0; 
      $READ -p "Press any key to continue ..."; 
      exec 2<&3; 
    fi
  elif [[ $OFFLINE -eq 0 && `echo $components|grep -icw dbm` -ge 1 && `echo $components|grep -ic rdbms` -lt 1 && $db_machine_compute -eq 1 ]]
  then
    components=EXADATA
  fi
  if [[ $OFFLINE -eq 0 && `echo $components|grep -ic ovm` -ge 1 && $VMTYPE != "PVM" ]]
  then
    echo -e "\nOVM module not applicable on this cluster. ${program_name} will run without any module specific\n"|tee -a $LOGFIL
    components=NONE
    it_is_rac=1  
    if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]] ; then 
      exec 3<&2; 
      exec 2<&0; 
      $READ -p "Press any key to continue ..."; 
      exec 2<&3; 
    fi
  elif [[ $OFFLINE -eq 0 && `echo $components|grep -ic ovm` -ge 1 && $VMTYPE = "PVM" ]]
  then
    TYP="-b"
  fi

  #Find out that will any command in this audit check will require root or not.
  if [ $op_mode -eq 1 ]
  then  
    #REQUIRE_ROOT=`grep -c "REQUIRES_ROOT 1" $REFFIL`
    REQUIRE_ROOT=`grep  "REQUIRES_ROOT_COUNT" $REFFIL|sed  -n 's/.*REQUIRES_ROOT_COUNT //p'| sed 's/^ *\(.*\) *$/\1/'`
  else
    REQUIRE_ROOT=`grep -c "REQUIRES_ROOT 1" $REFFIL`
  fi

  exa_machine=0
  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]] ; then exa_machine=1; fi
  if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] ; then exa_machine=1; fi

  bda_machine=0
  if [[ -n "$is_bda_machine" && $is_bda_machine -eq 1 ]] ; then bda_machine=1; fi

  root_all_prompt=0
  #echo "******** $db_machine_compute  $is_exalogic_machine  Looking for cells in $CELLIP"
  #cat  $CELLIP
  #echo "==================="

  ask_cell_password=1
  if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_cell_checks -eq "0" ]] || [[ -n "$exclude_profile" && $exclude_profile -eq "1" && $profile_cell_checks -eq "0" ]] || [[ -n "$dbm_vm" && "$dbm_vm"  -eq 1 ]] || [[ -n "$is_ssc_localzone_machine" && "$is_ssc_localzone_machine"  -eq 1 ]] ; then
    ask_cell_password=0
  fi
 
  #if [[ -n "$exa_machine" && $exa_machine -eq 1 ]] && [[ $is_exalogic_machine -eq 1 || $dbm_x2_2 -eq 1 || $dbm_x3_2 -eq 1  || $dbm_x2_8 -eq 1 || $dbm_v2 -eq 1 && $TYP != "-p" ]] && [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]] && [ "$upgrade_mode" -ne "3" ] && [ $only_hacheck_run -eq 0 ] && [ $ask_cell_password -eq "1" ]
  if [[ $db_machine_compute -eq 1  || $dbm_x2_2 -eq 1 || $dbm_x3_2 -eq 1  || $dbm_x2_8 -eq 1 || $dbm_v2 -eq 1 ]] && [ $TYP != "-p" ] && [[ -n "$skip_in_silent" && $skip_in_silent -eq 0 ]] && [ "$upgrade_mode" -ne "3" ] && [ $only_hacheck_run -eq 0 ] && [ $ask_cell_password -eq "1" ] && [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "0" ]] && [ -e "$CELLIP" ]
  then
    # First check if root password is same on all components. only for exa
    # The root password is stored in global_root_password
    root_all_prompt=0
    set_root_all_prompt
    set_root_all_prompt_called=1
    cell_type="normal"
    if [[ -n " $is_exalogic_machine" &&  $is_exalogic_machine -eq "1" ]]
    then
      cell_type="zfscell"
    fi
    cell_root_command=$(grep -icw "NEEDS_RUNNING STORAGE_CELL" $REFFIL)
    if [ -z "$RAT_CELL_SSH_USER" ];then cell_ssh_user="root"; else cell_ssh_user=$RAT_CELL_SSH_USER;fi
    first_cell_ip=$(cat $CELLIP|cut -d\" -f2|cut -d\; -f2|head -1)

    for cell_ip in `cat $CELLIP|cut -d\" -f2|cut -d\; -f2`
    do
      #cellPingStatus=$($PING -c 1 $PING_W_FLAG $cell_ip >/dev/null 2>&1;echo $?)
      test_node_reachability $cell_ip $cell_ssh_user;
      if [ $el_node_ping -eq "1" ] ; then
        cellPingStatus=0;
      else
        cellPingStatus=1;
      fi

      #if [[ -n "$cellPingStatus" && $cellPingStatus -eq 0 ]] 
      #then
      #  check_ssh_speed $cell_ssh_user $cell_ip
      #  if [[ -n $ssh_go_ahead && $ssh_go_ahead = 0 ]] ; then cellPingStatus=255; fi
      #fi
      if [ $cellPingStatus -eq 0 ]
      then 
        cell_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $cell_ssh_user $cell_ip ls >/dev/null 2>&1;echo $?);
        cell_password_status=0
        #cell_ssh_status=100
        #if [ $cell_ssh_status -eq 255 ];then cell_ssh_status=0;fi
        #cellname_full=$(cat /etc/hosts|grep -w "$cell_ip"|awk '{print $NF}'|cut -d'-' -f1)
        cellname_full=$(grep -w "$cell_ip" /etc/hosts|grep -v "^ *#"|awk '{print $NF}'|cut -d'-' -f1|head -1)
        storage_cells=$(cells1=`cat $CELLIP|cut -d\" -f2|cut -d\; -f2`;echo $cells1|sed 's/ /,/g');

        if [[ $daemon_init_mode -eq 1 && -n "$cell_ssh_status" && $cell_ssh_status -ne 0 ]]
        then
          echo -e "\n${cell_ssh_user} user equivalence is not setup between $localnode and ${BLINK}STORAGE SERVER${NORM} ${cellname_full}."
          log_daemon "\n${cell_ssh_user} user equivalence is not setup between $localnode and ${BLINK}STORAGE SERVER${NORM} ${cellname_full}."
          echo -e "\n\n${program_name} is exiting.."   
          log_daemon "\n\n${program_name} is exiting.."   
          exit 1
        fi   

        if [[ -n "$cell_ssh_status" && $cell_ssh_status -ne 0 ]]
        then
          if [ $root_all_prompt -eq "1" ] ; then
            echo "Validating ${cell_ssh_user} password on STORAGE SERVER"
            echo 
            cellssh_YesNo=1
          else
            echo -e "\n${cell_ssh_user} user equivalence is not setup between $localnode and ${BLINK}STORAGE SERVER${NORM} ${cellname_full} ($cell_ip)." 
            echo -e "\n1. Enter 1 if you will enter ${cell_ssh_user} password for each ${BLINK}STORAGE SERVER${NORM} when prompted."
            echo -e "\n2. Enter 2 to exit and configure $cell_ssh_user user equivalence manually and re-run ${program_name}."
            echo -e "\n3. Enter 3 to skip checking best practices on ${BLINK}STORAGE SERVER${NORM}.\n"

	    if [[ $EM_PROBE_MODE -eq 1 ]]
	    then
              cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_CC}" groupHeader="Cell Cluster Configuration">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="SINGLE_SELECT" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <text nls_id="orhc_exadata_n50_nlsid">
        For evaluating best practices on storage cells of cluster, connectivity between nodes needs to be setup
      </text>
    </context>
    <text nls_id="orhc_exadata_n13_nlsid">Indicate your selection from one of the options</text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o1q1">
	<tokenizedtext>
        <text nls_id="orhc_exadata_n51_nlsid">Enter {1} password for each storage cell</text>
	  <tokens><token index="1">$cell_ssh_user</token></tokens>
	</tokenizedtext>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n52_nlsid">Skip checking best practices on storage cells</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o3" isTerminal="Y">
	<tokenizedtext>
        <text nls_id="orhc_exadata_n53_nlsid">Exit and configure {1} user equivalence manually and re-run exachk</text>
	<tokens><token index="1">$cell_ssh_user</token></tokens>
	</tokenizedtext>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1" questionType="BOOLEAN" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n54_nlsid">Is {1} user password same on all Storage Server</text>
    <tokens><token index="1">$cell_ssh_user</token></tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1q1o1" qid="q${PROBE_QUES_CNT}o1q1o1q1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o1q1o2" qid="q${PROBE_QUES_CNT}o1q1o2q1">
         <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1o1q1" questionType="SECRET" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n82_nlsid">Common {1} user password on Storage Server</text>
    <tokens><token index="1">$cell_ssh_user</token></tokens>
    </tokenizedtext>
  </question>
EOF
	      echo -e "\n\n"
   	      echo -e "Please indicate your selection from one of the above options for STORAGE SERVER[1-3][1]:- "
	      cellssh_YesNo=3 
            elif [[ $EM_XMLD_MODE -eq 1 ]]
            then
   	      echo -e "Please indicate your selection from one of the above options for STORAGE SERVER[1-3][1]:- "

	      read_probe_xml "For evaluating best practices on storage cells of cluster, connectivity between nodes needs to be setup" "1"
	      cellssh_YesNo=$xml_rvalue
	    else
              exec 3<&2; exec 2<&0
              $READ -p  "Please indicate your selection from one of the above options for STORAGE SERVER[1-3][1]:- " cellssh_YesNo
	      read_code=`echo $?`;
              exec 2<&3
	      process_prompt "$read_code" "cellssh_YesNo" "3"
	    fi
          fi

          case $cellssh_YesNo in
            1)
              cell_password_status=1
              if [ $root_all_prompt -eq "1" ] ; then
                cell_samerootpassword_YesNo="y"
              else
        	if [[ $EM_XMLD_MODE -eq 1 ]]
        	then
                  echo -e "Is ${cell_ssh_user} password same on all STORAGE SERVER?[y/n][y]"

		  read_probe_xml "user password same on all Storage Server"
		  cell_samerootpassword_YesNo=$xml_rvalue
		else
                  echo -e "\n"
      	 	  exec 3<&2; exec 2<&0
                  $READ -p  "Is ${cell_ssh_user} password same on all STORAGE SERVER?[y/n][y]" cell_samerootpassword_YesNo
		  read_code=`echo $?`;
      	          exec 2<&3
		  process_prompt "$read_code" "cell_samerootpassword_YesNo" "y"
		fi
              fi
              case $cell_samerootpassword_YesNo in
      	        y|Y|Yes|YES|yes)
      	          cell_samerootpassword=1
                  if [ $root_all_prompt -eq "1" ] ; then
                    cell_rootpassword="$global_root_password"
                  else
      	            echo -e "\n"
      	            printf  "Enter ${cell_ssh_user} password for ${BLINK}STORAGE SERVER${NORM} :- "
		    if [[ $EM_XMLD_MODE -eq 1 ]]
		    then
		      read_probe_xml "Common {1} user password on Storage Server"
		      cell_rootpassword=$xml_rvalue 
		    else
      	              tty -s && stty -echo
      	              $READ -r cell_rootpassword
      	              tty -s && stty echo
		    fi
      		    printf "\n\nVerifying ${cell_ssh_user} password.\n\n. . ";
                  fi
      	          root_hostname=$cell_ip
      	          checkUserPassword "$root_hostname" "$cell_ssh_user" "$cell_rootpassword" "3" $cell_type
      	          printf ". ";
      	          if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
      	          then
      	             find_switch_root_password=$passwordToCheck
      	             first_cell_ip=$(cat $CELLIP|cut -d\" -f2|cut -d\; -f2|head -1)  
      	          fi
      	          cell_rootpassword=$passwordToCheck
      	          ;;
      	        n|N|No|NO|no)
      	          cell_samerootpassword=0
      	          root_cell_counter=0
      	          echo -e "\n"
      	          for cellname in `cat $CELLIP|cut -d\" -f2|cut -d\; -f2`
      	          do
                    cell_ssh_status2=$($SSHELL -o NumberOfPasswordPrompts=0 -l $cell_ssh_user $cellname ls >/dev/null 2>&1;echo $?);
                    if [[ -n "$cell_ssh_status2" && $cell_ssh_status2 -eq 0 ]]
                    then
                      echo "$cell_ssh_user password not checked on $cellname because ssh user equivalence found for $cell_ssh_user">>$LOGFIL
                    else
      	              if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
      	              then
      	                cellname_full=$cellname
      	              else
      	                #cellname_full=$(cat /etc/hosts|grep -w "$cellname"|awk '{print $NF}'|cut -d'-' -f1)  
      	                cellname_full=$(grep -w "$cellname" /etc/hosts|grep -v "^ *#"|awk '{print $NF}'|cut -d'-' -f1|head -1)  
      	              fi
      	              printf  "Enter ${cell_ssh_user} password for ${BLINK}STORAGE SERVER${NORM} $cellname_full ($cellname) :- "
		      if [[ $EM_XMLD_MODE -eq 1 ]]
		      then
			echo -e "\n"	
			read_probe_xml "<text>$cellname_full</text>"
			cell_rootpassword=$xml_rvalue
		      else
      	                tty -s && stty -echo
      	                $READ -r cell_rootpassword
      	                tty -s && stty echo
		      fi

      	              printf "\n\nVerifying ${cell_ssh_user} password.\n\n. . ";
      	              checkUserPassword "$cellname" "$cell_ssh_user" "$cell_rootpassword" "3" $cell_type
      	              printf ". ";
      	              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
      	              then
      	                find_switch_root_password=$passwordToCheck
      	                first_cell_ip=$cellname
      	              fi
      	              cell_rootpassword=$passwordToCheck
      	              a_cell_rootpassword[$root_cell_counter]=$cell_rootpassword
                    fi
      	            root_cell_counter=$(expr $root_cell_counter + 1 )
      	          done
      	          ;;
      	        *)
      	          cell_samerootpassword=1
      	          echo -e "\n"
      	          printf  "Enter ${cell_ssh_user} password for ${BLINK}STORAGE SERVER${NORM} :- "
      	          tty -s && stty -echo
      	          $READ -r cell_rootpassword
      	          tty -s && stty echo
      	          printf "\n\nVerifying ${cell_ssh_user} password.\n\n. . ";
      	          root_hostname=$cell_ip
      	          checkUserPassword "$root_hostname" "$cell_ssh_user" "$cell_rootpassword" "3" $cell_type
      	          printf ". ";
      	          if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
      	          then
      	            find_switch_root_password=$passwordToCheck
      	            first_cell_ip=$(cat $CELLIP|cut -d\" -f2|cut -d\; -f2|head -1)  
      	          fi
      	          cell_rootpassword=$passwordToCheck
      	          ;;
              esac 
              ;;
            2)
              echo -e "\nLogin as $cell_ssh_user user on $localnode\n\nA. Generate $cell_ssh_user ssh keys.\n\ta. ssh-keygen -t dsa\n\tb. ssh-keygen -t rsa\nAccept defaults so the ssh keys are created for $cell_ssh_user user\n\nB. Push ssh keys to set up ssh equivalence using following command. Enter $cell_ssh_user password when prompted for.\ndcli -c $storage_cells -l $cell_ssh_user -k\n\n"
              exit 1;
              ;; 
            3)
	      if [[ $EM_PROBE_MODE -eq 1 ]]
	      then
		cat >> ${PROBE_XML}.tmp <<EOF
  <question id="q${PROBE_QUES_CNT}o1q1o2q1" questionType="MULTIPART_QUESTION" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n56_nlsid">Component's {1} user password</text>
    <tokens><token index="1">$cell_ssh_user</token></tokens>
    </tokenizedtext>
    <multipart-question>
EOF
	        cell_counter=1
      	        for cellname in `cat $CELLIP|cut -d\" -f2|cut -d\; -f2`
      	        do
                  cell_ssh_status2=$($SSHELL -o NumberOfPasswordPrompts=0 -l $cell_ssh_user $cellname ls >/dev/null 2>&1;echo $?);
                  if [[ -n "$cell_ssh_status2" && $cell_ssh_status2 -eq 0 ]]
                  then
		    echo 
                  else
      	            if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
      	            then
      	              cellname_full=$cellname
      	            else
      	              cellname_full=$(grep -w "$cellname" /etc/hosts|grep -v "^ *#"|awk '{print $NF}'|cut -d'-' -f1|head -1)  
      	            fi
		    cat >> ${PROBE_XML}.tmp <<EOF
    <question id="q${PROBE_QUES_CNT}o1q1o2q1q${cell_counter}" questionType="SECRET" outcome="No">
      <text>$cellname_full</text>
    </question>
EOF
		    cell_counter=$(expr $cell_counter + 1 )
                  fi
      	        done
		cat >> ${PROBE_XML}.tmp <<EOF
    </multipart-question>
  </question>
</group>
EOF
		PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
	      fi 
              cell_password_status=3
              break
              ;;
            *)
              cell_password_status=1
              echo -e "\n"
              exec 3<&2; exec 2<&0
              $READ -p  "Is ${cell_ssh_user} password same on all STORAGE SERVER[y/n][y]" cell_samerootpassword_YesNo
	      read_code=`echo $?`;
              exec 2<&3
	      process_prompt "$read_code" "cell_samerootpassword_YesNo" "y"

              case $cell_samerootpassword_YesNo in
      	        y|Y|Yes|YES|yes)
      	          cell_samerootpassword=1
      	          echo -e "\n"
      	          printf  "Enter ${cell_ssh_user} password for ${BLINK}STORAGE SERVER${NORM} :- "
      	          tty -s && stty -echo
      	          $READ -r cell_rootpassword
      	          tty -s && stty echo
      	          printf "\n\nVerifying ${cell_ssh_user} password.\n\n. . ";
      	          root_hostname=$cell_ip
      	          checkUserPassword "$root_hostname" "$cell_ssh_user" "$cell_rootpassword" "3" $cell_type
      	          printf ". ";
      	          if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
      	          then
      	            find_switch_root_password=$passwordToCheck
      	            first_cell_ip=$(cat $CELLIP|cut -d\" -f2|cut -d\; -f2|head -1)  
      	          fi
      	          cell_rootpassword=$passwordToCheck
      	          ;;
      	        n|N|No|NO|no)
      	          cell_samerootpassword=0
      	          root_cell_counter=0

      	          for cellname in `cat $CELLIP|cut -d\" -f2|cut -d\; -f2`
      	          do
                    cell_ssh_status2=$($SSHELL -o NumberOfPasswordPrompts=0 -l $cell_ssh_user $cellname ls >/dev/null 2>&1;echo $?);
                    if [[ -n "$cell_ssh_status2" && $cell_ssh_status2 -eq 0 ]]
                    then
                      echo "$cell_ssh_user password not checked on $cellname because ssh user equivalence found for $cell_ssh_user">>$LOGFIL
                    else
                      if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
                      then 
                        cellname_full=$cellname
                      else
          	        #cellname_full=$(cat /etc/hosts|grep -w "$cellname"|awk '{print $NF}'|cut -d'-' -f1)  
			cellname_full=$(grep -w "$cellname" /etc/hosts|grep -v "^ *#"|awk '{print $NF}'|cut -d'-' -f1|head -1)
                      fi 
      		      printf  "Enter ${cell_ssh_user} password for ${BLINK}STORAGE SERVER${NORM} $cellname_full ($cellname) :- "
      		      tty -s && stty -echo
      		      $READ -r cell_rootpassword
      		      tty -s && stty echo
      	      	      printf "\n\nVerifying ${cell_ssh_user} password.\n\n. . ";
      		      checkUserPassword "$cellname" "$cell_ssh_user" "$cell_rootpassword" "3" $cell_type
      	      	      printf ". ";
      		      if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
      		      then
      		        find_switch_root_password=$passwordToCheck
      		        first_cell_ip=$cellname
      		      fi
      		      cell_rootpassword=$passwordToCheck
      		      a_cell_rootpassword[$root_cell_counter]=$cell_rootpassword
                    fi
      		    root_cell_counter=$(expr $root_cell_counter + 1 )
      	          done
      	          ;;
      	        *)
      	          cell_samerootpassword=1
      	          echo -e "\n"
      	          printf  "Enter $cell_ssh_user password for ${BLINK}STORAGE SERVER${NORM} :- "
      	          tty -s && stty -echo
      	          $READ cell_rootpassword
      	          tty -s && stty echo
      	          printf "\n\nVerifying ${cell_ssh_user} password.\n\n. . ";
      	          root_hostname=$cell_ip
      	          checkUserPassword "$root_hostname" "$cell_ssh_user" "$cell_rootpassword" "3" $cell_type
      	          printf ". ";
      	          if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
      	          then
      	            find_switch_root_password=$passwordToCheck
      	            first_cell_ip=$(cat $CELLIP|cut -d\" -f2|cut -d\; -f2|head -1)  
      	          fi
      	          cell_rootpassword=$passwordToCheck
      	     	  ;;
              esac
              ;; 
          esac
          break
          #"\nso setup user equivalence between $localnode and all storage cells for root user and re-run $program_name."
        elif [[ -n "$cell_ssh_status" && $cell_ssh_status -ne 0 ]]
        then
          cell_password_status=3 
        fi
      else
        cell_password_status=3 
        if [[ $ssh_go_ahead = 0 ]]
        then
          add_to_skipped_nodes "$cell_ip" "Network latency issue: Storage server is pingable but ssh took too long";
        else
          add_to_skipped_nodes "$cell_ip" "Storage server is not reachable";
        fi
      fi 
      printf ". ";
    done 

    if [[ -n "$cell_password_status" && $cell_password_status -eq 1 && "$cell_ssh_user" = "root" && -z "$RAT_IBSWITCHES" ]]
    then
      printf ". ";
      #if [[ -n "$cell_samerootpassword" && $cell_samerootpassword -eq 0 ]]  
      #then
      #  find_switch_root_password=${a_cell_rootpassword[0]}
      #elif [[ -n "$cell_samerootpassword" && $cell_samerootpassword -eq 1 ]]
      #then
      #  find_switch_root_password=$cell_rootpassword
      #fi
      # gadiga - create /tmp/.program first
      fixRootPassword "$find_switch_root_password"
      $EXPECT -f - << IBEOF
                               #set timeout 1
                               set timeout $passwordcheck_timeout
			       set le_find_switch_root_password "$fixedRootPassword"
                               log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }    
                               spawn -noecho $SSHELL $cell_ssh_user@$first_cell_ip rm -rf ${CELLRTEMPDIR} >/dev/null 2>&1
                               match_max 100000
			       expect {
				-nocase "permission denied *" {
				   exit 4;
			       }
			      	-nocase "no)?" {
				send -- "yes\n"
			       }
			        -nocase "*?assword:*" {
				send -- "\$le_find_switch_root_password\n"
			       }
			      	-nocase eof {
				exit
			       }
			       }
			       # Look for passwd prompt
			       expect {
			         -nocase "*?assword:*" {
			           send -- "\$le_find_switch_root_password\n"
			         }
			         # Stop the on logon tests and if asked to connect to master switch choose no
			         -nocase eof {
			           exit
			         } -nocase timeout {
			           send_error "Timed out while deleting ${CELLRTEMPDIR} on $first_cell_ip\n";
			           exit
			         }
			       }
			       expect -nocase eof
IBEOF
      printf ". ";
      $EXPECT -f - << IBEOF
                               #set timeout 1
                               set timeout $passwordcheck_timeout
			       set le_find_switch_root_password "$fixedRootPassword"
                               log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }    
                               spawn -noecho $SSHELL $cell_ssh_user@$first_cell_ip mkdir ${CELLRTEMPDIR} >/dev/null 2>&1
                               match_max 100000
			       expect {
				-nocase "permission denied *" {
				   exit 4;
			       }
			      	-nocase "no)?" {
				send -- "yes\n"
			       }
			        -nocase "*?assword:*" {
				send -- "\$le_find_switch_root_password\n"
			       }
			      	-nocase eof {
				exit
			       }
			       }
			       # Look for passwd prompt
			       expect {
			         -nocase "*?assword:*" {
			           send -- "\$le_find_switch_root_password\n"
			         }
			         # Stop the on logon tests and if asked to connect to master switch choose no
			         -nocase eof {
			           exit
			         } -nocase timeout {
			           send_error "Timed out while running mkdir on $first_cell_ip\n";
			           exit
			         }
			       }
			       expect -nocase eof
IBEOF
      printf ". ";
      $EXPECT -f - << IBEOF
			       #set timeout 1
                               set timeout $passwordcheck_timeout
			       set le_find_switch_root_password "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }
			       spawn -noecho $SSHELL $cell_ssh_user@$first_cell_ip "ibswitches 2>/dev/null >${CELLRTEMPDIR}/o_ibswitches_full.out"
			       match_max 100000
			       expect {
				-nocase "permission denied *" {
				   exit 4;
			       }
			      	-nocase "no)?" {
				send -- "yes\n"
			       }
			        -nocase "*?assword:*" {
				send -- "\$le_find_switch_root_password\n"
			       }
			      	-nocase eof {
				exit
			       }
			       }
			       # Look for passwd prompt
			       expect {
			         -nocase "*?assword:*" {
			           send -- "\$le_find_switch_root_password\n"
			         }
			         # Stop the on logon tests and if asked to connect to master switch choose no
			         -nocase eof {
			           exit
			         } -nocase timeout {
			           send_error "Timed out while running ibswitches command \n";
			           exit
			         }
			       }
			       expect -nocase eof
IBEOF
      printf ". ";
      $EXPECT -f - << IBEOF
			       #set timeout 1
                               set timeout $passwordcheck_timeout
			       set le_find_switch_root_password "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }
			       spawn $SCOPY $cell_ssh_user@$first_cell_ip:${CELLRTEMPDIR}/o_ibswitches_full.out ${RTEMPDIR}
			       match_max 100000
			       expect {
				-nocase "permission denied *" {
				   exit 4;
			       }
			      	-nocase "no)?" {
				send -- "yes\n"
			       }
			        -nocase "*?assword:*" {
				send -- "\$le_find_switch_root_password\n"
			       }
			      	-nocase eof {
				exit
			       }
			       }
			       # Look for passwd prompt
			       expect {
			         -nocase "*?assword:*" {
			           send -- "\$le_find_switch_root_password\n"
			         }
			         # Stop the on logon tests and if asked to connect to master switch choose no
			         -nocase eof {
			           exit
			         } -nocase timeout {
			           send_error "Timed out while copying ${CELLRTEMPDIR}/o_ibswitches_full.out file from $first_cell_ip\n";
			           exit
			         }
			       }
			       expect -nocase eof
IBEOF
      printf ". ";
      $EXPECT -f - << IBEOF
			       #set timeout 1
                               set timeout $passwordcheck_timeout
			       set le_find_switch_root_password "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }
                               spawn -noecho $SSHELL $cell_ssh_user@$first_cell_ip "cellcli -e \"list cell attributes makeModel\" 2>/dev/null>${SYSTEM_DESC_FIL}"
			       match_max 100000
			       expect {
				-nocase "permission denied *" {
				   exit 4;
			       }
			      	-nocase "no)?" {
				send -- "yes\n"
			       }
			        -nocase "*?assword:*" {
				send -- "\$le_find_switch_root_password\n"
			       }
			      	-nocase eof {
				exit
			       }
			       }
			       # Look for passwd prompt
			       expect {
			         -nocase "*?assword:*" {
			           send -- "\$le_find_switch_root_password\n"
			         }
			         # Stop the on logon tests and if asked to connect to master switch choose no
			         -nocase eof {
			           exit
			         } -nocase timeout {
			           send_error "Timed out while running cellcli command\n";
			           exit
			         }
			       }
			       expect -nocase eof
IBEOF
      printf ". ";
      $EXPECT -f - << IBEOF
			       #set timeout 1
                               set timeout $passwordcheck_timeout
			       set le_find_switch_root_password "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }
			       spawn $SCOPY $cell_ssh_user@$first_cell_ip:${SYSTEM_DESC_FIL} ${RTEMPDIR}
			       match_max 100000
			       expect {
				-nocase "permission denied *" {
				   exit 4;
			       }
			      	-nocase "no)?" {
				send -- "yes\n"
			       }
			        -nocase "*?assword:*" {
				send -- "\$le_find_switch_root_password\n"
			       }
			      	-nocase eof {
				exit
			       }
			       }
			       # Look for passwd prompt
			       expect {
			         -nocase "*?assword:*" {
			           send -- "\$le_find_switch_root_password\n"
			         }
			         # Stop the on logon tests and if asked to connect to master switch choose no
			         -nocase eof {
			           exit
			         } -nocase timeout {
			           send_error "Timed out while copying ${SYSTEM_DESC_FIL} file from $first_cell_ip\n";
			           exit
			         }
			       }
			       expect -nocase eof
IBEOF
      printf ". ";	
      $EXPECT -f - << IBEOF
			       #set timeout 1
                               set timeout $passwordcheck_timeout
			       set le_find_switch_root_password "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }   
			       spawn $SSHELL $cell_ssh_user@$first_cell_ip rm -f ${CELLRTEMPDIR}/o_ibswitches_full.out ${SYSTEM_DESC_FIL}
			       match_max 100000
			       expect {
				-nocase "permission denied *" {
				   exit 4;
			       }
			      	-nocase "no)?" {
				send -- "yes\n"
			       }
			        -nocase "*?assword:*" {
				send -- "\$le_find_switch_root_password\n"
			       }
			      	-nocase eof {
				exit
			       }
			       }
			       # Look for passwd prompt
			       expect {
			         -nocase "*?assword:*" {
			           send -- "\$le_find_switch_root_password\n"
			         }
			         # Stop the on logon tests and if asked to connect to master switch choose no
			         -nocase eof {
			           exit
			         } -nocase timeout {
			           send_error "Timed out while removing ${CELLRTEMPDIR}/o_ibswitches_full.out ${SYSTEM_DESC_FIL}\n";
			           exit
			         }
			       }
			       expect -nocase eof
IBEOF
      printf ". ";	
    elif [[ -n "$cell_password_status" && $cell_password_status -eq 0 && "$cell_ssh_user" = "root" && -z "$RAT_IBSWITCHES" ]]
    then
      printf ". ";	
      # gadiga -cell ssh is setup. create /tmp/.program
      #Commented this and created directory as needed rather than createing here on all cells. thats how if user presses ctrl+c, we will eave directory only on 1 cell and not on all
      #create_rtemp_dir_in_cells 
      first_cell_ip=$(cat $CELLIP|cut -d\" -f2|cut -d\; -f2|head -1)         
      $SSHELL $cell_ssh_user@$first_cell_ip "rm -rf ${CELLRTEMPDIR} >/dev/null 2>&1"
      $SSHELL $cell_ssh_user@$first_cell_ip "mkdir ${CELLRTEMPDIR} >/dev/null 2>&1"
      $SSHELL $cell_ssh_user@$first_cell_ip "ibswitches 2>/dev/null >${CELLRTEMPDIR}/o_ibswitches_full.out"
      $SSHELL $cell_ssh_user@$first_cell_ip "cellcli -e \"list cell attributes makeModel\" 2>/dev/null>${SYSTEM_DESC_FIL}"
      $SCOPY $cell_ssh_user@$first_cell_ip:${CELLRTEMPDIR}/o_ibswitches_full.out ${RTEMPDIR} >/dev/null 2>&1
      $SCOPY $cell_ssh_user@$first_cell_ip:${SYSTEM_DESC_FIL} ${RTEMPDIR} >/dev/null 2>&1
      $SSHELL $cell_ssh_user@$first_cell_ip rm -f ${CELLRTEMPDIR}/o_ibswitches_full.out ${SYSTEM_DESC_FIL} >/dev/null 2>&1
      $SSHELL $cell_ssh_user@$first_cell_ip "rmdir ${CELLRTEMPDIR}"
      printf ". ";	
    elif [ -n  "$RAT_IBSWITCHES" ]
    then
      printf ". ";
      for switchname in `echo $RAT_IBSWITCHES`
      do
        echo $switchname >>${RTEMPDIR}/o_ibswitches_full.out
      done
    fi
  else
    cell_ssh_status=0 
  fi

  printf ". ";
  echo "cell_ssh_status=$cell_ssh_status and cell_ssh_user=$cell_ssh_user">>$LOGFIL
  echo "CELL_SSH_USER = $cell_ssh_user" >>$MASTERFIL
  echo "CELL_PASSWORD_OPTION = $cell_password_status" >>$MASTERFIL
  echo "CELL_PASSWORD_OPTION = $cell_password_status" >>$LOGFIL  
    
  #following code is find infiniband switches from first cells   
  #Reassiging SYSTEM_DESC_FIL path back to compute node. initially it was cell temporory directory. now this file is available on compute node
  SYSTEM_DESC_FIL=${RTEMPDIR}/cell_system_description.out 
  #password prompt for ZFS cells for super cluster
  ask_zfs_password=1
  if [[ -n "$run_profile" && $run_profile -eq "1" && $zfs_in_profile -eq "0" && $ellite_in_profile -eq "0" && $elextensive_in_profile -eq "0" ]] ; then
    ask_zfs_password=0
  fi
  
  if [[ $is_ssc_machine -eq 2 || $is_exalogic_machine -eq 1 ]] && [[  $TYP != "-p"  && -n "$skip_in_silent" && $skip_in_silent -eq 0  && "$upgrade_mode" -ne "3" && $only_hacheck_run -eq 0 && $ask_zfs_password -eq "1" ]] && [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "0" ]] && [ -e "$CELLIP" ]
  then
    printf ". ";
    # First check if root password is same on all components. only for exa
    # The root password is stored in global_root_password
    if [ -z "$set_root_all_prompt_called" ] ; then
      root_all_prompt=0
      set_root_all_prompt
      set_root_all_prompt_called=1
      printf ". ";
    fi
    cell_type="zfscell"
    #cell_root_command=""
    if [ -z "$RAT_ZFS_SSH_USER" ];then zfs_ssh_user="root"; else zfs_ssh_user=$RAT_ZFS_SSH_USER;fi
    if [ $is_ssc_machine -eq 1 ];then discover_ssc_zfs_nodes;elif [ $is_exalogic_machine -eq 1 ];then ZFSIP=$CELLIP;fi
    for cell_ip in `cat $ZFSIP|cut -d= -f2|sed 's/"//g'`
    do
      printf ". ";
      #zfsPingStatus=$($PING -c 1 $PING_W_FLAG $cell_ip >/dev/null 2>&1;echo $?)
      test_node_reachability $cell_ip $zfs_ssh_user;
      if [ $el_node_ping -eq "1" ] ; then
        zfsPingStatus=0;
      else
        zfsPingStatus=1;
      fi

      #if [[ -n "$zfsPingStatus" && $zfsPingStatus -eq 0 ]] 
      #then
      #  check_ssh_speed $zfs_ssh_user $cell_ip
      #  if [[ -n $ssh_go_ahead && $ssh_go_ahead = 0 ]] ; then zfsPingStatus=255; fi
      #fi
      if [ $zfsPingStatus -eq 0 ]
      then 
    	zfs_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $zfs_ssh_user $cell_ip ls >/dev/null 2>&1;echo $?);
    	#cell_ssh_status=100
        if [[ $daemon_init_mode -eq 1 && -n "$zfs_ssh_status" && $zfs_ssh_status -ne 0 ]]
        then
          echo -e "\n${zfs_ssh_user} user equivalence is not setup between $localnode and ${BLINK}ZFS Storage Appliance${NORM} ${cell_ip}."
          echo -e "\n\n${program_name} is exiting.."   
          log_daemon "\n${zfs_ssh_user} user equivalence is not setup between $localnode and ${BLINK}ZFS Storage Appliance${NORM} ${cell_ip}."
          log_daemon "\n\n${program_name} is exiting.."   
          exit 1
        fi 
    	zfs_password_status=0
    	#if [ $cell_ssh_status -eq 255 ];then cell_ssh_status=0;fi
    	#zfsname_full=$(cat /etc/hosts|grep -w "$cell_ip"|awk '{print $NF}'|cut -d'-' -f1)
    	zfsname_full=$(grep -w "$cell_ip" /etc/hosts|awk '{print $NF}'|cut -d'-' -f1)
    	zfs_storage_cells=$(cells1=`cat $ZFSIP`;echo $cells1|sed 's/ /,/g');

    	if [[ -n "$zfs_ssh_status" && $zfs_ssh_status -ne 0 ]]
    	then
        if [ $root_all_prompt -eq "1" ] ; then
          echo "Validating root password on ZFS Storage Appliance"
          echo 
          zfsssh_YesNo=1
        else
    	  echo -e "\n${zfs_ssh_user} user equivalence is not setup between $localnode and ${BLINK}ZFS Storage Appliance${NORM} ${cell_ip}." 
    	  echo -e "\n1. Enter 1 if you will enter ${zfs_ssh_user} password for each ${BLINK}ZFS Storage Appliance${NORM} when prompted."
    	  echo -e "\n2. Enter 2 to exit and configure $zfs_ssh_user user equivalence manually and re-run ${program_name}."
    	  echo -e "\n3. Enter 3 to skip checking best practices on ${BLINK}ZFS Storage Appliance${NORM}.\n"
	  
  	  if [[ $EM_PROBE_MODE -eq 1 ]]
	  then
            cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_CC}" groupHeader="Cell Cluster Configuration">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="SINGLE_SELECT" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <text nls_id="orhc_exadata_n57_nlsid">
        For evaluating best practices on ZFS Storage Appliance of cluster, connectivity between nodes needs to be setup
      </text>
    </context>
    <text nls_id="orhc_exadata_n13_nlsid">Indicate your selection from one of the options</text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o1q1">
	<tokenizedtext>
        <text nls_id="orhc_exadata_n58_nlsid">Enter {1} password for each ZFS Storage Appliance</text>
	<tokens><token index="1">$zfs_ssh_user</token></tokens>
	</tokenizedtext>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n59_nlsid">Skip checking best practices on ZFS Storage Appliances</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o3" isTerminal="Y">
	<tokenizedtext>
        <text nls_id="orhc_exadata_n60_nlsid">Exit and configure {1} user equivalence manually and re-run ${program_name}</text>
	<tokens><token index="1">$zfs_ssh_user</token></tokens>
	</tokenizedtext>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1" questionType="BOOLEAN" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n61_nlsid">Is {1} user password same on all ZFS Storage Appliance</text>
    <tokens><token index="1">$zfs_ssh_user</token></tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1q1o1" qid="q${PROBE_QUES_CNT}o1q1o1q1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o1q1o2" qid="q${PROBE_QUES_CNT}o1q1o2q1">
         <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1o1q1" questionType="SECRET" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n84_nlsid">Common {1} user password on ZFS Storage Appliance</text>
    <tokens><token index="1">$zfs_ssh_user</token></tokens>
    </tokenizedtext>
  </question>
EOF
	      echo -e "\n\n"
              echo -e "Please indicate your selection from one of the above options for ZFS Storage Appliance[1-3][1]:- "
              zfsssh_YesNo=3
	  elif [[ $EM_XMLD_MODE -eq 1 ]]
	  then
	    echo -e "\n\n"
            echo -e "Please indicate your selection from one of the above options for ZFS Storage Appliance[1-3][1]:- "
	
	    read_probe_xml "For evaluating best practices on ZFS Storage Appliance of cluster, connectivity between nodes needs to be setup" 1
	    zfsssh_YesNo=$xml_rvalue
	  else
    	    exec 3<&2; exec 2<&0
    	    $READ -p  "Please indicate your selection from one of the above options for ZFS Storage Appliance[1-3][1]:- " zfsssh_YesNo
	    read_code=`echo $?`;
    	    exec 2<&3
	    process_prompt "$read_code" "zfsssh_YesNo" "3"
	  fi
        fi

    	case $zfsssh_YesNo in
    	1)
    	  zfs_password_status=1
    	  if [ $root_all_prompt -eq "1" ] ; then
    	    zfs_samerootpassword_YesNo="y"
    	  else
    	    echo -e "\n"
	    if [[ $EM_XMLD_MODE -eq 1 ]]
	    then
    	      echo -e "Is ${zfs_ssh_user} password same on all ZFS Storage Appliance?[y/n][y]"

	      read_probe_xml "password same on all ZFS Storage Appliance"
	      zfs_samerootpassword_YesNo=$xml_rvalue
	    else
    	      exec 3<&2; exec 2<&0
    	      $READ -p  "Is ${zfs_ssh_user} password same on all ZFS Storage Appliance?[y/n][y]" zfs_samerootpassword_YesNo
	      read_code=`echo $?`;
    	      exec 2<&3
	      process_prompt "$read_code" "zfs_samerootpassword_YesNo" "y"
	    fi
    	  fi
    	  case $zfs_samerootpassword_YesNo in
            y|Y|Yes|YES|yes)
    	      zfs_samerootpassword=1
    	      if [ $root_all_prompt -eq "1" ] ; then
    	        zfs_rootpassword="$global_root_password"
    	      else
		echo -e "\n" 
    	        printf  "Enter ${zfs_ssh_user} password for ${BLINK}ZFS Storage Appliance${NORM} :- "
		if [[ $EM_XMLD_MODE -eq 1 ]]
		then
		  read_probe_xml "Common {1} user password on ZFS Storage Appliance"
		  zfs_rootpassword=$xml_rvalue
		else
    	          tty -s && stty -echo
    	          $READ -r zfs_rootpassword
    	          tty -s && stty echo
		fi
    	      fi
              printf "\n\nVerifying ${zfs_ssh_user} password.\n\n. . ";
    	      root_hostname=$cell_ip
    	      checkUserPassword "$root_hostname" "$zfs_ssh_user" "$zfs_rootpassword" "3" $cell_type
              printf ". ";
    	      zfs_rootpassword=$passwordToCheck
    	      ;;
    	    n|N|No|NO|no)
    	      zfs_samerootpassword=0
    	      root_zfs_counter=0
    	      echo -e "\n"
    	      for zfsname in `cat $ZFSIP|cut -d= -f2|sed 's/"//g'`
    	      do
                zfs_ssh_status2=$($SSHELL -o NumberOfPasswordPrompts=0 -l $zfs_ssh_user $zfsname ls >/dev/null 2>&1;echo $?);
                if [[ -n "$zfs_ssh_status2" && $zfs_ssh_status2 -eq 0 ]]
                then
                  echo "$zfs_ssh_user password not checked on $zfsname because ssh user equivalence found for $zfs_ssh_user">>$LOGFIL
                else
		  echo -e "\n" 
    	          printf  "Enter ${zfs_ssh_user} password for ${BLINK}ZFS Storage Appliance${NORM} $zfsname :- "
		  if [[ $EM_XMLD_MODE -eq 1 ]]
		  then
		    read_probe_xml "<text>$zfsname</text>"
		    zfs_rootpassword=$xml_rvalue
		  else
    	            tty -s && stty -echo
    	            $READ -r zfs_rootpassword
    	            tty -s && stty echo
		  fi
                  printf "\n\nVerifying ${zfs_ssh_user} password.\n\n. . ";
    	          checkUserPassword "$zfsname" "$zfs_ssh_user" "$zfs_rootpassword" "3" $cell_type
                  printf ". ";
    	          zfs_rootpassword=$passwordToCheck
    	          a_zfs_rootpassword[$root_zfs_counter]=$zfs_rootpassword
                fi
    	        root_zfs_counter=$(expr $root_zfs_counter + 1 )
    	      done
    	      ;;
    	    *)
    	      zfs_samerootpassword=1
    	      echo -e "\n"
    	      printf  "Enter ${zfs_ssh_user} password for ${BLINK}ZFS Storage Appliance${NORM} :- "
    	      tty -s && stty -echo
    	      $READ -r zfs_rootpassword
    	      tty -s && stty echo
              printf "\n\nVerifying ${zfs_ssh_user} password.\n\n. . ";
    	      root_hostname=$cell_ip
    	      checkUserPassword "$root_hostname" "$zfs_ssh_user" "$zfs_rootpassword" "3" $cell_type
              printf ". ";
    	      zfs_rootpassword=$passwordToCheck
    	      ;;
    	  esac 
    	  ;;
    	2)
    	  echo -e "\nLogin as $zfs_ssh_user user on $localnode\n\nA. Generate $zfs_ssh_user ssh keys.\n\ta. ssh-keygen -t dsa\n\tb. ssh-keygen -t rsa\nAccept defaults so the ssh keys are created for $zfs_ssh_user user\n\nB. Push ssh keys to set up ssh equivalence using following command. Enter $zfs_ssh_user password when prompted for.\ndcli -c $zfs_storage_cells -l $zfs_ssh_user -k\n\n"
    	  exit 1;
    	  ;; 
    	3)
	  if [[ $EM_PROBE_MODE -eq 1 ]]
	  then
 	    cat >> ${PROBE_XML}.tmp <<EOF
  <question id="q${PROBE_QUES_CNT}o1q1o2q1" questionType="MULTIPART_QUESTION" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n56_nlsid">Component's {1} user password</text>
    <tokens><token index="1">$zfs_ssh_user</token></tokens>
    </tokenizedtext>
    <multipart-question>
EOF
	    zfs_counter=1
            for zfsname in `cat $ZFSIP|cut -d= -f2|sed 's/"//g'`
            do
              zfs_ssh_status2=$($SSHELL -o NumberOfPasswordPrompts=0 -l $zfs_ssh_user $zfsname ls >/dev/null 2>&1;echo $?);
              if [[ -n "$zfs_ssh_status2" && $zfs_ssh_status2 -eq 0 ]]
              then
                echo
              else
    		cat >> ${PROBE_XML}.tmp <<EOF
    <question id="q${PROBE_QUES_CNT}o1q1o2q1q${zfs_counter}" questionType="SECRET" outcome="No">
      <text>$zfsname</text>
    </question>
EOF
                zfs_counter=$(expr $zfs_counter + 1 )
              fi
            done
	    cat >> ${PROBE_XML}.tmp <<EOF
    </multipart-question>
  </question>
</group>
EOF
	    PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
	  fi
    	  zfs_password_status=3
    	  break
    	  ;;
    	*)
    	  zfs_password_status=1
    	  echo -e "\n"
    	  exec 3<&2; exec 2<&0
    	  $READ -p  "Is ${zfs_ssh_user} password same on all ZFS Storage Appliance[y/n][y]" zfs_samerootpassword_YesNo
	  read_code=`echo $?`;
    	  exec 2<&3
	  process_prompt "$read_code" "zfs_samerootpassword_YesNo" "y"
    	  case $zfs_samerootpassword_YesNo in
    	    y|Y|Yes|YES|yes)
    	      zfs_samerootpassword=1
    	      echo -e "\n"
    	      printf  "Enter ${zfs_ssh_user} password for ${BLINK}ZFS Storage Appliance${NORM} :- "
    	      tty -s && stty -echo
    	      $READ -r zfs_rootpassword
	      read_code=`echo $?`;
    	      tty -s && stty echo
    	      printf "\n\nVerifying ${zfs_ssh_user} password.\n\n. . ";
    	      root_hostname=$cell_ip
    	      checkUserPassword "$root_hostname" "$zfs_ssh_user" "$zfs_rootpassword" "3" $cell_type
    	      printf ". ";
    	      zfs_rootpassword=$passwordToCheck
    	      ;;
    	    n|N|No|NO|no)
    	      zfs_samerootpassword=0
    	      root_zfs_counter=0
    	      echo -e "\n"
    	      for zfsname in `cat $ZFSIP|cut -d= -f2|sed 's/"//g'`
    	      do
    	        printf ". ";	
                zfs_ssh_status2=$($SSHELL -o NumberOfPasswordPrompts=0 -l $zfs_ssh_user $zfsname ls >/dev/null 2>&1;echo $?);
                if [[ -n "$zfs_ssh_status2" && $zfs_ssh_status2 -eq 0 ]]
                then
                  echo "$zfs_ssh_user password not checked on $zfsname because ssh user equivalence found for $zfs_ssh_user">>$LOGFIL
                else
    	          printf  "Enter ${zfs_ssh_user} password for ${BLINK}ZFS Storage Appliance${NORM} $zfsname :- "
    	          tty -s && stty -echo
    	          $READ -r zfs_rootpassword
    	          tty -s && stty echo
    	          printf "\n\nVerifying ${zfs_ssh_user} password.\n\n. . ";
    	          checkUserPassword "$zfsname" "$zfs_ssh_user" "$zfs_rootpassword" "3" $cell_type
    	          zfs_rootpassword=$passwordToCheck
    	          printf ". ";
    	          a_zfs_rootpassword[$root_zfs_counter]=$zfs_rootpassword
                fi
    	        root_zfs_counter=$(expr $root_zfs_counter + 1 )
    	        printf ". ";
    	      done
    	      ;;
    	    *)
    	      zfs_samerootpassword=1
    	      echo -e "\n"
    	      printf  "Enter $zfs_ssh_user password for ${BLINK}ZFS Storage Appliance${NORM} :- "
    	      tty -s && stty -echo
    	      $READ -r zfs_rootpassword
    	      tty -s && stty echo
    	      printf "\n\nVerifying ${zfs_ssh_user} password.\n\n. . ";	
    	      root_hostname=$cell_ip
    	      checkUserPassword "$root_hostname" "$zfs_ssh_user" "$zfs_rootpassword" "3" $cell_type
    	      printf ". ";
    	      zfs_rootpassword=$passwordToCheck
    	      ;;
    	  esac
    	  ;; 
    	esac
    	break
        #"\nso setup user equivalence between $localnode and all storage cells for root user and re-run $program_name."
      elif [[ -n "$zfs_ssh_status" && $zfs_ssh_status -ne 0 ]]
      then
        zfs_password_status=3 
      fi
      else
        zfs_password_status=3 
        if [[ $ssh_go_ahead = 0 ]] 
        then
          add_to_skipped_nodes "$cell_ip" "Network latency issue: ZFS Storage Appliance is pingable but ssh took too long";
        else
          add_to_skipped_nodes "$cell_ip" "ZFS Storage Appliance is not reachable";
        fi
      fi 
    done 
  else
    zfs_ssh_status=0 
  fi

  if [[ $is_exalogic_machine -eq 1 || $is_bda_machine -eq 1 ]] && [[ -n "$swlist_file" && -e "$swlist_file" ]]
  then # exalogic or BDA machine. read switch info from file
    printf ". ";
    for switchname in `cat $swlist_file`
    do
      printf ". ";
      #$PING -c 1 $PING_W_FLAG $switchname >/dev/null 2>&1
      #switchping_status=$(echo $?)
      test_node_reachability $switchname "root" "Infiniband switch";
      if [ $el_node_ping -eq "1" ] ; then
        switchping_status=0;
        echo $switchname>>${RTEMPDIR}/o_ibswitches.out
      else
        switchping_status=1;
	add_to_skipped_nodes "$switchname" "$tnr_note"
      fi

      #if [ $switchping_status -eq 0 ]
      #then 
      #  check_ssh_speed "root" $switchname
      #  if [[ -n $ssh_go_ahead && $ssh_go_ahead = 0 ]] 
      #  then
      #    echo "Infiniband switch $switchname is reachable but ssh took too long.">>$LOGFIL  
      #    add_to_skipped_nodes "$switchname" "Network latency issue: Infiniband switch is reachable but ssh took too long";
      #  else
      #    echo $switchname>>${RTEMPDIR}/o_ibswitches.out
      #  fi
      #else
      #  $PING -c 1 $PING_W_FLAG $switchname >>$LOGFIL
      #  echo "Infiniband switch $switchname is not reachable so its being skipped from checking best practicing">>$LOGFIL  
      #  add_to_skipped_nodes "$switchname" "Infiniband switch is not reachable";
      #fi
    done
    rm -f ${RTEMPDIR}/o_ibswitches_full.out >/dev/null 2>&1
    cp ${RTEMPDIR}/o_ibswitches.out $OUTPUTDIR >/dev/null 2>&1
  fi
  echo "zfs_ssh_status=$zfs_ssh_status and zfs_ssh_user=$zfs_ssh_user">>$LOGFIL
  echo "ZFS_PASSWORD_OPTION = $zfs_password_status" >>$MASTERFIL
  echo "ZFS_PASSWORD_OPTION = $zfs_password_status" >>$LOGFIL  

  #password prompts for zfs appliance for super cluster ends here
      
  #echo "Switches:"
  #cat ${OUTPUTDIR}/o_ibswitches.out 
  #echo "=============="

  if [ -e ${RTEMPDIR}/o_ibswitches_full.out ]
  then
    #for switchname in `cat ${RTEMPDIR}/o_ibswitches_full.out|awk 'BEGIN { FS = "\" enhanced" } {print $1}'|awk '{print $NF}'|grep -vw localhost|cut -d' ' -f1`
    #for switchname in `cat ${RTEMPDIR}/o_ibswitches_full.out|grep -vwi gw|cut -d'"' -f2|awk {'print $NF}'|grep -vw localhost|grep -vi leaf|cut -d' ' -f1`
    OIFS="${IFS}";
    NIFS=$'\n';
    IFS="${NIFS}";
    for switch_line in `cat ${RTEMPDIR}/o_ibswitches_full.out`
    #while read switch_line
    do
      printf ". "
      switchname=$(echo "$switch_line"|grep -vwi gw|grep -vw localhost|grep -vi leaf|$AWK 'BEGIN { FS = "QDR " };{print $2}'|$AWK '{print $1}'|sed 's/"$//g')
      is_ibswitch_ip=$(echo $switchname|grep -c [A-Za-z])
      #if switch name is ip address than get previous filed from ibswitch output and see if its switchname  
      if [[ -n $is_ibswitch_ip && $is_ibswitch_ip -eq 0 ]]
      then
        switchname_ip=$switchname   
        switchname=$(echo "$switch_line"|grep -vwi gw|cut -d'"' -f2|awk {'print $(NF-1)}'|grep -vw localhost|grep -vi leaf|cut -d' ' -f1)
      fi   
      if [ -n "$switchname" ]
      then 
	#$PING -c 1 $PING_W_FLAG $switchname >/dev/null 2>&1
	#switchping_status=$(echo $?) 
        test_node_reachability "$switchname" "root" $switchname_ip "Infiniband switch";
        if [ $el_node_ping -eq "1" ] ; then
          switchping_status=0;
	  echo $switchname>>${RTEMPDIR}/o_ibswitches.out
        else
          switchping_status=1;
	  add_to_skipped_nodes "$switchname" "$tnr_note"
        fi

        #if switch name is not pingable than replace name with ip and ping again. 
        #if [ $switchping_status -ne 0 ]
        #then
        #  switchname=$switchname_ip
        #  $PING -c 1 $PING_W_FLAG $switchname >/dev/null 2>&1
        #fi     
	#
	#if [ $switchping_status -eq 0 ]
	#then
	#  check_ssh_speed "root" $switchname
	#  if [[ -n $ssh_go_ahead && $ssh_go_ahead = 0 ]]
	#  then
	#    echo "Infiniband switch $switchname is reachable but ssh took too long.">>$LOGFIL  
	#    add_to_skipped_nodes "$switchname" "Network latency issue: Infiniband switch is reachable but ssh took too long";
	#  else
	#    echo $switchname>>${RTEMPDIR}/o_ibswitches.out
	#  fi
	#else
	#  $PING -c 1 $PING_W_FLAG $switchname >>$LOGFIL
	#  echo "Infiniband switch $switchname is not reachable so its being skipped from checking best practicing">>$LOGFIL
	#  add_to_skipped_nodes "$switchname" "Infiniband switch is not reachable";
	#fi
      fi
    done
    #done<${RTEMPDIR}/o_ibswitches_full.out
    IFS="${OIFS}";
    mv -f ${RTEMPDIR}/o_ibswitches_full.out $OUTPUTDIR>/dev/null 2>&1
    cp ${RTEMPDIR}/o_ibswitches.out $OUTPUTDIR >/dev/null 2>&1
  fi
  #code is find infiniband switches from first cells ends here
  #ssh setup on cells finished here

  #following code is to find exadata version by logging in as root on storage server because oracle can not run imageinfo.
  if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] && [[ $dbm_x2_2 -eq 1 || $dbm_x3_2 -eq 1 || $dbm_x2_8 -eq 1 || $dbm_v2 -eq 1 && $TYP != "-p" ]]
  then
    printf ". ";
    if [ -n "$RAT_EXADATA_VERSION" ]
    then
      current_exadata_version=$(echo $RAT_EXADATA_VERSION|sed 's/\.//g')
      echo "Exadata version found on cluster = $current_exadata_version">>$LOGFIL
      echo "CURRENT_EXADATA_VERSION = $current_exadata_version" >>$MASTERFIL 
    else
      if [[ -n "$cell_password_status" && $cell_password_status -eq 1 && "$cell_ssh_user" = "root" ]]
      then
	fixRootPassword "$find_switch_root_password"
	current_exadata_version=$($EXPECT -f - << IBEOF
				    #set timeout 1
                                    set timeout $passwordcheck_timeout
				    set le_find_switch_root_password "$fixedRootPassword"
				    #log_user 0
                                    if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                      exp_internal 1
                                    } 
				    spawn -noecho $SSHELL $cell_ssh_user@$first_cell_ip "imageinfo -version"
				    match_max 100000
			       	    expect {
				      -nocase "permission denied *" {
				      exit 4;
			            }
			      	      -nocase "no)?" {
				      send -- "yes\n"
			            }
			              -nocase "*?assword:*" {
				      send -- "\$le_find_switch_root_password\n"
			            }
			      	      -nocase eof {
				      exit
			            }
			            }
			            # Look for passwd prompt
			            expect {
			              -nocase "*?assword:*" {
			                send -- "\$le_find_switch_root_password\n"
			              }
			              # Stop the on logon tests and if asked to connect to master switch choose no
			              -nocase eof {
			                exit
			              } -nocase timeout {
			                send_error "Timed out while running imageinfo command on $first_cell_ip\n";
			                exit
			              }
			            }
			            expect -nocase eof
IBEOF
)
  	printf ". ";
	if [ `echo "$current_exadata_version" | grep -ic "password:"` -gt 0 ]
	then
          ##CONTROLM	  current_exadata_version=$(echo $current_exadata_version|$AWK 'BEGIN { FS = "password:" };{print $2}'|sed 's/ //g'|sed 's///g')
	  current_exadata_version=$(echo $current_exadata_version|$AWK 'BEGIN { FS = "password:" };{print $2}'|sed 's/ //g'|tr -d '\r')
	else
          ##CONTROLM	  current_exadata_version=$(echo $current_exadata_version|sed 's/ //g'|sed 's///g')
	  current_exadata_version=$(echo $current_exadata_version|sed 's/ //g'|tr -d '\r')
	fi
	#current_exadata_version=$(echo $current_exadata_version|sed 's/\./#/g'|$AWK 'BEGIN{FS=OFS="#"}{$NF="";gsub(FS"+","")}1')
	current_exadata_version=$(echo $current_exadata_version|sed 's/\.//g'|cut -c 1-6)
	echo "Exadata version found on cluster = $current_exadata_version">>$LOGFIL
	echo "CURRENT_EXADATA_VERSION = $current_exadata_version" >>$MASTERFIL 
      elif [[ -n "$cell_password_status" && $cell_password_status -eq 0 && "$cell_ssh_user" = "root" ]]
      then
  	printf ". ";
	current_exadata_version=$($SSHELL $cell_ssh_user@$first_cell_ip "imageinfo -version")
	#current_exadata_version=$(echo $current_exadata_version|sed 's/\./#/g'|$AWK 'BEGIN{FS=OFS="#"}{$NF="";gsub(FS"+","")}1')
	current_exadata_version=$(echo $current_exadata_version|sed 's/\.//g'|cut -c 1-6)
	echo "Exadata version found on cluster = $current_exadata_version">>$LOGFIL
	echo "CURRENT_EXADATA_VERSION = $current_exadata_version" >>$MASTERFIL 
      fi
    fi

    if [[ -z "$current_exadata_version" &&  -n "$skip_in_silent" && $skip_in_silent -eq 0 && $cell_password_status -ne 3 && $upgrade_mode -ne 3 && $only_hacheck_run -eq 0  && $ask_cell_password -ne "0" ]]
    then
      echo -e ""
      echo -e "${RED}${program_name} could not determine Exadata software version from environment. Set RAT_EXADATA_VERSION environment variable to Exadata software version and re-run it.$NORM\n"
      echo -e "eg export RAT_EXADATA_VERSION=11.2.2.4.0\n"
      exit 1
    fi
  fi  

  #$READ -p "$current_exadata_version"
  #code to find out version ends here
  #calling is_this_db_machine again because some values will be available from storage server 
  bda_machine_type $localnode
  printf ". ";
  
  is_this_db_machine $localnode
  printf ". ";
  add_maa_scorecard
  printf ". ";
  add_hacheck
  printf ". ";
  
  write_db_machine_info_to_envfile $localnode
  printf ". ";
  
  db_root_ssh=1
  for db_root_ssh_host in `cat $HOSTLIST`
  do
    db_root_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $root_user $db_root_ssh_host ls >/dev/null 2>&1;echo $?);
    if [[ -n "$db_root_ssh_status" && $db_root_ssh_status -ne 0 ]]
    then
      if [[ $daemon_init_mode -eq 1 && -n "$db_root_ssh_status" && $db_root_ssh_status -ne 0 ]] || [[ $daemon_init_mode -eq 1 && -n "$daemon_init_mode_sudo" && $daemon_init_mode_sudo -eq 0 ]]
      then
        if [[ -n "$RAT_COMPUTE_RUNMODE" && $RAT_COMPUTE_RUNMODE = "serial" ]]; then
          echo -e "\n${root_user} user equivalence is not setup between $localnode and ${BLINK}DATABASE SERVER ${db_root_ssh_host}."
          echo -e "\n\n${program_name} is exiting.."
          log_daemon "\n${root_user} user equivalence is not setup between $localnode and ${BLINK}DATABASE SERVER ${db_root_ssh_host}."
          log_daemon "\n\n${program_name} is exiting.."
          exit 1
        fi
      fi    
      db_root_ssh=0
      db_root_with_nossh=$db_root_ssh_host
      echo -e "\nssh user equivalence not found for ${root_user} on ${db_root_ssh_host}\n">> $LOGFIL
      break
    else
      echo -e "\nssh user equivalence found for ${root_user} on ${db_root_ssh_host}\n">> $LOGFIL
    fi 
  done

  #$READ -p "components=$components"
  #$READ -p "TYP=$TYP REQUIRE_ROOT=$REQUIRE_ROOT"
  root_need_cell_ssh=0
  #if [ -n "$db_machine_compute" ] && [[ $dbm_v1 -eq 1 || $dbm_v2 -eq 1 ]] && [[  -n "$cell_password_status" && $cell_password_status -eq 3 ]]; then root_need_cell_ssh=1;fi
  if [ -n "$db_machine_compute" ] && [[ $dbm_v1 -eq 1 ]] && [[  -n "$cell_password_status" && $cell_password_status -eq 3 ]]; then root_need_cell_ssh=1;fi

  ask_root_password=1
  if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_root_checks -eq "0" ]] ; then
    ask_root_password=0
  elif [[ -n "$exclude_profile" && $exclude_profile -eq "1" && $profile_root_checks -eq "0" ]] ; then
    ask_root_password=0
  fi

  askrootp=0;
  if [ $is_windows -eq "0" ] ; then
    if [[ $single_instance_run -eq "0" || $db_machine_compute -eq 1 ]] || [[ $single_instance_run -eq "1" && $is_emagent_installed -eq 1 ]]; then
      askrootp=1;
    fi
  fi

  if [[ -n "$REQUIRE_ROOT" && $REQUIRE_ROOT -ge 1 ]] && [ $TYP = "-a" -o $TYP = "-b"  -o $TYP = "-u" ] && [ $userid -ne 0 ] && [[ -z $privilegechk || "$privilegechk" != "addr" ]] && [[ -n "$skip_in_silent" && $skip_in_silent -eq 0 ]] && [ "$components" != "OVM" ] && [ $root_need_cell_ssh -eq 0 ] && [ $upgrade_mode -ne 2 ] && [ $askrootp -eq 1 ] && [ $only_hacheck_run -eq 0 ] && [ $ask_root_password -eq 1 ] && [ $db_root_ssh -eq 0 ] && [ $daemon_init_mode_sudo -eq 0 ]
  then
    if [ $root_all_prompt -eq "1" ] ; then
      rootYesNo=1
    else
      echo -e "\n"
      #echo ""|tee -a $LOGFIL |tee -a $REPFIL
      #echo -e "\n$REQUIRE_ROOT of the included audit checks require root privilege. Please be prepared to supply the root password when prompted for each node in cluster.\n"
      echo -e "\n$REQUIRE_ROOT of the included audit checks require ${root_user} privileged data collection ${print_compute_node}. If sudo is not configured or the ${root_user} password is not available, audit checks which require ${root_user} privileged data collection can be skipped.\n"|tee -a $LOGFIL
      #echo -e "\n.Please select one of the following choices.\n"|tee -a $LOGFIL
      #echo  "If the root password is not available, only audit checks which do not require root privilege will be executed.\n">>$LOGFIL
      #echo -e "\n$REQUIRE_ROOT of the included audit checks require root privilege. Please select one of the following choices.\n">>$LOGFIL
      #echo  "$REQUIRE_ROOT  of the included audit checks require root privilege. Please be prepared to supply the root password when prompted for each node in cluster.\n">>$LOGFIL
      echo -e "\n1. Enter 1 if you will enter ${root_user} password for each ${print_compute_node} host when prompted"
      echo -e "\n2. Enter 2 if you have sudo configured for oracle user to execute root_${program_name}.sh script ${print_compute_node}" 
      echo -e "\n3. Enter 3 to skip the ${root_user} privileged collections ${print_compute_node}"
      echo -e "\n4. Enter 4 to exit and work with the SA to configure sudo ${print_compute_node} or to arrange for ${root_user} access and run the tool later.\n"
   
      if [[ $EM_PROBE_MODE -eq 1 ]]
      then
	cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_DC}" groupHeader="${GID_DC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="SINGLE_SELECT" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <text nls_id="orhc_exadata_n62_nlsid">
        For evaluating best practices on Database Server of cluster, connectivity between nodes needs to be setup
      </text>
    </context>
    <text nls_id="orhc_exadata_n13_nlsid">Indicate your selection from one of the options</text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o1q1">
	<tokenizedtext>
        <text nls_id="orhc_exadata_n63_nlsid">Enter {1} password for each Database Server</text>
	<tokens><token index="1">${root_user}</token></tokens>
	</tokenizedtext>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n64_nlsid">sudo configured for oracle user to execute root_${program_name}.sh script on Database Server</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o3">
	<tokenizedtext>
        <text nls_id="orhc_exadata_n65_nlsid">Skip {1} privileged collections on Database Server</text>
	<tokens><token index="1">${root_user}</token></tokens>
	</tokenizedtext>
      </option>
      <option id="q${PROBE_QUES_CNT}o4" isTerminal="Y">
	<tokenizedtext>
        <text nls_id="orhc_exadata_n66_nlsid">Exit and work with the SA to configure sudo Database Server or to arrange for {1} access and run the tool later</text>
	<tokens><token index="1">${root_user}</token></tokens>
	</tokenizedtext>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1" questionType="BOOLEAN" outcome="No">
EOF

        if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
	then
	  cat >> ${PROBE_XML}.tmp <<EOF
    <tokenizedtext>
    <text nls_id="orhc_exadata_n85_nlsid">Is {1} user password same on all compute nodes</text>
    <tokens><token index="1">${root_user}</token></tokens>
    </tokenizedtext> 
EOF
	else
	  cat >> ${PROBE_XML}.tmp <<EOF
    <tokenizedtext>
    <text nls_id="orhc_exadata_n86_nlsid">Is {1} password same on all nodes</text>
    <tokens><token index="1">${root_user}</token></tokens>
    </tokenizedtext>
EOF
	fi
	cat >> ${PROBE_XML}.tmp <<EOF
    <options>
      <option id="q${PROBE_QUES_CNT}o1q1o1" qid="q${PROBE_QUES_CNT}o1q1o1q1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o1q1o2" qid="q${PROBE_QUES_CNT}o1q1o2q1">
         <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1o1q1" questionType="SECRET" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n68_nlsid">Common {1} user password on nodes</text>
    <tokens><token index="1">${root_user}</token></tokens>
    </tokenizedtext>
  </question>
EOF
	echo -e "\n\n"
	echo "Please indicate your selection from one of the above options for ${root_user} access[1-4][1]:- "
 	rootYesNo=3	
      elif [[ $EM_XMLD_MODE -eq 1 ]]
      then
	echo -e "\n\n"
	echo "Please indicate your selection from one of the above options for ${root_user} access[1-4][1]:- "
	
	read_probe_xml "For evaluating best practices on Database Server of cluster, connectivity between nodes needs to be setup" "1"
	rootYesNo=$xml_rvalue
      else
        exec 3<&2; exec 2<&0
        $READ -p  "Please indicate your selection from one of the above options for ${root_user} access[1-4][1]:- " rootYesNo
	read_code=`echo $?`;
        exec 2<&3
	process_prompt "$read_code" "rootYesNo" "3"
      fi
    fi
    case $rootYesNo in
      1) 
        rootYesNoint=1
        #if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 && $dbm_v2 -eq 1 ]]
        if [[ -e $EXPECT ]]
        then
          if [ $root_all_prompt -eq "1" ] ; then
            samerootpassword_YesNo="y"
          else
            echo -e "\n"
             
            if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
            then      
	      if [[ $EM_XMLD_MODE -eq 1 ]]
	      then
                echo -e  "Is ${root_user} password same on all compute nodes?[y/n][y]"
		
		read_probe_xml "Is {1} user password same on all compute nodes"
		samerootpassword_YesNo=$xml_rvalue
	      else
                exec 3<&2; exec 2<&0
                $READ -p  "Is ${1} password same on all compute nodes?[y/n][y]" samerootpassword_YesNo
		read_code=`echo $?`;
                exec 2<&3
		process_prompt "$read_code" "samerootpassword_YesNo" "y"
	      fi
            else
	      if [[ $EM_XMLD_MODE -eq 1 ]]
	      then
                echo -e  "Is ${root_user} password same on all nodes?[y/n][y]" 
		
		read_probe_xml "Is {1} password same on all nodes"
		samerootpassword_YesNo=$xml_rvalue
	      else
                exec 3<&2; exec 2<&0
                $READ -p  "Is ${root_user} password same on all nodes?[y/n][y]" samerootpassword_YesNo
		read_code=`echo $?`;
                exec 2<&3
		process_prompt "$read_code" "samerootpassword_YesNo" "y"
	      fi
            fi
          fi
          case $samerootpassword_YesNo in
            y|Y|Yes|YES|yes)
              samerootpassword=1
              if [ $root_all_prompt -eq "1" ] ; then
                compute_rootpassword="$global_root_password"
              else
                echo -e "\n"
                printf  "Enter ${root_user} password ${print_compute_node}:- "
		if [[ $EM_XMLD_MODE -eq 1 ]]
	   	then
		  read_probe_xml "Common {1} user password on nodes"
		  compute_rootpassword=$xml_rvalue
		else
                  tty -s && stty -echo
                  $READ -r compute_rootpassword
                  tty -s && stty echo
		fi
              fi
              root_hostname=$(cat $HOSTLIST|head -1)
              compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $root_hostname ls >/dev/null 2>&1;echo $?);
              if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
              then
                echo "${root_user} password not checked on $root_hostname because ssh user equivalence found for ${root_user} ">>$LOGFIL
              else
                printf "\n\nVerifying ${root_user} password.\n\n. . ";
                checkUserPassword "$root_hostname" "${root_user}" "$compute_rootpassword" "3"
                printf ". ";
                if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
                then
                  find_switch_root_password=$passwordToCheck
                  first_compute_ip=$(cat $HOSTLIST|head -1)  
                fi
                compute_rootpassword=$passwordToCheck
              fi
              ;;
            n|N|No|NO|no)
              samerootpassword=0
              root_hostname_counter=0
              echo -e "\n"
              for root_hostname in `cat $HOSTLIST`
              do
                printf ". ";
                compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $root_hostname ls >/dev/null 2>&1;echo $?);
                if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
                then
                  echo "${root_user} password not checked on $root_hostname  because ssh user equivalence found for ${root_user} ">>$LOGFIL 
                else
		  echo -e "\n"
                  printf  "Enter ${root_user} password ${print_compute_node} $root_hostname :- "
		  if [[ $EM_XMLD_MODE -eq 1 ]]
		  then
		    read_probe_xml "<text>$root_hostname</text>"
		    compute_rootpassword=$xml_rvalue
		  else
                    tty -s && stty -echo
                    $READ -r compute_rootpassword
                    tty -s && stty echo
		  fi

                  printf "\n\nVerifying ${root_user} password.\n\n. . ";
                  checkUserPassword "$root_hostname" "${root_user}" "$compute_rootpassword" "3"
                  printf ". ";
                  if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
                  then
                    find_switch_root_password=$passwordToCheck
                    first_compute_ip=$root_hostname
                  fi
                  compute_rootpassword=$passwordToCheck
                  a_compute_rootpassword[$root_hostname_counter]=$compute_rootpassword
                fi
                  root_hostname_counter=$(expr $root_hostname_counter + 1)
              done 
              ;;
            *)
              samerootpassword=1
              echo -e "\n"
              printf  "Enter ${root_user} password ${print_compute_node}:- "
              tty -s && stty -echo
              $READ -r compute_rootpassword
              tty -s && stty echo
              printf "\n\nVerifying ${root_user} password.\n\n. . ";
              root_hostname=$(cat $HOSTLIST|head -1)
              compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $root_hostname ls >/dev/null 2>&1;echo $?);
              if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
              then
                echo "${root_user} password not checked on $root_hostname  because ssh user equivalence found for root">>$LOGFIL
              else
                checkUserPassword "$root_hostname" "${root_user}" "$compute_rootpassword" "3"
                printf ". ";
                if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
                then
                  find_switch_root_password=$passwordToCheck
                  first_compute_ip=$(cat $HOSTLIST|head -1)  
                fi
                compute_rootpassword=$passwordToCheck
              fi
              ;;
          esac 
        fi  
        ;;
      2) 
        rootYesNoint=2
        ;;
      3) 
	if [[ $EM_PROBE_MODE -eq 1 ]]
	then
          first_compute_ip=$(cat $HOSTLIST|head -1)
	  cat >> ${PROBE_XML}.tmp <<EOF
  <question id="q${PROBE_QUES_CNT}o1q1o2q1" questionType="MULTIPART_QUESTION" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n69_nlsid">Component's {1} user password</text>
    <tokens><token index="1">$root_user</token></tokens>
    </tokenizedtext>
    <multipart-question>
EOF
	  db_counter=1
	  for root_hostname in `cat $HOSTLIST`
	  do
            compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $root_hostname ls >/dev/null 2>&1;echo $?);
            if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
            then
              echo
            else
	      cat >> ${PROBE_XML}.tmp <<EOF
    <question id="q${PROBE_QUES_CNT}o1q1o2q1q${db_counter}" questionType="SECRET" outcome="No">
      <text>$root_hostname</text>
    </question>
EOF
	      db_counter=$(expr $db_counter + 1)
	    fi
	  done
	  cat >> ${PROBE_XML}.tmp <<EOF
    </multipart-question>
  </question>
</group>
EOF
          PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
	fi
        rootYesNoint=3
        ;;
      4) 
        rootYesNoint=4
        echo -e "\nif the intent is to set up sudo configuration please have a ${root_user} privileged user add the following line to the end of sudoers file using /usr/sbin/visudo on each node of cluster.\n"   
        echo -e "${usern} ALL=(root) NOPASSWD:$HOME/root_${program_name}.sh\n"
        exit 1
        ;;
      *)
        rootYesNoint=1
        #if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 && $dbm_v2 -eq 1 ]]
        if [[ -e $EXPECT ]]
        then
          echo -e "\n"
           
          if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
          then      
            exec 3<&2; exec 2<&0
            $READ -p  "Is ${root_user} password same on all compute nodes?[y/n][y]" samerootpassword_YesNo
	    read_code=`echo $?`;
            exec 2<&3
	    process_prompt "$read_code" "samerootpassword_YesNo" "y"
          else
            exec 3<&2; exec 2<&0
            $READ -p  "Is ${root_user} password same on all nodes?[y/n][y]" samerootpassword_YesNo
	    read_code=`echo $?`;
            exec 2<&3
	    process_prompt "$read_code" "samerootpassword_YesNo" "y"
          fi

          case $samerootpassword_YesNo in
          y|Y|Yes|YES|yes)
            samerootpassword=1
            echo -e "\n"
            printf  "Enter ${root_user} password ${print_compute_node}:- "
            tty -s && stty -echo
            $READ -r compute_rootpassword
            tty -s && stty echo
            printf "\n\nVerifying ${root_user} password.\n\n. . ";
            root_hostname=$(cat $HOSTLIST|head -1)
            compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $root_hostname ls >/dev/null 2>&1;echo $?);
            if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
            then
              echo "${root_user} password not checked on $root_hostname  because ssh user equivalence found for ${root_user} ">>$LOGFIL
            else
            checkUserPassword "$root_hostname" "${root_user}" "$compute_rootpassword" "3"
            printf ". ";
            if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
            then
              find_switch_root_password=$passwordToCheck
              first_compute_ip=$(cat $HOSTLIST|head -1)  
            fi
            compute_rootpassword=$passwordToCheck
            fi
            ;;
          n|N|No|NO|no)
            samerootpassword=0
            root_hostname_counter=0
            echo -e "\n"
            for root_hostname in `cat $HOSTLIST`
            do
              printf ". ";
              compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $root_hostname ls >/dev/null 2>&1;echo $?);
              if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
              then
                echo "${root_user} password not checked on $root_hostname  because ssh user equivalence found for ${root_user} ">>$LOGFIL 
              else
                printf  "Enter ${root_user} password ${print_compute_node} $root_hostname :- "
                tty -s && stty -echo
                $READ -r compute_rootpassword
                tty -s && stty echo
                printf "\n\nVerifying ${root_user} password.\n\n. . ";
                checkUserPassword "$root_hostname" "${root_user}" "$compute_rootpassword" "3"
                printf ". ";
                if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
                then
                  find_switch_root_password=$passwordToCheck
                  first_compute_ip=$(cat $HOSTLIST|head -1)  
                fi
                compute_rootpassword=$passwordToCheck
                a_compute_rootpassword[$root_hostname_counter]=$compute_rootpassword
              fi
              root_hostname_counter=$(expr $root_hostname_counter + 1)
            done 
            ;;
          *)
            samerootpassword=1
            echo -e "\n"
            printf  "Enter ${root_user} password ${print_compute_node}:- "
            tty -s && stty -echo
            $READ -r compute_rootpassword
            tty -s && stty echo
            root_hostname=$(cat $HOSTLIST|head -1)
            compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $root_hostname ls >/dev/null 2>&1;echo $?);
            if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
            then
              echo "${root_user} password not checked on $root_hostname  because ssh user equivalence found for root">>$LOGFIL
            else
              printf "\n\nVerifying ${root_user} password.\n\n. . ";
              checkUserPassword "$root_hostname" "${root_user}" "$compute_rootpassword" "3"
              printf ". ";
              if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
              then
              find_switch_root_password=$passwordToCheck
              first_compute_ip=$(cat $HOSTLIST|head -1)  
              fi
              compute_rootpassword=$passwordToCheck
            fi
            ;;
          esac 
        fi
      ;;
    esac
  else
    #if [ $NOQUESTION = "1" ]
    if [[ $NOQUESTION = "1" && $daemon_running -eq 0 ]] && [ $DOROOT = "1" ]
    then
      rootYesNoint=2
    elif [ $daemon_init_mode_sudo -eq 1 ]
    then 
      rootYesNoint=2    
    else
      if [[ $root_user_allowed -eq "1" ]] && [[ "$usern" = "${root_user}" || $userid -eq 0 ]] ; then
        rootYesNoint=1
      elif [ $db_root_ssh -eq 1 ]
      then
        rootYesNoint=1
        samerootpassword=1
      else
        rootYesNoint=3
      fi
    fi
  fi 

  if [[ $is_exalogic_machine -eq "1" || $is_bda_machine -eq 1 ]] ; then rootYesNoint=1; fi;
  echo "ROOT_OPTION = $rootYesNoint" >>$MASTERFIL
  echo "$show_version_envfile">>$MASTERFIL
  #following code is to check that if data file does not have pathcing info, it should only check the best praotices
  #if [[ $SILENT -eq 0 || $SILENT -eq 1 ]]
  #if [[ -n "$rootYesNoint" && $rootYesNoint -eq 1 && ! -e /tmp/o_ibswitches.out && -n "$RAT_CELL_SSH" ]]

  if [[ -n "$rootYesNoint" && $rootYesNoint -eq 1 && ! -e ${RTEMPDIR}/o_ibswitches.out ]] && [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] && [[ $dbm_x2_2 -eq 1 || $dbm_x3_2 -eq 1 || $dbm_x2_8 -eq 1 || $dbm_v2 -eq 1 ]] || [[ -n "$rootYesNoint" && $rootYesNoint -eq 1 &&  -e ${RTEMPDIR}/o_ibswitches.out && `cat ${RTEMPDIR}/o_ibswitches.out|wc -l` -eq 0 ]]
  then
    extract_ibswitches
  fi

  if [[ $EM_PROBE_MODE -eq 1 ]] && [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
  then
    eibsw="N"
    if [ ! -e ${RTEMPDIR}/o_ibswitches_full.out ]
    then
      eibsw="Y"
    else
      if [[ -s ${RTEMPDIR}/o_ibswitches_full.out ]] || [[ `cat ${RTEMPDIR}/o_ibswitches.out|wc -l` -eq 0 ]]
      then
        eibsw="Y"
      fi
    fi

    if [[ $eibsw = "Y" ]]
    then
      extract_ibswitches
    fi
  fi

  #following code is find infiniband switches from first cells   
  if [ -e ${RTEMPDIR}/o_ibswitches_full.out ]
  then
    #for switchname in `cat ${RTEMPDIR}/o_ibswitches_full.out|$AWK 'BEGIN { FS = "\" enhanced" } ;{print $1}'|awk '{print $NF}'|grep -vw localhost|cut -d' ' -f1`
    #for switchname in `cat ${RTEMPDIR}/o_ibswitches_full.out|cut -d'"' -f2|awk {'print $NF}'|grep -vw localhost|cut -d' ' -f1`
    #for switchname in `cat ${RTEMPDIR}/o_ibswitches_full.out|grep -vwi gw|cut -d'"' -f2|awk {'print $NF}'|grep -vw localhost|grep -vi leaf|cut -d' ' -f1`
    for switchname in `grep -vwi gw ${RTEMPDIR}/o_ibswitches_full.out|cut -d'"' -f2|awk {'print $NF}'|grep -vw localhost|grep -vi leaf|cut -d' ' -f1`
    do	
      printf ". ";
      #$PING -c 1 $PING_W_FLAG $switchname >/dev/null 2>&1
      #switchping_status=$(echo $?)

      is_ibswitch_ip=$(echo $switchname|grep -c [A-Za-z])
      if [[ -n $is_ibswitch_ip && $is_ibswitch_ip -eq 0 ]]
      then
        switchname_ip=$switchname
        switchname=$(cat ${RTEMPDIR}/o_ibswitches_full.out|grep -w "$switchname_ip"|grep -vwi gw|cut -d'"' -f2|awk {'print $(NF-1)}'|grep -vw localhost|grep -vi leaf|cut -d' ' -f1)
      fi

      if [ -n "$switchname" ]
      then
        test_node_reachability $switchname "root" "$switchname_ip" "Infiniband switch";
        if [ $el_node_ping -eq "1" ] ; then
          switchping_status=0;
	  echo $switchname>>${RTEMPDIR}/o_ibswitches.out;
        else
          switchping_status=1;
	  add_to_skipped_nodes "$switchname" "$tnr_note"
        fi
        
        #if [ $switchping_status -ne 0 ]
        #then
        #  switchname=$switchname_ip
        #  test_node_reachability $switchname "root"; 

        #  if [ $el_node_ping -eq "1" ] ; then
        #    switchping_status=0;
	#    check_ssh_speed "root" $switchname
        #  else
        #    switchping_status=1;
        #  fi
	#else
	#  check_ssh_speed "root" $switchname
        #fi
      fi
      #test_node_reachability $switchname;
      #if [ $el_node_ping -eq "1" ] ; then
      #  switchping_status=0;
      #else
      #  switchping_status=1;
      #fi
      #if [[ -n $ssh_go_ahead && $ssh_go_ahead = 0 ]] ; then switchping_status=1; fi
      #if [ $switchping_status -eq 0 ];then echo $switchname>>${RTEMPDIR}/o_ibswitches.out;fi
    done
    rm -f ${RTEMPDIR}/o_ibswitches_full.out >/dev/null 2>&1
    cp ${RTEMPDIR}/o_ibswitches.out $OUTPUTDIR >/dev/null 2>&1
  fi

  ask_switch_password=1
  if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_switch_checks -eq "0" ]] || [[ -n "$exclude_profile" && $exclude_profile -eq "1" && $profile_switch_checks -eq "0" ]] || [[ -n "$dbm_vm" && "$dbm_vm"  -eq 1 ]] || [[ -n "$is_ssc_localzone_machine" && "$is_ssc_localzone_machine"  -eq 1 ]]; then
    ask_switch_password=0
  fi

  exa_or_bda_machine=0
  if [[ -n "$exa_machine" && $exa_machine -eq 1 ]] || [[ -n "$bda_machine" && $bda_machine -eq 1 ]];
  then
    exa_or_bda_machine=1;
  fi
      
  if [[ -n "$exa_or_bda_machine" && $exa_or_bda_machine -eq 1 && -e ${RTEMPDIR}/o_ibswitches.out ]] && [[ $is_exalogic_machine -eq 1 || $dbm_v2 -eq 1 || $dbm_x2_8 -eq 1 || $dbm_x2_2 -eq 1 || $dbm_x3_2 -eq 1 || $is_bda_machine -eq 1 ]] && [[ -n "$skip_in_silent" && $skip_in_silent -eq 0 ]] && [ $ask_switch_password -eq "1" ]
  then
    ibswitch_root_command=9
    if [ -z "$RAT_IBSWITCH_USER" ]
    then 
      if [[ $is_exalogic_machine -eq 1 || $is_bda_machine -eq 1 ]]
      then
        ibswitch_user="root"
        ibswitch_user_noformat=${root_user}
      else
        if [ "$usern" = "${root_user}" ]
        then 
          ibswitch_user="root"
          ibswitch_user_noformat=$ibswitch_user
          ibswitch_user=${RED}${ibswitch_user}${NORM}   
        else
          ibswitch_user="nm2user"
          ibswitch_user_noformat=$ibswitch_user
          ibswitch_user=${RED}${ibswitch_user}${NORM}   
        fi
      fi
    else 
      ibswitch_user=$RAT_IBSWITCH_USER
      ibswitch_user_noformat=$RAT_IBSWITCH_USER
    fi

    ibs_equivalency=1
    for switchname in `cat ${RTEMPDIR}/o_ibswitches.out`
    do
      ibs_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user_noformat $switchname ls >/dev/null 2>&1;echo $?);
      if [[ -n "$ibs_ssh_status" && $ibs_ssh_status -ne 0 ]] 
      then 
        if [[ $daemon_init_mode -eq 1 && -n "$ibs_ssh_status" && $ibs_ssh_status -ne 0 ]]
        then
          echo -e "\n${ibswitch_user_noformat} user equivalence is not setup between $localnode and ${BLINK}Infiniband switch ${switchname}."
          echo -e "\n\n${program_name} is exiting.."
          log_daemon "\n${ibswitch_user_noformat} user equivalence is not setup between $localnode and ${BLINK}Infiniband switch ${switchname}."
          log_daemon "\n\n${program_name} is exiting.."
          exit 1
        fi  
        ibs_equivalency=0
        ibswitch_with_nossh=$switchname
        echo -e "\n ssh user equivalence not found for $ibswitch_user_noformat on ${switchname}\n">> $LOGFIL
        break  
      else
        echo -e "\n ssh user equivalence found for $ibswitch_user_noformat on ${switchname}\n">> $LOGFIL
      fi
    done

    if [[ $root_all_prompt -eq "1" && $ibswitch_user = "root" ]] ; then
      echo "Validating root password on INFINIBAND SWITCH"
      echo 
      ibswitch_YesNo=1
    else
      if [ $ibs_equivalency = 0 ]
      then
      	echo -e "\n"
        echo -e "\n${ibswitch_root_command} of the included audit checks require ${ibswitch_user} privileged data collection on ${BLINK}INFINIBAND SWITCH${NORM} .\n"|tee -a $LOGFIL
      	echo -e "\n1. Enter 1 if you will enter ${ibswitch_user} password for each ${BLINK}INFINIBAND SWITCH${NORM} when prompted"
        echo -e "\n2. Enter 2 to exit and to arrange for ${ibswitch_user} access and run the ${program_name} later."
        echo -e "\n3. Enter 3 to skip checking best practices on ${BLINK}INFINIBAND SWITCH${NORM}\n"
	if [[ $EM_PROBE_MODE -eq 1 ]]
	then
	  cat >> ${PROBE_XML}.tmp <<EOF
<group id="${GID_SC}" groupHeader="${GID_SC_HDR}">
  <question id="q${PROBE_QUES_CNT}" isParent="T" questionType="SINGLE_SELECT" defaultId="q${PROBE_QUES_CNT}o1" outcome="No">
    <context id="q${PROBE_QUES_CNT}c">
      <text nls_id="orhc_exadata_n70_nlsid">
        For evaluating best practices on Infiniband Switch of cluster, connectivity between nodes needs to be setup
      </text>
    </context>
    <text nls_id="orhc_exadata_n13_nlsid">Indicate your selection from one of the options</text>
    <options>
      <option id="q${PROBE_QUES_CNT}o1" qid="q${PROBE_QUES_CNT}o1q1">
	<tokenizedtext>
        <text nls_id="orhc_exadata_n71_nlsid">Enter {1} password for each Infiniband Switch</text>
	<tokens><token index="1">$ibswitch_user_noformat</token></tokens>
	</tokenizedtext>
      </option>
      <option id="q${PROBE_QUES_CNT}o2">
        <text nls_id="orhc_exadata_n72_nlsid">Skip checking best practices on Infiniband Switch</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o3" isTerminal="Y">
 	<tokenizedtext>
        <text nls_id="orhc_exadata_n60_nlsid">Exit and configure {1} user equivalence manually and re-run ${program_name}</text>
	<tokens><token index="1">$ibswitch_user_noformat</token></tokens>
	</tokenizedtext>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1" questionType="BOOLEAN" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n73_nlsid">Is {1} user password same on all Infiniband Switch</text>
    <tokens><token index="1">$ibswitch_user_noformat</token></tokens>
    </tokenizedtext>
    <options>
      <option id="q${PROBE_QUES_CNT}o1q1o1" qid="q${PROBE_QUES_CNT}o1q1o1q1">
        <text nls_id="orhc_exadata_n1_nlsid">True</text>
      </option>
      <option id="q${PROBE_QUES_CNT}o1q1o2" qid="q${PROBE_QUES_CNT}o1q1o2q1">
         <text nls_id="orhc_exadata_n2_nlsid">False</text>
      </option>
    </options>
  </question>
  <question id="q${PROBE_QUES_CNT}o1q1o1q1" questionType="SECRET" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n83_nlsid">Common {1} user password on Infiniband Switch</text>
    <tokens><token index="1">$ibswitch_user_noformat</token></tokens>
    </tokenizedtext>
  </question>
EOF
	  echo -e "\n\n"
	  echo -e "Please indicate your selection from one of the above options for INFINIBAND SWITCH[1-3][1]:- "
	  ibswitch_YesNo=3
	elif [[ $EM_XMLD_MODE -eq 1 ]]
	then
	  echo -e "\n\n"
	  echo -e "Please indicate your selection from one of the above options for INFINIBAND SWITCH[1-3][1]:- "
		    
	  read_probe_xml "For evaluating best practices on Infiniband Switch of cluster, connectivity between nodes needs to be setup" "1"
	  ibswitch_YesNo=$xml_rvalue
	else
      	  exec 3<&2; exec 2<&0
          $READ -p  "Please indicate your selection from one of the above options for INFINIBAND SWITCH[1-3][1]:- " ibswitch_YesNo
	  read_code=`echo $?`;
      	  exec 2<&3
	  process_prompt "$read_code" "ibswitch_YesNo" "3"
	fi
      else
      	ibswitch_YesNo=1			
      fi
    fi

    if [ -n "$ibswitch_user_noformat" ]; then ibswitch_user=$ibswitch_user_noformat;fi 

    case $ibswitch_YesNo in
      1)
        ibswitch_password_status=1
        if [[ $root_all_prompt -eq "1" && $ibswitch_user = "root" ]] || [[ $ibs_equivalency -eq 1 ]]; then
          ib_samerootpassword_YesNo="y"
        else
          echo -e "\n"
	  if [[ $EM_XMLD_MODE -eq 1 ]]
	  then
            echo -e  "Is $ibswitch_user password same on all INFINIBAND SWITCH ?[y/n][y]"
	
	    read_probe_xml "password same on all Infiniband Switch"
	    ib_samerootpassword_YesNo=$xml_rvalue
	  else
            exec 3<&2; exec 2<&0
            $READ -p  "Is $ibswitch_user password same on all INFINIBAND SWITCH ?[y/n][y]" ib_samerootpassword_YesNo
	    read_code=`echo $?`;
            exec 2<&3
	    process_prompt "$read_code" "ib_samerootpassword_YesNo" "y"
	  fi
        fi
        case $ib_samerootpassword_YesNo in
          y|Y|Yes|YES|yes)
            ib_samerootpassword=1
            echo -e "\n"
            if [ -n "$ibswitch_with_nossh" ]; then root_hostname=$ibswitch_with_nossh;else root_hostname=$(cat ${RTEMPDIR}/o_ibswitches.out|head -1);fi
            switch_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $root_hostname ls >/dev/null 2>&1;echo $?);

            if [[ -n "$switch_ssh_status1" && $switch_ssh_status1 -eq 0 ]]
            then
              echo -e "\n$ibswitch_user password not checked on $root_hostname because ssh user equivalence found for $ibswitch_user\n">> $LOGFIL
            else
              if [[ $root_all_prompt -eq "1" && $ibswitch_user = "root" ]] ; then
                switch_rootpassword="$global_root_password"
              else
                printf  "Enter $ibswitch_user password for ${BLINK}INFINIBAND SWITCH${NORM} :- "
		if [[ $EM_XMLD_MODE -eq 1 ]]
		then
		  read_probe_xml "Common {1} user password on Infiniband Switch"
		  switch_rootpassword=$xml_rvalue
		else
                  tty -s && stty -echo
                  $READ -r switch_rootpassword
                  tty -s && stty echo
		fi
                printf "\n\nVerifying $ibswitch_user password.\n\n. . ";
              fi
              checkUserPassword "$root_hostname" "$ibswitch_user" "$switch_rootpassword" "3" "ibswitch"
              printf ". ";
              switch_rootpassword=$passwordToCheck
            fi  
            ;;
          n|N|No|NO|no)
            ib_samerootpassword=0
            ib_root_counter=0
            echo -e "\n"  
            for switchname in `cat ${RTEMPDIR}/o_ibswitches.out` 
            do
              printf ". ";
              switch_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $switchname ls >/dev/null 2>&1;echo $?);
              if [[ -n "$switch_ssh_status1" && $switch_ssh_status1 -eq 0 ]]
              then
                echo -e "\n$ibswitch_user password not checked on $switchname because ssh user equivalence found for $ibswitch_user\n"|tee -a $LOGFIL
              else
                printf "Enter $ibswitch_user password for ${BLINK}INFINIBAND SWITCH${NORM} ${switchname} :- "
		if [[ $EM_XMLD_MODE -eq 1 ]]
		then
		  read_probe_xml "<text>$switchname</text>"
		  switch_rootpassword=$xml_rvalue
		else
                  tty -s && stty -echo
                  $READ -r switch_rootpassword
                  tty -s && stty echo
		fi

                printf "\n\nVerifying $ibswitch_user password.\n\n. . ";
                checkUserPassword "$switchname" "$ibswitch_user" "$switch_rootpassword" "3" "ibswitch" 
                printf ". ";
                switch_rootpassword=$passwordToCheck
                a_ib_switch_root_password[$ib_root_counter]=$switch_rootpassword
              fi
              ib_root_counter=$(expr $ib_root_counter + 1 )
            done
            ;;
          *)
            ib_samerootpassword=1
            echo -e "\n"
            if [ -n "$ibswitch_with_nossh" ]; then root_hostname=$ibswitch_with_nossh;else root_hostname=$(cat ${RTEMPDIR}/o_ibswitches.out|head -1);fi
            switch_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $root_hostname ls >/dev/null 2>&1;echo $?);
            if [[ -n "$switch_ssh_status1" && $switch_ssh_status1 -eq 0 ]]
            then
              echo -e "\n$ibswitch_user password not checked on $root_hostname because ssh user equivalence found for $ibswitch_user\n"|tee -a $LOGFIL
            else
              printf  "Enter $ibswitch_user password for ${BLINK}INFINIBAND SWITCH${NORM} :- "
              tty -s && stty -echo
              $READ -r switch_rootpassword
              tty -s && stty echo
              printf "\n\nVerifying $ibswitch_user password.\n\n. . ";
              checkUserPassword "$root_hostname" "$ibswitch_user" "$switch_rootpassword" "3" "ibswitch" 
              printf ". ";
              switch_rootpassword=$passwordToCheck
            fi 
            ;;
        esac 
        ;;
      2)
        ibswitch_password_status=2
        exit 1 
        ;;
      3)
	if [[ $EM_PROBE_MODE -eq 1 ]]
	then
	  ib_counter=1
	  cat >> ${PROBE_XML}.tmp <<EOF
  <question id="q${PROBE_QUES_CNT}o1q1o2q1" questionType="MULTIPART_QUESTION" outcome="No">
    <tokenizedtext>
    <text nls_id="orhc_exadata_n56_nlsid">Component's {1} user password</text>
    <tokens><token index="1">$ibswitch_user</token></tokens>
    </tokenizedtext>
    <multipart-question>
EOF
	  qib_counter=1
          for switchname in `cat ${RTEMPDIR}/o_ibswitches.out` 
          do
            printf ". ";
            switch_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $switchname ls >/dev/null 2>&1;echo $?);
            if [[ -n "$switch_ssh_status1" && $switch_ssh_status1 -eq 0 ]]
            then
              echo
            else
	      cat >> ${PROBE_XML}.tmp <<EOF
    <question id="q${PROBE_QUES_CNT}o1q1o2q1q${qib_counter}" questionType="SECRET" outcome="No">
    <text>$switchname</text>
  </question>
EOF
            fi
            qib_counter=$(expr $qib_counter + 1 )
            ib_counter=$(expr $ib_counter + 1 )
          done
          cat >> ${PROBE_XML}.tmp <<EOF
    </multipart-question>
  </question>
</group>
EOF
          PROBE_QUES_CNT=$(expr ${PROBE_QUES_CNT} + 1);
	fi
        ibswitch_password_status=3
        ;;
      *)
        ibswitch_password_status=1
        echo -e "\n"
        exec 3<&2; exec 2<&0
        $READ -p  "Is $ibswitch_user password same on all INFINIBAND SWITCH ?[y/n][y]" ib_samerootpassword_YesNo
	read_code=`echo $?`;
        exec 2<&3
	process_prompt "$read_code" "ib_samerootpassword_YesNo" "y"
        case $ib_samerootpassword_YesNo in
          y|Y|Yes|YES|yes)
            ib_samerootpassword=1
            echo -e "\n"
            if [ -n "$ibswitch_with_nossh" ]; then root_hostname=$ibswitch_with_nossh;else root_hostname=$(cat ${RTEMPDIR}/o_ibswitches.out|head -1);fi
            switch_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $root_hostname ls >/dev/null 2>&1;echo $?);
            if [[ -n "$switch_ssh_status1" && $switch_ssh_status1 -eq 0 ]]
            then
              echo -e "\n$ibswitch_user password not checked on $root_hostname because ssh user equivalence found for $ibswitch_user\n"|tee -a $LOGFIL
            else
              printf  "Enter $ibswitch_user password for ${BLINK}INFINIBAND SWITCH${NORM} :- "
              tty -s && stty -echo
              $READ -r switch_rootpassword
              tty -s && stty echo
              printf "\n\nVerifying $ibswitch_user password.\n\n. . ";
              checkUserPassword "$root_hostname" "$ibswitch_user" "$switch_rootpassword" "3" "ibswitch" 
              printf ". ";
              switch_rootpassword=$passwordToCheck
            fi
            ;;
          n|N|No|NO|no)
            ib_samerootpassword=0
            ib_root_counter=0
            echo -e "\n"  
            for switchname in `cat ${RTEMPDIR}/o_ibswitches.out` 
            do
              switch_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $switchname ls >/dev/null 2>&1;echo $?);
              if [[ -n "$switch_ssh_status1" && $switch_ssh_status1 -eq 0 ]]
              then
                echo -e "\n$ibswitch_user password not checked on $switchname because ssh user equivalence found for $ibswitch_user\n"|tee -a $LOGFIL
              else
                printf  "Enter $ibswitch_user password for ${BLINK}INFINIBAND SWITCH${NORM} ${switchname} :- "
                tty -s && stty -echo
                $READ -r switch_rootpassword
		read_code=`echo $?`;
                tty -s && stty echo
                printf "\nVerifying $ibswitch_user password.\n\n. . ";
                checkUserPassword "$switchname" "$ibswitch_user" "$switch_rootpassword" "3" "ibswitch" 
                printf ". ";
                switch_rootpassword=$passwordToCheck
                a_ib_switch_root_password[$ib_root_counter]=$switch_rootpassword
              fi
              ib_root_counter=$(expr $ib_root_counter + 1 )
            done
            ;;
          *)
            ib_samerootpassword=1
            echo -e "\n"
            if [ -n "$ibswitch_with_nossh" ]; then root_hostname=$ibswitch_with_nossh;else root_hostname=$(cat ${RTEMPDIR}/o_ibswitches.out|head -1);fi
            switch_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $root_hostname ls >/dev/null 2>&1;echo $?);
            if [[ -n "$switch_ssh_status1" && $switch_ssh_status1 -eq 0 ]]
            then
              echo -e "\n$ibswitch_user password not checked on $root_hostname because ssh user equivalence found for $ibswitch_user\n"|tee -a $LOGFIL
            else
              printf  "Enter $ibswitch_user password for ${BLINK}INFINIBAND SWITCH${NORM} :- "
              tty -s && stty -echo
              $READ -r switch_rootpassword
	      read_code=`echo $?`;
              tty -s && stty echo
	      process_prompt "$read_code" "switch_rootpassword" ""
              printf "\n\nVerifying $ibswitch_user password.\n\n. . ";
              checkUserPassword "$root_hostname" "$ibswitch_user" "$switch_rootpassword" "3" "ibswitch" 
              printf ". ";
              switch_rootpassword=$passwordToCheck
            fi  
            ;;
        esac
        ;;
    esac
    echo "IBSWITCH_PASSWORD_OPTION = $ibswitch_password_status" >>$MASTERFIL
    echo "IBSWITCH_PASSWORD_OPTION = $ibswitch_password_status" >>$LOGFIL
  fi

  #echo "cell_ssh_status=$cell_ssh_status">>$LOGFIL
  #lets print the nodes where root passwords are not working and ask user what does he want to do.

  if [[ -n "$noRootScriptNode" && ${#noRootScriptNode[@]} -gt 0 ]]
  then
    #echo -e "${RED}root passwords for following nodes are incorrect.\n\nYou can still continue but root privileged checks will not be executed on following nodes.\n${NORM}"
    echo -e "${RED}root passwords are incorrect or login to as root is disabled in ssh configuration for following nodes.\n\nYou can still continue but root privileged checks will not be executed on following nodes.\n${NORM}"
    nodesNoRootPasswordCounter=1
    for nodesNoRootPassword in ${noRootScriptNode[*]}
    do
      echo -e "$nodesNoRootPasswordCounter. $nodesNoRootPassword\n"
      echo "Incorrect ${root_user} password for $nodesNoRootPassword">>$LOGFIL
      nodesNoRootPasswordCounter=$(expr $nodesNoRootPasswordCounter + 1 )
    done
    nodesNoRootPasswordCounter=0
    printf "Do you want to continue[y/n][y]:- "
    $READ nodesNoRootPasswordYesNO
    read_code=`echo $?`;
    process_prompt "$read_code" "nodesNoRootPasswordYesNO" "y"
    case $nodesNoRootPasswordYesNO in
      y|Y|yes|YES|Yes) ;;
      n|N) 
	echo ""
        echo -e "${RED}\nPlease collect all ${root_user} passwords and run $program_name again.\n${NORM}"  
        exit 1
        ;;
      *)
       ;;
    esac    
    echo -e "\n" 
  fi 

  echo -e "\n" 
  #Stop here in daemon mode
  if [[ -n "$daemon_mode" && $daemon_mode -eq "1" ]] ; then
    mkdir $RTEMPDIR_D >/dev/null 2>&1;

    get_program_key
    export RAT_PROGRAM_KEY=$program_key
    if [ -n "$CRS" ] ; then export CRS_HOME=$CRS; fi
    export RAT_DAEMONDEB_INTERNAL=$DAEMONDEB

    ( 
      if [[ -n "$RAT_DAEMON_DEBUG" && $RAT_DAEMON_DEBUG -eq "1" ]] ; then set -x; fi

      keep_running=1 
      loop_cnt_autorun=0
      while [ $keep_running -eq "1" ] ;do
        loop_cnt_autorun=$(expr $loop_cnt_autorun + 1)
        if [ -e "$RTEMPDIR_D/commands" ] ; then
          handle_client_request;
        elif [ -e "$RTEMPDIR_D/stop" ] ; then
          stop_daemon_actual;
        elif [[ $loop_cnt_autorun -eq "10" ]] ; then
          loop_cnt_autorun=0
          started_autorun=0
          start_auto_run
          if [[ $started_autorun -eq "0" ]] && [[ $daemon_init_mode -eq "0" ]] ; then
            check_daemon_passwords
          fi
        fi
        sleep 5;
      done
    ) >> $DAEMONDEB 2>&1 &
    dpid=$!
    echo $dpid > $RTEMPDIR_D/daemon.pid
    if [ "$daemon_init_mode" -eq "0" ] ; then
      rm -f $WRKDIR/${program_name}_daemon.log
    fi

    update_daemon_file

    echo "${program_name} daemon is started with PID : $dpid";
    log_daemon "${program_name} daemon is started with PID : $dpid";
    cp $HOSTLIST $RTEMPDIR_D/.hosts.txt
    if [[ -n "$CELLIP" && -e "$CELLIP" ]] ; then cp $CELLIP $RTEMPDIR_D/.cells.txt; fi
    if [[ -n "$ZFSIP" && -e "$ZFSIP" ]] ; then cp $ZFSIP $RTEMPDIR_D/.zfs.txt; fi
    if [[ -n "${RTEMPDIR}/o_ibswitches.out" && -e "${RTEMPDIR}/o_ibswitches.out" ]] ; then cp ${RTEMPDIR}/o_ibswitches.out $RTEMPDIR_D/.ibs.txt; fi

    write_dnow_init

    #run_args=$(echo $argsaved | sed 's/-d *start//' | sed 's/^ *//' | sed 's/ *$//')
    if [[ -n "$run_args" ]] ; then
      argsaved=$run_args
      cleanup
      #$0 $run_args
      $PDIR/${program_name} $run_args
      exit 0
    else
      exit 0;
    fi
  fi

  if [[ $EM_PROBE_MODE -eq 1 ]] ; then finish_em_xml; fi

  if [ $SILENT -eq 0 ]
  then
    no_patch_rollup=0 
    no_patch_rollup=`grep -ic "NO Patch rollup selected" $REFFIL1`
    
    #$READ -p "TYP=$TYP no_patch_rollup=$no_patch_rollup REFFIL1=$REFFIL1"
  fi
  if [[ $TYP != "-b" && $no_patch_rollup -gt 0 ]]
  then
    no_patches=1
    echo -e $RED"\nThe driver file does not have information about either OS or database patches. Therefore it will check `uname` best practices only. $NORM \n"
    echo -e "\nThe script does not have information about either OS or database patches.  Therefore it will check `uname` best practices only.\n" >>$LOGFIL
    TYP="-b" 
  fi

  if [ $upgrade_mode -eq 2 ]
  then 
    echo -e "\nChecking Grid Infrastructure and RDBMS upgrade readiness to version ${targetversion}\n"
    #if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]]; then $READ -p "Press enter to  continue.....";fi
  else
    if [ $TYP != "-p" ] 
    then
      echo -e "\n*** Checking Best Practice Recommendations ("$GREEN"PASS"$NORM"/"$ORANGE"WARNING"$NORM"/"$RED"FAIL"$NORM") ***\n"
      echo "*** Checking Best Practice Recommendations ***\n" >>$LOGFIL
    fi
  fi
  #echo -e $GREEN"Beginning data collection for RAC using current environment settings...\n"$NORM
  #echo "Beginning data collection for RACusing current environment settings...\n" >>$LOGFIL
  #CODE TO CHECK THAT CLUSTER IS UP ON LOCAL NODE AND IF NOT,SCRIPT WILL TERMINATE
  #is_crs_up

  if [ $TYP != "-p" ]
  then
    if [ ${crs_up} -eq 1  ]
    then
      #echo -e $GREEN"CRS appears to be up on `hostname`.\n"$NORM
      echo "CRS appears to be up.\n" >>$LOGFIL
    else
      if [ $crs_installed -eq 1 ] 
      then
        #echo -e $RED"CRS appears to be down.  Skipping all CRS related audit checks. $NORM \n"
        echo "CRS appears to be down.  Skipping all CRS related audit checks.\n" >>$LOGFIL
      fi
    fi
  fi
    
  #echo "SQLNUM = $SQLNUM"
  #echo "DEBUG just before grepping for DB_VERSION"
  #### Create a master file to store database about a run and store in master table
  #SCRIPTVER=`grep DB_VERSION $REFFIL |awk {'print $3'} |sed -n 's///p'`
  #SCRIPTVER=`grep DB_VERSION $REFFIL |awk {'print $3'}` 
  #### Create a master file to store database about a run and store in master table
  #FILEDATE=`grep FILE_DATE $REFFIL|sed -n 's///p'`

  if [ $op_mode -eq 0 ]
  then
    get_winpath "REFFIL"
    FILEID=`$GREP FILE_ID $REFFIL`
    FILEDATE=`$GREP FILE_DATE $REFFIL`
    FILESIG=`$GREP FILE_SIG $REFFIL`
    DBPLATFORM=`$GREP DB_PLATFORM $REFFIL`
    OSDISTRO=`$GREP OS_DISTRO $REFFIL`
    OSVERSION=`GREP OS_VERSION $REFFIL`
    OSKERNEL=`GREP OS_KERNEL $REFFIL`
    restore_winpath "REFFIL"
  elif [ $op_mode -eq 1 ]
  then
    get_winpath "reffil_old"
    FILEID=`$GREP FILE_ID $reffil_old`
    FILEDATE=`$GREP FILE_DATE $reffil_old`
    FILESIG=`$GREP FILE_SIG $reffil_old`
    restore_winpath "reffil_old"
    if [ `uname -s` = "HP-UX" ]
    then
      DBPLATFORM=$(echo DB_PLATFORM = $os_arch_env_file)
    elif [ $(uname -p 2>/dev/null) = "s390x" ]
    then
         DBPLATFORM=$(echo DB_PLATFORM = "Linux on System z")
    else
      DBPLATFORM=$(echo DB_PLATFORM = $os_name $os_arch_env_file|tr "[a-z]" "[A-Z]")
    fi
    OSDISTRO=$(echo OS_DISTRO = $os_type_full)
    OSVERSION=$(echo OS_VERSION = $os_version)
    OSKERNEL=$(echo OS_KERNEL = `uname -r`)
  fi

  echo $FILEID>>$MASTERFIL
  echo $FILEDATE>>$MASTERFIL
  echo $FILESIG>>$MASTERFIL
  #DBVERSION=`grep DB_VERSION $REFFIL`
  #echo "DB_VERSION=$DBVERSION">>$MASTERFIL
  echo $DBPLATFORM>>$MASTERFIL
  upload_dbplatform=$(echo $DBPLATFORM|cut -d= -f2|sed 's/^\s//g'|sed 's/\s$//g')
  echo $OSDISTRO>>$MASTERFIL
  upload_osdistro=$(echo $OSDISTRO|cut -d= -f2|sed 's/^\s//g'|sed 's/\s$//g')
  echo $OSVERSION>>$MASTERFIL
  upload_osversion=$(echo $OSVERSION|cut -d= -f2|sed 's/^\s//g'|sed 's/\s$//g')
  echo $OSKERNEL>>$MASTERFIL
  upload_oskernel=$(echo $OSKERNEL|cut -d= -f2|sed 's/^\s//g'|sed 's/\s$//g')
  #echo "COLLECTION DATE = `date '+%d-%b-%Y %H:%M:%S'`">>$MASTERFIL
  collection_date=`date '+%d-%b-%Y %H:%M:%S'` 
  echo "COLLECTION DATE = $collection_date">>$MASTERFIL
  echo "SILENT = $SILENT" >>$MASTERFIL
  echo "SWITCH = $TYP">>$MASTERFIL
  echo "ASM_HOME = $ASM_HOME">>$MASTERFIL
  echo "${ORACLE_SID}_UP = $db_up">>$MASTERFIL
  echo "SOMEDB_UP = $somedb_up">>$MASTERFIL
  echo "LOCALNODE = $localnode">>$MASTERFIL
  if [ -n $cluster_name ]
  then
    echo "CLUSTER_NAME = $cluster_name">>$MASTERFIL
  fi 
   
  #put in the OS specific code in following block 

  #the database instance needs to be running in order to do the database checks
  if [[ $TYP != "-p" && $multiple_db -eq 0 ]]
  then
    if [[ ${stack_dbinst_up[$stack_counter]} -ne 0 ]]
    then
      echo -e $GREEN"Database instance $ORACLE_SID appears to be up on `hostname`.  Running audit checks on $ORACLE_SID instance"$NORM>>$LOGFIL
      echo "Database instance $ORACLE_SID appears to be up on `hostname`.  Running audit checks on $ORACLE_SID instance" >>$LOGFIL
      echo ""
      singleSqlValue "version" "instance" "v"
      VERSION=$sqlValue
      VERSION=$(echo $VERSION|awk '{print $3}')
      if [ "$VERSION" != "$DBVERSION" ]
      then
        #echo -e $RED"Audit script version ($DBVERSION) and database version ($VERSION) do not match"$NORM
        echo "Audit script version ($DBVERSION) and database version ($VERSION) do not match" >>$LOGFIL
        #echo ""
        #echo -e $RED"terminating audit check..."$NORM
        #echo "terminating audit check..." >>$LOGFIL
        #exit 1
      fi
    else
      if [[ ${rdbms_installed[$stack_counter]} -eq 1 ]]
      then
        #echo -e $RED"Database $db_name_to_check appears to be down. Skipping database related audit checks.$NORM \n"
        echo "Database instance $db_name_to_check appears to be down.  Skipping database related audit cheks.\n">>$LOGFIL
      fi
    fi
  fi

  #$READ -p "$SQLNUM $db_up"
  SQLNUM=`grep -c SQL_COMMAND_START $REFFIL`
  #for loop for muliple database sql collect to start here
  mb_db_counter=0
  for db_name_to_check in "${mb_db_names[@]}"
  do 
    echo -e "`date '+%a %b %d %H:%M:%S %Y'` - Initial SQL COllections started for $db_name_to_check\n">>$RACCHECK_TIMING
    #echo -e "`date '+%a %b %d %H:%M:%S %Y'` - Initial SQL COllections started for $db_name_to_check\n"
    sql_return_status=0
    SQLFIL=$OUTPUTDIR/d_check_${db_name_to_check}.sql
    UPDATEFIL=$OUTPUTDIR/db_update_${db_name_to_check}_$FDS.sql
    SPOOLFIL=$OUTPUTDIR/d_check_${db_name_to_check}.out      
    export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
    export ORACLE_SID=${mb_oracle_sids[$mb_db_counter]}
    DBUSR=${mb_sysdba_user[$mb_db_counter]}
    DBPWD=${mb_sysdba_pswd[$mb_db_counter]}
    #if [[ "$SQLNUM" -gt 0 && $TYP != "-p" ]] && [[ ${stack_db_status[$mb_db_counter]} -ne 0 || ${stack_dbinst_up[$stack_counter]} -ne 0 ]]

    #if [[ "$SQLNUM" -gt 0 && $TYP != "-p" ]]
    if [[ "$SQLNUM" -gt 0 ]]
    then 
      #Collecting stuff fro MAA
      singleSqlValue "open_mode" "database" "v"
      openMode=$sqlValue
      singleSqlValue "database_role" "database" "v"
      dbRole=$sqlValue
      singleSqlValue "version" "instance" "v"
      VERSION=$sqlValue
      VERSION=$(echo "$VERSION"|awk '{print $3}')
      echo "DB_NAME = $db_name_to_check|$VERSION|$ORACLE_HOME">>$MASTERFIL
      #$READ -p " see DB_VERSION $VERSION in $MASTERFIL"
      DB=$db_name_to_check
      #mb_database_role[$mb_db_counter]=$(echo "$dbRole"|$AWK 'BEGIN { FS = "= " };{print $2}'|sed 's/ /_/')
      mb_database_role[$mb_db_counter]=$(echo "$dbRole"|$AWK -F"=" '{print $2}'|cut -d ' ' -f2-3|sed 's/ /_/')
      if [ -z "${mb_database_role[$mb_db_counter]}" ]; then mb_database_role[$mb_db_counter]=$(echo "$dbRole"|$AWK '{print $3}'|sed 's/ /_/');fi
      echo "${db_name_to_check}.DATABASE_ROLE = ${mb_database_role[$mb_db_counter]}">>$MASTERFIL
      echo "${db_name_to_check}.DATABASE_TYPE = ${mb_database_type[$mb_db_counter]}">>$MASTERFIL
      if [[ ${#mb_database_role[@]} -gt 0 && ${mb_database_role[$mb_db_counter]} = "PRIMARY" ]]
      then
        singleSqlValue "global_name" "global_name" 
        global_name=$sqlValue
        mb_database_global_name[$mb_db_counter]=$(echo "$global_name"|awk '{print $3}')
      else
        singleSqlValue "db_unique_name" "database" "v"
        db_unique_name=$sqlValue
        mb_database_global_name[$mb_db_counter]=$(echo "$db_unique_name"|awk '{print $3}')
      fi   

      #echo "GlobalName = ${mb_database_global_name[$mb_db_counter]}"
      #mb_database_role[$mb_db_counter]=STANDBY
      #$READ -p " see $DB in $MASTERFIL"
      echo "${db_name_to_check}.GLOBAL_NAME = ${mb_database_global_name[$mb_db_counter]}">>$MASTERFIL

      if [[ ${#mb_checksysdba[@]} -gt 0 && ${mb_checksysdba[$mb_db_counter]} -eq 0 ]]
      then
        if [ $localnode = ${mb_running_host[$mb_db_counter]} ]
        then
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    get_dbOwner

            STORE_VAL=`su $dbOwner -c "echo \"set feedback  off heading off
   select distinct case when type = 'PHYSICAL' THEN D.NAME||'.PHYSICAL_STANDBY = '||1 ELSE D.NAME||'.PHYSICAL_STANDBY = '||0 end From gv\\\\\\\$archive_dest_status a,gv\\\\\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';\"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$"`
	    echo "$STORE_VAL" >>$MASTERFIL

            STORE_VAL=`su $dbOwner -c "echo \"set feedback  off heading off
   select distinct case when type = 'LOGICAL' THEN D.NAME||'.LOGICAL_STANDBY = '||1 ELSE D.NAME||'.LOGICAL_STANDBY = '||0 end from gv\\\\\\\$archive_dest_status a,gv\\\\\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';\"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$"`
	    echo "$STORE_VAL" >>$MASTERFIL

	    cd $OLD_DIR
	    unset OLD_DIR
	  else
            echo "set feedback  off heading off
   select distinct case when type = 'PHYSICAL' THEN D.NAME||'.PHYSICAL_STANDBY = '||1 ELSE D.NAME||'.PHYSICAL_STANDBY = '||0 end From gv\$archive_dest_status a,gv\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^$ >>$MASTERFIL
            echo "set feedback  off heading off
   select distinct case when type = 'LOGICAL' THEN D.NAME||'.LOGICAL_STANDBY = '||1 ELSE D.NAME||'.LOGICAL_STANDBY = '||0 end from gv\$archive_dest_status a,gv\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^$ >>$MASTERFIL
	  fi
        else #remote_database_code
          if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    get_dbOwner "${mb_running_host[$mb_db_counter]}"

            mb_mode_line=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
            export ORACLE_HOME=$ORACLE_HOME;
            export ORACLE_SID=$ORACLE_SID; 
	    cd "$dbhome_dir"; 
            su $dbOwner -c "echo \"set feedback  off heading off
  select distinct case when type = 'PHYSICAL' THEN D.NAME||'.PHYSICAL_STANDBY = '||1 ELSE D.NAME||'.PHYSICAL_STANDBY = '||0 end From gv\\\\\\\$archive_dest_status a,gv\\\\\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';\"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$"
            su $dbOwner -c "echo \"set feedback  off heading off
  select distinct case when type = 'LOGICAL' THEN D.NAME||'.LOGICAL_STANDBY = '||1 ELSE D.NAME||'.LOGICAL_STANDBY = '||0 end from gv\\\\\\\$archive_dest_status a,gv\\\\\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';\"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$"
EOF
)
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
            mb_mode_line=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
            export ORACLE_HOME=$ORACLE_HOME;
            export ORACLE_SID=$ORACLE_SID; 
            echo "set feedback  off heading off
   select distinct case when type = 'PHYSICAL' THEN D.NAME||'.PHYSICAL_STANDBY = '||1 ELSE D.NAME||'.PHYSICAL_STANDBY = '||0 end From gv\\\$archive_dest_status a,gv\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^$
            echo "set feedback off heading off
   select distinct case when type = 'LOGICAL' THEN D.NAME||'.LOGICAL_STANDBY = '||1 ELSE D.NAME||'.LOGICAL_STANDBY = '||0 end from gv\\\$archive_dest_status a,gv\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^$
EOF
)
	  fi
          echo "$mb_mode_line" >> $MASTERFIL
        fi
      else
        #following two lines were added to find out about standby like is there any logical or physical standby in use.
        if [[ ${#mb_running_host[@]} -gt 0 && $localnode = ${mb_running_host[$mb_db_counter]} ]]
        then
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    get_dbOwner

            STORE_VAL=`su $dbOwner -c "echo \"set feedback  off heading off
   select distinct case when type = 'PHYSICAL' THEN D.NAME||'.PHYSICAL_STANDBY = '||1 ELSE D.NAME||'.PHYSICAL_STANDBY = '||0 end From gv\\\\\\\$archive_dest_status a,gv\\\\\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$"`
	    echo "$STORE_VAL" >>$MASTERFIL

            STORE_VAL=`su $dbOwner -c "echo \"set feedback  off heading off
   select distinct case when type = 'LOGICAL' THEN D.NAME||'.LOGICAL_STANDBY = '||1 ELSE D.NAME||'.LOGICAL_STANDBY = '||0 end from gv\\\\\\\$archive_dest_status a,gv\\\\\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$"`
	    echo "$STORE_VAL" >>$MASTERFIL
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
            echo "set feedback off heading off
   select distinct case when type = 'PHYSICAL' THEN D.NAME||'.PHYSICAL_STANDBY = '||1 ELSE D.NAME||'.PHYSICAL_STANDBY = '||0 end From gv\$archive_dest_status a,gv\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^$ >>$MASTERFIL
            echo "set feedback off heading off
   select distinct case when type = 'LOGICAL' THEN D.NAME||'.LOGICAL_STANDBY = '||1 ELSE D.NAME||'.LOGICAL_STANDBY = '||0 end from gv\$archive_dest_status a,gv\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^$ >>$MASTERFIL
	  fi
        else #remote_database_code
	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	    get_dbOwner "${mb_running_host[$mb_db_counter]}"

            mb_mode_line=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
            export ORACLE_HOME=$ORACLE_HOME;
            export ORACLE_SID=$ORACLE_SID; 
	    cd "$dbhome_dir"; 
            su $dbOwner -c "echo \"set feedback  off heading off
  select distinct case when type = 'PHYSICAL' THEN D.NAME||'.PHYSICAL_STANDBY = '||1 ELSE D.NAME||'.PHYSICAL_STANDBY = '||0 end From gv\\\\\\\$archive_dest_status a,gv\\\\\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$"
            su $dbOwner -c "echo \"set feedback  off heading off
  select distinct case when type = 'LOGICAL' THEN D.NAME||'.LOGICAL_STANDBY = '||1 ELSE D.NAME||'.LOGICAL_STANDBY = '||0 end from gv\\\\\\\$archive_dest_status a,gv\\\\\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';\"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$"
EOF
)
	    cd $OLD_DIR
	    unset OLD_DIR
	  else
            mb_mode_line=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
            export ORACLE_HOME=$ORACLE_HOME;
            export ORACLE_SID=$ORACLE_SID; 
            echo "set feedback off heading off
  select distinct case when type = 'PHYSICAL' THEN D.NAME||'.PHYSICAL_STANDBY = '||1 ELSE D.NAME||'.PHYSICAL_STANDBY = '||0 end From gv\\\$archive_dest_status a,gv\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^$
            echo "set feedback off heading off
  select distinct case when type = 'LOGICAL' THEN D.NAME||'.LOGICAL_STANDBY = '||1 ELSE D.NAME||'.LOGICAL_STANDBY = '||0 end from gv\\\$archive_dest_status a,gv\\\$database d where D.inst_id=a.inst_id and A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^$
EOF
)
	  fi
          echo "$mb_mode_line" >> $MASTERFIL
        fi
      fi
    fi
    #echo "database_mode : $mb_mode_line"
    mb_db_counter=$(expr $mb_db_counter + 1) 
  done
  mb_db_counter=0
  #For loop for multiple database for sql collect to finish here
  #echo -e "\nLog file for collections and audit checks are at\n${LOGFIL}\n"
fi 
#IF TO CHECK THE OFFLINE MODE ENDS HERE

#echo "%%%%%%%%%%%%%%%%%%%%%%$sqlValue%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
# singleSqlValue "sysdate" "dual"
# singleSqlValue "count(instance_name)" "instance" "gv"
#---------------------------------------------------------------------
#for i in `$CRS/bin/olsnodes`

#this is test code to write database files for every run but not to overwrite for each node.
# it should work in offline as well as 
if [[ "$TYP" != "-p" ]]
then
  if [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq "1" ]]
  then
    DBACTUAL=/dev/null
    if [[ $OFFLINE -eq 0 || $RAT_RUNMODE_INTERNAL = "slave" ]] 
    then
      if [ $SILENT -eq 1 ]
      then
        UPLOADFIL_VAR=$(echo ${UPLOADFIL_VAR}_${localnode}_collect)
      else
        UPLOADFIL_VAR=$(echo ${UPLOADFIL_VAR}_${localnode})
      fi
      OUTPUTDIR_VAR=$(echo ${OUTPUTDIR_VAR}_${localnode})
      OUTPUTDIR_NEW=$WRKDIR/${OUTPUTDIR_VAR}_${FDS}_${TAG}
      UPLOADFIL=$WRKDIR/${UPLOADFIL_VAR}_${FDS}_${TAG}
    fi
  elif [ -n "$DB" ]
  then
    DBACTUAL=$OUTPUTDIR/d_actual_${DB}.out
    ent_naming=$DB
    #echo "" > $DBACTUAL 
    if [[ $OFFLINE -eq 0 || $RAT_RUNMODE_INTERNAL = "slave" ]]
    then
     if [ $is_windows -eq "0" ] ; then
      T_UPLOADFIL_VAR="$UPLOADFIL_VAR"
      if [ $SILENT -eq 1 ]
      then
        UPLOADFIL_VAR=$(echo ${UPLOADFIL_VAR}_${localnode}_${DB}_collect)
      else
        UPLOADFIL_VAR=$(echo ${UPLOADFIL_VAR}_${localnode}_${DB})
      fi
      if [[ -n "$db_name_to_check_none" && $db_name_to_check_none -eq 1 ]]
      then 
        UPLOADFIL_VAR=$(echo ${T_UPLOADFIL_VAR}_${localnode})
        OUTPUTDIR_VAR=$(echo ${OUTPUTDIR_VAR}_${localnode})
      else
        OUTPUTDIR_VAR=$(echo ${OUTPUTDIR_VAR}_${localnode}_${DB})
      fi
     fi
     UPLOADFIL=$WRKDIR/${UPLOADFIL_VAR}_${FDS}${TAG}
     OUTPUTDIR_NEW=$WRKDIR/${OUTPUTDIR_VAR}_${FDS}${TAG}
    fi 
  elif [ -n "${stack_asm_sid[0]}" ] 
  then
    if [[ $OFFLINE -eq 0 || $RAT_RUNMODE_INTERNAL = "slave" ]]
    then
      if [ $SILENT -eq 1 ]
      then
        UPLOADFIL_VAR=$(echo ${UPLOADFIL_VAR}_${localnode}_collect)
      else
        UPLOADFIL_VAR=$(echo ${UPLOADFIL_VAR}_${localnode})
      fi
      UPLOADFIL=$WRKDIR/${UPLOADFIL_VAR}_${FDS}${TAG}
      OUTPUTDIR_VAR=$(echo ${OUTPUTDIR_VAR}_${localnode})
      OUTPUTDIR_NEW=$WRKDIR/${OUTPUTDIR_VAR}_${FDS}${TAG}
    fi 
    #aName=$(echo ${stack_asm_sid[0]}|sed 's/[0-9]//g') 
    #DBACTUAL=$OUTPUTDIR/d_actual_${aName}.out
    #echo "" > $DBACTUAL 
  else
    DBACTUAL=/dev/null
    #To add hostname in collections name if database does not exists
    if [[ $OFFLINE -eq 0 || $RAT_RUNMODE_INTERNAL = "slave" ]] 
    then
      if [ $SILENT -eq 1 ]
      then
        UPLOADFIL_VAR=$(echo ${UPLOADFIL_VAR}_${localnode}_collect)
      else
        UPLOADFIL_VAR=$(echo ${UPLOADFIL_VAR}_${localnode})
      fi
      OUTPUTDIR_VAR=$(echo ${OUTPUTDIR_VAR}_${localnode})
      OUTPUTDIR_NEW=$WRKDIR/${OUTPUTDIR_VAR}_${FDS}${TAG}
      UPLOADFIL=$WRKDIR/${UPLOADFIL_VAR}_${FDS}${TAG}
    fi
  fi
fi

#user friendly collection name to insert into table
upload_collection_name=$(basename "$OUTPUTDIR_NEW")

if [ $OFFLINE -eq 0 ]; then echo -e "\nCollections and audit checks log file is \n${OUTPUTDIR_NEW}/log/${program_name}.log\n";fi
#if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 ]]; then rm $OUTPUTDIR/d_actual_*.out >/dev/null 2>&1;fi;
if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 ]]; then rm $OUTPUTDIR/d_actual_*.out >/dev/null 2>&1;fi;
#if [[ -e $DBACTUAL &&  -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 ]]; then rm $DBACTUAL >/dev/null 2>&1;fi;
#$READ -p "DB=$DB"
#$READ -p "UPLOADFIL=$UPLOADFIL OUTPUTDIR_NEW=$OUTPUTDIR_NEW"

#this is where xml for em plug gets initialized
#xml_prefix1="$program_name"
#xml_prefix2="$program_name"
#xml_prefix3="$program_name"
xml_prefix1="Exacheck"
xml_prefix2="ExaCheck"
xml_prefix3="exacheck"
if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
then
  rack_type=$EXALOGIC_RACK
  engs_machine="Exalogic"
  xml_prefix1="Exacheck"
  xml_prefix2="ExaCheck"
  xml_prefix3="exacheck"
elif [[ -n "$is_bda_machine" && $is_bda_machine -eq "1" ]]
then
  rack_type=N/A
  engs_machine="Big Data Appliance"
  xml_prefix1="Exacheck"
  xml_prefix2="ExaCheck"
  xml_prefix3="exacheck"
elif [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq "1" ]]
then
  rack_type=N/A
  engs_machine="Exalytics"
  xml_prefix1="Exacheck"
  xml_prefix2="ExaCheck"
  xml_prefix3="exacheck"
elif [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] 
then
  rack_type=$EXADATA_RACK
  engs_machine="Exadata"
  xml_prefix1="Exacheck"
  xml_prefix2="ExaCheck"
  xml_prefix3="exacheck"
elif [[ -n "$oda_machine" && $oda_machine -eq 1 ]]
then
  rack_type=""
  engs_machine="Database Appliance"
else
  rack_type=""
  engs_machine=""
fi

echo "<Checks>" > $XMLRECFIL

UTCTSTAMP=`date -u`

echo "<${xml_prefix1}Results modelVersion=\"$modelVersion\" RackType=\"$rack_type\" EngineeredSystems=\"$engs_machine\" RackIdentifier=\"$RackIdentifier\" TimeStamp=\"$UTCTSTAMP\" ExadataType=\"$EXADATA_VERSION\" xsi:noNamespaceSchemaLocation=\"${xml_prefix3}_result.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">" >$XMLREPFIL
echo "<${xml_prefix2}Exclusions modelVersion=\"$modelVersion\" RackType=\"$rack_type\" EngineeredSystems=\"$engs_machine\" RackIdentifier=\"$RackIdentifier\" ExadataType=\"$EXADATA_VERSION\" xsi:noNamespaceSchemaLocation=\"${xml_prefix3}_exclusion.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">" >$XMLSKIPFIL

if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_bda_machine" && $is_bda_machine -eq "1" ]] || [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]; 
then
  touch $COLLECT_TIMING
fi

if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_bda_machine" && $is_bda_machine -eq "1" ]]; 
then
  html_rack_type="System"
fi

if [ -z "$RAT_RUNMODE_INTERNAL" ] ; 
then
  RAT_RUNMODE_INTERNAL="master"
fi

parallel_run_feaible=0
if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -n "$is_bda_machine" && $is_bda_machine -eq "1" ]] || [[ -e "$EXPECT" ]] || [[ $rootYesNoint -eq "3" ]] || [[ "$usern" = "${root_user}" || $userid -eq 0 ]] ; 
then
  parallel_run_feaible=1
fi

#echo "parallel_run_feaible=$parallel_run_feaible"

if [[ -z "$RAT_COMPUTE_RUNMODE" ]] ; then RAT_COMPUTE_RUNMODE="parallel"; fi;

if [[ $RAT_RUNMODE_INTERNAL = "master" && -n "$RAT_COMPUTE_RUNMODE" && $RAT_COMPUTE_RUNMODE = "parallel" && $parallel_run_feaible -eq "0" && $localonly -eq "0" ]] ; 
then
  RAT_COMPUTE_RUNMODE="serial"
  echo -e "${RED}Running ${program_name} in $RAT_COMPUTE_RUNMODE mode because expect($EXPECT) is not available to supply ${root_user} passwords on remote nodes${NORM}" |tee -a $LOGFIL
  echo
  echo -e "${RED}NOTICE:  Installing the expect utility ($EXPECT) will allow ${program_name} to gather ${root_user} passwords at the beginning of the process and execute ${program_name} on all nodes in parallel speeding up the entire process. For more info - http://www.nist.gov/el/msid/expect.cfm.  Expect is available for all major platforms.  See User Guide for more details.${NORM}"
  echo;
fi

echo "Running in $RAT_COMPUTE_RUNMODE mode" >> $LOGFIL 

if [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]] 
then
  #echo "#### $INPUTDIR $OUTPUTDIR $DUMPDIR";
  OFFLINE=0
  TYP=$RUNSWITCH
  #outdir=`dirname $MASTERFIL`
  #indir=$INPUTDIR
  #INPUTDIR=$(ls -d `pwd`/.input_*|tail -1)
  #cp -R $INPUTDIR $indir
  #cp -R $OUTPUTDIR $outdir
  localnode=$RAT_LOCALNODE_INTERNAL
  echo $localnode  > $HOSTLIST
  #hostname |cut -d"." -f1 > $HOSTLIST
  #localnode=$(hostname |cut -d"." -f1)

  mb_db_counter=0
  for db_name_to_check in "${mb_db_names[@]}"
  do
    l_oh=$(grep -w "DB_NAME = $db_name_to_check" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f3)
    mb_oracle_homes[$mb_db_counter]=$l_oh
    mb_db_counter=$(expr $mb_db_counter + 1)
  done
  cp $INPUTDIR/*.dat $DUMPDIR
  cp -f $INPUTDIR/*.sh $DUMPDIR
  REFFIL=$DUMPDIR/collections.dat
  REFFIL1=$DUMPDIR/rules.dat
  ORCLENVFIL=$DUMPDIR/set_orcl_env.sh
  #Reassiging SYSTEM_DESC_FIL path back to compute node. initially it was cell temporory directory. now this file is available on compute node
  SYSTEM_DESC_FIL=${RTEMPDIR}/cell_system_description.out 
  #PROFILE="$HOME/.bash_profile"
  #if [ ! -f $PROFILE ]; then PROFILE="$HOME/.profile";fi
  #v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $8}')
  #usern=`whoami`
  root_need_cell_ssh=0
  if [ $op_mode -eq 1 ]
  then  
    REQUIRE_ROOT=`grep  "REQUIRES_ROOT_COUNT" $REFFIL|sed  -n 's/.*REQUIRES_ROOT_COUNT //p'| sed 's/^ *\(.*\) *$/\1/'`
  else
    REQUIRE_ROOT=`grep -c "REQUIRES_ROOT 1" $REFFIL`
  fi

  compute_rootpassword="$root_pass";
  if [[ -n "$RAT_COMPUTEPASSWORD_INTERNAL" && $RAT_COMPUTEPASSWORD_INTERNAL -ne "3" ]] ; then
    samerootpassword=1
  fi

  final_components=$components

  ea_db_node="$RAT_EA_DB_NODE_INTERNAL"
  ea_ec1_node="$RAT_EA_EC1_NODE_INTERNAL"
  ea_ovmm_node="$RAT_EA_OVMM_NODE_INTERNAL"
  ea_pc1_node="$RAT_EA_PC1_NODE_INTERNAL"
  ea_pc2_node="$RAT_EA_PC2_NODE_INTERNAL"
  print_pass_on_screen=$RAT_PRINT_PASS_ON_SCREEN_INTERNAL
 
  collection_date=$(grep "COLLECTION DATE = " $MASTERFIL| sed 's/COLLECTION DATE = //')
  upload_dbplatform=$(grep "DB_PLATFORM = " $MASTERFIL| sed 's/DB_PLATFORM = //'|sed 's/^\s//g'|sed 's/\s$//g')
  upload_osdistro=$(grep "OS_DISTRO = " $MASTERFIL| sed 's/OS_DISTRO = //'|sed 's/^\s//g'|sed 's/\s$//g')
  upload_oskernel=$(grep "OS_KERNEL = " $MASTERFIL| sed 's/OS_KERNEL = //'|sed 's/^\s//g'|sed 's/\s$//g')
  upload_osversion=$(grep "OS_VERSION = " $MASTERFIL| sed 's/OS_VERSION = //'|sed 's/^\s//g'|sed 's/\s$//g')
  DBVERSION=$DBVERSION_OFFLINE
  cluster_name=$(grep "CLUSTER_NAME = " $MASTERFIL| sed 's/CLUSTER_NAME = //')
  upload_collection_name=$RAT_UPLOAD_COLLECTION_NAME_INTERNAL
  cp $MASTERFIL $MASTERFIL.saved
fi

if [[ $OFFLINE -eq "0" && $is_exalogic_machine -eq 0 && $is_exalytics_machine -eq 0 && $is_bda_machine -eq 0 && $RAT_RUNMODE_INTERNAL = "master" ]]  
then
  for prompt_host in `cat $HOSTLIST`
  do
    PRMPTORCLENVFIL="$RTEMPDIR/prmpt_set_orcl_env_file.sh"
    cp -r  $ORCLENVFIL $PRMPTORCLENVFIL >/dev/null 2>&1
    echo $bash_source_check >>$PRMPTORCLENVFIL
    echo "exit 0" >>$PRMPTORCLENVFIL
    check_cascade_prompt 
  done
fi

if [[ $OFFLINE -eq 0 && -n "$RAT_COMPUTE_RUNMODE" && $RAT_COMPUTE_RUNMODE = "parallel" && $RAT_RUNMODE_INTERNAL = "master" ]] ; then
  stack_counter_l=1
  #for i in `cat $HOSTLIST |grep -v $localnode`
  for i in `grep -v $localnode $HOSTLIST`
  do
    if [[ -n "$samerootpassword" && $samerootpassword -eq 0 ]] ; then
      compute_rootpassword=${a_compute_rootpassword[$stack_counter_l]}
      stack_counter_l=$(expr $stack_counter_l + 1)
    fi
    get_cygpath "SYSTEM_DESC_FIL"
    $SCOPY $SYSTEM_DESC_FIL $i:$RTEMPDIR/ > /dev/null 2>&1
    restore_cygpath "SYSTEM_DESC_FIL"
    echo -e "\nStarting to run ${program_name} in background on $i\n"
    rm -f $RTEMPDIR/run.pid
    cr_file=$RTEMPDIR/${program_name}_compute_$i.sh
    run_file=$RTEMPDIR/${program_name}_run_slave_$i.sh
    echo "#!$bash_scr" > $cr_file
    echo "$RAT_DEBUG_FLG" >> $cr_file
    echo "echo \$\$ > $RTEMPDIR/run.pid" >> $cr_file
    echo "$SSHELL_EL $i $run_file" >> $cr_file
    chmod +x $cr_file

    echo "#!$bash_scr" > $run_file
    echo "$bash_source" >> $run_file
    echo "$RAT_DEBUG_FLG" >> $run_file
    echo "cd $RTEMPDIR; export RAT_RUNMODE_INTERNAL=slave; " >> $run_file
    echo "export RAT_LOCALNODE_INTERNAL=\"$i\"; " >> $run_file
    echo "export RAT_FDS_INTERNAL=\"${FDS}\"; " >> $run_file
    echo "export RAT_COMPUTE_RUNMODE=\"parallel\"; " >> $run_file
    #if  [[ $rootYesNoint -ne "3" ]] ; then
    #  echo "$READ -s -p \"Enter root password:\" root_pass" >>$run_file
    #  echo "$READ -s -p \"Start the run:\" run_start" >>$run_file
    #fi
    echo "export RAT_COMPUTEPASSWORD_INTERNAL=\"$rootYesNoint\"; " >> $run_file
    #echo "echo \"root password is \$root_pass\"" >> $run_file
    #echo "export RAT_COMPUTEPASSWORD_INTERNAL=\"$compute_rootpassword\"; " >> $run_file
    echo "export RAT_PRINT_PASS_ON_SCREEN_INTERNAL=\"$print_pass_on_screen\"; " >> $run_file
    echo "export RAT_EA_DB_NODE_INTERNAL=$ea_db_node" >> $run_file
    echo "export RAT_EA_EC1_NODE_INTERNAL=$ea_ec1_node" >> $run_file
    echo "export RAT_EA_OVMM_NODE_INTERNAL=$ea_ovmm_node" >> $run_file
    echo "export RAT_EA_PC1_NODE_INTERNAL=$ea_pc1_node" >> $run_file
    echo "export RAT_EA_PC2_NODE_INTERNAL=$ea_pc2_node" >> $run_file
    echo "export RAT_UPLOAD_COLLECTION_NAME_INTERNAL=$upload_collection_name" >> $run_file
    # Set all RAT_ env in remote nodes also
    env | grep RAT_ | grep -wv RAT_OUTPUT > $OUTPUTDIR/rat_env.txt
    while read envs
    do
      e_key=$(echo $envs| cut -d"=" -f1)
      e_val=$(echo $envs| sed 's/[^=]*=//')
      echo "export $e_key=\"$e_val\"" >> $run_file
    done < $OUTPUTDIR/rat_env.txt
    echo "echo > $RTEMPDIR/empty.log" >> $run_file
    echo "echo > $RTEMPDIR/empty.log" >> $run_file
    echo "echo > $RTEMPDIR/empty.log" >> $run_file
    scr=$(basename $0)
    #echo "./$scr -f < $RTEMPDIR/empty.log" >> $run_file
    if [[ -n "$bash_path" ]] ; then
      echo "export PATH=$bash_path:$PATH" >> $run_file
    fi

    slavedebugFileName=$RTEMPDIR/${program_name}_${i}_slave_debug.log

    if [ -n "$options_components" ]; then
      if [[ -n "$RAT_CLIENT_DEBUG" && $RAT_CLIENT_DEBUG -eq "1" ]]
      then
	echo "$bash_scr ./$scr -f -c $options_components 2>$slavedebugFileName" >> $run_file
      else
        echo "$bash_scr ./$scr -f -c $options_components" >> $run_file
      fi
    else
      if [[ -n "$RAT_CLIENT_DEBUG" && $RAT_CLIENT_DEBUG -eq "1" ]]
      then
	echo "$bash_scr ./$scr -f 2>$slavedebugFileName" >> $run_file
      else
        echo "$bash_scr ./$scr -f" >> $run_file
      fi
    fi
    chmod +x $run_file
    get_cygpath "WRKDIR"
    get_cygpath "SCRIPTPATH"
    get_cygpath "INPUTDIR"
    get_cygpath "OUTPUTDIR"
    get_cygpath "RTEMPDIR"
    #$SCOPY -r $run_file $0 $WRKDIR/cgrep $SCRIPTPATH/collections.dat $SCRIPTPATH/rules.dat $SCRIPTPATH/.cgrep/ $INPUTDIR $OUTPUTDIR $i:$RTEMPDIR/ > /dev/null 2>&1
    $SCOPY -r $run_file $RPDIR/${program_name} $WRKDIR/cgrep $SCRIPTPATH/collections.dat $SCRIPTPATH/rules.dat $SCRIPTPATH/.cgrep/ $INPUTDIR $OUTPUTDIR $i:$RTEMPDIR/ > /dev/null 2>&1
    restore_cygpath "WRKDIR"
    restore_cygpath "SCRIPTPATH"
    restore_cygpath "INPUTDIR"
    restore_cygpath "OUTPUTDIR"
    restore_cygpath "RTEMPDIR"
    if [ -e "$EXCLUDEFIL" ] ; then
      get_cygpath "EXCLUDEFIL"
      $SCOPY $EXCLUDEFIL $i:$RTEMPDIR/ > /dev/null 2>&1
      restore_cygpath "EXCLUDEFIL"
    fi

    is_SSH_blocked "$i" "$usern" "$compute_rootpassword"

    if [[ $SSH_blocked -eq 1 ]]; then
      echo -e "\n${RED}${i} is reachable but SSH is blocked.No collections and audit checks will be executed on ${i}${NORM}\n"|tee -a $LOGFIL
      add_to_skipped_nodes "${i}" "SSH Issue: Node is reachable but SSH is blocked"
      continue;
    fi

    if  [[ $rootYesNoint -eq "3" || $userid -eq 0 ]] ; then
      $cr_file > $OUTPUTDIR/$i.slave.log </dev/null 2>&1 &
      run_pid=$!
    else
      fixRootPassword "$compute_rootpassword"
      $EXPECT -f - > $OUTPUTDIR/$i.slave.log 2>&1 </dev/null << IBEOF &
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }
        set timeout $passwordcheck_timeout
	set le_compute_rootpassword "$fixedRootPassword"
        spawn -noecho $cr_file
        match_max 100000
        log_user 0
        expect -nocase "password:*";
	send -- "\$le_compute_rootpassword\n";
        expect -nocase "run:*";
        send -- "\n";
        set timeout -1
        log_user 1 
        expect -nocase eof
        exit
IBEOF
      #run_pid=$(cat $RTEMPDIR/run.pid)
      run_pid=$!
    fi
    touch $RTEMPDIR/nowatch.pid
    echo "$run_pid" >>  $RTEMPDIR/nowatch.pid
    cpids[$run_pid]="$run_pid";
    cpid_names[$run_pid]="$i"
  done

  # Master runs only on local node
  mv $HOSTLIST $HOSTLIST.org
  echo $localnode > $HOSTLIST
fi

#echo "Using $REFFIL and $REFFIL1";
if [[ $OFFLINE -eq "0" ]]
then
  echo "FAIL = 0" >> $CELLIBNTFILE
  echo "WARN = 0" >> $CELLIBNTFILE
  echo "INFO = 0" >> $CELLIBNTFILE
  echo "TOTAL = 0" >> $CELLIBNTFILE

  sed "/MULTIPLE_ORACLE_HOMES =/d" $MASTERFIL > $MASTERFIL.new
  if [ ! -z $multiple_oracle_homes ]
  then 
    echo "MULTIPLE_ORACLE_HOMES = $multiple_oracle_homes" >> $MASTERFIL.new
  else
    echo "MULTIPLE_ORACLE_HOMES = 0" >> $MASTERFIL.new
  fi
  mv -f $MASTERFIL.new $MASTERFIL
fi

if [ -n "$MERGEFILES" ]
then 
  echo -e ""

  d_index=0;
  slave_check_index=""
  for xdir in $dirarr
  do	
    echo -e ""
    echo -e "Started merging $xdir"
    
    xdir=`basename $xdir`;
    xdir=$(echo $xdir|sed 's/\.zip//g');
    
    copy_from_dir;
    d_index=$(expr $d_index + 1);
  done
  mv $HOSTLIST $HOSTLIST.new
  touch $HOSTLIST
fi

if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then cp ${HOSTLIST} $TMP_OUTPUT; fi

#HOST LOOP Starts 
get_current_epoch "1"
start_time=$epoch_time

echo "Start Time:$start_time" >> $LOGFIL

for i in `cat $HOSTLIST`
do
  if [[ `grep -wic "$i.EMAGENT_INSTALLED = 1" $MASTERFIL` -gt 0 ]];then
	is_emagent_installed=1;
	mb_emagent_home=`grep "$i.EMAGENT_HOME" $MASTERFIL|cut -d'=' -f2|sed 's/ //g'`;
        agent_inst=`grep "$i.EMAGENT_INST " $MASTERFIL|cut -d'=' -f2|sed 's/ //g'`;
  else
	is_emagent_installed=0;
  fi

  if [[ -n "$is_exalogic_guest_vm" && $is_exalogic_guest_vm -eq "1" ]]  
  then
    OSCHECKRESULT=$OUTPUTDIR/o_audit_result_${i}.out
    skipnode=`grep LOCALNODE $MASTERFIL |awk '{print $3}'`
    if [ $i = $skipnode ]
    then
      continue
    fi
  fi 

  echo "=============================================================" |tee -a $LOGFIL |tee -a $REPFIL_FAIL|tee -a $SREPFIL_FAIL|tee -a $SREPFIL_PASS|tee -a $REPFIL_PASS
  echo "                    Node name - $i                                " |tee -a $LOGFIL |tee -a $REPFIL_FAIL|tee -a $SREPFIL_FAIL|tee -a $SREPFIL_PASS|tee -a $REPFIL_PASS
  echo "=============================================================" |tee -a $LOGFIL |tee -a $REPFIL_FAIL|tee -a $SREPFIL_FAIL|tee -a $SREPFIL_PASS|tee -a $REPFIL_PASS

  #tried to fix not to execute opatch if another nodes does not have oracle binaries.
  if [[ ${crs_installed[$stack_counter]} -eq 0 && $single_instance_run -eq "0" ]]; then TYP="-b";fi;
  if [[ ${crs_installed[$stack_counter]} -eq 0 && ${rdbms_installed[$stack_counter]}  -eq 0 ]]; then TYP="-b";fi;
  #

  #calling Exa functions to re-assign modules for each not to support hybrid racks
  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]; then  assign_exalogic_module "$i" ;fi
  #this fucction will check either its a db machine or not for each node
  if [[ "$i" != "$localnode" || $RAT_RUNMODE_INTERNAL = "slave" ]] ; then is_this_db_machine $i; bda_machine_type $i;add_maa_scorecard;add_hacheck; write_db_machine_info_to_envfile $i;fi 

  #assign the right status for stack variables
  assign_stack_status;

  ACREPCOUNT=0
  call_zfs_collection=1

  #In profile run call zfs collection only if zfs profile is selected
  if [[ -n "$run_profile" && $run_profile -eq "1" && $zfs_in_profile -eq "0" && $ellite_in_profile -eq "0" && $elextensive_in_profile -eq "0" ]] ; then
    call_zfs_collection=0
  fi

  if [[ $call_zfs_collection -eq "1" ]] ; then
    if [ $is_ssc_machine -eq 2  ]
    then
      execute_zfs_collection "$ZFSIP" "$ZFSAKSHSCRIPT"
    elif [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]]
    then
      if [ -e "$CELLIP" ]; then execute_zfs_collection "$CELLIP" "$ZFSAKSHSCRIPT"; fi;
    fi
    if [[ -n "$RAT_GLOBAL_RUNMODE" && $RAT_GLOBAL_RUNMODE = "parallel" ]]; then wait_for_cell_completion; fi
    echo -e ""
  fi

  if [ $RUNSWITCH != "-p" ]
  then
    case $TYP in
      -a|-b|-f|-u)
         current_check=1
         CUR_LEVEL=1   
         #following if is to set L1 to 1 in offline if there are no OS_COLLECT in data file and osCheckIndexNo has value like -OSCOLLECTCOUNT 0. did this chage for Exalytics 
         if [[ $OFFLINE -eq 1 && `echo $osCheckIndexNo|grep -c [A-Z]` -ge 1 ]];then osCheckIndexNo=1;fi
         #this is to skip collections in offline
         if [ $OFFLINE -eq 0 ];then L1=1;else L1=$osCheckIndexNo;fi
         L2=0;L3=0;L4=0;L5=0;L6=0;L7=0;L8=0;L9=0;L10=0;
         ROW=$L1.$L2.$L3.$L4.$L5.$L6.$L7.$L8.$L9.$L10
         OSSPOOLFIL="$OSOUTFIL"_"$i".out
         #ROOTSCRPT="$INPUTDIR/root_${program_name}".sh
         IBSWITCHSCRPT="$INPUTDIR/${program_name}_ibswitch".sh
         CELLSSCRPT="$INPUTDIR/${program_name}_cells".sh
         if [ -f $ROOTSCRPT ];then rm -f $ROOTSCRPT; fi;
         if [ $op_mode -eq 1 ]
         then
           OSCOLLECTSUM=`grep  "OS_COLLECT_COUNT" $REFFIL|sed  -n 's/.*OS_COLLECT_COUNT //p'| sed 's/^ *\(.*\) *$/\1/'`
         else
           OSCOLLECTSUM=`grep -c "OS_COLLECT_COMMAND_START" $REFFIL`
         fi
         #$READ -p "OSCOLLECTSUM=$OSCOLLECTSUM"
         OSCOLLECTCNT=0
         OSCHECKRESULT=$OUTPUTDIR/o_audit_result_${i}.out
         OSPKGSILENT=$OUTPUTDIR/o_pkg_status_silent_${i}.out
         OSACTUAL=$OUTPUTDIR/o_actual_${i}.out
         AACTUAL=$OUTPUTDIR/a_actual_${i}.out
         if [[ -e $OSACTUAL &&  -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 ]]; then rm $OSACTUAL >/dev/null 2>&1;fi;
         if [[ -e $AACTUAL &&  -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 ]]; then rm $AACTUAL >/dev/null 2>&1;fi;

         # store the old value for clusterware_check_count for previous compute node because if current node is control VM than clusterware_check_count will not increase
         if [[ -n "$clusterware_check_count" &&  $clusterware_check_count -gt 0 ]]; then clusterware_check_count_old=$clusterware_check_count;fi
         #$READ -p "clusterware_check_count=$clusterware_check_count clusterware_check_count_old=$clusterware_check_count_old"
         clusterware_check_count=0
         collect_file_counter=0
         cls_check_host_list[$stack_counter]=$i
         if [[ -e $OGGHOMESVERSIONFIL && `grep -wic $i $OGGHOMESVERSIONFIL` -gt 0 ]];then is_goldengate_installed=1;else is_goldengate_installed=0;fi
         echo "is_goldengate_installed =$is_goldengate_installed on $i and file is $OGGHOMESVERSIONFIL">>$LOGFIL
         #echo "" >$OSACTUAL

         if  [ $OFFLINE -eq 0 ]
         then
           echo -e "`date '+%a %b %d %H:%M:%S %Y'` - Execution started on $i\n">>$RACCHECK_TIMING
           if [[ $SUDOCMD != "/usr/bin/sudo" ]]
           then
             # A valid sudo command was set up, so I know this is being run by Oracle and I don't need the below environment variables.  I need the
             # root_raccheck.sh script to look exactly the same in every instance so that the Dell sudo command works and adding specific system
             # environment variables will mess that up!
             ORACLEENVVARS=SetOracleEnvVars
             echo "#!$bash_scr">>$TMPDIR/$ORACLEENVVARS
             echo "$bash_source">>$TMPDIR/$ORACLEENVVARS
             echo "$RAT_DEBUG_FLG">>$TMPDIR/$ORACLEENVVARS	   
             echo "export ORACLE_HOME=$ORACLE_HOME">>$TMPDIR/$ORACLEENVVARS
             echo "export CRS_HOME=$CRS">>$TMPDIR/$ORACLEENVVARS
             echo "export ORACLE_SID=$ORACLE_SID">>$TMPDIR/$ORACLEENVVARS
             echo "">>$ROOTSCRPT
             echo ". $TMPDIR/$ORACLEENVVARS">>$ROOTSCRPT
             echo "echo -e \"\\n\\n\`date '+%a %b %d %H:%M:%S %Y'\` - STARTED ON  \`hostname|cut -d. -f1\`\" >>${RTEMPDIR}/o_root_collect_timing.out" >>$ROOTSCRPT
           else
             ORACLEENVVARS=SetOracleEnvVarsPlaceHolder
             echo "#!$bash_scr">>$ROOTSCRPT
             echo "$bash_source">>$ROOTSCRPT
             echo "$RAT_DEBUG_FLG">>$ROOTSCRPT
             echo "if [ -e $PROFILE ]; then . $PROFILE>/dev/null 2>&1;fi">>$ROOTSCRPT   
             echo "export ORACLE_HOME=$ORACLE_HOME">>$ROOTSCRPT
             echo "export CRS_HOME=$CRS">>$ROOTSCRPT
             echo "export TMPDIR=$TMPDIR">>$ROOTSCRPT   
             echo "export RTEMPDIR=$RTEMPDIR">>$ROOTSCRPT   
             #echo "export ORA_CRS_HOME=$CRS">>$ROOTSCRPT
             echo "export ORACLE_SID=$ORACLE_SID">>$ROOTSCRPT
             echo "echo -e \"\\n\\n\`date '+%a %b %d %H:%M:%S %Y'\` - STARTED ON  \`hostname|cut -d. -f1\`\\n\" >>${RTEMPDIR}/o_root_collect_timing.out" >>$ROOTSCRPT
             if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
             then 
               echo "export PATH=\$PATH:/usr/local/bin:/bin:/usr/bin:/sbin:/usr/sbin:/opt/MegaRAID/MegaCli/:/opt/oracle/cell/cellsrv/bin">>$ROOTSCRPT
              echo "export OSS_BIN=/opt/oracle/cell/cellsrv/bin">>$ROOTSCRPT
             fi
           fi
           if [[ -n "$ibswitch_password_status" && $ibswitch_password_status -eq 1 ]]
           then 
             echo "#!/bin/env bash">>$IBSWITCHSCRPT
             echo "$RAT_DEBUG_FLG">>$IBSWITCHSCRPT
             echo "export RTEMPDIR=$IBRTEMPDIR">>$IBSWITCHSCRPT
             echo "export TMPDIR=$TMPDIR">>$IBSWITCHSCRPT
             echo "export IBTMPDIR=$IBTMPDIR">>$IBSWITCHSCRPT
             echo "export SWITCH_TYPE_FIL=${IBRTEMPDIR}/${SWITCH_TYPE_FIL_SHORT}">>$IBSWITCHSCRPT
             echo "echo -e \"\\n\\n\`date '+%a %b %d %H:%M:%S %Y'\` - STARTED ON  \`hostname|cut -d. -f1\`\\n\" >>${IBRTEMPDIR}/s_root_collect_timing.out" >>$IBSWITCHSCRPT
           fi
           if [[ $root_need_cell_ssh -eq 0 ]]
           then 
             echo "#!/bin/env bash">>$CELLSSCRPT
             echo "$RAT_DEBUG_FLG">>$CELLSSCRPT
             echo "if [ -e $PROFILE ]; then . $PROFILE>/dev/null 2>&1;fi">>$CELLSSCRPT
             echo "export PATH=\$PATH:/usr/local/bin:/bin:/usr/bin:/sbin:/usr/sbin:/opt/MegaRAID/MegaCli/:/opt/oracle/cell/cellsrv/bin">>$CELLSSCRPT
             echo "export OSS_BIN=/opt/oracle/cell/cellsrv/bin">>$CELLSSCRPT
             echo "export RTEMPDIR=$CELLRTEMPDIR">>$CELLSSCRPT
             echo "export TMPDIR=$TMPDIR">>$CELLSSCRPT
             echo "export CELLTMPDIR=$CELLTMPDIR">>$CELLSSCRPT
             echo "echo -e \"\\n\\n\`date '+%a %b %d %H:%M:%S %Y'\` - STARTED ON  \`hostname|cut -d. -f1\`\\n\" >>${CELLRTEMPDIR}/c_root_collect_timing.out" >>$CELLSSCRPT
           fi
           if [[ -e $ORCLENVFIL ]]; then chmod 744 $ORCLENVFIL; fi
           if [ $i = $localnode ]
           then
             cp $ORCLENVFIL $TMPDIR/ 2>/dev/null
             cp $MASTERFIL $TMPDIR/ 2>/dev/null
           else
             #following code is to put the correct ORACLE_SID in ORAENVFIL which is used to set the environment on each host
             sed  "/ORACLE_SID/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
             cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
             rm $INPUTDIR/tmp_env_file.out
             echo "export ORACLE_SID=${stack_dbinst_name[$stack_counter]}">>$ORCLENVFIL
             if [ $is_windows -eq "1" ] ; then
               scp_ORCLENVFIL=$(cygpath $ORCLENVFIL)
               scp_MASTERFIL=$(cygpath $MASTERFIL)
               $SCOPY $scp_ORCLENVFIL $i:$TMPDIR/ >/dev/null
               $SCOPY $scp_MASTERFIL $i:$TMPDIR/ >/dev/null 
             else
               $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null
               $SCOPY $MASTERFIL $i:$TMPDIR/ >/dev/null 
             fi
           fi
           TRGTORCLENV=$TMPDIR/`basename $ORCLENVFIL`
         #end here
         fi

         #ROOTFLG=0
         #no_of_checks_to_execute=$(grep -c "CHECK_ID" $REFFIL)
         #last_check_in_dat=$(cat $REFFIL|sed -n ''${no_of_checks_to_execute}'p'|cut -d\. -f1|cut -d_ -f2) 
         #$READ -p "no_of_checks_to_execute=$no_of_checks_to_execute last_check_in_dat=$last_check_in_dat"
         #db_name_to_check=$(cat $running_db_list|sed -n ''${db_to_check}'p') 

         while [ -n "$ROW" ]
         #while [ "$ROW" -le $last_check_in_dat ]
         do
           #$READ -p "ROW=$ROW"
           while [[ -z "$LEVEL" && $CUR_LEVEL -gt 0 ]]
           do
             #LEVEL=`grep _$ROW\-LEVEL $REFFIL |awk {'print $2'}`
             LEVEL=`grep _$ROW\-LEVEL $REFFIL |cut -d- -f2|awk '{print $2}'`
             #LEVEL=`grep _$ROW $REFFIL |awk {'print $2'}`
             #echo "ROW=$ROW, LEVEL=$LEVEL"
             if [[ -z "$LEVEL" && $L1 -gt 0 ]]
             then
               #we didn't find anything for the current ROW
               #that being the case we need to traverse up a level and keep looking
               #until we have nowhere else to look
               case $CUR_LEVEL in
                10) L10=0; L9=$(($L9+1)); CUR_LEVEL=9 ;;
                 9) L9=0; L8=$(($L8+1)); CUR_LEVEL=8 ;;
                 8) L8=0; L7=$(($L7+1)); CUR_LEVEL=7 ;;
                 7) L7=0; L6=$(($L6+1)); CUR_LEVEL=6 ;;
                 6) L6=0; L5=$(($L5+1)); CUR_LEVEL=5 ;;
                 5) L5=0; L4=$(($L4+1)); CUR_LEVEL=4 ;;
                 4) L4=0; L3=$(($L3+1)); CUR_LEVEL=3 ;;
                 3) L3=0; L2=$(($L2+1)); CUR_LEVEL=2 ;;
                 2) L2=0; L1=$(($L1+1)); CUR_LEVEL=1 ;;
                 1) L1=0; CUR_LEVEL=0 ;;
               esac

               if [ $L1 -gt 0 ]
               then
                 ROW=$L1.$L2.$L3.$L4.$L5.$L6.$L7.$L8.$L9.$L10
               else
                 ROW=
               fi
               #echo "CURRENT LEVEL MAIN LOOP = $CUR_LEVEL"
             fi
             #echo "LOOP ROW = $ROW" 
           done
           unset execute_once COMTYPE PARAM_PATH ISBRANCH REQUIRES_ROOT_OS PARAM NEEDS_RUNNING OP COMP ALVL PMSG FMSG SF CAT SUBCAT COM_REPORT SOURCEFIL_REPORT SOURCEFIL_REPORT_NEW audit_check_name OPSTAT database_mode check_exadata_version check_database_role check_database_type

   	   # _1.0.0.0.0.0.0.0.0.0-LEVEL 1-CHECK_ID 5ADE41BF1E15571AE0401490CACF3E60 
   	   # gadiga added multiple version support whcih appends version to end
           if [ $op_mode -eq 1 ] 
           then
             CHECK_ID=`grep "_${ROW}-LEVEL ${LEVEL}-CHECK_ID" $REFFIL|sed  -n 's/.*CHECK_ID //p'| sed 's/^ *\(.*\) *$/\1/'`
           else
             CHECK_ID=`grep "_${ROW}-CHECK_ID" $REFFIL|sed  -n 's/.*CHECK_ID //p'| sed 's/^ *\(.*\) *$/\1/'`
           fi    

           run_in_multiple_versions=0
           versions_to_run=""
           if [ `echo "$CHECK_ID" | grep -c " "` -gt 0 ]
           then
             run_in_multiple_versions=1
             versions_to_run="$CHECK_ID";
             CHECK_ID=$(echo "$CHECK_ID" | awk '{print $1}')
             versions_to_run=$(echo $versions_to_run | sed 's/'$CHECK_ID' //')
             if [ -n "$RAT_DEBUG_V" ] ; then echo "$ROW $CHECK_ID runs only on $versions_to_run"; fi;
           else
             if [ -n "$RAT_DEBUG_V" ] ; then echo "$ROW $CHECK_ID is running"; fi;
           fi
           #run_in_multiple_versions=0
           #$READ -p "CHECK_ID=$CHECK_ID $REFFIL $REFFIL1 ROW=$ROW LEVEL=$LEVEL"
           CLUSTERCHECK_FIL=${OUTPUTDIR}/${CHECK_ID}.out
           #reading audit_checK_name and collection_name here to support skipping checks based on name

           if [ $op_mode -eq 0 ]
           then 
             COMTYPE=`grep _$ROW\-TYPE $REFFIL |awk {'print $2'}` 
             PARAM_PATH=`grep _$ROW\-PARAM_PATH $REFFIL |awk {'print $2'}` 
             HOME_PATH=`grep _$ROW\-HOME_PATH $REFFIL |awk {'print $2'}` 
             ISBRANCH=`grep _$ROW\-IS_BRANCH $REFFIL |awk {'print $2'} `
             REQUIRES_ROOT_OS=`grep _$ROW\-REQUIRES_ROOT $REFFIL |awk {'print $2'}`
             PARAM=`grep "_"$ROW"-PARAM_PATH" $REFFIL |sed  -n 's/.*PARAM_PATH //p'`
             NEEDS_RUNNING=`grep "_"$ROW"-NEEDS_RUNNING" $REFFIL |sed  -n 's/.*NEEDS_RUNNING //p'| sed 's/^ *\(.*\) *$/\1/'`
             TARGET_TYPE=`grep "_"$ROW"-TARGET_TYPE" $REFFIL |sed  -n 's/.*TARGET_TYPE //p'| sed 's/^ *\(.*\) *$/\1/'`
             execute_once=`grep "_"$ROW"-EXECUTE_ONCE" $REFFIL |sed  -n 's/.*EXECUTE_ONCE //p'| sed 's/^ *\(.*\) *$/\1/'`
             SF=`grep "_"$ROW"-SF" $REFFIL |sed  -n 's/.*-SF //p'` 
             check_components=`grep "_"$ROW"-COMPONENTS" $REFFIL |sed  -n 's/.*COMPONENTS //p'| sed 's/^ *\(.*\) *$/\1/'`
             OP=`grep _$ROW\-OPERATOR $REFFIL |sed  -n 's/.*OPERATOR //p'`
             if [[ -z "$OP && -e $REFFIL1 ]];then OP=`grep _$ROW\-OPERATOR $REFFIL1 |sed  -n 's/.*OPERATOR //p'`;fi
             COMP=`grep "_"$ROW"-COMPARE_VALUE" $REFFIL |sed  -n 's/.*COMPARE_VALUE //p'` 
             if [[ -z "$COMP && -e $REFFIL1 ]];then COMP=`grep "_"$ROW"-COMPARE_VALUE" $REFFIL1 |sed  -n 's/.*COMPARE_VALUE //p'`;fi
             check_exadata_version=$(grep "_"$ROW"-EXADATA_VERSION" $REFFIL |sed  -n 's/.*EXADATA_VERSION //p'| sed 's/^ *\(.*\) *$/\1/')
             check_database_role=$(grep "_"$ROW"-DATABASE_ROLE" $REFFIL |sed  -n 's/.*DATABASE_ROLE //p'| sed 's/^ *\(.*\) *$/\1/')
             check_database_type=$(grep "_"$ROW"-DATABASE_TYPE" $REFFIL |sed  -n 's/.*DATABASE_TYPE //p'| sed 's/^ *\(.*\) *$/\1/')
             check_database_mode=$(grep "_"$ROW"-DATABASE_MODE" $REFFIL |sed  -n 's/.*DATABASE_MODE //p'| sed 's/^ *\(.*\) *$/\1/')
             audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
             COLLECTION_NAME=`grep "_"$ROW"-COLLECTION_NAME" $REFFIL |sed  -n 's/.*COLLECTION_NAME //p'`     
             COLLECTION_DIFF_CANDIDATE=`grep _$ROW\-COLLECTION_DIFF_CANDIDATE $REFFIL |awk {'print $2'}`
	     LOGIC=`grep _$ROW\-LOGIC $REFFIL |awk {'print $2'}`
	     OUTFILVAL=`grep _$ROW\-OUTPUT_FILE $REFFIL |awk {'print $2'}`
           else
             COMTYPE=`grep _$CHECK_ID\-TYPE $REFFIL |awk {'print $2'}` 
             #$READ -p "COMTYPE =$COMTYPE"
             PARAM_PATH=`grep _$CHECK_ID\-PARAM_PATH $REFFIL |awk {'print $2'}` 
             HOME_PATH=`grep _$CHECK_ID\-HOME_PATH $REFFIL |awk {'print $2'}` 
             ISBRANCH=`grep _$CHECK_ID\-IS_BRANCH $REFFIL |awk {'print $2'} `
             REQUIRES_ROOT_OS=`grep _$CHECK_ID\-REQUIRES_ROOT $REFFIL |awk {'print $2'}`
             PARAM=`grep "_"$CHECK_ID"-PARAM_PATH" $REFFIL |sed  -n 's/.*PARAM_PATH //p'`
             NEEDS_RUNNING=`grep "_"$CHECK_ID"-NEEDS_RUNNING" $REFFIL |sed  -n 's/.*NEEDS_RUNNING //p'| sed 's/^ *\(.*\) *$/\1/'`
             TARGET_TYPE=`grep "_"$CHECK_ID"-TARGET_TYPE" $REFFIL |sed  -n 's/.*TARGET_TYPE //p'| sed 's/^ *\(.*\) *$/\1/'`
             execute_once=`grep "_"$CHECK_ID"-EXECUTE_ONCE" $REFFIL |sed  -n 's/.*EXECUTE_ONCE //p'| sed 's/^ *\(.*\) *$/\1/'`
             check_exadata_version=$(grep "_"$CHECK_ID"-EXADATA_VERSION" $REFFIL |sed  -n 's/.*EXADATA_VERSION //p'| sed 's/^ *\(.*\) *$/\1/')
             check_database_role=$(grep "_"$CHECK_ID"-DATABASE_ROLE" $REFFIL |sed  -n 's/.*DATABASE_ROLE //p'| sed 's/^ *\(.*\) *$/\1/')
             check_database_type=$(grep "_"$CHECK_ID"-DATABASE_TYPE" $REFFIL |sed  -n 's/.*DATABASE_TYPE //p'| sed 's/^ *\(.*\) *$/\1/')
             check_database_mode=$(grep "_"$CHECK_ID"-DATABASE_MODE" $REFFIL |sed  -n 's/.*DATABASE_MODE //p'| sed 's/^ *\(.*\) *$/\1/')
             SF=`grep "_"$CHECK_ID"-SF" $REFFIL |sed  -n 's/.*-SF //p'` 
             check_components=`grep "_"$CHECK_ID"-COMPONENTS" $REFFIL |sed  -n 's/.*COMPONENTS //p'| sed 's/^ *\(.*\) *$/\1/'`
             OP=`grep _$CHECK_ID\-OPERATOR $REFFIL |sed  -n 's/.*OPERATOR //p'`
             if [[ -z "$OP" && -e $REFFIL1 ]];then OP=`grep _$CHECK_ID\-OPERATOR $REFFIL1 |sed  -n 's/.*OPERATOR //p'`;fi
             COMP=`grep "_"$CHECK_ID"-COMPARE_VALUE" $REFFIL |sed  -n 's/.*COMPARE_VALUE //p'` 
             if [[ -z "$COMP" && -e $REFFIL1 ]];then  COMP=`grep "_"$CHECK_ID"-COMPARE_VALUE" $REFFIL1 |sed  -n 's/.*COMPARE_VALUE //p'`;fi
             audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'` 
             COLLECTION_NAME=`grep "_"$CHECK_ID"-COLLECTION_NAME" $REFFIL |sed  -n 's/.*COLLECTION_NAME //p'`
	     COLLECTION_DIFF_CANDIDATE=`grep _$CHECK_ID\-COLLECTION_DIFF_CANDIDATE $REFFIL |awk {'print $2'}`
	     LOGIC=`grep _$CHECK_ID\-LOGIC $REFFIL |awk {'print $2'}`
	     OUTFILVAL=`grep _$CHECK_ID\-OUTPUT_FILE $REFFIL |awk {'print $2'}`
           fi
           audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'` 

	   if [[ -n "$COLLECTION_DIFF_CANDIDATE" && "$COLLECTION_DIFF_CANDIDATE" = "Y" ]]
	   then
	   	echo "$CHECK_ID|$COLLECTION_NAME|$NEEDS_RUNNING|$OUTFILVAL|$COMTYPE" >> $COLLDIFFFIL
	   fi 

           get_current_epoch 
           echo -e "[CHECK:$CHECK_ID][HOST: $i][TYPE: $COMTYPE][COLLECTION_NAME: $COLLECTION_NAME][AUDIT_CHECK_NAME: $audit_check_name] Check Start Time: $epoch_time" >> $CHK_TIMINGS
     
           if [[ -n "$LEVEL" &&  $LEVEL -eq "1" ]]
           then  
	     # Unset array used for holding OPSTAT values in multi db case
             # $m_opstat[$CUR_LEVEL]=db1,db2,db3 where opstat=1
             unset m_opstat 
           fi 

	   #code to handle mixed hardware storage cells   
           if [[ $mixed_hardware -gt 1 && "$COMTYPE" = "OS_OUT_CHECK" && "$NEEDS_RUNNING" = "STORAGE_CELL" && "$i" = "$localnode" && $RAT_RUNMODE_INTERNAL = "master" ]]
           then
             old_components=$components
             if [[ $mixed_hardware_v2 -ge 1 && `echo $check_components|grep -wc "DBM"` -ge 1 && `echo $components|grep -wc "EXADATA"` -eq 0 ]]
             then
               components=$(echo $components:EXADATA)
             fi   
             if [[ $mixed_hardware_x2_2 -ge 1 && `echo $check_components|grep -wc "X2-2"` -ge 1 && `echo $components|grep -wc "X2-2"` -eq 0 ]]
             then
               components=$(echo $components:X2-2)
             fi  
             if [[ $mixed_hardware_x3_2 -ge 1 && `echo $check_components|grep -wc "X3-2"` -ge 1 && `echo $components|grep -wc "X3-2"` -eq 0 ]]
             then
               components=$(echo $components:X3-2)
             fi  
             if [[ $mixed_hardware_x4_2 -ge 1 && `echo $check_components|grep -wc "X4-2"` -ge 1 && `echo $components|grep -wc "X4-2"` -eq 0 ]]
             then
               components=$(echo $components:X4-2)
             fi
             if [[ $mixed_hardware_x5_2 -ge 1 && `echo $check_components|grep -wc "X5-2"` -ge 1 && `echo $components|grep -wc "X5-2"` -eq 0 ]]
             then
               components=$(echo $components:X5-2)
             fi

           fi
           #code to handle mixed hardware storage cells   

           #if [ -n "$it_is_rac_old" ]; then it_is_rac=$it_is_rac_old;fi
           if [ `echo $components|grep -iwc EXADATA` -ge 1 ] && [[ `echo $check_components|grep -wc "DBM"` -ge 1 ]]; then check_components=$(echo $check_components|sed 's/:/ /g'|sed 's/\<DBM\>/EXADATA/g'|sed 's/ /:/g');fi
           if [ "$components" = "RDBMS" ] && [[ $old_check_components = "DBM:RDBMS" || $old_check_components = "DBM:RDBMS:UPGR" ]]; then check_components=RDBMS;fi 
           old_check_components=$check_components
           component_match_count=0 
           loop_check_components=$(echo $check_components|sed 's/:/ /g')
           for check_component in $loop_check_components
           do
             component_match_count1=$(echo $components|grep -icw $check_component)
             if [[ -n "$component_match_count1" && $component_match_count1 -ge 1 ]]; then component_match_count=$(expr $component_match_count + 1 );fi
           done  
    
           #Profiles
           if [[ -n "$run_profile" && $run_profile -eq "1" ]] ; then
             in_profile=0
             ex_profile=1
             check_in_profiles
             if [[ $in_profile -eq "0" || $ex_profile -eq "0" ]] ; then 
               component_match_count=0; 
               echo "Skipping check (id $CHECK_ID) because its not in profile $profiles2run"  >> $LOGFIL
             fi;
           fi
          #components=$saved_components

          # For multiple_version_support we add new checks at the end.
          # The new check may be a collection which can't run in offline
          if [[ $run_in_multiple_versions -eq 1 && $OFFLINE -eq "1" ]]
          then
            if [[ $COMTYPE = "OS_COLLECT" || $COMTYPE = "SQL_COLLECT" ]]
            then #bypass collections in offiline mode
              COMTYPE="NOCOLLECT"
              call_get_log_result=0;
            fi
          fi

          if [[ $run_in_multiple_versions -eq 1 && "$versions_to_run" = "no-release" ]]; then component_match_count=0; fi
          #if check_exadat_version is null than set very high values so it will execute for any exadata version. this is temporary fix until we have version for all checks
          check_exadata_version=$(echo $check_exadata_version|sed 's/ //g')       
          check_exadata_version=$(echo $check_exadata_version|sed 's/\.//g')
          if [ -z "$check_exadata_version" ]; then check_exadata_version=912240;fi
          
          #To delete white space from check_databaes_Role and to handle old checks where database_role is not assigned so default is primary
          check_database_role=$(echo $check_database_role|sed 's/ //g')       
          if [ -z "$check_database_role" ]; then check_database_role=PRIMARY;fi

          #To delete white space from check_databaes_type and to handle old checks where database_type is not assigned so default is normal
          check_database_type=$(echo $check_database_type|sed 's/ //g')       
          if [ -z "$check_database_type" ]; then check_database_type="NORMAL:CDB";fi

          #To delete white space from check_databaes_mode and to handle old checks where database_mode is not assigned so default is open
          check_database_mode=$(echo $check_database_mode|sed 's/ //g')       
          if [ -z "$check_database_mode" ]; then check_database_mode=3;fi

          #echo  "check_components=$check_components and components=$components component_match_count=$component_match_count for $CHECK_ID"
          if [[ $COMTYPE = "OS" && $REQUIRES_ROOT_OS = 1 ]]
          then
            echo "$COMTYPE" >/dev/null 2>&1
          fi     

          if [ $SILENT -eq "0" ]
          then
            if [ $op_mode -eq 0 ]
            then
              ALVL=`grep _$ROW\-ALERT_LEVEL $REFFIL1 |awk {'print $2'}`
              PMSG=`grep "_"$ROW"-PASS_MSG" $REFFIL1 |sed  -n 's/.*PASS_MSG //p'`
              FMSG=`grep "_"$ROW"-FAIL_MSG" $REFFIL1 |sed  -n 's/.*FAIL_MSG //p'`
              CAT=`grep "_"$ROW"-CAT" $REFFIL1 |sed  -n 's/.*-CAT //p'`
              SUBCAT=`grep "_"$ROW"-SUBCAT" $REFFIL1 |sed  -n 's/.*-SUBCAT //p'`
            else
              ALVL=`grep _$CHECK_ID\-ALERT_LEVEL $REFFIL1 |awk {'print $2'}`
              PMSG=`grep "_"$CHECK_ID"-PASS_MSG" $REFFIL1 |sed  -n 's/.*PASS_MSG //p'`
              FMSG=`grep "_"$CHECK_ID"-FAIL_MSG" $REFFIL1 |sed  -n 's/.*FAIL_MSG //p'`
              CAT=`grep "_"$CHECK_ID"-CAT" $REFFIL1 |sed  -n 's/.*-CAT //p'`
              SUBCAT=`grep "_"$CHECK_ID"-SUBCAT" $REFFIL1 |sed  -n 's/.*-SUBCAT //p'`
            fi 
            ALVL_CHECK=$ALVL
          fi

          #CHECK TYPES 
          case $COMTYPE in
            OS)
	      if [[ $execute_once -eq 1 && $i != $localnode ]]
	      then
		call_get_log_result=0
		echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) because execute_once is true">>$LOGFIL
	      elif [[ $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave" ]]
	      then
		call_get_log_result=0
		echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) because execute_once is true">>$LOGFIL
	      #if [[ $NEEDS_RUNNING = "RDBMS" && -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 && ${#ttx_dbpath[@]} -ne 0 ]]
	      elif [[ $NEEDS_RUNNING = "RDBMS" && -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 && ${#ttx_dbpath[@]} -ne 0 ]]
	      then
	        if [ $op_mode -eq 0 ]
	        then 
	          COM=`grep "_"$ROW"-OS_COMMAND" $REFFIL |sed  -n 's/.*OS_COMMAND //p'`
	          COM_REPORT=`grep "_"$ROW"-OS_COMMAND_REPORT" $REFFIL |sed  -n 's/.*OS_COMMAND_REPORT //p'`
	          audit_check_name=`grep "_"$ROW"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
	        else
                  com_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_START"
	          com_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_END"
	          COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d')
	          com_report_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_START"
	          com_report_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_END"
	          COM_REPORT=$(sed -n /$com_report_begin_pattern/,/$com_report_end_pattern/p $REFFIL|sed '1d'|sed '$d')
	          #COM=`grep "_"$CHECK_ID"-OS_COMMAND" $REFFIL |sed  -n 's/.*OS_COMMAND //p'`
	          #COM_REPORT=`grep "_"$CHECK_ID"-OS_COMMAND_REPORT" $REFFIL |sed  -n 's/.*OS_COMMAND_REPORT //p'`
	          audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
	        fi
	        audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'`
	      	ORIG_PMSG=$PMSG
	        ORIG_FMSG=$FMSG
	        if [ $OFFLINE -eq 0 ];then cp $ORCLENVFIL $INPUTDIR/trgt_orcl_env.orig;fi;

	        mb_db_counter=0
	        for db_name_to_check in "${mb_db_names[@]}"
	        do
	          skip_this_version=0;
                  index=1;
                  d=1;

                  for ((j=1;j<=${#ttx_dbpath[@]};j+=1));
                  do
                    if [[ "${ttx_dbpath[$j]}" = "$db_name_to_check" ]];
                    then
                      d=$index;
                    fi
                    index=$(expr $index + 1);
                  done

	          if [ $skip_this_version -eq 0 ]
	          then
	            if [ $OFFLINE -eq "0" ]
	            then
	              echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $db_name_to_check database\n">>$CHECKS_TIMING
	
	              sed  "/TTX_DBPATH/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	              cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	              rm $INPUTDIR/tmp_env_file.out
	              sed  "/TTX_VERSION/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	              cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	              rm $INPUTDIR/tmp_env_file.out
	              sed  "/TTX_INSTANCE_NAME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	              cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	              rm $INPUTDIR/tmp_env_file.out
	              sed  "/TTX_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	              cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	              rm $INPUTDIR/tmp_env_file.out
	              sed  "/TTX_DAEMON_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	              cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	              rm $INPUTDIR/tmp_env_file.out
	
	              echo "export TTX_DBPATH='${ttx_dbpath[$d]}'">>$ORCLENVFIL
	              echo "export TTX_VERSION='${ttx_version[$d]}'">>$ORCLENVFIL
	              echo "export TTX_INSTANCE_NAME='${ttx_instance_name[$d]}'">>$ORCLENVFIL
	              echo "export TTX_HOME='${ttx_home[$d]}'">>$ORCLENVFIL
	              echo "export TTX_DAEMON_HOME='${ttx_daemon_home[$d]}'">>$ORCLENVFIL
	
	              get_cygpath "ORCLENVFIL"
	              if [ $i = $localnode ]; then cp $ORCLENVFIL $TMPDIR; else $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
	              restore_cygpath "ORCLENVFIL"
	              #TRGTORCLENV=$TMPDIR/`basename $ORCLENVFIL`
	              #localcmd=$TMPDIR/localcmd.sh
	              copy_env_files_to_tmp
	              db_name_to_check_noslash=$(echo ${db_name_to_check}|sed 's/\//_/g')
	              nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${db_name_to_check_noslash}.sh/g");

	              echo "#!$bash_scr" >$localcmd
	              echo "$RAT_DEBUG_FLG" >>$localcmd
	              echo "$bash_source" >>$localcmd
	              echo ". $TRGTORCLENV">>$localcmd

	              if [ -n "$COM_REPORT" ]
	              then
	                echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $db_name_to_check|tr "[a-z]" "[A-Z]") DATABASE - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	              fi
	        
	              get_current_epoch 
	              echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $db_name_to_check] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

	              if [ $i = $localnode ]
	              then
  		 	OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out	
	                echo "$COM">>$localcmd
	                #if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out 2>>$ERRFIL">>$localcmd;fi
	                if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi
			echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	                echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd
	                chmod 744 $localcmd
	                if [ $RAT_DEBUG -eq 1 ]
	                then
	                  FILVAL=`$localcmd`
	               	  returncode=`echo $?`
			  set_alvl $returncode;
	                else
	                  FILVAL=`$localcmd 2>>$ERRFIL`
	               	  returncode=`echo $?`
			  set_alvl $returncode;
	                fi

	                #if [ -e $localcmd ]; then rm $localcmd; fi;
	                #if [ -e $localcmd ]; then mv $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
			if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm $localcmd; fi
	              else
   			OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
	                echo "$COM">>$localcmd
	                #if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> $RTEMPDIR/${CHECK_ID}_${i}_report.out">>$localcmd;fi
	                if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> ${OUTFIL_REPORT}">>$localcmd;fi
			echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	                echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

	                #if [ -e $localcmd ]; then cp $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
			if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

	                get_cygpath "localcmd"
	                get_cygpath "OUTPUTDIR"
	                get_cygpath "RTEMPDIR"
	                $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
	                $SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$RTEMPDIR >/dev/null 2>&1
	                $SSHELL $i "chmod 744 $RTEMPDIR/localcmd.sh"

	                if [ $RAT_DEBUG -eq 1 ]
	                then
	                  FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh"`
	                  returncode=`echo $?`
			  set_alvl $returncode;
	                else
	                  FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
	                  returncode=`echo $?`
			  set_alvl $returncode;
	                fi

	                $SCOPY $i:$RTEMPDIR/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1
	                $SSHELL $i "rm -f $RTEMPDIR/localcmd.sh $RTEMPDIR/${CHECK_ID}_${i}_report.out $TRGTORCLENV>/dev/null 2>&1"
	                restore_cygpath "localcmd"
	                restore_cygpath "OUTPUTDIR"
	                restore_cygpath "RTEMPDIR"
	              fi

	              get_current_epoch 
	              echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $db_name_to_check] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

	              move_failed_to_skipped "$returncode" "" "$i:$db_name_to_check"
	              echo "" >>$OSSPOOLFIL
	              printf "%s %s %s %s %s %s\n" "$db_name_to_check $PARAM_PATH $ROW == $FILVAL" >>$OSSPOOLFIL
	            fi

	            if [ -n "$COM_REPORT" ]
	            then
	              SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	              if [ $OFFLINE -eq 0 ]
	              then
	                SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
	              else
	                SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	              fi
	            fi
	            call_get_log_result=0
	            PMSG=$(echo $ORIG_PMSG for ${db_name_to_check})
	            FMSG=$(echo $ORIG_FMSG for ${db_name_to_check})
	            VAL=`grep "$db_name_to_check $PARAM_PATH $ROW " $OSSPOOLFIL|sed  -n 's/.*== //p'`
	            if [ $mb_db_counter -gt 0 ];then write_report_on_fail=0;fi
	            get_log_result "inloop" "-"
	            if [ $OFFLINE -eq 0 ]; then echo -e "end time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $db_name_to_check database\n">>$CHECKS_TIMING;fi
	          fi
	          mb_db_counter=$(expr $mb_db_counter + 1)
	        done
	        mb_db_counter=0
	        write_report_on_fail=1
	        if [[ $OFFLINE -eq 0 && -e $INPUTDIR/trgt_orcl_env.orig ]]
	        then
	          cp $INPUTDIR/trgt_orcl_env.orig $ORCLENVFIL
	          rm $INPUTDIR/trgt_orcl_env.orig
	          get_cygpath "ORCLENVFIL"
	          if [ $i = $localnode ]; then cp $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
	          restore_cygpath "ORCLENVFIL"
	        fi
	
	      elif [ "$PARAM" = "EMAGENT_HOME" ]
              then
               if [[ $component_match_count  -lt 1 ]]
               then
                  echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
                  call_get_log_result=0
               else
	       if [ $is_emagent_installed -eq 1 ]
	       then
  	        if [ $op_mode -eq 0 ]
                then
                  COM=`grep "_"$ROW"-OS_COMMAND" $REFFIL |sed  -n 's/.*OS_COMMAND //p'`
                  COM_REPORT=`grep "_"$ROW"-OS_COMMAND_REPORT" $REFFIL |sed  -n 's/.*OS_COMMAND_REPORT //p'`
                  audit_check_name=`grep "_"$ROW"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                else
                  com_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_START"
                  com_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_END"
                  COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                  com_report_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_START"
                  com_report_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_END"
                  COM_REPORT=$(sed -n /$com_report_begin_pattern/,/$com_report_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                  audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                fi
                audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'`
	
		    ORIG_PMSG=$PMSG
                    ORIG_FMSG=$FMSG
		    OLD_OH=$ORACLE_HOME;
		      #mb_ogg_home=$mb_emagent_home
                      mb_emagent_home_without_slash=$(echo $mb_emagent_home|sed 's/\///g')
                      mb_emagent_home_without_slash=$(echo $mb_emagent_home_without_slash|sed 's/\.//g')
                        if [ $OFFLINE -eq "0"  ]
                        then
                          echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_emagent_home\n">>$CHECKS_TIMING
                          #echo "export ORACLE_HOME=${mb_emagent_home}">>$ORCLENVFIL
                          if [ $i = $localnode ]; then cp $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
                          copy_env_files_to_tmp
                          nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_emagent_home_without_slash}.sh/g");

                          echo "#!$bash_scr" >$localcmd
                          echo "$RAT_DEBUG_FLG" >>$localcmd
                          echo "$bash_source" >>$localcmd
			  echo "export ORACLE_HOME=${mb_emagent_home}">>$localcmd
			  echo "export EMAGENT_INST=${agent_inst}">>$localcmd
                          if [ -n "$COM_REPORT" ]
                          then
                            echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $mb_emagent_home|tr "[a-z]" "[A-Z]") ORACLE AGENT HOME - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                          fi

                          get_current_epoch
                          echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_emagent_home] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

                          if [ $i = $localnode ]
                          then
			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			      cp ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $TMP_OUTPUT
	                      OUTFIL_REPORT=$TMP_OUTPUT/${CHECK_ID}_${i}_report.out
			    else
			      OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			    fi
                            chmod 744 $localcmd
                            echo "$COM">>$localcmd
                            
                            if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi
                            echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
			    echo "export ORACLE_HOME=$OLD_OH">>$localcmd
                            echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                              get_agentOwner
			      cp $localcmd $TMP_OUTPUT
			      cmdname=`basename $localcmd`;
			      localcmd="$TMP_OUTPUT/$cmdname";	
                              chown $agentOwner:$agentGroup $localcmd
                              chown $agentOwner:$agentGroup $TRGTORCLENV
                              FILVAL=`su $agentOwner -c "$localcmd" 2>>$ERRFIL`
			      FILVAL=`echo "$FILVAL"|tr -d '\n'`	
                              returncode=`echo $?`
                              set_alvl $returncode;
			      cp $TMP_OUTPUT/${CHECK_ID}_${i}_report.out ${OUTPUTDIR}
                            else
                              FILVAL=`$localcmd 2>>$ERRFIL`
			      FILVAL=`echo "$FILVAL"|tr -d '\n'`
                              returncode=`echo $?`
                              set_alvl $returncode;
                            fi
					
		     	    if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm $localcmd; fi

                          else #remote
	    		    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	                        OUTFIL_REPORT=$TMP_OUTPUT/${CHECK_ID}_${i}_report.out
			    else
				OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
			    fi

                            echo "$COM">>$localcmd
                           
                            if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> ${OUTFIL_REPORT}">>$localcmd;fi
                            echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
			    echo "export ORACLE_HOME=$OLD_OH">>$localcmd
                            echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

                            if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

                            $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1

		            if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
  		              $SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$TMP_OUTPUT >/dev/null 2>&1
		              $SSHELL $i "chmod 744 $TMP_OUTPUT/${CHECK_ID}_${i}_report.out"
		            else
		              $SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$RTEMPDIR >/dev/null 2>&1
		              $SSHELL $i "chmod 744 ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out"
		            fi

                            $SSHELL $i "chmod 744 $RTEMPDIR/localcmd.sh"

			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                              get_agentOwner
			      $SSHELL $i "cp $RTEMPDIR/localcmd.sh $TMP_OUTPUT"
                              cmdname="localcmd.sh";
                              localcmd="$TMP_OUTPUT/$cmdname";
                              $SSHELL $i "chown $agentOwner:$agentGroup $localcmd"
			      $SSHELL $i "chown $agentOwner:$agentGroup $TMP_OUTPUT/${CHECK_ID}_${i}_report.out"	
                              $SSHELL $i "chown $agentOwner:$agentGroup $TRGTORCLENV"
                              FILVAL=`$SSHELL $i "su $agentOwner -c \"$localcmd\"" 2>>$ERRFIL`
			      FILVAL=`echo "$FILVAL"|tr -d '\n'`
                              returncode=`echo $?`
                              set_alvl $returncode;
                            else
                              FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
			      FILVAL=`echo "$FILVAL"|tr -d '\n'`
                              returncode=`echo $?`
                              set_alvl $returncode;
                            fi
			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	                      $SCOPY $i:$TMP_OUTPUT/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1
			    else
			      $SCOPY $i:$RTEMPDIR/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1
			    fi
                            $SSHELL $i "rm -f $RTEMPDIR/localcmd.sh $RTEMPDIR/${CHECK_ID}_${i}_report.out $TRGTORCLENV>/dev/null 2>&1"
                          fi

                          get_current_epoch
                          echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_emagent_home] Execution End Time: $epoch_time" >> $CHK_TIMINGS

                          move_failed_to_skipped "$returncode" "" "$i:$mb_emagent_home"
                          echo "" >>$OSSPOOLFIL
                          printf "%s %s %s %s %s %s\n" "$mb_emagent_home_without_slash $PARAM_PATH $ROW == $FILVAL" >>$OSSPOOLFIL
                        fi
                        call_get_log_result=0
                        VAL=`grep "$mb_emagent_home_without_slash $PARAM_PATH $ROW " $OSSPOOLFIL|sed  -n 's/.*== //p'`
                        if [ -n "$COM_REPORT" ]
                        then
                          SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                          if [ $OFFLINE -eq 0 ]
                          then
                            SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
                          else
                            SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                          fi
                        fi
                        get_log_result "inloop" "$mb_emagent_home"
                        if [ $OFFLINE -eq 0 ]; then echo -e "end time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_emagent_home\n">>$CHECKS_TIMING;fi
	       else
			call_get_log_result='';
	       fi
              fi
              elif [[ $PARAM = "TIMESTEN" && -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 && ${#ttx_home[@]} -ne 0 ]]
       	      then
                if [ $op_mode -eq 0 ]
                then 
                  COM=`grep "_"$ROW"-OS_COMMAND" $REFFIL |sed  -n 's/.*OS_COMMAND //p'`
                  COM_REPORT=`grep "_"$ROW"-OS_COMMAND_REPORT" $REFFIL |sed  -n 's/.*OS_COMMAND_REPORT //p'`
                  audit_check_name=`grep "_"$ROW"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                else
                  com_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_START"
	          com_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_END"
	          COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d')
	          com_report_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_START"
	          com_report_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_END"
	          COM_REPORT=$(sed -n /$com_report_begin_pattern/,/$com_report_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                  #COM=`grep "_"$CHECK_ID"-OS_COMMAND" $REFFIL |sed  -n 's/.*OS_COMMAND //p'`
                  #COM_REPORT=`grep "_"$CHECK_ID"-OS_COMMAND_REPORT" $REFFIL |sed  -n 's/.*OS_COMMAND_REPORT //p'`
                  audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                fi
                audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'`
                ORIG_PMSG=$PMSG
                ORIG_FMSG=$FMSG

                if [ $OFFLINE -eq 0 ];then cp $ORCLENVFIL $INPUTDIR/trgt_orcl_env.orig;fi;

                for mb_db_homes in ${mb_oracle_homes_distinct[@]}
                do
                  skip_this_version=1
                  index=1;
                  d=1;
                  for dump in ${ttx_home[@]}
                  do
                    if [ $dump = $mb_db_homes ];
                    then
                      d=$index;
                      skip_this_version=0;
                    fi
                    index=$(expr $index + 1);
                  done
                  mb_db_homes_without_slash=$(echo $mb_db_homes|sed 's/\///g')
                  mb_db_homes_without_slash=$(echo $mb_db_homes_without_slash|sed 's/\.//g')

                  if [ $skip_this_version -eq 0 ]
                  then
                    if [ $OFFLINE -eq "0"  ]
                    then
                      echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_db_homes\n">>$CHECKS_TIMING

                      sed  "/TTX_DBPATH/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
                      cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
                      rm $INPUTDIR/tmp_env_file.out
                      sed  "/TTX_VERSION/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
                      cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
                      rm $INPUTDIR/tmp_env_file.out
                      sed  "/TTX_INSTANCE_NAME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
                      cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
                      rm $INPUTDIR/tmp_env_file.out
                      sed  "/TTX_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
                      cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
                      rm $INPUTDIR/tmp_env_file.out
                      sed  "/TTX_DAEMON_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
                      cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
                      rm $INPUTDIR/tmp_env_file.out

                      echo "export TTX_DBPATH='${ttx_dbpath[$d]}'">>$ORCLENVFIL
                      echo "export TTX_VERSION='${ttx_version[$d]}'">>$ORCLENVFIL
                      echo "export TTX_INSTANCE_NAME='${ttx_instance_name[$d]}'">>$ORCLENVFIL
                      echo "export TTX_HOME='${ttx_home[$d]}'">>$ORCLENVFIL
                      echo "export TTX_DAEMON_HOME='${ttx_daemon_home[$d]}'">>$ORCLENVFIL

                      get_cygpath "ORCLENVFIL"
                      get_cygpath "TMPDIR"
                      if [ $i = $localnode ]; then cp $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
                      restore_cygpath "ORCLENVFIL"
                      restore_cygpath "TMPDIR"
                      #TRGTORCLENV=$TMPDIR/`basename $ORCLENVFIL`
                      #localcmd=$TMPDIR/localcmd.sh
                      copy_env_files_to_tmp
	              nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_db_homes_without_slash}.sh/g");

                      echo "#!$bash_scr" >$localcmd
	              echo "$RAT_DEBUG_FLG" >>$localcmd
                      echo "$bash_source" >>$localcmd
                      echo ". $TRGTORCLENV">>$localcmd
                      if [ -n "$COM_REPORT" ]
                      then
                        echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $mb_db_homes|tr "[a-z]" "[A-Z]") DATABASE_HOME - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                      fi

	              get_current_epoch 
	              echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $db_name_to_check] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

                      if [ $i = $localnode ]
                      then
			OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                        echo "$COM">>$localcmd
                        #if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out 2>>$ERRFIL">>$localcmd;fi
                        if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi
			echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	                echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd
                        chmod 744 $localcmd
	                if [ $RAT_DEBUG -eq 1 ]
                        then
                          FILVAL=`$localcmd`
	              	  returncode=`echo $?`
			  set_alvl $returncode;
	                else
                          FILVAL=`$localcmd 2>>$ERRFIL`
	                  returncode=`echo $?`
			  set_alvl $returncode;
	                fi

                        #if [ -e $localcmd ]; then rm $localcmd; fi;
	                #if [ -e $localcmd ]; then mv $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
			if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm $localcmd; fi
                      else
			OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
                        echo "$COM">>$localcmd
                        #if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> $RTEMPDIR/${CHECK_ID}_${i}_report.out">>$localcmd;fi
                        if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> ${OUTFIL_REPORT}">>$localcmd;fi
			echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	                echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

	                #if [ -e $localcmd ]; then cp $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
			if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

                        get_cygpath "localcmd"
                        get_cygpath "OUTPUTDIR"
                        get_cygpath "RTEMPDIR"
                        $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
                        $SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$RTEMPDIR >/dev/null 2>&1
                        $SSHELL $i "chmod 744 $RTEMPDIR/localcmd.sh"
	                if [ $RAT_DEBUG -eq 1 ]
	                then
                          FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh"`
	                  returncode=`echo $?`
			  set_alvl $returncode;
	                else
                          FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
	                  returncode=`echo $?`
			  set_alvl $returncode;
	                fi

                        $SCOPY $i:$RTEMPDIR/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1
                        $SSHELL $i "rm -f $RTEMPDIR/localcmd.sh $RTEMPDIR/${CHECK_ID}_${i}_report.out $TRGTORCLENV>/dev/null 2>&1"
                        restore_cygpath "localcmd"
                        restore_cygpath "OUTPUTDIR"
                        restore_cygpath "RTEMPDIR"
                      fi

	              get_current_epoch 
	              echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $db_name_to_check] Execution End Time: $epoch_time" >> $CHK_TIMINGS

	              move_failed_to_skipped "$returncode" "" "$i:$mb_db_homes"
                      echo "" >>$OSSPOOLFIL
                      printf "%s %s %s %s %s %s\n" "$mb_db_homes_without_slash $PARAM_PATH $ROW == $FILVAL" >>$OSSPOOLFIL
                    fi
	            call_get_log_result=0
                    PMSG=$(echo $ORIG_PMSG for ${mb_db_homes})
                    FMSG=$(echo $ORIG_FMSG for ${mb_db_homes})
                    call_get_log_result=0;
                    VAL=`grep "$mb_db_homes_without_slash $PARAM_PATH $ROW " $OSSPOOLFIL|sed  -n 's/.*== //p'`
                    if [ -n "$COM_REPORT" ]
                    then
                      SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                      if [ $OFFLINE -eq 0 ]
                      then
                        SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
                      else
                        SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                      fi
                    fi
                    if [ $mb_db_counter -gt 0 ];then write_report_on_fail=0;fi
                    get_log_result "inloop" "$mb_db_homes"
                    if [ $OFFLINE -eq 0 ]; then echo -e "end time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_db_homes\n">>$CHECKS_TIMING;fi
                  fi
                  mb_db_counter=$(expr $mb_db_counter + 1)
                done
                mb_db_counter=0
                write_report_on_fail=1
                if [[ $OFFLINE -eq 0 && -e $INPUTDIR/trgt_orcl_env.orig ]]
                then
                  cp $INPUTDIR/trgt_orcl_env.orig $ORCLENVFIL
                  rm $INPUTDIR/trgt_orcl_env.orig
                  get_cygpath "ORCLENVFIL"
                  if [ $i = $localnode ]; then cp $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
                  restore_cygpath "ORCLENVFIL"
                fi
              else 
                match=0				
                for mb_db_homes in ${mb_oracle_homes_distinct[@]}
                do
                  for dump in ${ttx_home[@]}
                  do
                    if [[ "$dump" = "$mb_db_homes" ]];
                    then
                      match=$(expr $match + 1);
                    fi
                  done
                done
                if [[ $PARAM = "BI_INSTANCE" ]] && [[ $match -eq ${#mb_oracle_homes_distinct[@]} ]]
                then
                  call_get_log_result=0 
                elif [[ $PARAM = "CRS" &&  ${crs_installed[$stack_counter]} -eq 0 ]] ||  [[ $PARAM = "RDBMS" &&  ${rdbms_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "TIMESTEN" &&  ${ttx_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "ASM" &&  ${asm_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "GOLDENGATE_HOME" && $is_goldengate_installed -eq 0 ]]
                then
                  call_get_log_result=0
                elif [[ $NEEDS_RUNNING = "CRS" &&  ${stack_crs_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "RDBMS" &&  ${stack_dbinst_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "ASM" &&  ${stack_asm_up[$stack_counter]} -eq 0 ]] || [[ $NEEDS_RUNNING = "ACFS" &&  ${stack_acfs_up[$stack_counter]} -eq 0  ]]
                then
                  call_get_log_result=0
                  #elif  [[ -n "$it_is_rac" && $it_is_rac -eq 0 &&  $component_match_count  -lt 1 ]] 
                elif  [[ $component_match_count  -lt 1 ]]
                then
                  echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
                  call_get_log_result=0
                elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$audit_check_name" $EXCLUDEFIL` -ge 1 ]]
                then
                  call_get_log_result=0 
                  echo "Skipping $audit_check_name (CHECK ID $CHECK_ID)  on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                  generate_exceptions_xml "Skipping $(echo $audit_check_name|sed 's/\[DBMV2]//g') because its in exclude file $EXCLUDEFIL"
                  #added this condtion because Andrego asked not to run these three checks if not profiles in use
		elif [ -z "$profiles2run" ] && [ -e $PROFILEONLY ] && [[ `grep -ic $CHECK_ID $PROFILEONLY` -ge 1 ]]
                then 
                  call_get_log_result=0
                  echo "Not running $audit_check_name($CHECK_ID) because no profile is in use">>$LOGFIL
                else 
                  #echo "$SF and count=`echo $SF|grep -ic "GENERIC ORACLE PRE-UPGRADE COLLECTIONS AND AUDIT CHECKS"` and TYP=$TYP"
                  call_get_log_result=1
                  if [ $op_mode -eq 0 ]
                  then 
                    COM=`grep "_"$ROW"-OS_COMMAND" $REFFIL |sed  -n 's/.*OS_COMMAND //p'`
                    COM_REPORT=`grep "_"$ROW"-OS_COMMAND_REPORT" $REFFIL |sed  -n 's/.*OS_COMMAND_REPORT //p'`
                    audit_check_name=`grep "_"$ROW"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                  else
	            com_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_START"
	            com_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_END"
	            COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d')
	            com_report_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_START"
	            com_report_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_END"
	            COM_REPORT=$(sed -n /$com_report_begin_pattern/,/$com_report_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                    #COM=`grep "_"$CHECK_ID"-OS_COMMAND" $REFFIL |sed  -n 's/.*OS_COMMAND //p'`
                    #COM_REPORT=`grep "_"$CHECK_ID"-OS_COMMAND_REPORT" $REFFIL |sed  -n 's/.*OS_COMMAND_REPORT //p'`
                    #if action report is "intentionally left blank" then unset it beacuse we dont want to print that in report
                    if [ `echo $COM_REPORT|grep -icw "blank"` -ge 1 ]; then unset COM_REPORT;fi
                    audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                  fi
                  audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'`
                  if [[ "$NEEDS_RUNNING" = "ASM" || "$NEEDS_RUNNING" = "ACFS" ]] && [[ $OFFLINE -eq "0"  && ${stack_asm_up[$stack_counter]} -eq 1 ]]
                  #if [[ $NEEDS_RUNNING = "ASM" && $OFFLINE -eq "0" && ${stack_asm_up[$stack_counter]} -eq 1 ]]
                  then
                    OLD_ORACLE_SID=$(grep ORACLE_SID $ORCLENVFIL|cut -d= -f2)
                    OLD_ORACLE_HOME=$(grep ORACLE_HOME $ORCLENVFIL|cut -d= -f2)
	            sed  "/ORACLE_SID/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	            cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	            rm $INPUTDIR/tmp_env_file.out
	            sed  "/ORACLE_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	            cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	            rm $INPUTDIR/tmp_env_file.out
	            echo "export ORACLE_SID=${stack_asm_sid[$stack_counter]}">>$ORCLENVFIL
	            
	            inst_name=${stack_asm_sid[$stack_counter]} 
                    if [[ -n "$crs112" && $crs112 -ge 1 ]]
                    then
                      echo "export ORACLE_HOME=$CRS">>$ORCLENVFIL
                    else
	              echo "export ORACLE_HOME=${stack_asm_home[$stack_counter]}">>$ORCLENVFIL
                    fi
		    update_ld_lib_path "CRS"
                    get_cygpath "ORCLENVFIL"
                    if [ $i = $localnode ]; then cp $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
                    restore_cygpath "ORCLENVFIL"
                    TRGTORCLENV=$TMPDIR/`basename $ORCLENVFIL`    
                    #cat $TRGTORCLENV
                    #$READ -p "OLD_ORACLE_SID=$OLD_ORACLE_SID OLD_ORACLE_HOME=$OLD_ORACLE_HOME ORACLE_HOME=$ORACLE_HOME ORACLE_SID=$ORACLE_SID"
                  fi

	          if [[ -n "$os_check_needs_collect_file" && $os_check_needs_collect_file -eq 1 ]]
	          then 
	            if [ -f $OUTPUTDIR/$VAL_FIL ]
	            then
		      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			cp $OUTPUTDIR/$VAL_FIL $TMP_OUTPUT			
		      else
			cp $OUTPUTDIR/$VAL_FIL $RTEMPDIR
		      fi
	              #cp $OUTPUTDIR/$VAL_FIL $WRKDIR
	              collect_files[$collect_file_counter]=${VAL_FIL}
	              collect_file_counter=$(expr $collect_file_counter + 1 )
	            fi
	          #$READ -p "os_check_needs_collect_file=$os_check_needs_collect_file VAL_FIL=$VAL_FIL collect_file_counter=$collect_file_counter file_to_copy=$OUTPUTDIR/$VAL_FIL"   
	          fi
                  #echo  "needs_running=$NEEDS_RUNNING action=$COM"
                  #echo "multiple_db=$multiple_db NEEDS_RUNNING=$NEEDS_RUNNING PARAM=$PARAM limits=`echo $COM|grep -ic "limits.conf"` usrlimit=`echo $COM|grep -ic "usrlimit"`"
                  if [[ `echo $COM|grep -ic "limits.conf"` -ge 1 || `echo $COM|grep -ic "usrlimit"` -ge 1 ]]; then ulimit_cmd=1;else ulimit_cmd=0;fi
                  #Not to call get_log_result for storage server cells in exalogic if its running on remote node
                  if [[ $NEEDS_RUNNING = "ZFS" && -e $CELLIP && -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" && $i != $localnode ]]; then call_get_log_result=0;fi
                  if [[ $NEEDS_RUNNING = "ZFS" && -e $ZFSIP && -n "$is_ssc_machine" && $is_ssc_machine -eq "1" && $i != $localnode ]]; then call_get_log_result=0;fi
                  if [[ $NEEDS_RUNNING = "STORAGE_CELL" && $RAT_RUNMODE_INTERNAL = "slave" ]]; then call_get_log_result=0;fi
                  if [[ $NEEDS_RUNNING = "ZFS" && $RAT_RUNMODE_INTERNAL = "slave" ]]; then call_get_log_result=0;fi
                  # Dont call get_log_result if user selected skip cells
                  if [[ $NEEDS_RUNNING = "STORAGE_CELL" && -n "$cell_password_status" && $cell_password_status -eq 3 ]]; then call_get_log_result=0;fi
                  if [[ $NEEDS_RUNNING = "ZFS" && -n "$zfs_password_status" && $zfs_password_status -eq 3 && -e $ZFSIP ]] ; then call_get_log_result=0;fi
                  #$READ -p "ulimit_cmd=$ulimit_cmd in $COM"
	
                  if [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "RDBMS" ]]
                  then
                    ORIG_PMSG=$PMSG
                    ORIG_FMSG=$FMSG
                    if [ $OFFLINE -eq 0 ];then cp $ORCLENVFIL $INPUTDIR/trgt_orcl_env.orig;fi;
                    #cat $ORCLENVFIL
                    #$READ -p "before mbd os"
                    mb_db_counter=0
                    mb_db_counter_log=0

                    #Meta File for DB parallelization
 	            if [[ $OFFLINE -eq "0" && -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 ]]
	            then 
		      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		        COM=$(echo "$COM"|sed 's/\$TMPDIR/\$TMP_OUTPUT/g'|sed 's/\$RTEMPDIR/\$TMP_OUTPUT/g')
			COM_REPORT=$(echo "$COM_REPORT"|sed 's/\$TMPDIR/\$TMP_OUTPUT/g'|sed 's/\$RTEMPDIR/\$TMP_OUTPUT/g')
		      fi 
		      t_PSQL_STAT="${PSQL_STAT}_${CHECK_ID}"
                      t_PSQL_METAFIL="${PSQL_METAFIL}_${CHECK_ID}"
                      echo "CHECKID=$CHECK_ID"                             	 	>  $t_PSQL_METAFIL 
                      echo "COMTYPE=$COMTYPE"                              	 	>> $t_PSQL_METAFIL  
                      echo "COM_START=$COM" 					        >> $t_PSQL_METAFIL 
		      echo "COM_END"						        >> $t_PSQL_METAFIL
                      echo "COM_REPORT_START=$COM_REPORT"                    	        >> $t_PSQL_METAFIL 
                      echo "COM_REPORT_END"    	                   	                >> $t_PSQL_METAFIL 
                      echo "RAT_RUNMODE_INTERNAL=$RAT_RUNMODE_INTERNAL"    	 	>> $t_PSQL_METAFIL 
	              echo "PARAM_PATH=$PARAM_PATH"                             	>> $t_PSQL_METAFIL
	              echo "ROW=$ROW"                                                   >> $t_PSQL_METAFIL
	
	              #DB information for DB parallelization
	              t_PSQL_INFIL="${PSQL_INFIL}_${CHECK_ID}"
	              t_mb_db_counter=0
	              for db_name_to_check in "${mb_db_names[@]}"
	              do
	                match_database_role "${mb_database_role[$t_mb_db_counter]}"
	                match_database_type "${mb_database_type[$t_mb_db_counter]}"

	                echo "${db_name_to_check},${mb_oracle_sids[$t_mb_db_counter]},${mb_oracle_homes[$t_mb_db_counter]},${mb_database_role[$t_mb_db_counter]},$dbrole_match_count,${mb_database_type[$t_mb_db_counter]},$dbtype_match_count,${mb_sysdba_user[$t_mb_db_counter]},${mb_sysdba_pswd[$t_mb_db_counter]},${RAT_PDB_USER},${mb_db_sys_password[$t_mb_db_counter]},${mb_db_connect_string[$t_mb_db_counter]},${mb_checksysdba[$t_mb_db_counter]},${mb_running_host[$t_mb_db_counter]}" >> $t_PSQL_INFIL
	                t_mb_db_counter=$(expr $t_mb_db_counter + 1)
	              done
	              t_mb_db_counter=0
	            fi

                    psql_counter=0
                    for db_name_to_check in "${mb_db_names[@]}"
                    do
                      #$READ -p "current_oh_owner=$current_oh_owner"
 	              if [[ $OFFLINE -eq "0" && -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 ]]
	              then
	                if [[ $psql_counter -eq 0 ]]
	                then
	                  parallel_sql
	                fi
			if [[ -n $PRET_STATUS && $PRET_STATUS -ne "0" ]]; then
  			  move_failed_to_skipped "$PRET_STATUS" "" "$i:$db_name_to_check" "1"
			fi
	
                        psql_counter=$(expr $psql_counter + 1)
	              fi

                      if [ $OFFLINE -eq 0  ]
                      then
                        current_oh_owner=$(ls -l ${mb_oracle_homes[$mb_db_counter]}/bin/oracle 2>/dev/null|awk '{print $3}')
			if [[ -z $current_oh_owner ]]; then
                          current_oh_host=$(grep -w "RDBMS_ORACLE_HOME = ${mb_oracle_homes[$mb_db_counter]}" $MASTERFIL|awk '{print $3}'|cut -d '|' -f4|cut -d ',' -f1)
			  t_flag="-T"
			  current_oh_owner=`$SSHELL $t_flag ${current_oh_host} "ls -l ${mb_oracle_homes[$mb_db_counter]}/bin/oracle 2>/dev/null >&1|awk '{print \\$3}'"`
			fi
                      else
                        usern=$(grep "CURRENT_USER" $DUMPDIR/$CHKFIL|awk '{print $3}')
                        current_oracle_home=$(grep -w "DB_NAME = $db_name_to_check" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f3)
                        current_oh_owner=$(grep -w "RDBMS_ORACLE_HOME = $current_oracle_home" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f3)
                      fi
		      if [[ -n $current_oh_owner ]]; then 
			dbGroup=$(groups "$current_oh_owner" 2>/dev/null >&1|cut -d: -f2|awk '{print $1}'|sed 's/ //g');
			if [[ -z $dbGroup && $OFFLINE -eq 0 ]]; then
 		          dbGroup=`$SSHELL $t_flag ${current_oh_host} "groups "$current_oh_owner"|cut -d: -f2|awk '{print \\$1}'|sed 's/ //g'"`
		          dbhome_dir=`$SSHELL $t_flag ${current_oh_host} "cat /etc/passwd|grep -w "$current_oh_owner"|cut -d":" -f6"`
			else
			  dbhome_dir=$(cat /etc/passwd|grep -w "$current_oh_owner"|cut -d":" -f6);
			fi
		      fi 

                      skip_this_version=0
                      set_skip_this_version "-"
                      if [ $skip_this_version -eq 1 ] ; then
                        echo "Skipping check($CHECK_ID) on version 1 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                      fi

                      #if [[ $skip_this_version -eq 0 && $usern = $current_oh_owner ]]
                      if [[ $skip_this_version -eq 0 && $usern = $current_oh_owner ]] || [[ $skip_this_version -eq 0 && -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]
                      then
                        skip_this_version=0
                      else
                        skip_this_version=1
                      fi
                      #$READ -p "current_oh_owner=$current_oh_owner"
                      #following if is to skip any audit checks which query files in ORALCE_HOME not owned by current user
	              call_get_log_result=0
                      if [ $skip_this_version -eq 0 ]
                      then
	                if [ $OFFLINE -eq 0  ]
	                then
	                  inst_mode=$(grep -w "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_MODE|awk '{print $3}')
			  inst_name=$(grep -w "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_NAME|awk '{print $3}');
	                else
	                  inst_mode=$(grep -w "$i.$db_name_to_check" $DUMPDIR/$CHKFIL|grep INSTANCE_MODE|awk '{print $3}')
			  inst_name=$(grep -w "$i.$db_name_to_check" $DUMPDIR/$CHKFIL|grep INSTANCE_NAME|awk '{print $3}');
	                fi
                        #$READ -p "inst_mode=$inst_mode for $db_name_to_check dbrole = ${mb_database_role[$mb_db_counter]} and check_database_role = $check_database_role"
                        match_database_role "${mb_database_role[$mb_db_counter]}"
                        match_database_type "${mb_database_type[$mb_db_counter]}"  
                        if [[ $dbrole_match_count -ge 1 && $dbtype_match_count -ge 1 ]]
                        #if [[ "${mb_database_role[$mb_db_counter]}" = "$check_database_role" ]]
                        then
	                  if [[ $OFFLINE -eq "0"  && $inst_mode -eq 3 && -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 0 ]]
	                  then
	                    echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $db_name_to_check database\n">>$CHECKS_TIMING 
	              	    #$READ -p "os_check_needs_collect_file=$os_check_needs_collect_file VAL_FIL=$VAL_FIL collect_file_counter=$collect_file_counter file_to_copy=$OUTPUTDIR/$VAL_FIL"   

	                    sed  "/ORACLE_SID/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	                    cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	                    rm $INPUTDIR/tmp_env_file.out
	                    sed  "/ORACLE_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	                    cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	                    rm $INPUTDIR/tmp_env_file.out
	                    inst_name=$(grep -w "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_NAME|awk '{print $3}')
	                    echo "export ORACLE_SID=${inst_name}">>$ORCLENVFIL
	                    echo "export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}">>$ORCLENVFIL
			    update_ld_lib_path
	                    get_cygpath "ORCLENVFIL"
	                    if [ $i = $localnode ]; then cp $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
	                    restore_cygpath "ORCLENVFIL"
	                    #TRGTORCLENV=$TMPDIR/`basename $ORCLENVFIL`  
                            #localcmd=$TMPDIR/localcmd.sh
	                    #cat $ORCLENVFIL
	                    #$READ -p "see changed file"
                            copy_env_files_to_tmp "$usern"
	                    nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${db_name_to_check}.sh/g");

                            echo "#!$bash_scr" >$localcmd
	                    echo "$RAT_DEBUG_FLG" >>$localcmd
                            echo "$bash_source" >>$localcmd
                            echo ". $TRGTORCLENV">>$localcmd

	                    if [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 0 ]]
	                    then	
	                      get_current_epoch 
	                      echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $db_name_to_check] Execution Start Time: $epoch_time" >> $CHK_TIMINGS
	                    fi

	                    if [ $i = $localnode ]
	                    then
			      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			        OUTFIL_REPORT=${TMP_OUTPUT}/${CHECK_ID}_${i}_report.out
			        OLD_OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			      else
			        OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			      fi
                              if [ -n "$COM_REPORT" ]; then
                                echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $db_name_to_check|tr "[a-z]" "[A-Z]") DATABASE - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$OUTFIL_REPORT
                              fi
	              	      echo "$COM">>$localcmd
                              #if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out 2>>$ERRFIL">>$localcmd;fi
                              if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi
			      echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	              	      echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd
	              	      #echo "exit 0">>$localcmd
                              if [[ -e $localcmd ]]; then chmod 744 $localcmd; fi
                              if [[ -e $TRGTORCLENV ]] ; then chmod 744 $TRGTORCLENV; fi

			      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
				OLD_DIR=`pwd`
				cd "$dbhome_dir";

				chown $current_oh_owner:$dbGroup $TRGTORCLENV
				chown $current_oh_owner:$dbGroup $localcmd
	              	        FILVAL=`su $current_oh_owner -c "$localcmd 2>>$ERRFIL"`
	              	        returncode=`echo $?`
				set_alvl $returncode;

				move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
				cd $OLD_DIR;
	    			unset OLD_DIR
			      else
	              	        FILVAL=`$localcmd 2>>$ERRFIL`
	              	        returncode=`echo $?`
				set_alvl $returncode;
			      fi

	              	      #if [ -e $localcmd ]; then rm $localcmd; fi;
                              #if [ -e $localcmd ]; then mv $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
			      if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm $localcmd; fi
	                    else
			      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
  			        OUTFIL_REPORT=$TMP_OUTPUT/${CHECK_ID}_${i}_report.out
  			        OLD_OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
			      else
  			        OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
			      fi
                              if [ -n "$COM_REPORT" ]; then
                                echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $db_name_to_check|tr "[a-z]" "[A-Z]") DATABASE - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$OUTFIL_REPORT
                              fi
                              echo "$COM">>$localcmd
                              #if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> $RTEMPDIR/${CHECK_ID}_${i}_report.out">>$localcmd;fi
                              if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> ${OUTFIL_REPORT}">>$localcmd;fi
			      echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	              	      echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

	              	      #if [ -e $localcmd ]; then cp $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
			      if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

                              #$SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
                              #$SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$RTEMPDIR >/dev/null 2>&1
	
			      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
				OLD_DIR=`pwd`
				cd "$dbhome_dir";

                                get_cygpath "OUTFIL_REPORT"
                                get_cygpath "TMP_OUTPUT"
                                get_cygpath "localcmd"
                                $SCOPY $OUTFIL_REPORT $i:$TMP_OUTPUT >/dev/null 2>&1
                                $SCOPY $localcmd $i:$TMP_OUTPUT >/dev/null 2>&1

                                $SSHELL $i "chmod 744 $TRGTORCLENV"
                                $SSHELL $i "chmod 744 $localcmd"
				$SSHELL $i "chown $current_oh_owner:$dbGroup $TRGTORCLENV"
				$SSHELL $i "chown $current_oh_owner:$dbGroup $localcmd"
                                FILVAL=`$SSHELL $i "su ${current_oh_owner} -c \"$TMP_OUTPUT/localcmd.sh\"" 2>>$ERRFIL`
	              	        returncode=`echo $?`
                                set_alvl $returncode;
				cd $OLD_DIR
	    			unset OLD_DIR
                                restore_cygpath "OUTFIL_REPORT"
                                restore_cygpath "TMP_OUTPUT"
                                restore_cygpath "localcmd"
			      else
                                get_cygpath "RTEMPDIR"
                                get_cygpath "localcmd"
                                $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
                                $SCOPY $OUTFIL_REPORT $i:$RTEMPDIR >/dev/null 2>&1

                                $SSHELL $i "chmod 744 $RTEMPDIR/localcmd.sh"
                                FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
	              	        returncode=`echo $?`
                                set_alvl $returncode;
                                restore_cygpath "RTEMPDIR"
                                restore_cygpath "localcmd"
			      fi

                              #$SCOPY $i:$RTEMPDIR/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1
                              #$SSHELL $i "rm -f $RTEMPDIR/localcmd.sh $RTEMPDIR/${CHECK_ID}_${i}_report.out>/dev/null 2>&1"
                              get_cygpath "OUTFIL_REPORT"
                              get_cygpath "OUTPUTDIR"
                              $SCOPY $i:$OUTFIL_REPORT $OUTPUTDIR >/dev/null 2>&1
                              $SSHELL $i "rm -f $localcmd $OUTFIL_REPORT $TRGTORCLENV>/dev/null 2>&1"
                              restore_cygpath "OUTPUTDIR"
                              restore_cygpath "OUTFIL_REPORT"
	                    fi

	              	    if [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 0 ]]
	              	    then	
	              	      get_current_epoch 
	                      echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $db_name_to_check] Execution End Time: $epoch_time" >> $CHK_TIMINGS
	                    fi

	                    move_failed_to_skipped "$returncode" "" "$i:$db_name_to_check" "1"
	                    echo "" >>$OSSPOOLFIL
	                    printf "%s %s %s %s %s %s\n" "$db_name_to_check $PARAM_PATH $ROW == $FILVAL" >>$OSSPOOLFIL
	                    #echo " $db_name_to_check $PARAM_PATH $ROW  $COM == $FILVAL" >>$OSSPOOLFIL
	                  fi 

	                  if [ $inst_mode -eq 3 ]
	                  then
	                    if [ -n "$COM_REPORT" ]
	                    then 
	                      SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	                      if [ $OFFLINE -eq 0 ]
	                      then
	                          SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
	                      else
	                          SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	                      fi
	                    fi   
	                    #PMSG=$(echo $ORIG_PMSG for ${GREEN}${db_name_to_check}${NORM})
	                    #FMSG=$(echo $ORIG_FMSG for ${ORANGE}${db_name_to_check}${NORM})
	                    PMSG=$(echo $ORIG_PMSG for ${db_name_to_check})
	                    FMSG=$(echo $ORIG_FMSG for ${db_name_to_check})
	                    VAL=`grep "$db_name_to_check $PARAM_PATH $ROW " $OSSPOOLFIL|sed  -n 's/.*== //p'`
	                    if [ $mb_db_counter -gt 0 ];then write_report_on_fail=0;fi
			
	                    get_log_result "inloop" "-"
	                    mb_db_counter_log=$(expr $mb_db_counter_log + 1)
	                    if [ $OFFLINE -eq 0 ]; then echo -e "end time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $db_name_to_check database\n">>$CHECKS_TIMING;fi
    	                    #if [[ $ISBRANCH -eq 0 &&  $OFFLINE -eq 0 ]]; then echo "${db_name_to_check}.${CHECK_ID}|${VAL}" >>$OSACTUAL ;fi;
	                  fi
                        else
                          call_get_log_result=0    
                          echo "skipping $COM at $ROW for $db_name_to_check because database role does not(${mb_database_role[$mb_db_counter]}) match to check role ($check_database_role) or database type(${mb_database_type[$mb_db_counter]}) does not match to ${check_database_type}">>$LOGFIL 
                        fi
                      fi
                      mb_db_counter=$(expr $mb_db_counter + 1)
                    done

	            if [[ $OFFLINE -eq "0" && -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 ]]
	            then
	              rm -f "$t_PSQL_METAFIL" >/dev/null 2>&1
	              rm -f "$t_PSQL_INFIL" >/dev/null 2>&1
		      rm -f "$t_PSQL_STAT" >/dev/null 2>&1
	            fi

                    mb_db_counter=0
                    write_report_on_fail=1
                    if [[ $OFFLINE -eq 0 && -e $INPUTDIR/trgt_orcl_env.orig ]]
                    then 
                      cp $INPUTDIR/trgt_orcl_env.orig $ORCLENVFIL
                      rm $INPUTDIR/trgt_orcl_env.orig
                      get_cygpath "ORCLENVFIL"
                      get_cygpath "TMPDIR"
	              if [ $i = $localnode ]; then cp $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
                      restore_cygpath "ORCLENVFIL"
                      restore_cygpath "TMPDIR"
                    fi
                    #cat $ORCLENVFIL
                    #$READ -p "after mbd os"
                  elif [[ -n "$multiple_oracle_homes" && $multiple_oracle_homes -ge 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" ]] && [[ $PARAM = "RDBMS" || $PARAM = "BI_INSTANCE" ]] && [[ -n "$ulimit_cmd" && $ulimit_cmd -eq 0 ]] 
                  #elif [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" ]]
                  then
                    ORIG_PMSG=$PMSG
                    ORIG_FMSG=$FMSG
                    if [ $OFFLINE -eq 0 ];then cp $ORCLENVFIL $INPUTDIR/trgt_orcl_env.orig;fi;
                    #cat $ORCLENVFIL
                    #$READ -p "before mbd os"
                    mb_db_counter=0
                    mb_db_counter_log=0
                    for mb_db_homes in ${mb_oracle_homes_distinct[@]}
                    do
                      skip_this_version=0
                      set_skip_this_version "$mb_db_homes"
                      if [ $skip_this_version -eq 1 ]
                      then #dont run
                        mb_db_counter=$(expr $mb_db_counter + 1)
                        echo "Skipping check($CHECK_ID) on version 2 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                        continue
                      fi
                      
                      index=1;
                      match=0
                      for dump in ${ttx_home[@]}
                      do
                        if [ $dump = $mb_db_homes ];
                        then
                          match=1;
                        fi
                        index=$(expr $index + 1);
                      done
                      if [ $match -eq 1 ]; then continue; fi		

                      mb_db_homes_without_slash=$(echo $mb_db_homes|sed 's/\///g')
                      mb_db_homes_without_slash=$(echo $mb_db_homes_without_slash|sed 's/\.//g')

	              if [[ $PARAM = "BI_INSTANCE" ]]
	              then
                      	if [ $OFFLINE -eq "0"  ]
	                then
                          echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_db_homes\n">>$CHECKS_TIMING
                      	  sed  "/ORACLE_SID/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	                  cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
                          rm $INPUTDIR/tmp_env_file.out
                      	  sed  "/ORACLE_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	                  cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
                      	  rm $INPUTDIR/tmp_env_file.out
                          inst_name=$(grep -w "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_NAME|awk '{print $3}')
	                  echo "export ORACLE_SID=${inst_name}">>$ORCLENVFIL
                          echo "export ORACLE_HOME=${mb_db_homes}">>$ORCLENVFIL
			  update_ld_lib_path
	              	  ORACLE_HOME=${mb_db_homes}
	              	  bi_instances=$(grep -iw "OBIEE_INSTANCE_MAP:" $MASTERFIL |grep -i "$ORACLE_HOME "|awk -F'=' '{print $2}')
	              	  bi_instances=$(echo $bi_instances|sed 's/,/ /g');

	              	  for bi_instance in `echo $bi_instances`		
	              	  do
                      	    bi_instance_without_slash=$(echo $bi_instance|sed 's/\///g')
	              	    bi_instance_without_slash=$(echo $bi_instance_without_slash|sed 's/\.//g')

	              	    sed "/BI_INSTANCE/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	              	    cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	              	    rm $INPUTDIR/tmp_env_file.out
	              	    echo "export BI_INSTANCE=$bi_instance">>$ORCLENVFIL

                            get_cygpath "ORCLENVFIL"
                            get_cygpath "TMPDIR"
	              	    if [ $i = $localnode ]; then cp $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
                            restore_cygpath "ORCLENVFIL"
                            restore_cygpath "TMPDIR"
	              	    #TRGTORCLENV=$TMPDIR/`basename $ORCLENVFIL`       
	              	    #localcmd=$TMPDIR/localcmd.sh
	              	    copy_env_files_to_tmp
                            nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_db_homes_without_slash}_${bi_instance_without_slash}.sh/g");

	              	    echo "#!$bash_scr" >$localcmd
	              	    echo "$RAT_DEBUG_FLG" >>$localcmd
	              	    echo "$bash_source" >>$localcmd
	              	    echo ". $TRGTORCLENV">>$localcmd
	              	    if [ -n "$COM_REPORT" ]
	              	    then
	              	      echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $mb_db_homes|tr "[a-z]" "[A-Z]") DATABASE_HOME - $(echo $bi_instance|tr "[a-z]" "[A-Z]") BI_INSTANCE - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	              	    fi

	              	    get_current_epoch 
	              	    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes][TAG2: $bi_instance] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

	              	    if [ $i = $localnode ]
	              	    then
			      OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	              	      chmod 744 $localcmd
	              	      echo "$COM">>$localcmd
	              	      #if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out 2>>$ERRFIL">>$localcmd;fi
	              	      if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi
			      echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	              	      echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

	              	      FILVAL=`$localcmd 2>>$ERRFIL`
	              	      returncode=`echo $?`
			      set_alvl $returncode;

	              	      #if [ -e $localcmd ]; then rm $localcmd; fi;
	              	      #if [ -e $localcmd ]; then mv $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
			      if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm $localcmd; fi
	              	    else
			      OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
	              	      echo "$COM">>$localcmd
	              	      #if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> $RTEMPDIR/${CHECK_ID}_${i}_report.out">>$localcmd;fi
	              	      if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> ${OUTFIL_REPORT} ">>$localcmd;fi
			      echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	              	      echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

	              	      #if [ -e $localcmd ]; then cp $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
			      if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

	              	      get_cygpath "localcmd"
	              	      get_cygpath "RTEMPDIR"
	              	      get_cygpath "OUTPUTDIR"
	              	      $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
	              	      $SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$RTEMPDIR >/dev/null 2>&1 
	              	      $SSHELL $i "chmod 744 $RTEMPDIR/localcmd.sh"
	              	      FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
	              	      returncode=`echo $?`
			      set_alvl $returncode;

	              	      $SCOPY $i:$RTEMPDIR/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1
	              	      $SSHELL $i "rm -f $RTEMPDIR/localcmd.sh $RTEMPDIR/${CHECK_ID}_${i}_report.out $TRGTORCLENV>/dev/null 2>&1"
                              restore_cygpath "localcmd"
                              restore_cygpath "RTEMPDIR"
                              restore_cygpath "OUTPUTDIR"
	              	    fi

	              	    get_current_epoch 
	              	    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes][TAG2: $bi_instance] Execution End Time: $epoch_time" >> $CHK_TIMINGS

	              	    move_failed_to_skipped "$returncode" "" "$i:$mb_db_homes:$bi_instance"
	              	    echo "" >>$OSSPOOLFIL
	              	    printf "%s %s %s %s %s %s\n" "$mb_db_homes_without_slash:$bi_instance_without_slash $PARAM_PATH $ROW == $FILVAL" >>$OSSPOOLFIL

	              	    call_get_log_result=0
	              	    PMSG=$(echo $ORIG_PMSG for ${mb_db_homes}:${bi_instance})
	              	    FMSG=$(echo $ORIG_FMSG for ${mb_db_homes}:${bi_instance})
	              	    VAL=`grep "$mb_db_homes_without_slash:$bi_instance_without_slash $PARAM_PATH $ROW " $OSSPOOLFIL|grep -i "$bi_instance"|sed  -n 's/.*== //p'`
	              	    if [ -n "$COM_REPORT" ]
	              	    then 
	              	      SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	              	      if [ $OFFLINE -eq 0 ]
	              	      then
	              	        SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
	              	      else
	              	        SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	              	      fi
	              	    fi   
	              	    if [ $mb_db_counter -gt 0 ];then write_report_on_fail=0;fi
	              	    get_log_result "inloop" "$mb_db_homes"
	              	  done
	              	fi
	              	mb_db_counter_log=$(expr $mb_db_counter_log + 1)
	              	if [ $OFFLINE -eq 0 ]; then echo -e "end time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_db_homes\n">>$CHECKS_TIMING;fi
	              	mb_db_counter=$(expr $mb_db_counter + 1)
	              	ORACLE_HOME=""
	              else
                      	if [ $OFFLINE -eq "0"  ]
                      	then
			  if [[ ! -e $mb_db_homes ]]; then
			    echo -e "skipping $audit_check_name at $CHECK_ID on ${i} because $mb_db_homes is not available.\n">>$LOGFIL
			    continue;
			  fi
	              	  echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_db_homes\n">>$CHECKS_TIMING
	              	  sed  "/ORACLE_SID/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	              	  cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	              	  rm $INPUTDIR/tmp_env_file.out
	              	  sed  "/ORACLE_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	              	  cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	              	  rm $INPUTDIR/tmp_env_file.out
	              	  inst_name=$(grep -w "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_NAME|awk '{print $3}')
	              	  echo "export ORACLE_SID=${inst_name}">>$ORCLENVFIL
	              	  echo "export ORACLE_HOME=${mb_db_homes}">>$ORCLENVFIL
			  update_ld_lib_path
	              	  get_cygpath "ORCLENVFIL"
                          if [ $i = $localnode ]; then cp $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
	              	  restore_cygpath "ORCLENVFIL"
	              	  #TRGTORCLENV=$TMPDIR/`basename $ORCLENVFIL`       
	              	  #localcmd=$TMPDIR/localcmd.sh
	              	  copy_env_files_to_tmp "$usern"
	              	  nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_db_homes_without_slash}.sh/g");

	              	  echo "#!$bash_scr" >$localcmd
	              	  echo "$RAT_DEBUG_FLG" >>$localcmd
	              	  echo "$bash_source" >>$localcmd
	              	  echo ". $TRGTORCLENV">>$localcmd

	              	  get_current_epoch 
	              	  echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

	              	  if [ $i = $localnode ]
	              	  then
			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			      OUTFIL_REPORT=${TMP_OUTPUT}/${CHECK_ID}_${i}_report.out
			      OLD_OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			    else
			      OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			    fi
	              	    if [ -n "$COM_REPORT" ]; then
	              	      echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $mb_db_homes|tr "[a-z]" "[A-Z]") DATABASE_HOME - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$OUTFIL_REPORT
	              	    fi
	              	    echo "$COM">>$localcmd
	              	    #if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out 2>>$ERRFIL">>$localcmd;fi
	              	    if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi
			    echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	              	    echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd
                            if [[ -e $localcmd ]]; then chmod 744 $localcmd; fi
                            if [[ -e $TRGTORCLENV ]] ; then chmod 744 $TRGTORCLENV; fi

			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			      if [ $OFFLINE -eq 0  ]; then
				OLD_OH=$ORACLE_HOME
				ORACLE_HOME=${mb_db_homes}
			        get_dbOwner
				ORACLE_HOME=$OLD_OH
			      else
				dbOwner=$(grep "RDBMS_ORACLE_HOME = $mb_db_homes" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f3)
  				if [ -n $dbOwner ]; then 
				  dbGroup=$(groups "$dbOwner"|cut -d: -f2|awk '{print $1}'|sed 's/ //g');
				  dbhome_dir=$(cat /etc/passwd|grep -w "$dbOwner"|cut -d":" -f6);
				fi
				OLD_DIR=`pwd`
				cd "$dbhome_dir";  
			      fi 

	              	      chown $dbOwner:$dbGroup $localcmd
			      chown $dbOwner:$dbGroup $TRGTORCLENV 
	              	      FILVAL=`su $dbOwner -c "$localcmd" 2>>$ERRFIL`
	              	      returncode=`echo $?`
			      set_alvl $returncode;

			      move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
	  		      cd $OLD_DIR
	    		      unset OLD_DIR
			    else
	              	      FILVAL=`$localcmd 2>>$ERRFIL`
	              	      returncode=`echo $?`
			      set_alvl $returncode;
			    fi

	              	    #if [ -e $localcmd ]; then rm $localcmd; fi;
                            #if [ -e $localcmd ]; then mv $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
			    if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm $localcmd; fi
	              	  else
			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			      OUTFIL_REPORT=$TMP_OUTPUT/${CHECK_ID}_${i}_report.out
			      OLD_OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
			    else
			      OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
			    fi
	              	    if [ -n "$COM_REPORT" ]; then
	              	      echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $mb_db_homes|tr "[a-z]" "[A-Z]") DATABASE_HOME - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$OUTFIL_REPORT
	              	    fi
	              	    echo "$COM">>$localcmd
	              	    #if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> $RTEMPDIR/${CHECK_ID}_${i}_report.out">>$localcmd;fi
	              	    if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> ${OUTFIL_REPORT}">>$localcmd;fi
			    echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	              	    echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

                            #if [ -e $localcmd ]; then cp $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
			    if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

	              	    #$SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
	              	    #$SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$RTEMPDIR >/dev/null 2>&1 

			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
	              	      $SCOPY $localcmd $i:$TMP_OUTPUT >/dev/null 2>&1
	              	      $SCOPY $OUTFIL_REPORT $i:$TMP_OUTPUT >/dev/null 2>&1 

			      if [ $OFFLINE -eq 0  ]; then
				OLD_OH=$ORACLE_HOME
				ORACLE_HOME=${mb_db_homes}
			        get_dbOwner
				ORACLE_HOME=$OLD_OH
			      else
				dbOwner=$(grep "RDBMS_ORACLE_HOME = $mb_db_homes" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f3)
  				if [ -n $dbOwner ]; then 
				  dbGroup=$(groups "$dbOwner"|cut -d: -f2|awk '{print $1}'|sed 's/ //g');
				  dbhome_dir=$(cat /etc/passwd|grep -w "$dbOwner"|cut -d":" -f6);
				fi
				OLD_DIR=`pwd`
				cd "$dbhome_dir";  
			      fi 
			      if [ -n $dbOwner ]; then dbGroup=$(groups "$dbOwner"|cut -d: -f2|awk '{print $1}'|sed 's/ //g'); fi

                              $SSHELL $i "chmod 744 $TRGTORCLENV"
                              $SSHELL $i "chmod 744 $localcmd"
			      $SSHELL $i "chown $dbOwner:$dbGroup $TRGTORCLENV"
			      $SSHELL $i "chown $dbOwner:$dbGroup $localcmd"
	              	      FILVAL=`$SSHELL $i "su $dbOwner -c \"$TMP_OUTPUT/localcmd.sh\"" 2>>$ERRFIL`
	              	      returncode=`echo $?`
			      set_alvl $returncode;
	  		      cd $OLD_DIR
	    		      unset OLD_DIR
			    else
	              	      $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
	              	      $SCOPY $OUTFIL_REPORT $i:$RTEMPDIR >/dev/null 2>&1 

	              	      $SSHELL $i "chmod 744 $RTEMPDIR/localcmd.sh"
	              	      FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
	              	      returncode=`echo $?`
			      set_alvl $returncode;
			    fi

	              	    #$SCOPY $i:$RTEMPDIR/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1
	              	    #$SSHELL $i "rm -f $RTEMPDIR/localcmd.sh $RTEMPDIR/${CHECK_ID}_${i}_report.out>/dev/null 2>&1"
	              	    $SCOPY $i:$OUTFIL_REPORT $OUTPUTDIR >/dev/null 2>&1
			    $SSHELL $i "rm -f $localcmd $OUTFIL_REPORT $TRGTORCLENV>/dev/null 2>&1"
	              	  fi

	              	  get_current_epoch 
	              	  echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_db_homes] Execution End Time: $epoch_time" >> $CHK_TIMINGS

	              	  move_failed_to_skipped "$returncode" "" "$i:$mb_db_homes"
	              	  echo "" >>$OSSPOOLFIL
	              	  #echo " $mb_db_homes_without_slash $PARAM_PATH $ROW  $COM == $FILVAL" >>$OSSPOOLFIL
	              	  printf "%s %s %s %s %s %s\n" "$mb_db_homes_without_slash $PARAM_PATH $ROW == $FILVAL" >>$OSSPOOLFIL
	              	fi
	              	call_get_log_result=0
	              	PMSG=$(echo $ORIG_PMSG for ${mb_db_homes})
	              	FMSG=$(echo $ORIG_FMSG for ${mb_db_homes})
	              	#RPT_PMSG=$(echo $ORIG_PMSG for ${mb_db_homes})
	              	#RPT_FMSG=$(echo $ORIG_FMSG for ${mb_db_homes})
	              	VAL=`grep "$mb_db_homes_without_slash $PARAM_PATH $ROW " $OSSPOOLFIL|sed  -n 's/.*== //p'`
	              	if [ -n "$COM_REPORT" ]
	              	then 
	              	  SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	              	  if [ $OFFLINE -eq 0 ]
	              	  then
	              	    SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
	              	  else
	              	    SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	              	  fi
	              	fi   
	              	if [ $mb_db_counter -gt 0 ];then write_report_on_fail=0;fi
	              	get_log_result "inloop" "$mb_db_homes"
	              	mb_db_counter_log=$(expr $mb_db_counter_log + 1)
	              	if [ $OFFLINE -eq 0 ]; then echo -e "end time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_db_homes\n">>$CHECKS_TIMING;fi
	              	mb_db_counter=$(expr $mb_db_counter + 1)
	                #if [[ $ISBRANCH -eq 0 &&  $OFFLINE -eq 0 ]]; then echo "${mb_db_homes_without_slash}.${CHECK_ID}|${VAL}" >>$OSACTUAL; fi    
	              	#mb_db_counter=$(expr $mb_db_counter + 1)
                      fi
                    done
                    mb_db_counter=0 
                    write_report_on_fail=1

                    if [[ $OFFLINE -eq 0 && -e $INPUTDIR/trgt_orcl_env.orig ]]
                    then
                      cp $INPUTDIR/trgt_orcl_env.orig $ORCLENVFIL
                      rm $INPUTDIR/trgt_orcl_env.orig
                      if [ $i = $localnode ]; then cp $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
                    fi
                  elif [[ $is_goldengate_installed -eq 1 && "$PARAM" = "GOLDENGATE_HOME" ]]
                  then 
                    ORIG_PMSG=$PMSG
                    ORIG_FMSG=$FMSG
                    #for mb_ogg_home in `cat  $OGGHOMESVERSIONFIL|grep -wi $i|cut -d'|' -f2`
                    for mb_ogg_home in `grep -wi $i $OGGHOMESVERSIONFIL|cut -d'|' -f2`
                    do
                      mb_ogg_home_without_slash=$(echo $mb_ogg_home|sed 's/\///g')
                      mb_ogg_home_without_slash=$(echo $mb_ogg_home_without_slash|sed 's/\.//g')
                      #mb_ogg_home_version=$(cat  $OGGHOMESVERSIONFIL|grep -wi $mb_ogg_home|cut -d'|' -f3|sed 's/\.//g')
                      mb_ogg_home_version=$(grep -wi $mb_ogg_home $OGGHOMESVERSIONFIL|cut -d'|' -f3|sed 's/\.//g')
                      ogg_version_found=$(echo $check_exadata_version|grep -iwc $mb_ogg_home_version)
                      if [ $ogg_version_found -gt 0 ]
                      then
                        if [ $OFFLINE -eq "0"  ]
                        then
		          echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_ogg_home\n">>$CHECKS_TIMING
		          #echo "export ORACLE_HOME=${mb_db_homes}">>$ORCLENVFIL
		          echo "export ORACLE_OGG_HOME=${mb_ogg_home}">>$ORCLENVFIL
			  update_ld_lib_path
                     	  if [ $i = $localnode ]; then cp $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
		          #TRGTORCLENV=$TMPDIR/`basename $ORCLENVFIL`       
		          #localcmd=$TMPDIR/localcmd.sh
		          copy_env_files_to_tmp
		          nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${mb_ogg_home_without_slash}.sh/g");

		          echo "#!$bash_scr" >$localcmd
		          echo "$RAT_DEBUG_FLG" >>$localcmd
		          echo "$bash_source" >>$localcmd
		          echo ". $TRGTORCLENV">>$localcmd
		          if [ -n "$COM_REPORT" ]
		          then
		            echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $mb_ogg_home|tr "[a-z]" "[A-Z]") GOLDENGATE_HOME - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
		          fi

		          get_current_epoch 
		          echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_ogg_home] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

		          if [ $i = $localnode ]
		          then
			    OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
		            chmod 744 $localcmd
		            echo "$COM">>$localcmd
		            #if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out 2>>$ERRFIL">>$localcmd;fi
		            if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi
			    echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
		            echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

		            FILVAL=`$localcmd 2>>$ERRFIL`
		            returncode=`echo $?`
			    set_alvl $returncode;

		            #if [ -e $localcmd ]; then rm $localcmd; fi;
                            #if [ -e $localcmd ]; then mv $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
			    if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm $localcmd; fi
		          else
			    OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
		            echo "$COM">>$localcmd
		            #if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> $RTEMPDIR/${CHECK_ID}_${i}_report.out">>$localcmd;fi
		            if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> ${OUTFIL_REPORT}">>$localcmd;fi
			    echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
		            echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

		            #if [ -e $localcmd ]; then cp $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
			    if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

		            $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
		            $SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$RTEMPDIR >/dev/null 2>&1 
		            $SSHELL $i "chmod 744 $RTEMPDIR/localcmd.sh"
		            FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
		            returncode=`echo $?`
			    set_alvl $returncode;

		            $SCOPY $i:$RTEMPDIR/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1
		            $SSHELL $i "rm -f $RTEMPDIR/localcmd.sh $RTEMPDIR/${CHECK_ID}_${i}_report.out $TRGTORCLENV>/dev/null 2>&1"
		          fi

		          get_current_epoch 
		          echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $mb_ogg_home] Execution End Time: $epoch_time" >> $CHK_TIMINGS

		          move_failed_to_skipped "$returncode" "" "$i:$mb_ogg_home"
		          echo "" >>$OSSPOOLFIL
		          printf "%s %s %s %s %s %s\n" "$mb_ogg_home_without_slash $PARAM_PATH $ROW == $FILVAL" >>$OSSPOOLFIL
		        fi
		        call_get_log_result=0
		        PMSG=$(echo $ORIG_PMSG for ${mb_ogg_home})
		        FMSG=$(echo $ORIG_FMSG for ${mb_ogg_home})
		        #RPT_PMSG=$(echo $ORIG_PMSG for ${mb_db_homes})
		        #RPT_FMSG=$(echo $ORIG_FMSG for ${mb_db_homes})
		        VAL=`grep "$mb_ogg_home_without_slash $PARAM_PATH $ROW " $OSSPOOLFIL|sed  -n 's/.*== //p'`
		        if [ -n "$COM_REPORT" ]
		        then 
		          SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
		          if [ $OFFLINE -eq 0 ]
		          then
		            SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
		          else
		            SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
		          fi
		        fi   
		        get_log_result "inloop" "$mb_ogg_home"
		        if [ $OFFLINE -eq 0 ]; then echo -e "end time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_ogg_home\n">>$CHECKS_TIMING;fi
	                #if [[ $ISBRANCH -eq 0 &&  $OFFLINE -eq 0 ]]; then echo "${mb_db_homes_without_slash}.${CHECK_ID}|${VAL}" >>$OSACTUAL; fi    
                      else
		        call_get_log_result=0
                        echo "skipping $audit_check_name at $CHECK_ID for $mb_ogg_home because check version OGG_HOME_VERSION($mb_ogg_home_version) is not applied to check ($check_exadata_version)">>$LOGFIL
                      fi
                    done
                    if [[ $OFFLINE -eq 0 && -e $INPUTDIR/trgt_orcl_env.orig ]]
                    then
                      cp $INPUTDIR/trgt_orcl_env.orig $ORCLENVFIL
                      rm $INPUTDIR/trgt_orcl_env.orig
                      if [ $i = $localnode ]; then cp $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
                    fi
                  elif [[ $multiple_db -eq 0 && "$NEEDS_RUNNING" = "RDBMS" ]]
                  #elif [[ -n "$ulimit_cmd" && $ulimit_cmd -eq 0 ]] && [[ "$NEEDS_RUNNING" = "RDBMS" || $PARAM = "RDBMS" ]]
                  then
                    ORIG_PMSG=$PMSG
                    ORIG_FMSG=$FMSG
                    mb_db_counter=0 
                    mb_db_counter_log=0 
                    if [ $OFFLINE -eq 0  ]
                    then
                      current_oh_owner=$(ls -l ${mb_oracle_homes[$mb_db_counter]}/bin/oracle|awk '{print $3}')
                      if [[ -z $current_oh_owner ]]; then
                        current_oh_host=$(grep -w "RDBMS_ORACLE_HOME = ${mb_oracle_homes[$mb_db_counter]}" $MASTERFIL|awk '{print $3}'|cut -d '|' -f4|cut -d ',' -f1)
                        t_flag="-T"
                        current_oh_owner=`$SSHELL $t_flag ${current_oh_host} "ls -l ${mb_oracle_homes[$mb_db_counter]}/bin/oracle 2>/dev/null >&1|awk '{print \\$3}'"`
                      fi
	              inst_mode=$(grep "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_MODE|awk '{print $3}')
                    else
	              inst_mode=$(grep "$i.$db_name_to_check" $DUMPDIR/$CHKFIL|grep INSTANCE_MODE|awk '{print $3}')
                      usern=$(grep "CURRENT_USER" $DUMPDIR/$CHKFIL|awk '{print $3}')
                      current_oracle_home=$(grep "DB_NAME = $db_name_to_check" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f3)
                      current_oh_owner=$(grep "RDBMS_ORACLE_HOME = $current_oracle_home" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f3)
                    fi
		    if [[ -n $current_oh_owner ]]; then 
		      dbGroup=$(groups "$current_oh_owner"|cut -d: -f2|awk '{print $1}'|sed 's/ //g');
                      if [[ -z $dbGroup && $OFFLINE -eq 0 ]]; then
                        dbGroup=`$SSHELL $t_flag ${current_oh_host} "groups "$current_oh_owner"|cut -d: -f2|awk '{print \\$1}'|sed 's/ //g'"`
                        dbhome_dir=`$SSHELL $t_flag ${current_oh_host} "cat /etc/passwd|grep -w "$current_oh_owner"|cut -d":" -f6"`
                      else
                        dbhome_dir=$(cat /etc/passwd|grep -w "$current_oh_owner"|cut -d":" -f6);
                      fi
		    fi 
                    #echo "current_oh_owner=$current_oh_owner all_homes=${mb_oracle_homes[@]} current_home=${mb_oracle_homes[$mb_db_counter]} usern=$usern"
	            call_get_log_result=0
                    skip_this_version=0
                    set_skip_this_version "-"
                    if [ $skip_this_version -eq 1 ] ; then
                      echo "Skipping check($CHECK_ID) on version 3 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                    fi

                    #if [[ $skip_this_version -eq 0 && $usern = $current_oh_owner ]]
                    if [[ $skip_this_version -eq 0 && $usern = $current_oh_owner ]] || [[ $skip_this_version -eq 0 && -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]
                    then
                      skip_this_version=0
                    else
                      skip_this_version=1
                    fi

                    if [ $skip_this_version -eq 0 ]
                    then
                      match_database_role "${mb_database_role[$mb_db_counter]}"
                      match_database_type "${mb_database_type[$mb_db_counter]}"
                      if [[ $dbrole_match_count -ge 1 && $dbtype_match_count -ge 1 ]]      
                      #if [[ "${mb_database_role[$mb_db_counter]}" = "$check_database_role" ]]
                      then
		        if [[ $OFFLINE -eq "0" && $inst_mode -eq 3 ]]
		        then
	  	          echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i}\n">>$CHECKS_TIMING
	    	          #$READ -p "os_check_needs_collect_file=$os_check_needs_collect_file VAL_FIL=$VAL_FIL collect_file_counter=$collect_file_counter file_to_copy=$OUTPUTDIR/$VAL_FIL"   

                          sed  "/ORACLE_SID/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
                          cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
                          rm $INPUTDIR/tmp_env_file.out
                          sed  "/ORACLE_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
                          cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
                          rm $INPUTDIR/tmp_env_file.out
                          inst_name=$(grep -w "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_NAME|awk '{print $3}')
                          echo "export ORACLE_SID=${inst_name}">>$ORCLENVFIL
                          echo "export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}">>$ORCLENVFIL
			  update_ld_lib_path
                          get_cygpath "ORCLENVFIL"
                          if [ $i = $localnode ]; then cp $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
                          restore_cygpath "ORCLENVFIL"
                          #TRGTORCLENV=$TMPDIR/`basename $ORCLENVFIL`
		          #localcmd=$TMPDIR/localcmd.sh
		          copy_env_files_to_tmp "$usern"
	                  nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}.sh/g");

		          echo "#!$bash_scr" >$localcmd
		          echo "$RAT_DEBUG_FLG" >>$localcmd
		          echo "$bash_source" >>$localcmd
		          echo ". $TRGTORCLENV">>$localcmd

		          get_current_epoch 
		          echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $db_name_to_check] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

		          if [ $i = $localnode ]
		          then
			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			      OUTFIL_REPORT=${TMP_OUTPUT}/${CHECK_ID}_${i}_report.out
			      OLD_OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			    else
			      OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			    fi
		            if [ -n "$COM_REPORT" ]; then 
		              #echo "echo -e $COM_REPORT \\n Above command was executed on $i for following output\\n >${OUTPUTDIR}/${CHECK_ID}_${i}_report.out">>$localcmd 
		              echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $db_name_to_check|tr "[a-z]" "[A-Z]") DATABASE - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$OUTFIL_REPORT
		            fi
		            echo "$COM 2>>$ERRFIL">>$localcmd
		            #if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out 2>>$ERRFIL">>$localcmd;fi
		            if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi
			    echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
		            echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd
		            #echo "exit 0">>$localcmd
		            if [[ -e $localcmd ]]; then chmod 744 $localcmd; fi
			    if [[ -e $TRGTORCLENV ]]; then chmod 744 $TRGTORCLENV; fi

			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			      OLD_DIR=`pwd`
			      cd "$dbhome_dir";

		              chown $current_oh_owner:$dbGroup $TRGTORCLENV
			      chown $current_oh_owner:$dbGroup $localcmd    
			      FILVAL=`su ${current_oh_owner} -c "$localcmd 2>>$ERRFIL"`
		              returncode=`echo $?`
			      set_alvl $returncode;	

			      move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
			      cd $OLD_DIR
	    		      unset OLD_DIR
			    else
		              FILVAL=`$localcmd 2>>$ERRFIL`
		              returncode=`echo $?`
			      set_alvl $returncode;
			    fi

		            #if [ -e $localcmd ]; then rm $localcmd; fi;
		            #if [ -e $localcmd ]; then mv $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
			    if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm $localcmd; fi
		          else
			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			      OUTFIL_REPORT=$TMP_OUTPUT/${CHECK_ID}_${i}_report.out
			      OLD_OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
			    else
			      OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
			    fi
		            if [ -n "$COM_REPORT" ]; then 
		              #echo "echo -e $COM_REPORT \\n Above command was executed on $i for following output\\n >${OUTPUTDIR}/${CHECK_ID}_${i}_report.out">>$localcmd 
		              echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $db_name_to_check|tr "[a-z]" "[A-Z]") DATABASE - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$OUTFIL_REPORT
		            fi
		            echo "$COM">>$localcmd
		            #if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> $RTEMPDIR/${CHECK_ID}_${i}_report.out">>$localcmd;fi
		            if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> ${OUTFIL_REPORT}">>$localcmd;fi
			    echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
		            echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd
		               	   
		            #if [ -e $localcmd ]; then cp $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
			    if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

		            #$SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
		            #$SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$RTEMPDIR >/dev/null 2>&1

			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			      OLD_DIR=`pwd`
			      cd "$dbhome_dir";

		              $SCOPY $localcmd $i:$TMP_OUTPUT >/dev/null 2>&1
		              $SCOPY $OUTFIL_REPORT $i:$TMP_OUTPUT >/dev/null 2>&1

                              $SSHELL $i "chmod 744 $TRGTORCLENV"
                              $SSHELL $i "chmod 744 $localcmd"
			      $SSHELL $i "chown $current_oh_owner:$dbGroup $TRGTORCLENV"
			      $SSHELL $i "chown $current_oh_owner:$dbGroup $localcmd"
		              FILVAL=`$SSHELL $i "su ${current_oh_owner} -c \"$TMP_OUTPUT/localcmd.sh\"" 2>>$ERRFIL`
		              returncode=`echo $?`
                              set_alvl $returncode;
			      cd $OLD_DIR
	    		      unset OLD_DIR
			    else
		              $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
			      $SCOPY $OUTFIL_REPORT $i:$RTEMPDIR >/dev/null 2>&1

		              $SSHELL $i "chmod 744 $RTEMPDIR/localcmd.sh"
		              FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
		              returncode=`echo $?`
                              set_alvl $returncode;
			    fi

		            #$SCOPY $i:$RTEMPDIR/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1
		            #$SSHELL $i "rm -f $RTEMPDIR/localcmd.sh $RTEMPDIR/${CHECK_ID}_${i}_report.out>/dev/null 2>&1"
		            $SCOPY $i:$OUTFIL_REPORT $OUTPUTDIR >/dev/null 2>&1
		  	    $SSHELL $i "rm -f $localcmd $OUTFIL_REPORT $TRGTORCLENV>/dev/null 2>&1"	
		          fi

		          get_current_epoch 
		          echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $db_name_to_check] Execution End Time: $epoch_time" >> $CHK_TIMINGS

		          move_failed_to_skipped "$returncode" "" "$i"
		          echo "" >>$OSSPOOLFIL
		          #echo " $PARAM_PATH $ROW  $COM == $FILVAL" >>$OSSPOOLFIL
		          printf "%s %s %s %s %s\n" " $PARAM_PATH $ROW == $FILVAL" >>$OSSPOOLFIL
                        else
                           #this part for bug 19134391 when instance is not running(inst_mode=0)
                          call_get_log_result=0
                          echo "skipping $COM at $CHECK_ID for $db_name_to_check because instance for $db_name_to_check is down on $i">>$LOGFIL
		        fi
		        #PMSG=$(echo $ORIG_PMSG for ${GREEN}${db_name_to_check}${NORM})
		        #FMSG=$(echo $ORIG_FMSG for ${ORANGE}${db_name_to_check}${NORM})
		        PMSG=$(echo $ORIG_PMSG for ${db_name_to_check})
		        FMSG=$(echo $ORIG_FMSG for ${db_name_to_check}) 
		        if [ -n "$COM_REPORT" ]
		        then
		          SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out 
		          if [ $OFFLINE -eq 0 ]
		          then
		            SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
		          else
		            SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
		          fi                 
		        fi
		        if [ $inst_mode -eq 3 ]
		        then
		          call_get_log_result=0
		          VAL=`grep "$PARAM_PATH $ROW " $OSSPOOLFIL|sed  -n 's/.*== //p'`
		          #VAL=`grep "$mb_db_homes_without_slash $PARAM_PATH $ROW " $OSSPOOLFIL|sed  -n 's/.*== //p'`
		          if [ $mb_db_counter -gt 0 ];then write_report_on_fail=0;fi
		          get_log_result "inloop" "-"
		          mb_db_counter_log=$(expr $mb_db_counter_log + 1)
		          if [ $OFFLINE -eq 0 ]; then echo -e "end time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_db_homes\n">>$CHECKS_TIMING;fi
		        fi
                      else
                        call_get_log_result=0
                        echo "skipping $COM at $CHECK_ID for $db_name_to_check because database role does not(${mb_database_role[$mb_db_counter]}) match to check role ($check_database_role) or database type(${mb_database_type[$mb_db_counter]}) does not match to ${check_database_type}">>$LOGFIL
                      fi
                    fi
                  elif [[ $NEEDS_RUNNING = "ZFS" && -n "$zfs_password_status" && $zfs_password_status -ne 3 && -e $ZFSIP ]] && [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" || $is_ssc_machine -eq 1 ]] && [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]]
                  then 
                    ORIG_PMSG=$PMSG
                    ORIG_FMSG=$FMSG
                    cell_count=0    
                    COM_KEYWORK=$COM

                    if [ `cat $ZFSIP| wc -l` -eq "0" ] ; then call_get_log_result=0; fi
                    for cellname in `cat $ZFSIP|cut -d= -f2|sed 's/"//g'`
                    do     
		      if [ $OFFLINE -eq "0" ]
		      then
		        echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${cellname}\n">>$CHECKS_TIMING
                        unset COM
                        unset col_result_count  
                        check_begin_pattern_check=START_OF_AUDIT_CHECK_${COM_KEYWORK}.aksh
                        check_end_pattern_check=END_OF_AUDIT_CHECK_${COM_KEYWORK}.aksh
                        check_begin_pattern_report=START_OF_REPORT_${COM_KEYWORK}.aksh
                        check_end_pattern_report=END_OF_REPORT_${COM_KEYWORK}.aksh
       			COM="sed -n /$check_begin_pattern_check/,/$check_end_pattern_check/p $OUTPUTDIR/${cellname}.exalogic_zfs_checks.out|sed '1d'|sed '\$d'|awk '{print \$NF}'"
                 	COM_REPORT="sed -n /$check_begin_pattern_report/,/$check_end_pattern_report/p $OUTPUTDIR/${cellname}.exalogic_zfs_checks.out|sed '1d'|sed '\$d'"
                        col_result_count=$(grep -wic "$check_end_pattern_report" $OUTPUTDIR/${cellname}.exalogic_zfs_checks.out)
		        #localcmd=$TMPDIR/localcmd.sh
                        if [[ -n "$col_result_count" && $col_result_count -gt 0 ]]
                        then
			    copy_env_files_to_tmp
			    nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}_${cellname}.sh/g");
                            call_get_log_result=1
			    echo "#!$bash_scr" >$localcmd
			    echo "$RAT_DEBUG_FLG" >>$localcmd
			    echo "$bash_source" >>$localcmd
			    echo ". $TRGTORCLENV">>$localcmd
			    echo "$COM 2>>$ERRFIL">>$localcmd
			    if [ -n "$COM_REPORT" ]
			    then 
			      OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			      echo -e "TO REVIEW COLLECTED DATA FROM $(echo ${cellname}|tr "[a-z]" "[A-Z]") FOR $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			      echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd
			    fi

			    get_current_epoch 
			    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $cellname] Execution Start Time: $epoch_time" >> $CHK_TIMINGS		      
	    
			    chmod 744 $localcmd
			    echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
			    echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

			    FILVAL=`$localcmd 2>>$ERRFIL`
			    returncode=`echo $?`
			    set_alvl $returncode;

			    if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm $localcmd; fi
			    get_current_epoch 
			    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $cellname] Execution End Time: $epoch_time" >> $CHK_TIMINGS		      
			    move_failed_to_skipped "$returncode" "" "$i:$cellname"
			    echo "" >>$OSSPOOLFIL
			    printf "%s %s %s %s %s\n" " $PARAM_PATH $ROW ${cellname} == $FILVAL" >>$OSSPOOLFIL
                        else
                            call_get_log_result=0
                            echo "skipping $audit_check_name($CHECK_ID) for $cellname because $check_begin_pattern_check does not exists in $OUTPUTDIR/${cellname}.exalogic_zfs_checks.out">>$SKIPFIL
                            generate_exceptions_xml  "skipping $audit_check_name($CHECK_ID) for $cellname because $check_begin_pattern_check does not exists in $OUTPUTDIR/${cellname}.exalogic_zfs_checks.out"
                            let G_SKIP_CHECKS=$G_SKIP_CHECKS+1
                            let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1;
                        fi #end if when output for a check is not found in storage server collection file
		      fi # end of OFFLINE if
		      if [ -n "$COM_REPORT" ]
		      then
			   SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			   if [ $OFFLINE -eq 0 ]
			   then
			       SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
			   else
			       SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
		           fi
		      fi
		      #$READ -p "stop for cell check"
		      PMSG=$(echo $ORIG_PMSG for ${cellname})
		      FMSG=$(echo $ORIG_FMSG for ${cellname})
		      VAL=`grep "$PARAM_PATH $ROW " $OSSPOOLFIL|grep ${cellname} |sed  -n 's/.*== //p'`
                      if [ $cell_count -gt 0 ];then write_report_on_fail=0;fi
                      if [[ -n "$call_get_log_result" && $call_get_log_result -eq 1 ]]; then get_log_result;call_get_log_result=0; fi
                      if [ $OFFLINE -eq 0 ]; then echo -e "end time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_db_homes\n">>$CHECKS_TIMING;fi
                      cell_count=$( expr $cell_count + 1 )
                    done  
             	    cell_count=0 
         	  elif [[ -z "$NEEDS_RUNNING" || $NEEDS_RUNNING != "ZFS" ]]
                  then
	            if [ $OFFLINE -eq "0" ]
	            then
                      echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i}\n">>$CHECKS_TIMING
                      #localcmd=$TMPDIR/localcmd.sh
                      copy_env_files_to_tmp "$usern"
	              nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}.sh/g");

                      echo "#!$bash_scr" >$localcmd
	              echo "$RAT_DEBUG_FLG" >>$localcmd
                      echo "$bash_source" >>$localcmd
                      echo ". $TRGTORCLENV">>$localcmd
	              #$READ -p "os_check_needs_collect_file=$os_check_needs_collect_file VAL_FIL=$VAL_FIL collect_file_counter=$collect_file_counter file_to_copy=$OUTPUTDIR/$VAL_FIL"   
	              
	              get_current_epoch 
	              echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution Start Time: $epoch_time" >> $CHK_TIMINGS
		      if [[ -e $localcmd ]]; then chmod 744 $localcmd; fi
		      if [[ -e $TRGTORCLENV ]]; then chmod 744 $TRGTORCLENV; fi
	              
	              if [ $i = $localnode ]
	              then
			if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		          OUTFIL_REPORT=${TMP_OUTPUT}/${CHECK_ID}_${i}_report.out
		          OLD_OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			else
		          OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			fi
                        if [ -n "$COM_REPORT" ]; then
                          echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$OUTFIL_REPORT
                        fi 
	                echo "$COM 2>>$ERRFIL">>$localcmd
                        #if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out 2>>$ERRFIL">>$localcmd;fi 
                        if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi 
			echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	                echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd
	
			if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			  OLD_OH=$ORACLE_HOME
			  ORACLE_HOME=$CRS 
			  get_dbOwner
			  ORACLE_HOME=$OLD_OH

			  chown $dbOwner:$dbGroup $TRGTORCLENV	
			  chown $dbOwner:$dbGroup $localcmd
			  FILVAL=`su $dbOwner -c "$localcmd" 2>>$ERRFIL`
	                  returncode=`echo $?`
			  set_alvl $returncode;

			  move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append"
	  		  cd $OLD_DIR
	    		  unset OLD_DIR
			else
                          FILVAL=`$localcmd 2>>$ERRFIL`
	                  returncode=`echo $?`
			  set_alvl $returncode;
			fi
                        #if [ -e $localcmd ]; then rm $localcmd; fi;
	                #if [ -e $localcmd ]; then mv $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
			if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm $localcmd; fi
	              else
                        if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]]
                        then
			  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		            OUTFIL_REPORT=${TMP_OUTPUT}/${CHECK_ID}_${i}_report.out
		            OLD_OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			  else
		            OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			  fi
                          if [ -n "$COM_REPORT" ]; then
                            echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$OUTFIL_REPORT
                          fi 
			  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			    OLD_OH=$ORACLE_HOME
			    ORACLE_HOME=$CRS 
			    get_dbOwner
			    ORACLE_HOME=$OLD_OH
			
			    chown $dbOwner:$dbGroup $TRGTORCLENV	
	                    FILVAL=`$SSHELL_EL $i "su $dbOwner -c \". $TRGTORCLENV; $COM\"" 2>>$ERRFIL`
  			    FILVAL=$(echo $FILVAL|tr -d '\r')
                            if [ -n "$COM_REPORT" ]; then 
			      #$SSHELL_EL $i "su $dbOwner -c \". $TRGTORCLENV; $COM_REPORT\"" 2>>$ERRFIL >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out;
			      $SSHELL_EL $i "su $dbOwner -c \". $TRGTORCLENV; $COM_REPORT\"" 2>>$ERRFIL >>$OUTFIL_REPORT;

			      move_files "$OUTFIL_REPORT" "$OLD_OUTFIL_REPORT" "append" 
			    fi
	  		    cd $OLD_DIR
	    		    unset OLD_DIR
			  else
	                    FILVAL=`$SSHELL_EL $i " . $TRGTORCLENV; $COM" 2>>$ERRFIL`
  			    FILVAL=$(echo $FILVAL|tr -d '\r')
                            if [ -n "$COM_REPORT" ]; then 
			      #$SSHELL_EL $i " . $TRGTORCLENV; $COM_REPORT" 2>>$ERRFIL >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out;
			      $SSHELL_EL $i " . $TRGTORCLENV; $COM_REPORT" 2>>$ERRFIL >>$OUTFIL_REPORT;
			    fi
			  fi
                        else
			  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		            OUTFIL_REPORT=$TMP_OUTPUT/${CHECK_ID}_${i}_report.out
		            OLD_OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
			  else
		            OUTFIL_REPORT=$RTEMPDIR/${CHECK_ID}_${i}_report.out
			  fi
                          if [ -n "$COM_REPORT" ]; then
                            echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$OUTFIL_REPORT
                          fi 
                          echo "$COM">>$localcmd
                          #if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> $RTEMPDIR/${CHECK_ID}_${i}_report.out">>$localcmd;fi
                          if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> ${OUTFIL_REPORT}">>$localcmd;fi
			  echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	                  echo "if [ -n \"\$rat_exitcode\" ]; then exit \$rat_exitcode; else exit 0;fi">>$localcmd

   	                  #if [ -e $localcmd ]; then cp $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
			  if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

                          #$SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
                          #$SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$RTEMPDIR >/dev/null 2>&1
			
			  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                            $SCOPY $localcmd $i:$TMP_OUTPUT >/dev/null 2>&1
                            $SCOPY $OUTFIL_REPORT $i:$TMP_OUTPUT >/dev/null 2>&1

			    OLD_OH=$ORACLE_HOME
			    ORACLE_HOME=$CRS 
			    get_dbOwner
			    ORACLE_HOME=$OLD_OH

                            $SSHELL $i "chmod 744 $TRGTORCLENV"
                            $SSHELL $i "chmod 744 $localcmd"
			    $SSHELL $i "chown $dbOwner:$dbGroup $TRGTORCLENV"
                            $SSHELL $i "chown $dbOwner:$dbGroup $localcmd"
                            FILVAL=`$SSHELL $i "su $dbOwner -c \"$TMP_OUTPUT/localcmd.sh\"" 2>>$ERRFIL` 
	                    returncode=`echo $?`
			    set_alvl $returncode;
	  		    cd $OLD_DIR
	    		    unset OLD_DIR
			  else
                            $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
                            $SCOPY $OUTFIL_REPORT $i:$RTEMPDIR >/dev/null 2>&1

                            $SSHELL $i "chmod 744 $RTEMPDIR/localcmd.sh"
                            FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
	                    returncode=`echo $?`
			    set_alvl $returncode;
                          fi
                          #$SCOPY $i:$RTEMPDIR/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1
                          #$SSHELL $i "rm -f $RTEMPDIR/localcmd.sh $RTEMPDIR/${CHECK_ID}_${i}_report.out>/dev/null 2>&1"  
                          get_cygpath "OUTPUTDIR"
                          $SCOPY $i:$OUTFIL_REPORT $OUTPUTDIR >/dev/null 2>&1
                          restore_cygpath "OUTPUTDIR"
                          $SSHELL $i "rm -f $localcmd $OUTFIL_REPORT $TRGTORCLENV>/dev/null 2>&1"  
                        fi
                      fi

	              get_current_epoch 
	              echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution End Time: $epoch_time" >> $CHK_TIMINGS
	              
	              move_failed_to_skipped "$returncode" "" "$i"
	              echo "" >>$OSSPOOLFIL
	              #echo " $PARAM_PATH $ROW  $COM == $FILVAL" >>$OSSPOOLFIL
	              printf "%s %s %s %s %s\n" " $PARAM_PATH $ROW == $FILVAL" >>$OSSPOOLFIL
	            fi
	            VAL=`grep "$PARAM_PATH $ROW " $OSSPOOLFIL|sed  -n 's/.*== //p'`
                    if [ -n "$COM_REPORT" ]
                    then
                      SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                      if [ $OFFLINE -eq 0 ]
                      then
                        SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
                      else
                        SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                      fi
                    fi
	            #if [[ $ISBRANCH -eq 0 &&  $OFFLINE -eq 0 ]]; then echo "${CHECK_ID}|${VAL}" >>$OSACTUAL ; fi
         	  fi

                  #if [[ $NEEDS_RUNNING = "ASM" && $OFFLINE -eq "0" && ${stack_asm_up[$stack_counter]} -eq 1 ]]
                  if [[ "$NEEDS_RUNNING" = "ASM" || "$NEEDS_RUNNING" = "ACFS" ]] && [[ $OFFLINE -eq "0"  && ${stack_asm_up[$stack_counter]} -eq 1 ]]
                  then
	            sed  "/ORACLE_SID/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	            cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	            rm $INPUTDIR/tmp_env_file.out
	            sed  "/ORACLE_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	            cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	            rm $INPUTDIR/tmp_env_file.out
	            echo "export ORACLE_SID=$OLD_ORACLE_SID">>$ORCLENVFIL
	            echo "export ORACLE_HOME=$OLD_ORACLE_HOME">>$ORCLENVFIL
	  	    update_ld_lib_path "CRS"
                    get_cygpath "ORCLENVFIL"
                    if [ $i = $localnode ]; then cp $ORCLENVFIL $TMPDIR; else  $SCOPY $ORCLENVFIL $i:$TMPDIR/ >/dev/null;fi;
                    restore_cygpath "ORCLENVFIL"
                    TRGTORCLENV=$TMPDIR/`basename $ORCLENVFIL`    
                    #cat $TRGTORCLENV
                  fi
                fi
              fi

              if [[ -n "$LEVEL" && $call_get_log_result -eq 1 ]]
              then
                #we don't want to call this function unless there's a valid
                #set of data for it to evaluate.  If there's no level then that
                #just means we've reached the end of the hierarchy and no more
                #rows to process.
                #
                #calling get_log_result() when in SILENT mode will only do logging
                #there won't be any comparison done and the "PASS" flag will be set
                get_log_result
                if [ $OFFLINE -eq 0 ]; then echo -e "end time -  `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i}\n">>$CHECKS_TIMING;fi
              fi
              ;;
            OS_COLLECT)
              #if [ $OFFLINE -eq "0" ]
              #then
              #$READ -p "PARAM=$PARAM CRS_I=${crs_installed[$stack_counter]} RDBMS_I=${rdbms_installed[$stack_counter]} SC=$stack_counter "
              if [[ $PARAM = "CRS" &&  ${crs_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "RDBMS" &&  ${rdbms_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "ASM" &&  ${asm_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "GOLDENGATE_HOME" && $is_goldengate_installed -eq 0 ]]
              then
                call_get_log_result=0
                OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
              elif [[ $NEEDS_RUNNING = "CRS" &&  ${stack_crs_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "RDBMS" &&  ${stack_dbinst_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "ASM" &&  ${stack_asm_up[$stack_counter]} -eq 0 ]] || [[ $NEEDS_RUNNING = "ACFS" &&  ${stack_acfs_up[$stack_counter]} -eq 0  ]]
              then
                call_get_log_result=0
                OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1` 
              elif [[ $NEEDS_RUNNING = "ACFS" && $db_machine_compute -eq 1 ]] 
              then
                OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
                call_get_log_result=0
              elif [[ $execute_once -eq 1 && "$i" != "$localnode" ]]
              then
                OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
                call_get_log_result=0
              elif [[ $execute_once -eq 1 && "$RAT_RUNMODE_INTERNAL" = "slave" ]]
              then
                OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
                call_get_log_result=0
              #elif  [[ $components != "NONE" &&  $components != $check_components ]]
              elif  [[ $component_match_count  -lt 1 ]]
              #elif  [[ -n "$it_is_rac" && $it_is_rac -eq 0 &&  $component_match_count  -lt 1 ]]
              then
                echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
                OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
                call_get_log_result=0
              elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$COLLECTION_NAME" $EXCLUDEFIL` -ge 1 ]]
              then
                if [[ $NEEDS_RUNNING = "STORAGE_CELL" || $NEEDS_RUNNING = "ZFS" || $NEEDS_RUNNING = "SWITCH" || $NEEDS_RUNNING = "SPINE_SWITCH" ]] && [[ "$RAT_RUNMODE_INTERNAL" = "slave" ]]
	        then
                  OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
                  call_get_log_result=0
  	        else
                  OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
                  call_get_log_result=0
                  echo "Skipping $COLLECTION_NAME (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                  generate_exceptions_xml "Skipping $COLLECTION_NAME because its in exclude file $EXCLUDEFIL"
                fi
              else
                call_get_log_result=1
                if [ $op_mode -eq 0 ]
                then
                  COM=`grep "_"$ROW"-OS_COLLECT_COMMAND" $REFFIL |sed  -n 's/.*OS_COLLECT_COMMAND //p'` 
                  COM_REPORT=`grep "_"$ROW"-OS_COLLECT_COMMAND_REPORT" $REFFIL |sed  -n 's/.*OS_COLLECT_COMMAND_REPORT //p'` 
                  REQUIEE_ROOT=`grep "_"$ROW"-REQUIRES_ROOT" $REFFIL |sed  -n 's/.*REQUIRES_ROOT //p'`
                  COLLECTION_NAME=`grep "_"$ROW"-COLLECTION_NAME" $REFFIL |sed  -n 's/.*COLLECTION_NAME //p'`
                else
                  com_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_START"
                  com_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_END"
                  COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                  com_report_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_START"
                  com_report_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_END"
                  COM_REPORT=$(sed -n /$com_report_begin_pattern/,/$com_report_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                  #COM=`grep "_"$CHECK_ID"-OS_COLLECT_COMMAND" $REFFIL |sed  -n 's/.*OS_COLLECT_COMMAND //p'` 
                  #COM_REPORT=`grep "_"$CHECK_ID"-OS_COLLECT_COMMAND_REPORT" $REFFIL |sed  -n 's/.*OS_COLLECT_COMMAND_REPORT //p'` 
                  REQUIEE_ROOT=`grep "_"$CHECK_ID"-REQUIRES_ROOT" $REFFIL |sed  -n 's/.*REQUIRES_ROOT //p'`
                  COLLECTION_NAME=`grep "_"$CHECK_ID"-COLLECTION_NAME" $REFFIL |sed  -n 's/.*COLLECTION_NAME //p'`
                fi
                OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
                #echo "REQUIEE_ROOT =$REQUIEE_ROOT"
                #$READ -p "STOP"
                #OUTFILNAME is the name we set up in the app as the file name we want
                #the data redirected to when doing OS and SQL COLLECTs
                #we'll search this file for OS and SQL param valuesa
                #so SQL and OS COLLECT creates OUTFIL in the OUTPUTDIR
                #SQL and OS PARAM reads the values of the parameters from OUTFIL
                #OUTFIL will also be archived at the end
                #FIELDPOS is the position we define in the app to tell the script
                #which field to look in for the value as the position might vary from
                #command to command or OS to OS
                if [ $op_mode -eq 0 ]
                then
                  OUTFILNAM=`grep _$ROW\-OUTPUT_FILE $REFFIL |awk {'print $2'}`
                else
                  OUTFILNAM=`grep _$CHECK_ID\-OUTPUT_FILE $REFFIL |awk {'print $2'}`
                fi
                #note we do not append an extension here since the OS commands are 
                #executed on each node and for formatting purposes we append the host 
	        #and the .out in the OS_COLLECT case of log_result()
                
                copy_env_files_to_tmp 
                #Changes made by jrmullan 03/22/10
                #I am changing the file names on the remote nodes to be the same regardless of node.  I need to do this to keep pthe
                #root_raccheck.sh script generic so that the sudo command works from every node.  Once the files are copied back to
                #the local node I will append node information at that point.
                #ORIGINAL STATEMENT:
                #OUTFIL=/tmp/"o_"$OUTFILNAM"_"$i".out"
                #OUTFIL=/tmp/"o_"$OUTFILNAM".out"
                OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_"$i".out"
                if [ $i = $localnode ]
                then
                  OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_"$i"_report.out"
                else
                  OUTFIL_REPORT=$RTEMPDIR/"o_"$OUTFILNAM"_"$i"_report.out"
                fi

                if [[ $REQUIEE_ROOT -eq 0 && $is_exalogic_machine -ne "1" ]]
                then
                  if [ $OFFLINE -eq 0 ]
                  then
                    #localcmd=$TMPDIR/localcmd.sh
                    copy_env_files_to_tmp
	            nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}.sh/g");

                    echo "#!$bash_scr" >$localcmd
	            echo "$RAT_DEBUG_FLG" >>$localcmd
                    echo "$bash_source" >>$localcmd
                    echo ". $TRGTORCLENV">>$localcmd
                    echo "$COM">>$localcmd
                    if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT}">>$localcmd;fi
                    chmod 744 $localcmd

	            #if [ -e $localcmd ]; then cp $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
		    if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi

                    #if [ -n "$COM_REPORT" ]
                    #then
                    #    localcmd_report=/tmp/localcmd_report.sh
                    #    echo "#!$bash_scr" >$localcmd_report
	            #    echo "$RAT_DEBUG_FLG" >>$localcmd
                    #    echo "$bash_source" >>$localcmd_report
                    #    chmod 755 $localcmd_report
                    #    echo ". $TRGTORCLENV">>$localcmd_report
                    #    echo $COM_REPORT>>$localcmd_report
                    #fi
                  fi
                else
                  if [ $OFFLINE -eq 0 ]
                  then
                    #Changes made by jrmullan 03/22/10
                    #I am changing the file names on the remote nodes to be the same regardless of node.  I need to do this to keep pthe
                    #root_raccheck.sh script generic so that the sudo command works from every node.  Once the files are copied back to
                    #the local node I will append node information at that point.
                    #ORIGINAL STATEMENT:
                    #OUTFIL=/tmp/"o_"$OUTFILNAM"_"$i".out"
                    if [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH" ]]
                    then
	              if [[ -n "$ibswitch_password_status" && $ibswitch_password_status -eq 1 && $i = $localnode  && $RAT_RUNMODE_INTERNAL = "master" ]]
	              then
	                OUTFIL=${IBRTEMPDIR}/"s_${OUTFILNAM}.out"
	                OUTFIL_REPORT=${IBRTEMPDIR}/"s_"$OUTFILNAM"_report.out"
                        ROOT_COLLECT_TIMING=${IBRTEMPDIR}/s_root_collect_timing.out
	                COMSBSTR=`echo $COM |awk '{print substr($0,0,60)}' 2>/dev/null|sed 's/\`//g' |sed 's/ //g'`
	                if [ -z "$COLLECTION_NAME" ] 
	                then
	                  echo "echo \"Collecting - $COMSBSTR \"" >>$IBSWITCHSCRPT
	                else
	                  echo "echo \"Collecting - $COLLECTION_NAME \"" >>$IBSWITCHSCRPT
	                fi
                        echo "echo -e \"\`date '+%a %b %d %H:%M:%S %Y'\` - $COLLECTION_NAME on \`hostname|cut -d. -f1\`\" >>$ROOT_COLLECT_TIMING" >>$IBSWITCHSCRPT
                        write_root_collections_log "$IBSWITCHSCRPT"

	                get_current_epoch 
	                echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

	                echo "$COM >>$OUTFIL" >> $IBSWITCHSCRPT 
                        if [ -n "$COM_REPORT" ]
                        then 
                          echo "echo -e \"TO REVIEW COLLECTED DATA FROM \$(hostname|cut -d. -f1|tr \"[a-z]\" \"[A-Z]\") FOR $(echo $COLLECTION_NAME|tr "[a-z]" "[A-Z]") \\n\\n\\n\" >>$OUTFIL_REPORT" >>$IBSWITCHSCRPT
                          echo "$COM_REPORT >>$OUTFIL_REPORT 2>/dev/null " >>$IBSWITCHSCRPT
                        fi

	                get_current_epoch 
	                echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution End Time: $epoch_time" >> $CHK_TIMINGS
	              fi
                    elif [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
                    then
                      if [[ -n "$skip_in_silent" && $skip_in_silent -eq 0 && $current_exadata_version -lt $check_exadata_version ]]
                      then
	                if [ -z "$RAT_CELL_SSH_USER" ] || [[ -n "$DOROOT" && $DOROOT -eq 1 ]] || [ $RAT_CELL_SSH_USER = "cellmonitor" ]
	                then  
	                  if [[ $root_need_cell_ssh -eq 0 && $i = $localnode  && $RAT_RUNMODE_INTERNAL = "master" ]]
	                  then
	                    OUTFIL=${CELLRTEMPDIR}/"c_${OUTFILNAM}.out"
	                    ROOT_COLLECT_TIMING=${CELLRTEMPDIR}/c_root_collect_timing.out
	                    OUTFIL_REPORT=${CELLRTEMPDIR}/"c_"$OUTFILNAM"_report.out"
	                    COMSBSTR=`echo $COM |awk '{print substr($0,0,60)}' 2>/dev/null|sed 's/\`//g' |sed 's/ //g'`
	                    if [ -z "$COLLECTION_NAME" ] 
	                    then
	              	      echo "echo \"Collecting - $COMSBSTR \"" >>$CELLSSCRPT
	                    else
	              	      echo "echo \"Collecting - $COLLECTION_NAME \"" >>$CELLSSCRPT
	                    fi
	                    echo "echo -e \"\`date '+%a %b %d %H:%M:%S %Y'\` - $COLLECTION_NAME on \`hostname|cut -d. -f1\`\" >>$ROOT_COLLECT_TIMING" >>$CELLSSCRPT
	                    write_root_collections_log "$CELLSSCRPT"

	                    get_current_epoch 
	                    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

	                    echo "$COM >>$OUTFIL" >> $CELLSSCRPT
	                    if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>$OUTFIL_REPORT 2>/dev/null " >>$CELLSSCRPT;fi

	                    get_current_epoch 
	                    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution End Time: $epoch_time" >> $CHK_TIMINGS
	                  fi 
	                elif [[ -n "$RAT_CELL_SSH_USER" && $RAT_CELL_SSH_USER = "celladmin"  && $REQUIEE_ROOT -eq 2 && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]]
	                then  
	                  if [[ $root_need_cell_ssh -eq 0 && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master"  ]]
	                  then
	                    OUTFIL=${CELLRTEMPDIR}/"c_${OUTFILNAM}.out"
	                    ROOT_COLLECT_TIMING=${CELLRTEMPDIR}/c_root_collect_timing.out
	                    OUTFIL_REPORT=${CELLRTEMPDIR}/"c_"$OUTFILNAM"_report.out"
	                    COMSBSTR=`echo $COM |awk '{print substr($0,0,60)}' 2>/dev/null|sed 's/\`//g' |sed 's/ //g'`
	                    if [ -z "$COLLECTION_NAME" ] 
	                    then
	              	      echo "echo \"Collecting - $COMSBSTR \"" >>$CELLSSCRPT
	                    else
	              	      echo "echo \"Collecting - $COLLECTION_NAME \"" >>$CELLSSCRPT
	                    fi
	                    echo "echo -e \"\`date '+%a %b %d %H:%M:%S %Y'\` - $COLLECTION_NAME on \`hostname|cut -d. -f1\`\" >>$ROOT_COLLECT_TIMING" >>$CELLSSCRPT
	                    write_root_collectionlog "$CELLSSCRPT"

	                    get_current_epoch 
	                    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

	                    echo "$COM >>$OUTFIL" >> $CELLSSCRPT
	                    if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>$OUTFIL_REPORT 2>/dev/null " >>$CELLSSCRPT;fi

	                    get_current_epoch 
	                    echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution End Time: $epoch_time" >> $CHK_TIMINGS
	                  fi
	                fi
                      fi  
                    else
		     if [[ "$PARAM" = "EMAGENT_HOME" && $is_emagent_installed -ne 1 ]]
                     then
			echo ""
		     else 	
	              OUTFIL=${RTEMPDIR}/"o_"$OUTFILNAM".out"
                      ROOT_COLLECT_TIMING=${RTEMPDIR}/o_root_collect_timing.out
	              OUTFIL_REPORT=${RTEMPDIR}/"o_"$OUTFILNAM"_report.out"
	              if [[ $i = $localnode ]]
	              then
	                touch $OUTFIL >/dev/null 2>&1
	                touch $ROOT_COLLECT_TIMING >/dev/null 2>&1
                        if [ -n "$COM_REPORT" ]; then  touch $OUTFIL_REPORT >/dev/null 2>&1;fi
	              else
	                $SSHELL $i touch $OUTFIL >/dev/null 2>&1
	                $SSHELL $i touch $ROOT_COLLECT_TIMING >/dev/null 2>&1
                        if [ -n "$COM_REPORT" ]; then   $SSHELL $i touch $OUTFIL_REPORT >/dev/null 2>&1;fi
                        #$SSHELL $i 'echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[:lower:]"  "[:upper:]") FOR $(echo $COLLECTION_NAME|tr "[:lower:]"  "[:upper:]") \n\n\n" >> $OUTFIL_REPORT'
	              fi
                      echo "echo -e \"TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") FOR $(echo $COLLECTION_NAME|tr "[a-z]" "[A-Z]") \\n\\n\\n\" >>$OUTFIL_REPORT" >>$ROOTSCRPT
	              COMSBSTR=`echo $COM |awk '{print substr($0,0,60)}' 2>/dev/null|sed 's/\`//g' |sed 's/ //g'`
	              if [ -z "$COLLECTION_NAME" ] 
	              then
	                echo "echo \"Collecting - $COMSBSTR \"" >>$ROOTSCRPT
	              else
	                echo "echo \"Collecting - $COLLECTION_NAME \"" >>$ROOTSCRPT
	              fi
                      echo "echo -e \"\`date '+%a %b %d %H:%M:%S %Y'\` - $COLLECTION_NAME on \`hostname|cut -d. -f1\`\" >>$ROOT_COLLECT_TIMING" >>$ROOTSCRPT
                      write_root_collections_log "$ROOTSCRPT"

	              get_current_epoch 
	              echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution Start Time: $epoch_time" >> $CHK_TIMINGS
		      if [[ "$PARAM" = "EMAGENT_HOME" && $is_emagent_installed -eq 1 ]]
		      then
			      echo "export EMAGENT_INST=${agent_inst}">>$ROOTSCRPT
		      fi

	              echo "$COM  >>$OUTFIL" >> $ROOTSCRPT
	              if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>$OUTFIL_REPORT 2>/dev/null " >> $ROOTSCRPT;fi

	              get_current_epoch 
	              echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution End Time: $epoch_time" >> $CHK_TIMINGS
		     fi	
                    fi         
                  fi
                fi
                if [[ -n "$LEVEL" &&  $REQUIEE_ROOT -eq 0 && $call_get_log_result -eq 1 ]]
                then
                  #we don't want to call this function unless there's a valid
                  #set of data for it to evaluate.  If there's no level then that
                  #just means we've reached the end of the hierarchy and no more
                  #rows to process.
                  #
                  #in SILENT mode we'll execute the command derived here and do 
                  #some logging but there is nothing to compare
                  #echo " in get_log_result REQUIEE_ROOT=$REQUIEE_ROOT"
                  get_log_result
                fi
              fi # OS collect without root ends here
         
              #if  [[ $OSCOLLECTCNT -eq $OSCOLLECTSUM && $OFFLINE -eq 0 && $REQUIRE_ROOT -gt 0  && $rootYesNoint -ne 3 && $root_need_cell_ssh -eq 0   ]]
              if  [[ $OSCOLLECTCNT -eq $OSCOLLECTSUM && $OFFLINE -eq 0 && $rootYesNoint -ne 3 && $root_need_cell_ssh -eq 0 ]] && [[ $REQUIRE_ROOT -gt 0 || -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
              then
   	        if [ -f "$ROOTSCRPT" ]; then 
		  if [ ! -e "$OUTPUTDIR/root_${program_name}.sh" ]; then
		    cp $ROOTSCRPT $OUTPUTDIR;
		  fi
                fi

                #change permission of temporary raccheck files created by root to current user
                echo "chown $usern:$running_group ${RTEMPDIR}/o_*.out >/dev/null 2>&1">>$ROOTSCRPT
                if [ -n "$RAT_KEEP_SUDO_TMP" ]; 
                then  
                  cp -f $ROOTSCRPT /tmp/ 
                  ROOTSCRPT=/tmp/root_${program_name}.sh
                else 
                  if [ $i = $localnode ]; then cp -f $ROOTSCRPT $HOME;fi
                  ROOTSCRPT=$HOME/root_${program_name}.sh
                fi
                chmod 544 $ROOTSCRPT

                # Create lock file for watchdog for root collections.
                touch $ROOT_LCKFIL

                #$READ -p "STOP  $ROOTSCRPT /tmp/.racrx/"
                #ROOTSCRPT=/tmp/root_${program_name}.sh
                if [ -z "$noRootScriptNode" ];then noPasswordAvailable=0;fi
                noPasswordAvailable=$(echo ${noRootScriptNode[*]}|grep -c $i)
                if [[ $i = $localnode && $noPasswordAvailable -eq 0 ]]
                then
                  # Changes made by jrmullan 03/22/10
                  unset FNAMEANDPATH
                  unset FNAME
                  if [ $rootYesNoint -eq 2 ]
                  then
                    echo -e "\nPreparing to run root privileged commands ${print_compute_node} ${i}.\n"
                    # Changes made by jrmullan 03/22/10
                    #$SSHELL -t $i $SUDOCMD "$ROOTSCRPT"
                    $SUDOCMD "$ROOTSCRPT" 2>>$ERRFIL
                  elif [ $rootYesNoint -eq 1 ]
                  then
                    if [[ -n "$samerootpassword" && $samerootpassword -eq 1 ]]
                    then
                      if [ $userid -ne 0 ]
                      then
                        echo -e "Preparing to run root privileged commands ${print_compute_node} $i."
                        echo "Preparing to run root privileged commands on $i.">>$LOGFIL
                      fi
                      if [ $userid -eq 0 ] ; then
                        $ROOTSCRPT
	                returncode=`echo $?`		
	                move_failed_to_skipped "$returncode" "$ROOTSCRPT execution"
                      else
                        compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $i ls >/dev/null 2>&1;echo $?);
                        if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
                        then
                          echo "${root_user} password not checked on $root_hostname because ssh user equivalence found for ${root_user}">>$LOGFIL
                          $SSHELL ${root_user}@$i "$ROOTSCRPT"
                        else   
			  checkUserPassword "$i" "${root_user}" "$compute_rootpassword" "1"
                          #hadollar=$(echo $compute_rootpassword|grep -c "$");if [ $has_dollar -ge 1 ]; then compute_rootpassword=$(echo $compute_rootpassword|sed 's/\$/\\$/g');fi
			  if [ $passwordCheckStatus -eq 0 ]
			  then
			    fixRootPassword "$compute_rootpassword"
			    $EXPECT -f - 2>>$WATCHLOG << IBEOF
				  set timeout $passwordcheck_timeout
				  set le_compute_rootpassword "$fixedRootPassword"
                                  if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                    exp_internal 1
                                  }
                                  log_user 0
				  spawn -noecho $SSHELL ${root_user}@$i "$ROOTSCRPT"			
				  match_max 100000
				  expect {
				  -nocase "permission denied *" {
				    exit 4;
			          }
				  -nocase "no)?" {
				    send -- "yes\n"
				  }
                                  -nocase "*?assword:*" {
                                    send -- "\$le_compute_rootpassword\n"
                                  }
                                  -nocase eof {
                                    exit 
                                  }
				  }
				  # Look for passwd prompt
                                  log_user 1
		       		  set timeout $watchdog_wakeup_root
				  expect {
				  -nocase "*?assword:*" {
					send -- "\$le_compute_rootpassword\n"
				  }
				  -nocase eof {
					exit
				  }
				  -nocase timeout {
					send_error "Timed out while running $ROOTSCRPT on $i\n";
					exit
				  }
				  }
                                  log_user 1
				  # Stop the on logon tests and if asked to connect to master switch choose no
				  expect {
				  -nocase eof {
					exit
				  }
				  -nocase timeout {
					send_error "Timed out while running $ROOTSCRPT on $i\n";
					exit
				  }
				  }
IBEOF
                          else
			    echo -e "\n\n${RED}Skipping ${userToCheck} privileged checks for ${nodeNameToCheck}.\nThe $userToCheck password must have been changed since the passwords were validated at the beginning of tool execution ${NORM}\n" |tee -a $LOGFIL 
			  fi
                        fi 
                      fi
                    elif [[ -n "$samerootpassword" && $samerootpassword -eq 0 ]]
                    then
                      if [ $userid -ne 0 ]
                      then
                        echo -e "Preparing to run root privileged commands on ${print_compute_node} ${i}."
                        echo "Preparing to run root privileged commands on $i.">>$LOGFIL
                      fi
                      if [ $userid -eq 0 ] ; then
                        $ROOTSCRPT
                      else
                        compute_rootpassword=${a_compute_rootpassword[$stack_counter]}
                        compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $i ls >/dev/null 2>&1;echo $?); 
                        if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
                        then
                          echo "${root_user} password not checked on $root_hostname because ssh user equivalence found for ${root_user}">>$LOGFIL
                          $SSHELL ${root_user}@$i "$ROOTSCRPT" 
                        else
			  checkUserPassword "$i" "${root_user}" "$compute_rootpassword" "1"
			  if [ $passwordCheckStatus -eq 0 ]
			  then
			    fixRootPassword "$compute_rootpassword"
			    $EXPECT -f - 2>>$WATCHLOG << IBEOF
				  set timeout $passwordcheck_timeout 
				  set le_compute_rootpassword "$fixedRootPassword"
                                  if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                    exp_internal 1
                                  }   
                                  log_user 0
				  spawn -noecho $SSHELL ${root_user}@$i "$ROOTSCRPT"			
				  #spawn -noecho $SSHELL_EL $i "su - ${root_user} -c $ROOTSCRPT"			
                                   
				  match_max 100000
				  expect {
				  -nocase "permission denied *" {
				    exit 4;
			          }
				  -nocase "no)?" {
					send -- "yes\n"
					}
    			   	  -nocase "*?assword:*" {
                                 	send -- "\$le_compute_rootpassword\n"
                                  	}
			   	  -nocase eof {
					 exit
				  	}
				  }
				  # Look for passwd prompt
                                  log_user 1
		       		  set timeout $watchdog_wakeup_root
                       		  expect {
                       		    -nocase "*?assword:*" {
                       		         send -- "\$le_compute_rootpassword\n"
                       		  }
                       		  -nocase eof {
                       		         exit
                       		  }
                       		  -nocase timeout {
		       		 	send_error "Timed out while running $ROOTSCRPT on $i\n";
                       		        exit
                       		  }
                       		  }
                       		  log_user 1
		       		  # Stop the on logon tests and if asked to connect to master switch choose no
                       		  expect {
                       		    -nocase eof {
                       		         exit
                       		  }
                       		    -nocase timeout {
		       		 	send_error "Timed out while running $ROOTSCRPT on $i\n";
                       		         exit
                       		  }
                       		 }
IBEOF
			  else
			    echo -e "\n\n${RED}Skipping ${userToCheck} privileged checks for ${nodeNameToCheck}.\nThe $userToCheck password must have been changed since the passwords were validated at the beginning of tool execution ${NORM}\n"|tee -a $LOGFIL
			  fi
                        fi   
                      fi
                    else 
                      if [ $userid -ne 0 ] && [[ -z $privilegechk || "$privilegechk" != "addr" ]]
                      then
                        echo -e "Preparing to run root privileged commands ${print_compute_node} $i.  Please enter ${root_user} password when prompted."
                        echo "Preparing to run root privileged commands on $i.  Please enter ${root_user} password when prompted.">>$LOGFIL
                      fi
                      if [ $userid -ne 0 ] && [[ -z $privilegechk || "$privilegechk" != "addr" ]]  
		      then 	
                        $SSHELL ${root_user}@$i "$ROOTSCRPT"			
                      else
                        $ROOTSCRPT
                      fi
                      #Fix for bug 14336860 
                      #$SSHELL_EL $i "su - root -c $ROOTSCRPT"
                    fi
                  fi
 
                  # Changes made by jrmullan 03/22/10
                  for FNAMEANDPATH in `ls ${RTEMPDIR}/o_* 2>/dev/null`
                  do
                    # Strip off /tmp/ and .out and insert nodename and .out back in to filename
                    FNAME=`echo $FNAMEANDPATH |$AWK 'BEGIN { FS = "/" } {printf $NF}'|cut -d. -f1`
                    if [[ -e $OUTPUTDIR/$FNAME"_"$i".out" && -e $FNAMEANDPATH ]]
                    then 
                      cat $FNAMEANDPATH  >>$OUTPUTDIR/$FNAME"_"$i".out"
                    elif [ -e $FNAMEANDPATH ]
                    then                   
                      cp -r $FNAMEANDPATH $OUTPUTDIR/$FNAME"_"$i".out" > /dev/null
                    fi
                    if [[ `echo $FNAME|grep -ic "root_clusterwide_check"` -lt 1 && "$FNAME" != "o_exadata_disk.out" && `echo $FNAME|grep -ic "ibswitches"` -lt 1 && `ls -l $FNAMEANDPATH|awk '{print $3}'` != "${root_user}" ]]; then rm $FNAMEANDPATH >/dev/null 2>&1;fi
		    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
                      if [[ `echo $FNAME|grep -ic "root_clusterwide_check"` -ge 1 ]]; then mv $FNAMEANDPATH $TMPDIR  >/dev/null 2>&1; fi;
		    else
                      if [[ `echo $FNAME|grep -ic "root_clusterwide_check"` -ge 1 && `ls -l $FNAMEANDPATH|awk '{print $3}'` != "${root_user}" ]]; then mv $FNAMEANDPATH $TMPDIR  >/dev/null 2>&1; fi;
		    fi
                  done
                  #rm -r /tmp/o_*.out >/dev/null 2>&1
                  if [[ -n "$ORACLEENVVARS" && $ORACLEENVVARS != "" ]];then  rm tmp/$ORACLEENVVARS >/dev/null 2>&1; fi;
                  rm -f $ROOTSCRPT >/dev/null 2>&1
                  if [ -f $ROOTSCRPT ]; then rm -f $ROOTSCRPT >/dev/null 2>&1;fi;
                  if [[ -e ${OUTPUTDIR}/o_root_collect_timing_${i}.out && -e $COLLECT_TIMING ]]
                  then
                    cat ${OUTPUTDIR}/o_root_collect_timing_${i}.out >> $COLLECT_TIMING
                    rm -f ${OUTPUTDIR}/o_root_collect_timing_${i}.out  >/dev/null 2>&1
                  fi
                elif [ $noPasswordAvailable -eq 0 ]
                then
                  unset FNAMEANDPATH
                  unset FNAME
                  $SCOPY $TMPDIR/$ORACLEENVVARS $i:$TMPDIR/ >/dev/null 2>&1
                  if [ -n "$RAT_KEEP_SUDO_TMP" ];
                  then 
                    $SCOPY $ROOTSCRPT $i:$TMPDIR/ >/dev/null 2>&1
                  else
                    $SCOPY $ROOTSCRPT $i:$HOME >/dev/null 2>&1
                  fi
                  $SSHELL $i "chmod 544 $ROOTSCRPT"
                  if [ $rootYesNoint -eq 2 ]
                  then
                    echo -e "\nPreparing to run root privileged commands ${print_compute_node} ${i}.\n"
                    $SSHELL -t $i $SUDOCMD "$ROOTSCRPT" 2>>$ERRFIL
                  elif [ $rootYesNoint -eq 1 ]
                  then
                    if [[ -n "$samerootpassword" && $samerootpassword -eq 1 ]]
                    then
                      if [ $userid -ne 0 ]
                      then
                        echo -e "Preparing to run root privileged commands ${print_compute_node} $i."
                        echo "Preparing to run root privileged commands on $i.">>$LOGFIL
                      fi
                      compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $i ls >/dev/null 2>&1;echo $?);
                      if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
                      then
                        echo "${root_user} password not checked on $root_hostname  because ssh user equivalence found for ${root_user}">>$LOGFIL
                        $SSHELL ${root_user}@$i "$ROOTSCRPT"
                      else   
			checkUserPassword "$i" "${root_user}" "$compute_rootpassword" "1"
			if [ $passwordCheckStatus -eq 0 ]
			then
			  fixRootPassword "$compute_rootpassword"
			  $EXPECT -f - 2>>$WATCHLOG << IBEOF
				  set timeout $passwordcheck_timeout
				  set le_compute_rootpassword "$fixedRootPassword"
                                  if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                    exp_internal 1
                                  }
                                  log_user 0
				  spawn -noecho $SSHELL ${root_user}@$i "$ROOTSCRPT"			
				  #spawn -noecho $SSHELL_EL $i "su - ${root_user} -c $ROOTSCRPT"			
				  match_max 100000
				  expect {
				  -nocase "permission denied *" {
				    exit 4;
			          }
				  -nocase "no)?" {
					send -- "yes\n"
					}
    			   	  -nocase "*?assword:*" {
                                 	send -- "\$le_compute_rootpassword\n"
                                  	}
			   	  -nocase eof {
					 exit
				  	}
				  }
				  # Look for passwd prompt
                                  log_user 1
		       		  set timeout $watchdog_wakeup_root
                       		  expect {
                       		    -nocase "*?assword:*" {
                       		         send -- "\$le_compute_rootpassword\n"
                       		  }
                       		    -nocase eof {
                       		         exit
                       		  }
                       		    -nocase timeout {
		       		 	send_error "Timed out while running $ROOTSCRPT on $i\n";
                       		         exit
                       		  }
                       		  }
                       		  log_user 1
		       		  # Stop the on logon tests and if asked to connect to master switch choose no
                       		  expect {
                       		     -nocase eof {
                       		          exit
                       		     }
                       		     -nocase timeout {
		       		  	send_error "Timed out while running $ROOTSCRPT on $i\n";
                       		          exit
                       		     }
                       		  }
IBEOF
			else
			  echo -e "\n\n${RED}Skipping ${userToCheck} privileged checks for ${nodeNameToCheck}.\nThe $userToCheck password must have been changed since the passwords were validated at the beginning of tool execution ${NORM}\n"|tee -a $LOGFIL
			  #echo -e "\n\n${RED}Still ${userToCheck} password for $nodeNameToCheck was wrong. $userToCheck priviledged check will not be executed on $nodeNameToCheck ${NORM}\n"
			fi
                      fi
                    elif [[ -n "$samerootpassword" && $samerootpassword -eq 0 ]]
                    then
                      if [ $userid -ne 0 ]
                      then
                        echo -e "Preparing to run root privileged commands on ${print_compute_node} $i."
                        echo "Preparing to run root privileged commands on $i.">>$LOGFIL
                      fi
                      compute_rootpassword=${a_compute_rootpassword[$stack_counter]}
                      compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l ${root_user} $i ls >/dev/null 2>&1;echo $?);
                      if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
                      then
                        echo "${root_user} password not checked on $root_hostname  because ssh user equivalence found for ${root_user}">>$LOGFIL
                        $SSHELL root@$i "$ROOTSCRPT" 
                      else
		        checkUserPassword "$i" "${root_user}" "$compute_rootpassword" "1"
		        if [ $passwordCheckStatus -eq 0 ]
		        then
		          fixRootPassword "$compute_rootpassword"
		          $EXPECT -f - 2>>$WATCHLOG << IBEOF
		            set timeout $passwordcheck_timeout
		            set le_compute_rootpassword "$fixedRootPassword"
                            if { "$RAT_EXPECT_DEBUG" == "-d" } {
                              exp_internal 1
                            }
                            log_user 0
		            spawn -noecho $SSHELL ${root_user}@$i "$ROOTSCRPT"			
		            #spawn -noecho $SSHELL_EL $i "su - ${root_user} -c $ROOTSCRPT"			
		            match_max 100000
		              expect {
		            -nocase "permission denied *" {
		              exit 4;
		            }
		            -nocase "no)?" {
		          	send -- "yes\n"
		          	}
    		               -nocase "*?assword:*" {
                           	send -- "\$le_compute_rootpassword\n"
                            	}
		               -nocase eof {
		          	 exit
		            	}
		            }
		            # Look for passwd prompt
                            log_user 1
		            set timeout $watchdog_wakeup_root
                            expect {
                              -nocase "*?assword:*" {
                                   send -- "\$le_compute_rootpassword\n"
                              }
                              -nocase eof {
                                   exit
                              }
                              -nocase timeout {
		           	send_error "Timed out while running $ROOTSCRPT on $i\n";
                                   exit
                              }
                            }
                            log_user 1
		            # Stop the on logon tests and if asked to connect to master switch choose no
                            expect {
                               -nocase eof {
                                    exit
                               }
                               -nocase timeout {
		            	send_error "Timed out while running $ROOTSCRPT on $i\n";
                                    exit
                               }
                            }
IBEOF
		        else
		          #echo -e "\n\n${RED}Still ${userToCheck} password for $nodeNameToCheck was wrong. $userToCheck priviledged check will not be executed on $nodeNameToCheck ${NORM}\n"
		          echo -e "\n\n${RED}Skipping ${userToCheck} privileged checks for ${nodeNameToCheck}.\nThe $userToCheck password must have been changed since the passwords were validated at the beginning of tool execution ${NORM}\n"|tee -a $LOGFIL  
		        fi
                      fi
                    else  
                      if [ $userid -ne 0 ]
                      then
                        echo -e "Preparing to run root privileged commands ${print_compute_node} $i.  Please enter ${root_user} password when prompted."
                        echo "Preparing to run root privileged commands on $i.  Please enter ${root_user} password when prompted.">>$LOGFIL
                      fi
                      $SSHELL ${root_user}@$i "$ROOTSCRPT"			
                      #Fix for bug 14336860 
                      #$SSHELL_EL $i "su - root -c $ROOTSCRPT 2>/dev/null"
                    fi
                  fi

                  for FNAMEANDPATH in `$SSHELL -n $i "ls ${RTEMPDIR}/o_* 2>/dev/null"`
                  do
                    FNAME=`echo $FNAMEANDPATH |$AWK 'BEGIN { FS = "/" } {printf $NF}'|cut -d. -f1`
                    if [ -e $OUTPUTDIR/$FNAME"_"$i".out" ]
                    then
                      $SSHELL $i cat $FNAMEANDPATH  >>$OUTPUTDIR/$FNAME"_"$i".out"
                    else
                      $SCOPY -r $i:$FNAMEANDPATH $OUTPUTDIR/$FNAME"_"$i".out" > /dev/null 2>&1
                    fi
                    if [[ `echo $FNAME|grep -ic "root_clusterwide_check"` -lt 1 && "$FNAME" != "o_exadata_disk.out" ]]; then $SSHELL $i rm -f $FNAMEANDPATH >/dev/null 2>&1;fi
                    if [[ `echo $FNAME|grep -ic "root_clusterwide_check"` -ge 1 ]]; then $SSHELL $i mv $FNAMEANDPATH $TMPDIR  >/dev/null 2>&1; fi;
                  done
                  #Changes made by jrmullan 03/22/10
                  #$SSHELL $i rm -f /tmp/o_*.out >/dev/null 2>&1
                  if [[ -n "$ORACLEENVVARS" && $ORACLEENVVARS != "" ]];then $SSHELL $i rm -r $TMPDIR/$ORACLEENVVARS >/dev/null 2>&1;fi;
                  $SSHELL $i rm -f $ROOTSCRPT >/dev/null 2>&1

                  if [ -f $ROOTSCRPT ]; 
  		  then 
		    #rm -f $ROOTSCRPT >/dev/null 2>&1;
		    mv -f $ROOTSCRPT $OUTPUTDIR >/dev/null 2>&1;
 		  fi;

                  if [[ -e ${OUTPUTDIR}/o_root_collect_timing_${i}.out && -e $COLLECT_TIMING ]]
                  then
                    cat ${OUTPUTDIR}/o_root_collect_timing_${i}.out >> $COLLECT_TIMING
                    rm -f ${OUTPUTDIR}/o_root_collect_timing_${i}.out  >/dev/null 2>&1
                  fi
                else
		  echo -e "\n${RED}Skipping root privileged commands ${print_compute_node} ${NORM} ${i}\n"|tee -a $LOGFIL
                fi
              fi #Finished here with executing command with root for each host

              echo -e "OSCOLLECTCNT=$OSCOLLECTCNT OSCOLLECTSUM= $OSCOLLECTSUM rootYesNoint=$rootYesNoint root_need_cell_ssh=$root_need_cell_ssh REQUIRE_ROOT=$REQUIRE_ROOT" >>$LOGFIL
              #$READ -p "rootYesNoint=$rootYesNoint"
              if  [[ $OSCOLLECTCNT -eq $OSCOLLECTSUM && $OFFLINE -eq 0 && $cell_root_command -gt 0  && $cell_password_status -ne 3 && "$profiles2run" != "switch" ]]
              then
                #Create lock file for watchdog for root collections.
                touch $ROOT_LCKFIL

   	        if [ -f "$CELLSSCRPT" ]; then cp $CELLSSCRPT $OUTPUTDIR; fi;
                if [ -z "$noRootScriptNode" ];then noPasswordAvailable=0;fi
                if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -e $CELLIP ]]  
                then
                  #cat $IBSWITCHSCRPT
                  #$READ -p "good to run"
                  if [ ! -e $CELLDIR ];then mkdir $CELLDIR >/dev/null 2>&1;fi
                  cp $CELLIP $CELLDIR 2>/dev/null 2>&1
                  root_cell_counter=0
                  no_of_cells=$(wc -l $CELLIP |awk '{print $1}'|tr -d ' ')
                  no_of_cells=$(expr $no_of_cells - 1);
                  in_last_cell=0
                  if [[ ! -n "$RAT_CELL_RUNMODE" ]] ; then RAT_CELL_RUNMODE="parallel"; fi;

                  for cellname in `cat $CELLIP|cut -d= -f2|cut -d\; -f2|sed 's/"//g'` 
                  do
                    #cellPingStatus=$($PING -c 1 $PING_W_FLAG $cellname >/dev/null 2>&1;echo $?)
		    test_node_reachability $cellname $cell_ssh_user;
		    if [ $el_node_ping -eq "1" ] ; then
                      cellPingStatus=0;
		    else
		      cellPingStatus=1;
        	    fi

        	    #if [[ -n "$cellPingStatus" && $cellPingStatus -eq 0 ]] 
	            #then
        	    #  check_ssh_speed $cell_ssh_user $cellname
	            #  if [[ -n $ssh_go_ahead && $ssh_go_ahead = 0 ]] ; then cellPingStatus=255; fi
        	    #fi
                    if [[ -n "$cellPingStatus" && $cellPingStatus -eq 0 ]]
                    then
		      noPasswordAvailable=$(echo ${noRootScriptNode[*]}|grep -c $cellname)
		      if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
                      then
                        cellname_full=$cellname
                      else
		        #cellname_full=$(cat /etc/hosts|grep -w "$cellname"|awk '{print $NF}'|cut -d'-' -f1)
		        cellname_full=$(grep -w "$cellname" /etc/hosts|grep -v "^ *#"|awk '{print $NF}'|cut -d'-' -f1|head -1)
                      fi
                      
		      #echo "$cellname = $cellname_full" >>$CELLDIR/cells.out
                      if [[ $no_of_cells -eq $root_cell_counter ]] ; then last_cell_name=$cellname; in_last_cell=1; fi
		      cell_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $cell_ssh_user $cellname ls >/dev/null 2>&1;echo $?);
		      if [[ -n "$cell_password_status" && $cell_password_status -ne 3 ]] && [[ -n "$cell_ssh_status1" && $cell_ssh_status1 -eq 0 && $is_exalogic_machine -eq 0 ]]
		      then # ssh is setup on cells
		        if [ -f "$CELLSSCRPT" ] ; then cp $CELLSSCRPT $OUTPUTDIR >/dev/null 2>&1; fi;
                        cellname_short=$(echo $cellname|sed 's/\./_/g') 
                        CELLDIR_SHORT=$CELLDIR/$cellname_short
                        #delete directory in exachk output directory for this cell if it exits 
                        if [ -e $CELLDIR_SHORT ]; then rm -rf $CELLDIR_SHORT >/dev/null 2>&1; fi
                        mkdir -p $CELLDIR_SHORT       
                        if [[ -n "$RAT_CELL_RUNMODE" && $RAT_CELL_RUNMODE = "parallel" ]] ; then
		          echo -e "\nStarting to run $cell_ssh_user privileged commands in background on ${BLINK}STORAGE SERVER${NORM} $cellname_full ($cellname)\n"
                          start_run_on_cell_in_background
		          cellnameFullActual=$($SSHELL $cell_ssh_user@$cellname "hostname|cut -d. -f1")
		          echo "$cellname = $cellnameFullActual" >>$CELLDIR/cells.out
                        else
		          echo -e "\nPreparing to run $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER${NORM} $cellname_full ($cellname)\n"

			  is_SSH_blocked "$cellname" "$cell_ssh_user" "$cell_rootpassword" "CELL"
			  if [[ $SSH_blocked -eq 1 ]]; then
			    echo -e "\n${RED}Skipping $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER ${NORM} ${RED} ${cellname} is available but SSH is blocked.${NORM}\n"|tee -a $LOGFIL
			    add_to_skipped_nodes "${cellname}" "SSH Issue: STORAGE SERVER is reachable but SSH is blocked"
			    continue;
			  fi

                          if [[ -n "$DOROOT" && $DOROOT -eq 1 && -n "$RAT_CELL_SSH_USER" && $RAT_CELL_SSH_USER = "celladmin" ]] || [[ -n "$RAT_CELL_SSH_USER" && "$RAT_CELL_SSH_USER" = "cellmonitor" ]]
                          then
                            $SCOPY  $CELLSSCRPT $cell_ssh_user@$cellname:$CELLTMPDIR >/dev/null 2>&1
		            $SSHELL $cell_ssh_user@$cellname chmod 544 $CELLTMPDIR/${program_name}_cells.sh >/dev/null 2>&1
                            $SSHELL $cell_ssh_user@$cellname mkdir ${CELLRTEMPDIR} >/dev/null 2>&1
                            $SSHELL -t $cell_ssh_user@$cellname sudo "$CELLTMPDIR/${program_name}_cells.sh" 2>/dev/null
		            returncode=`echo $?`
		            #$SSHELL -o StrictHostKeyChecking=no $cell_ssh_user@$cellname /tmp/${program_name}_cells.sh 2>/dev/null 
		            $SCOPY  $cell_ssh_user@$cellname:${CELLRTEMPDIR}/c_*.out $CELLDIR_SHORT >/dev/null 2>&1
		            $SSHELL $cell_ssh_user@$cellname rm -f $CELLTMPDIR/${program_name}_cells.sh  >/dev/null 2>&1
		            $SSHELL $cell_ssh_user@$cellname rm -f ${CELLRTEMPDIR}/c_*.out >/dev/null 2>&1
		            $SSHELL $cell_ssh_user@$cellname rmdir  ${CELLRTEMPDIR} >/dev/null 2>&1
                            if [ -e $CELLDIR_SHORT ]; then format_cell_switch_files "$cellname_short" "$CELLDIR_SHORT" "cell";fi
		            cellnameFullActual=$($SSHELL $cell_ssh_user@$cellname "hostname|cut -d. -f1")
		            echo "$cellname = $cellnameFullActual" >>$CELLDIR/cells.out
                          else
		            $SCOPY  $CELLSSCRPT $cell_ssh_user@$cellname:$CELLTMPDIR >/dev/null 2>&1
		            $SSHELL $cell_ssh_user@$cellname chmod 544 $CELLTMPDIR/${program_name}_cells.sh >/dev/null 2>&1
                            $SSHELL $cell_ssh_user@$cellname mkdir ${CELLRTEMPDIR} >/dev/null 2>&1
		            $SSHELL $cell_ssh_user@$cellname $CELLTMPDIR/${program_name}_cells.sh 2>/dev/null 
		            returncode=`echo $?`
		            $SCOPY  $cell_ssh_user@$cellname:${CELLRTEMPDIR}/c_*.out $CELLDIR_SHORT >/dev/null 2>&1
		            $SSHELL $cell_ssh_user@$cellname rm -f $CELLTMPDIR/${program_name}_cells.sh  >/dev/null 2>&1
		            $SSHELL $cell_ssh_user@$cellname rm -f ${CELLRTEMPDIR}/c_*.out ${CELLRTEMPDIR}/o_*.out >/dev/null 2>&1
		            $SSHELL $cell_ssh_user@$cellname rmdir  ${CELLRTEMPDIR} >/dev/null 2>&1
                            if [ -e $CELLDIR_SHORT ]; then format_cell_switch_files "$cellname_short" "$CELLDIR_SHORT" "cell";fi
		            cellnameFullActual=$($SSHELL $cell_ssh_user@$cellname "hostname|cut -d. -f1")
		            echo "$cellname = $cellnameFullActual" >>$CELLDIR/cells.out
                          fi
		          move_failed_to_skipped "$returncode" "$CELLTMPDIR/${program_name}_cells.sh execution"
                        fi #end of parallel or seiral if
		      elif [ $noPasswordAvailable -eq 0 ]
		      then
                        cellname_short=$(echo $cellname|sed 's/\./_/g') 
                        CELLDIR_SHORT=$CELLDIR/$cellname_short
                        #delete directory in exachk output directory for this cell if it exits 
                        if [ -e $CELLDIR_SHORT ]; then rm -rf $CELLDIR_SHORT >/dev/null 2>&1; fi
                        mkdir -p $CELLDIR_SHORT       
                        if [[ -n "$RAT_CELL_RUNMODE" && $RAT_CELL_RUNMODE = "parallel" ]] ; then
			  echo -e "\nStarting to run $cell_ssh_user privileged commands in background on ${BLINK}STORAGE SERVER${NORM} $cellname_full ($cellname)\n"
                        else
			  echo -e "\nPreparing to run $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER${NORM} $cellname_full ($cellname)\n"
                        fi
			if [[ -n "$cell_samerootpassword" && $cell_samerootpassword -eq 0 ]]
			then
			  #echo -e "\nPreparing to run $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER${NORM} ${cellname_full}."
			  #echo -e "\n"
			  #printf  "Enter $cell_ssh_user password for ${BLINK}STORAGE SERVER${NORM} ${cellname_full} :- "
			  #tty -s && stty -echo
			  #read cell_rootpassword
			  #tty -s && stty echo
			  #echo -e "\n" 
			  cell_rootpassword=${a_cell_rootpassword[$root_cell_counter]}
			    
			  #else
			  #echo -e "\nPreparing to run $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER${NORM} $cellname_full\n"
			fi

			is_SSH_blocked "$cellname" "$cell_ssh_user" "$cell_rootpassword" "CELL"
			if [[ $SSH_blocked -eq 1 ]]; then
			  echo -e "\n${RED}Skipping $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER ${NORM} ${RED} ${cellname} is available but SSH is blocked.${NORM}\n"|tee -a $LOGFIL
			  add_to_skipped_nodes "${cellname}" "SSH Issue: STORAGE SERVER is reachable but SSH is blocked"
			  continue;
			fi

			cell_type="normal"
			if [[ $passwordCheckStatus -eq 0 ]]
			then # Normal exadata cell
			  fixRootPassword "$cell_rootpassword"
                          cellhostname=$($EXPECT -f - << IBEOF
                                              set timeout $passwordcheck_timeout
					      set le_cell_rootpassword "$fixedRootPassword"
                                              #log_user 0
                                              if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                                exp_internal 1
                                              } 
                                              spawn -noecho $SSHELL $cell_ssh_user@$cellname "hostname|cut -d. -f1"
                                              match_max 100000
                                              expect {
					  	  -nocase "permission denied *" {
					  	     exit 4;
					        }
                                          	  -nocase "no)?" {
                                          	     send -- "yes\n"
                                                }
					  	  -nocase "*?assword:*" {
					  	     send -- "\$le_cell_rootpassword\n"
					  	}
					  	  -nocase eof {
					  	     exit
					  	}
                                              }
					      # Look for passwd prompt
						expect {
						    -nocase "*?assword:*" {
							 send -- "\$le_cell_rootpassword\n"
						    }
						    -nocase eof {
							 exit
						    }
						    -nocase timeout {
							send_error "Timed out\n";
							exit
						    }
						 }
					      # Stop the on logon tests and if asked to connect to master switch choose no
						 expect {
						    -nocase eof {
							 exit
						    }
						    -nocase timeout {
							send_error "Timed out\n";
							exit
						    }
						 }
IBEOF
)
                          ##CONTROLM  cellnameFullActual=$(echo "$cellhostname"|tail -1|sed 's/ //g'|sed 's///g')
			  cellnameFullActual=$(echo "$cellhostname"|tail -1|sed 's/ //g'|tr -d '\r')
                          #cellnameFullActual=$(echo $cellhostname|awk 'BEGIN { FS = "password:" };{print $2}'|sed 's/ //g'|sed 's///g')
                          echo "$cellname = $cellnameFullActual" >>$CELLDIR/cells.out

                          if [[ -n "$RAT_CELL_RUNMODE" && $RAT_CELL_RUNMODE = "parallel" ]] ; then
                            start_run_on_cell_in_background
                          else
			    fixRootPassword "$cell_rootpassword"
			    $EXPECT -f - << IBEOF
			       set timeout $passwordcheck_timeout
			       set le_cell_rootpassword "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }
			       spawn $SCOPY $CELLSSCRPT $SCRIPTPATH/.cgrep/$ASREXACHK  $SCRIPTPATH/.cgrep/$checkFlashCache $cell_ssh_user@$cellname:$CELLTMPDIR
			       match_max 100000
				 expect {
			       -nocase "permission denied *" {
			 	     exit 4;
			        }
			       -nocase "no)?" {
				     send -- "yes\n"
                                } 
			       -nocase "*?assword:*" {
			    	     send -- "\$le_cell_rootpassword\n"
				}
				-nocase eof {
				     exit
				}
			       }
			       # Look for passwd prompt
                       	       expect {
                       		    -nocase "*?assword:*" {
                       		         send -- "\$le_cell_rootpassword\n"
                       		    }
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
		       		 	send_error "Timed out while copying $CELLSSCRPT on $cellname\n";
                       		        exit
                       		    }
                       		 }
		       	       #Stop the on logon tests and if asked to connect to master switch choose no
                       	       expect {
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
		       		 	send_error "Timed out while copying $CELLSSCRPT on $cellname\n";
                       		        exit
                       		    }
                       	       }
IBEOF
                            #-- gadiga create ${RTEMPDIR}
                            $EXPECT -f - << IBEOF
                               set timeout $passwordcheck_timeout			
			       set le_cell_rootpassword "$fixedRootPassword"
                               log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }
                               spawn $SSHELL $cell_ssh_user@$cellname mkdir ${CELLRTEMPDIR} >/dev/null 2>&1
                               match_max 100000
                                 expect {
			       -nocase "permission denied *" {
			 	     exit 4;
			        }
                               -nocase "no)?" {
                                     send -- "yes\n"
			        }
			       -nocase "*?assword:*" {
			    	     send -- "\$le_cell_rootpassword\n"
				}
				-nocase eof {
				     exit
				}
                                }
			        # Look for passwd prompt
                       	        expect {
                       	  	    -nocase "*?assword:*" {
                       	  	         send -- "\$le_cell_rootpassword\n"
                       	  	    }
                       	  	    -nocase eof {
                       	  	         exit
                       	  	    }
                       	  	    -nocase timeout {
		       	  	 	send_error "Timed out while creating ${CELLRTEMPDIR} directory on $cellname\n";
                       	  	        exit
                       	  	    }
                       	  	}
		       	        # Stop the on logon tests and if asked to connect to master switch choose no
                       	  	expect {
                       	  	    -nocase eof {
                       	  	         exit
                       	  	    }
                       	  	    -nocase timeout {
		       	  	 	send_error "Timed out while creating ${CELLRTEMPDIR} directory on $cellname\n";
                       	  	        exit
                       	  	    }
                       	  	}
IBEOF

			    $EXPECT -f - << IBEOF
			       set timeout $passwordcheck_timeout
			       set le_cell_rootpassword "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }  
			       spawn $SSHELL $cell_ssh_user@$cellname chmod 544 $CELLTMPDIR/${program_name}_cells.sh $CELLTMPDIR/$ASREXACHK $CELLTMPDIR/$checkFlashCache
			       match_max 100000
				 expect {
			       -nocase "permission denied *" {
			 	     exit 4;
			        }
			       -nocase "no)?" {
				     send -- "yes\n"
			        }
			       -nocase "*?assword:*" {
			    	     send -- "\$le_cell_rootpassword\n"
				}
				-nocase eof {
				     exit
				}
			        }
			        # Look for passwd prompt
                       	        expect {
                       	  	    -nocase "*?assword:*" {
                       	  	         send -- "\$le_cell_rootpassword\n"
                       	  	    }
                       	  	    -nocase eof {
                       	  	         exit
                       	  	    }
                       	  	    -nocase timeout {
		       	  	 	send_error "Timed out while modifying permissions on $cellname\n";
                       	  	        exit
                       	  	    }
                       	  	 }
		       	        # Stop the on logon tests and if asked to connect to master switch choose no
                       	  	expect {
                       	  	    -nocase eof {
                       	  	         exit
                       	  	    }
                       	  	    -nocase timeout {
		       	  	 	send_error "Timed out while modifying permissions on $cellname\n";
                       	  	        exit
                       	  	    }
                       	  	 }
IBEOF
			    $EXPECT -f - 2>>$WATCHLOG << IBEOF
			       set timeout $passwordcheck_timeout
			       set le_cell_rootpassword "$fixedRootPassword"
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }
			       spawn -noecho $SSHELL $cell_ssh_user@$cellname $CELLTMPDIR/${program_name}_cells.sh
			       match_max 100000
				 expect {
			       -nocase "permission denied *" {
			 	     exit 4;
			        }
			       -nocase "no)?" {
				     send -- "yes\n"
			        }
			       -nocase "*?assword:*" {
			    	     send -- "\$le_cell_rootpassword\n"
				}
				-nocase eof {
				     exit
				}
			      }	
			      # Look for passwd prompt
			      set timeout $watchdog_wakeup_root
                       	      expect {
                       		    -nocase "*?assword:*" {
                       		         send -- "\$le_cell_rootpassword\n"
                       		    }
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
					send_error "Timed out while running $CELLTMPDIR/${program_name}_cells.sh on $cellname\n";
                       		        exit
                       		    }
                               }
			       # Stop the on logon tests and if asked to connect to master switch choose no
                       	       expect {
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
                                        send_error "Timed out while running $CELLTMPDIR/${program_name}_cells.sh on $cellname\n";
                       		        exit
                       		    }
                       	        }
IBEOF
#only for execution
			    returncode=`echo $?`
			    move_failed_to_skipped "$returncode" "$CELLTMPDIR/${program_name}_cells.sh execution"
			    $EXPECT -f - << IBEOF
			       #set timeout 5
                               set timeout $passwordcheck_timeout
			       set le_cell_rootpassword "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                  exp_internal 1
                               }    
			       spawn $SCOPY $cell_ssh_user@$cellname:${CELLRTEMPDIR}/c_*.out $CELLDIR_SHORT
			       match_max 100000
				expect {
			       -nocase "permission denied *" {
			 	     exit 4;
			        }
			       -nocase "no)?" {
				     send -- "yes\n"
			        }
			       -nocase "*?assword:*" {
			    	     send -- "\$le_cell_rootpassword\n"
				}
				-nocase eof {
				     exit
				}
			        }
			        # Look for passwd prompt
                       	      	expect {
                       		    -nocase "*?assword:*" {
                       		         send -- "\$le_cell_rootpassword\n"
                       		    }
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
		       		 	send_error "Timed out while copying outfiles from $cellname\n";
                       		        exit
                       		    }
                       		 }
		       	         # Stop the on logon tests and if asked to connect to master switch choose no
                       		 expect {
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
		       		 	send_error "Timed out while copying outfiles from $cellname\n";
                       		        exit
                       		    }
                       		 }
IBEOF
			    $EXPECT -f - << IBEOF
			       set timeout $passwordcheck_timeout
			       set le_cell_rootpassword "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }
			       spawn $SSHELL $cell_ssh_user@$cellname rm -f $CELLTMPDIR/${program_name}_cells.sh $CELLTMPDIR/$ASREXACHK  $CELLTMPDIR/$checkFlashCache 2>/dev/null
			       match_max 100000
				 expect {
			       -nocase "permission denied *" {
			 	     exit 4;
			        }
			       -nocase "no)?" {
				     send -- "yes\n"
			        }
			       -nocase "*?assword:*" {
			    	     send -- "\$le_cell_rootpassword\n"
				}
				-nocase eof {
				     exit
				}
			        }
			        # Look for passwd prompt
                       	      	expect {
                       		    -nocase "*?assword:*" {
                       		         send -- "\$le_cell_rootpassword\n"
                       		    }
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
		       		 	send_error "Timed out while removing files on $cellname\n";
                       		        exit
                       		    }
                       		 }
		      	         # Stop the on logon tests and if asked to connect to master switch choose no
                       		 expect {
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
		       		 	send_error "Timed out while removing files on $cellname\n";
                       		        exit
                       		    }
                       		 }
IBEOF
			    $EXPECT -f - << IBEOF
			       set timeout $passwordcheck_timeout
			       set le_cell_rootpassword "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }   
			       spawn $SSHELL $cell_ssh_user@$cellname rm -f ${CELLRTEMPDIR}/c_*.out ${CELLRTEMPDIR}/o_*.out
			       match_max 100000
			       expect {
			       -nocase "permission denied *" {
			 	     exit 4;
			        }
			       -nocase "no)?" {
				     send -- "yes\n"
			        }
			       -nocase "*?assword:*" {
			    	     send -- "\$le_cell_rootpassword\n"
				}
				-nocase eof {
				     exit
				}
			        }
			        # Look for passwd prompt
                       	      	expect {
                       		    -nocase "*?assword:*" {
                       		         send -- "\$le_cell_rootpassword\n"
                       		    }
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
		       		 	send_error "Timed out while removing files on $cellname\n";
                       		        exit
                       		    }
                       		}
		       	        # Stop the on logon tests and if asked to connect to master switch choose no
                       		expect {
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
		       		 	send_error "Timed out while removing files on $cellname\n";
                       		        exit
                       		    }
                       		 }
IBEOF
                            $EXPECT -f - << IBEOF
			       set timeout $passwordcheck_timeout
			       set le_cell_rootpassword "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }
			       spawn $SSHELL $cell_ssh_user@$cellname rmdir  ${CELLRTEMPDIR}
			       match_max 100000
				 expect {
			       -nocase "permission denied *" {
			 	     exit 4;
			        }
			       -nocase "no)?" {
				     send -- "yes\n"
			        }
			       -nocase "*?assword:*" {
			    	     send -- "\$le_cell_rootpassword\n"
				}
				-nocase eof {
				     exit
				}
			        }
			        # Look for passwd prompt
                       	      	expect {
                       		    -nocase "*?assword:*" {
                       		         send -- "\$le_cell_rootpassword\n"
                       		    }
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
		       		 	send_error "Timed out while removing $CELLRTEMPDIR directory on $cellname\n";
                       		        exit
                       		    }
                       		 }
		                 # Stop the on logon tests and if asked to connect to master switch choose no
                       		 expect {
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
		       		 	send_error "Timed out while removing $CELLRTEMPDIR directory on $cellname\n";
                       		        exit
                       		    }
                       		 }
IBEOF
                            if [ -e $CELLDIR_SHORT ]; then format_cell_switch_files "$cellname_short" "$CELLDIR_SHORT" "cell";fi
                          fi #end of parallel and serial check exeuction
			else
			  #echo -e "\n\n${RED}Still ${userToCheck} password for $nodeNameToCheck was wrong. $userToCheck privileged check will not be executed on $nodeNameToCheck ${NORM}\n"
			  echo -e "\n\n${RED}Skipping ${userToCheck} privileged checks for ${nodeNameToCheck}.\nThe $userToCheck password must have been changed since the passwords were validated at the beginning of tool execution ${NORM}\n"|tee -a $LOGFIL  
			fi 
		      else
		        echo -e "\n${RED}Skipping $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER ${NORM} ${cellname}\n"|tee -a $LOGFIL
		      fi
		      if [[ -e $CELLDIR/c_root_collect_timing.out && -e $COLLECT_TIMING ]]
		      then
		        cat $CELLDIR/c_root_collect_timing.out >> $COLLECT_TIMING
		        rm -f $CELLDIR/c_root_collect_timing.out  >/dev/null 2>&1
		      fi
                    else
		      if [[ $ssh_go_ahead = 0 ]]
		      then
		        echo -e "\n${RED}Skipping $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER ${NORM} ${RED} ${cellname} is available but ssh took too long.${NORM}\n"|tee -a $LOGFIL
		        add_to_skipped_nodes "${cellname}" "Network latency issue: Storage Server is pingable but ssh took too long"
		      else
		        echo -e "\n${RED}Skipping $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER ${NORM} ${RED} ${cellname} because its not available.${NORM}\n"|tee -a $LOGFIL
		        #echo -e "\n${RED}Skipping $cellname to execute $cell_ssh_user privileged checks because $cellname is not reachable${NORM}\n"
		        add_to_skipped_nodes "${cellname}" "Storage Server is not available"
		      fi
                    fi  
                    root_cell_counter=$(expr $root_cell_counter + 1)
                  done

                  if [[ -n "$RAT_CELL_RUNMODE" && $RAT_CELL_RUNMODE = "parallel" ]] && [[ -n "$RAT_GLOBAL_RUNMODE" && $RAT_GLOBAL_RUNMODE = "serial" ]]; then
                    wait_for_cell_completion
                  fi
                fi
              if [ -e $CELLDIR/cells.out ]; then cp $CELLDIR/cells.out $RTEMPDIR >/dev/null 2>&1; if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then cp $CELLDIR/cells.out $TMP_OUTPUT >/dev/null 2>&1; fi; fi
              root_cell_counter=0 
              #function to discover mixed hardware cells
              #mixed_hardware_cells_discovery 
              fi #Finished here with executing command with root for each cell

              no_ib_switch=1
              if  [[ $OSCOLLECTCNT -eq $OSCOLLECTSUM && $OFFLINE -eq 0 && $ibswitch_root_command -gt 0  && -n "$ibswitch_password_status" && $ibswitch_password_status -eq 1 ]]
              then
                #Create lock file for watchdog for root collections.
                touch $ROOT_LCKFIL

                if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -e ${RTEMPDIR}/o_ibswitches.out ]]  
                then
                  if [ -z "$noRootScriptNode" ];then noPasswordAvailable=0;fi  
                  #cat $IBSWITCHSCRPT
                  #$READ -p "good to run"
                  #function to map ip address to switch name and find switch type for each(leaf or spine)
                  switch_ip_type_name_mapping 
                  ib_root_counter=0
                  no_of_ibs=$(wc -l ${RTEMPDIR}/o_ibswitches.out | awk '{print $1}')
                  no_of_ibs=$(expr $no_of_ibs - 1);
                  in_last_ib=0
	          last_ib_name=""
                  if [[ ! -n "$RAT_IBSWITCH_RUNMODE" ]] ; then RAT_IBSWITCH_RUNMODE="parallel"; fi;
                  for switchname in `cat ${RTEMPDIR}/o_ibswitches.out` 
                  do
                    if [ $no_of_ibs -eq $ib_root_counter ] ; then
	              last_ib_name=$switchname
                      in_last_ib=1
                      no_ib_switch=0
                    fi
                    #Following code is to change switch ip address to fully qualified domain name so OS_OUT_CHECK dont get skipped
                    is_ibswitch_ip=$(echo $switchname|grep -c [A-Za-z])
                    if [[ -n $is_ibswitch_ip && $is_ibswitch_ip -eq 0 ]]
                    then
                      switchname_short=$(echo $switchname|sed 's/\./_/g')
                    else
                      switchname_short=$(echo $switchname|cut -d. -f1)            
                      #switchname=$(nslookup $switchname|grep -iw name|awk '{print $NF}'|sed 's/\.$//')
                    fi
                    switchDirShort=$OUTPUTDIR/$switchname_short
                    if [ -e $switchDirShort ]; then rm -rf $switchDirShort >/dev/null 2>&1; fi
                    mkdir -p $switchDirShort  
                    echo $switchname>>$INPUTDIR/o_ibswitches.out      
                    #$READ -p "after converting ip to name"
                    noPasswordAvailable=$(echo ${noRootScriptNode[*]}|grep -c $switchname)  
                    switch_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $switchname ls >/dev/null 2>&1;echo $?);
                     
                    if [[ -n "$switch_ssh_status" && $switch_ssh_status -eq 0 ]]
                    then
                      if [[ -n "$RAT_IBSWITCH_RUNMODE" && $RAT_IBSWITCH_RUNMODE = "parallel" ]] ; then
	                echo -e "\nStarting to run $ibswitch_user privileged commands in background on ${BLINK}INFINIBAND SWITCH ${NORM} ${switchname}\n"
                        start_run_on_ib_in_background
                      else
	                echo -e "\nPreparing to run $ibswitch_user privileged commands on ${BLINK}INFINIBAND SWITCH ${NORM} ${switchname}\n"

			is_SSH_blocked "$switchname" "$ibswitch_user" "$switch_rootpassword" "SWITCH"
			if [[ $SSH_blocked -eq 1 ]]; then
			  echo -e "\n${RED}Skipping $ibswitch_user privileged commands on ${BLINK}INFINIBAND SWITCH ${NORM} ${RED} ${switchname} is available but SSH is blocked.${NORM}\n"|tee -a $LOGFIL 
			  add_to_skipped_nodes "${switchname}" "SSH Issue: INFINIBAND SWITCH is reachable but SSH is blocked"
			  continue;
			fi   

                        $SSHELL $ibswitch_user@$switchname mkdir ${IBRTEMPDIR} >/dev/null 2>&1
                        $SCOPY  $IBSWITCHSCRPT $ibswitch_user@$switchname:$IBTMPDIR >/dev/null 2>&1
                        $SCOPY  $SWITCH_TYPE_FIL $ibswitch_user@$switchname:${IBRTEMPDIR} >/dev/null 2>&1
                        $SSHELL $ibswitch_user@$switchname chmod 544 $IBTMPDIR/${program_name}_ibswitch.sh >/dev/null 2>&1
                        $SSHELL $ibswitch_user@$switchname $IBTMPDIR/${program_name}_ibswitch.sh 2>/dev/null 
	                returncode=`echo $?`
                        $SCOPY  $ibswitch_user@$switchname:${IBRTEMPDIR}/s_*.out $switchDirShort >/dev/null 2>&1
                        $SSHELL $ibswitch_user@$switchname rm -f $IBTMPDIR/${program_name}_ibswitch.sh  >/dev/null 2>&1
                        $SSHELL $ibswitch_user@$switchname rm -f ${IBRTEMPDIR}/s_*.out ${IBRTEMPDIR}/o_*.out ${IBRTEMPDIR}/${SWITCH_TYPE_FIL_SHORT} >/dev/null 2>&1
                        $SSHELL $ibswitch_user@$switchname rmdir ${IBRTEMPDIR} >/dev/null 2>&1
                        if [ -e $switchDirShort ]; then format_cell_switch_files "$switchname_short" "$switchDirShort" "switch";fi
	                move_failed_to_skipped "$returncode" "$IBTMPDIR/${program_name}_ibswitch.sh execution"
                      fi
                    elif [ $noPasswordAvailable -eq 0 ]
                    then
                      if [[ -n "$RAT_IBSWITCH_RUNMODE" && $RAT_IBSWITCH_RUNMODE = "parallel" ]] ; then
	                echo -e "\nStarting to run $ibswitch_user privileged commands in background on ${BLINK}INFINIBAND SWITCH${NORM} ${switchname}.\n"
                      else
	                echo -e "\nPreparing to run $ibswitch_user privileged commands on ${BLINK}INFINIBAND SWITCH${NORM} ${switchname}.\n"
                      fi
	              if [[ -n "$ib_samerootpassword" && $ib_samerootpassword -eq 0 ]]
	              then
	                #echo -e "\n"
	                #    printf  "Enter $ibswitch_user password for ${BLINK}INFINIBAND SWITCH${NORM} ${switchname} :- "
	                #    tty -s && stty -echo
	                #    read switch_rootpassword
	                #    tty -s && stty echo
	                #    echo -e "\n" 
	                # else
	                #   echo -e "\nPreparing to run $ibswitch_user privileged commands on ${BLINK}INFINIBAND SWITCH${NORM} $switchname\n"
	                switch_rootpassword=${a_ib_switch_root_password[$ib_root_counter]}
	              fi
                      #$READ -p "$switchname $ibswitch_user $switch_rootpassword"  
                      checkUserPassword "$switchname" "$ibswitch_user" "$switch_rootpassword" "1"  

		      is_SSH_blocked "$switchname" "$ibswitch_user" "$switch_rootpassword" "SWITCH"
		      if [[ $SSH_blocked -eq 1 ]]; then
		        echo -e "\n${RED}Skipping $ibswitch_user privileged commands on ${BLINK}INFINIBAND SWITCH ${NORM} ${RED} ${switchname} is available but SSH is blocked.${NORM}\n"|tee -a $LOGFIL 
		        add_to_skipped_nodes "${switchname}" "SSH Issue: INFINIBAND SWITCH is reachable but SSH is blocked"
		        continue;
		      fi   

                      if [ $passwordCheckStatus -eq 0 ]
                      then
                        if [ -f "$IBSWITCHSCRPT" ] ; then cp $IBSWITCHSCRPT $OUTPUTDIR >/dev/null 2>&1; fi;

                        if [[ -n "$RAT_IBSWITCH_RUNMODE" && $RAT_IBSWITCH_RUNMODE = "parallel" ]] ; then
                          start_run_on_ib_in_background
                        else
                          # gadiga - create the /tmp/.program first
			  fixRootPassword "$switch_rootpassword"
			  $EXPECT -f - << IBEOF
			   set timeout $passwordcheck_timeout 
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           }  
			   spawn $SSHELL $ibswitch_user@$switchname mkdir ${IBRTEMPDIR} >/dev/null 2>&1
			   match_max 100000
			     expect {
			   -nocase "permission denied *" {
			        exit 4;
			   }
			   -nocase "no)?" {
			        send -- "yes\n"
			    }
			   -nocase "*?assword:*" {
			        send -- "\$le_switch_rootpassword\n"
			    }
			   -nocase eof {
			        exit
			    }
			  }
			  # Look for passwd prompt
                       	  	expect {
                       	        -nocase "*?assword:*" {
                       	             send -- "\$le_switch_rootpassword\n"
                       	        }
                       	        -nocase eof {
                       	             exit
                       	        }
                       	        -nocase timeout {
		       	     	send_error "Timed out while creating on $switchname\n";
                       	            exit
                       	        }
                       	     }
		       	  # Stop the on logon tests and if asked to connect to master switch choose no
                       		 expect {
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
		       		 	send_error "Timed out while creating on $switchname\n";
                       		        exit
                       		    }
                           }
IBEOF
			  $EXPECT -f - << IBEOF
			   set timeout $passwordcheck_timeout 
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           }   
			   spawn $SCOPY $IBSWITCHSCRPT $ibswitch_user@$switchname:$IBTMPDIR
			    match_max 100000
			     expect {
			   -nocase "permission denied *" {
			        exit 4;
			    }
			   -nocase "no)?" {
			        send -- "yes\n"
			    }
			   -nocase "*?assword:*" {
			        send -- "\$le_switch_rootpassword\n"
			    }
			   -nocase eof {
			        exit
			    }
			    }
			      # Look for passwd prompt
                       	      	expect {
                       		    -nocase "*?assword:*" {
                       		         send -- "\$le_switch_rootpassword\n"
                       		    }
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
		       		 	send_error "Timed out while copying $IBSWITCHSCRPT on $switchname\n";
                       		        exit
                       		    }
                       		 }
		       	      # Stop the on logon tests and if asked to connect to master switch choose no
                       		 expect {
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
		       		 	send_error "Timed out while copying $IBSWITCHSCRPT on $switchname\n";
                       		        exit
                       		    }
                       	      }
IBEOF
			  $EXPECT -f - << IBEOF
			   set timeout $passwordcheck_timeout
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           }   
			   spawn $SCOPY $SWITCH_TYPE_FIL $ibswitch_user@$switchname:${IBRTEMPDIR}
			   match_max 100000
			   expect {
			   -nocase "permission denied *" {
			      exit 4;
			   }
			   -nocase "no)?" {
				 send -- "yes\n"
			    }
			   -nocase "*?assword:*" {
			        send -- "\$le_switch_rootpassword\n"
			    }
			   -nocase eof {
			        exit
			    }
  		            }
			    # Look for passwd prompt
                       	    	expect {
                       	          -nocase "*?assword:*" {
                       	               send -- "\$le_switch_rootpassword\n"
                       	          }
                       	          -nocase eof {
                       	               exit
                       	          }
                       	          -nocase timeout {
		       	       	send_error "Timed out while copying $SWITCH_TYPE_FIL on $switchname\n";
                       	              exit
                       	          }
                       	       }
		       	    # Stop the on logon tests and if asked to connect to master switch choose no
                       		 expect {
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
		       		 	send_error "Timed out while copying $SWITCH_TYPE_FIL on $switchname\n";
                       		        exit
                       		    }
                       	    }
IBEOF

			  $EXPECT -f - << IBEOF
			   set timeout $passwordcheck_timeout 
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           }  
			   spawn $SSHELL $ibswitch_user@$switchname chmod 544 $IBTMPDIR/${program_name}_ibswitch.sh
			   match_max 100000
			     expect {
			   -nocase "permission denied *" {
			        exit 4;
			    }
			   -nocase "no)?" {
			        send -- "yes\n"
			    }
			   -nocase "*?assword:*" {
			        send -- "\$le_switch_rootpassword\n"
			    }
			   -nocase eof {
			        exit
			    }
			    }
			    # Look for passwd prompt
                       	    expect {
                       		    -nocase "*?assword:*" {
                       		         send -- "\$le_switch_rootpassword\n"
                       		    }
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
		       		 	send_error "Timed out while changing permissions on $switchname\n";
                       		        exit
                       		    }
                       		 }
		       	    # Stop the on logon tests and if asked to connect to master switch choose no
                       		 expect {
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
		       		 	send_error "Timed out while changing permissions on $switchname\n";
                       		        exit
                       		    }
                       		 }
IBEOF
			  $EXPECT -f - 2>>$WATCHLOG << IBEOF
			   set timeout $passwordcheck_timeout
			   set le_switch_rootpassword "$fixedRootPassword"
			   #log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           } 
			   spawn -noecho $SSHELL_EL $ibswitch_user@$switchname $IBTMPDIR/${program_name}_ibswitch.sh
			   match_max 100000
			     expect {
			   -nocase "permission denied *" {
			        exit 4;
			    }
			   -nocase "no)?" {
			        send -- "yes\n"
			    }
			   -nocase "*?assword:*" {
			        send -- "\$le_switch_rootpassword\n"
			    }
			   -nocase eof {
			        exit
			    }
			    }
			    set timeout $watchdog_wakeup
			    # Look for passwd prompt
                       	      	expect {
                       		    -nocase "*?assword:*" {
                       		         send -- "\$le_switch_rootpassword\n"
                       		    }
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
					send_error "Timed out while running $IBTMPDIR/${program_name}_ibswitch.sh on $switchname\n";
                       		        exit
                       		    }
                       		 }
		       	         # Stop the on logon tests and if asked to connect to master switch choose no
                       		 expect {
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
					send_error "Timed out while running $IBTMPDIR/${program_name}_ibswitch.sh on $switchname\n";
                       		        exit
                       		    }
                       	    }
IBEOF
			  #only for execution
			  returncode=`echo $?`
			  move_failed_to_skipped "$returncode" "$IBTMPDIR/${program_name}_ibswitch.sh execution"
			  
			  $EXPECT -f - << IBEOF
			   #set timeout 5
                           set timeout $passwordcheck_timeout
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           }
			   spawn $SCOPY $ibswitch_user@$switchname:${IBRTEMPDIR}/s_*.out $switchDirShort
			   match_max 100000
			     expect {
			   -nocase "permission denied *" {
			     exit 4;
			   }
			   -nocase "no)?" {
			        send -- "yes\n"
			    }
			   -nocase "*?assword:*" {
			        send -- "\$le_switch_rootpassword\n"
			    }
			   -nocase eof {
			        exit
			    }
			    }
			    # look for passwd prompt
                       	    expect {
                       		    -nocase "*?assword:*" {
                       		         send -- "\$le_switch_rootpassword\n"
                       		    }
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
					send_error "Timed out while copying ${IBRTEMPDIR}/s_*.out files from $switchname\n";
                       		        exit
                       		    }
                       		 }
		       	     # stop the on logon tests and if asked to connect to master switch choose no
                       		 expect {
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
					send_error "Timed out while copying ${IBRTEMPDIR}/s_*.out files from $switchname\n";
                       		        exit
                       		    }
                       	      }
IBEOF
			  $EXPECT -f - << IBEOF
			   set timeout $passwordcheck_timeout
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           }
			   spawn $SSHELL $ibswitch_user@$switchname rm -f $IBTMPDIR/${program_name}_ibswitch.sh
			   match_max 100000
			     expect {
			   -nocase "permission denied *" {
			        exit 4;
			    }
			   -nocase "no)?" {
			        send -- "yes\n"
			    }
			   -nocase "*?assword:*" {
			        send -- "\$le_switch_rootpassword\n"
			    }
			   -nocase eof {
			        exit
			    }
			    }
			    # look for passwd prompt
                       	    expect {
                       		    -nocase "*?assword:*" {
                       		         send -- "\$le_switch_rootpassword\n"
                       		    }
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
					send_error "Timed out while removing $IBTMPDIR/${program_name}_ibswitch.sh from $switchname\n";
                       		        exit
                       		    }
                       		 }
		       	    # stop the on logon tests and if asked to connect to master switch choose no
                       	    expect {
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
					send_error "Timed out while removing $IBTMPDIR/${program_name}_ibswitch.sh from $switchname\n";
                       		        exit
                       		    }
                       		 }
IBEOF
			  $EXPECT -f - << IBEOF
			   set timeout $passwordcheck_timeout
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           } 
			   spawn $SSHELL $ibswitch_user@$switchname rm -f ${IBRTEMPDIR}/s_*.out ${IBRTEMPDIR}/o_*.out ${IBRTEMPDIR}/${SWITCH_TYPE_FIL_SHORT}
			   match_max 100000
			   expect {
			   -nocase "permission denied *" {
			        exit 4;
			    }
			   -nocase "no)?" {
			        send -- "yes\n"
			    }
			   -nocase "*?assword:*" {
			        send -- "\$le_switch_rootpassword\n"
			    }
			   -nocase eof {
			        exit
			    }
			    }
  		            # look for passwd prompt
                            expect {
                              -nocase "*?assword:*" {
                                   send -- "\$le_switch_rootpassword\n"
                              }
                              -nocase eof {
                                   exit
                              }
                              -nocase timeout {
		          	send_error "Timed out while removing files from $switchname\n";
                                  exit
                              }
                           }
		           # stop the on logon tests and if asked to connect to master switch choose no
                           expect {
                              -nocase eof {
                                   exit
                              }
                              -nocase timeout {
		          	send_error "Timed out while removing files from $switchname\n";
                                  exit
                              }
                           }
IBEOF
                  	  $EXPECT -f - << IBEOF
			   set timeout $passwordcheck_timeout
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } { 
                             exp_internal 1
                           } 
			   spawn $SSHELL $ibswitch_user@$switchname rmdir ${IBRTEMPDIR}
			   match_max 100000
			     expect {
			   -nocase "permission denied *" {
			        exit 4;
			    }
			   -nocase "no)?" {
			        send -- "yes\n"
			    }
			   -nocase "*?assword:*" {
			        send -- "\$le_switch_rootpassword\n"
			    }
			   -nocase eof {
			        exit
			    }
			    }
			    # look for passwd prompt
                       	    expect {
                       		    -nocase "*?assword:*" {
                       		         send -- "\$le_switch_rootpassword\n"
                       		    }
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
					send_error "Timed out while removing ${IBRTEMPDIR} from $switchname\n";
                       		        exit
                       		    }
                       		 }
		       	     # stop the on logon tests and if asked to connect to master switch choose no
                       	      expect {
                       		    -nocase eof {
                       		         exit
                       		    }
                       		    -nocase timeout {
					send_error "Timed out while removing ${IBRTEMPDIR} from $switchname\n";
                       		        exit
                       		    }
                       	      }
IBEOF
                          if [ -e $switchDirShort ]; then format_cell_switch_files "$switchname_short" "$switchDirShort" "switch";fi
                        fi # endif RAT_RUNMODE
                      else
                        #echo -e "\n\n${RED}Still ${userToCheck} password for $nodeNameToCheck was wrong. $userToCheck privileged check will not be executed on $nodeNameToCheck ${NORM}\n"
                        echo -e "\n\n${RED}Skipping ${userToCheck} privileged checks for ${nodeNameToCheck}.\nThe $userToCheck password must have been changed since the passwords were validated at the beginning of tool execution ${NORM}\n"|tee -a $LOGFIL  
                        add_to_skipped_nodes "$switchname" "The $ibswitch_user password validation failed on Infiniband Switch"
                      fi  
                    else
		      echo -e "\n${RED}Skipping $ibswitch_user privileged commands on ${BLINK}INFINIBAND SWITCH ${NORM} ${switchname}\n"|tee -a $LOGFIL
		      add_to_skipped_nodes "${switchname}" "The $ibswitch_user password validation failed Infiniband Switch."
                    fi
                    if [[ -e $OUTPUTDIR/s_root_collect_timing.out && -e $COLLECT_TIMING ]]
		    then
		      cat $OUTPUTDIR/s_root_collect_timing.out >> $COLLECT_TIMING
		      rm -f $OUTPUTDIR/s_root_collect_timing.out  >/dev/null 2>&1
		    fi
                    ib_root_counter=$(expr $ib_root_counter + 1)
                  done

                  if [[ -n "$RAT_IBSWITCH_RUNMODE" && $RAT_IBSWITCH_RUNMODE = "parallel" ]] && [[ -n "$RAT_GLOBAL_RUNMODE" && $RAT_GLOBAL_RUNMODE = "serial" ]] ; then
                    wait_for_ib_completion
                  fi
                  #This is to copy new switch names file after converting ip addresses to fully qualified domain name
                  if [ -e $INPUTDIR/o_ibswitches.out ]; then mv -f $INPUTDIR/o_ibswitches.out  ${RTEMPDIR}/o_ibswitches.out;fi  
                  #$READ -p "stop after mvoing file"
                fi
                #function to map ip address to switch name and find switch type for each(leaf or spine)
                #switch_ip_type_name_mapping 
              fi #Finished here with executing command with root for each infiniband switch 

	      if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]]; then
	        if [[ -n "$RAT_GLOBAL_RUNMODE" && $RAT_GLOBAL_RUNMODE = "parallel" ]] ; then
	          wait_for_system_completion;
	        fi
	      fi

	      if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]] && [[ -n "$RAT_GLOBAL_RUNMODE" && $RAT_GLOBAL_RUNMODE = "parallel" ]] ; 
	      then
	        if [[ -n "$RAT_IBSWITCH_RUNMODE" && $RAT_IBSWITCH_RUNMODE = "serial" ]];
	        then
	        	print_ib=0;
	        fi 
	        if [[ "$last_ib_name" != "" ]];
	        then
	          if [[ "$print_ib" = "1" ]];
	          then	
	            if [[ -n "$cell_type" && $cell_type  != "zfscell" ]] || [[ -z $cell_type ]] ; then
	              if [ -f ${RTEMPDIR}/${switchname}.out ]; then
	                echo -e "\n"
	                echo "Collections from INFINIBAND SWITCH:";
	                echo "------------------------------------";
	                cat ${RTEMPDIR}/${switchname}.out			
	                print_ib=0;
	              fi
	            fi
	          fi
	        fi
	      fi

              if  [[ $OSCOLLECTCNT -eq $OSCOLLECTSUM && $OFFLINE -eq 0 ]] && [ $components != "OVM" ] 
              then 
                if [ $SILENT -eq 0 ]
                then
                  #commented following if because exalogic also has collections and want to print this on exalogic too 
                  #if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 0 || $i = $localnode ]]
                  #then 
                  echo -e "\n\nData collections completed. Checking best practices on ${i}."
                  echo -e "--------------------------------------------------------------------------------------\n\n" 
                  #fi  
                else
                  echo -e "\n\nNow collecting Oracle Patch inventory.Please standby."
                fi
                if [ -e "$ROOT_LCKFIL" ] ; then rm -f "$ROOT_LCKFIL" >/dev/null 2>&1; fi
              fi
              if  [[ $OSCOLLECTCNT -eq $OSCOLLECTSUM && $OFFLINE -eq 0 && -n "$RAT_COMPUTE_RUNMODE" && $RAT_COMPUTE_RUNMODE = "parallel" ]] ; then
                if [[ $RAT_RUNMODE_INTERNAL = "master" ]] ; then # master.. scp the *v_parameter* to all nodes
                  odir=$(basename $OUTPUTDIR)
                  #for rnode in `cat $HOSTLIST.org |grep -v $localnode`
                  for rnode in `grep -v $localnode $HOSTLIST.org`
                  do
                    get_cygpath "OUTPUTDIR"
                    get_cygpath "RTEMPDIR"
                    $SCOPY $OUTPUTDIR/*v_parameter* $rnode:$RTEMPDIR/$odir > /dev/null 2>&1
                    $SSHELL $rnode "touch $RTEMPDIR/master.collections.done "
                    restore_cygpath "OUTPUTDIR"
                    restore_cygpath "RTEMPDIR"
                  done
                elif [[ $is_exalogic_machine -eq "0" ]] ; then # wait for $RTEMPDIR/master.collections.done
                  #echo "waiting for master collections. ";
                  mc_done=0
                  while [[ $mc_done -eq "0" ]] ; do
                    if [[ -e "$RTEMPDIR/master.collections.done" ]] ; then mc_done=1; fi;
                    if [[ $mc_done -eq "0" ]] ; then
                      #printf ". "
                      sleep 2
                    fi
                  done
                  echo
                fi
              fi
              #To copy cell flash cache mode file to each node to execute BP9 or greater in Grid Infrastructure home for Write Back Flash Cache on remote node 
              if [[ -e $CELLDIR/c_cbc_CellFlashCacheMode_${cellname_short}.out && $i = $localnode ]]
              then
                for rnode in `if [ -e $HOSTLIST.org ]; then cat $HOSTLIST.org;else cat $HOSTLIST;fi`;
		do 
	 	  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		    $SCOPY $CELLDIR/c_cbc_CellFlashCacheMode_${cellname_short}.out $rnode:$TMP_OUTPUT/CellFlashCacheMode.out > /dev/null 2>&1;
		  fi	  
		  $SCOPY $CELLDIR/c_cbc_CellFlashCacheMode_${cellname_short}.out $rnode:$TMPDIR/CellFlashCacheMode.out > /dev/null 2>&1;
		  echo "rnode=$rnode" >>$LOGFIL;
		done
              fi  
              mixed_hardware=0 
              if [[ $(ls -l $CELLDIR 2>/dev/null|wc -l) -gt 10 && "$i" = "$localnode" ]];then  mixed_hardware_cells_discovery;fi
              #if [[ $OSCOLLECTCNT -eq $OSCOLLECTSUM && $OFFLINE -eq 0 ]]; then cp -r $OUTPUTDIR/*vm_cfg_guid* $RTEMPDIR >/dev/null 2>&1; cp -r $OUTPUTDIR/*showvnics_guid* $RTEMPDIR >/dev/null 2>&1;fi
  	      ;;
            SQL|SQL_PARAM|SQL_COLLECT|SQL_OUT_CHECK|OS_PARAM|OS_PACKAGE|OS_PATCH|CLUSTERWIDE_CHECK|SYSTEMWIDE_CHECK|ORACLE_PATCH|CROSS_NODE_CHECK)
              case $COMTYPE in
                SQL)
           	  #if [ ${stack_asm_up[$stack_counter]} -eq 1 -o ${stack_dbinst_up[$stack_counter]} -ne 0 ]
                  #if  [[ -n "$it_is_rac" && $it_is_rac -eq 0 &&  $component_match_count  -lt 1 ]]
                  if  [[ $component_match_count  -lt 1 ]]
                  then
                    echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
                    call_get_log_result=0
                  elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$audit_check_name" $EXCLUDEFIL` -ge 1 ]]
                  then
                    call_get_log_result=0
                    echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                    generate_exceptions_xml "Skipping $audit_check_name because its in exclude file $EXCLUDEFIL"
	          elif [ -z "$profiles2run" ] && [ -e $PROFILEONLY ] && [[ `grep -ic $CHECK_ID $PROFILEONLY` -ge 1 ]]
                  then
                     call_get_log_result=0
                     echo "Not running $audit_check_name($CHECK_ID) because no profile is in use">>$LOGFIL
                  else   
                    call_get_log_result=1
                    mb_db_counter=0
                    mb_db_counter_log=0
	            if [[ -n "${stack_dbinst_up[$stack_counter]}" &&  ${stack_dbinst_up[$stack_counter]} -ne 0 ]]
	            then
	              if [ $op_mode -eq 0 ]
	              then
	                COM=`grep "_"$ROW"-SQL_COMMAND" $REFFIL |sed  -n 's/.*SQL_COMMAND //p'`
	                COM_REPORT=`grep "_"$ROW"-SQL_COMMAND_REPORT" $REFFIL |sed  -n 's/.*SQL_COMMAND_REPORT //p'`
	                audit_check_name=`grep "_"$ROW"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
	              else
                        com_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_START"
	                com_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_END"
	                COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d')
	                com_report_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_START"
	                com_report_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_END"
	                COM_REPORT=$(sed -n /$com_report_begin_pattern/,/$com_report_end_pattern/p $REFFIL|sed '1d'|sed '$d')
	                #COM=`grep "_"$CHECK_ID"-SQL_COMMAND" $REFFIL |sed  -n 's/.*SQL_COMMAND //p'`
	                #COM_REPORT=`grep "_"$CHECK_ID"-SQL_COMMAND_REPORT" $REFFIL |sed  -n 's/.*SQL_COMMAND_REPORT //p'`
	                audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
	              fi
	              audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'`
	              #in this case $SPOOLFILE already exists so we can lookup the value
	              #we're looking for now
	              #VAL=`grep $PARAM_PATH $SPOOLFIL |awk {'print $3'}`
                      ORIG_PMSG=$PMSG
                      ORIG_FMSG=$FMSG

                      #Meta File for DB parallelization
 	              if [[ $OFFLINE -eq 0 && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 ]]
	              then 
			t_PSQL_STAT="${PSQL_STAT}_${CHECK_ID}"
                        t_PSQL_METAFIL="${PSQL_METAFIL}_${CHECK_ID}"
                        echo "CHECKID=$CHECK_ID"                             	 >  $t_PSQL_METAFIL 
                        echo "COMTYPE=$COMTYPE"                              	 >> $t_PSQL_METAFIL  
                        echo "COM_START=$COM"                                  	 >> $t_PSQL_METAFIL 
		        echo "COM_END"						 >> $t_PSQL_METAFIL
                        echo "COM_REPORT_START=$COM_REPORT"                    	 >> $t_PSQL_METAFIL 
                        echo "COM_REPORT_END"    	                   	 >> $t_PSQL_METAFIL 
                        echo "AUDIT_CHECK_NAME=$audit_check_name"            	 >> $t_PSQL_METAFIL 
                        echo "RAT_RUNMODE_INTERNAL=$RAT_RUNMODE_INTERNAL"    	 >> $t_PSQL_METAFIL 
	
	                #DB information for DB parallelization
	                t_PSQL_INFIL="${PSQL_INFIL}_${CHECK_ID}"
	                t_mb_db_counter=0
	                for db_name_to_check in "${mb_db_names[@]}"
	                do
	                  match_database_role "${mb_database_role[$t_mb_db_counter]}"
	                  match_database_type "${mb_database_type[$t_mb_db_counter]}"

	                  echo "${db_name_to_check},${mb_oracle_sids[$t_mb_db_counter]},${mb_oracle_homes[$t_mb_db_counter]},${mb_database_role[$t_mb_db_counter]},$dbrole_match_count,${mb_database_type[$t_mb_db_counter]},$dbtype_match_count,${mb_sysdba_user[$t_mb_db_counter]},${mb_sysdba_pswd[$t_mb_db_counter]},${RAT_PDB_USER},${mb_db_sys_password[$t_mb_db_counter]},${mb_db_connect_string[$t_mb_db_counter]},${mb_checksysdba[$t_mb_db_counter]},${mb_running_host[$t_mb_db_counter]}" >> $t_PSQL_INFIL
	                  t_mb_db_counter=$(expr $t_mb_db_counter + 1)
	                done
	                t_mb_db_counter=0
	              fi

	              psql_counter=0
                      for db_name_to_check in "${mb_db_names[@]}"
                      do
	                #DB parallelization
 	                if [[ $OFFLINE -eq 0 && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 ]]
	                then
	                  if [[ $psql_counter -eq 0 ]]
	                  then
	                    parallel_sql
	                  fi
			  if [[ -n $PRET_STATUS && $PRET_STATUS -ne "0" ]]; then
  			    move_failed_to_skipped "$PRET_STATUS" "" "$i:$db_name_to_check" "1"
			  fi
	
                          psql_counter=$(expr $psql_counter + 1)
	                fi
	               
                        skip_this_version=0
                        set_skip_this_version "-"
                        if [ $skip_this_version -eq 1 ]
                        then #dont run
                          mb_db_counter=$(expr $mb_db_counter + 1)
                          echo "Skipping check($CHECK_ID) on version 4 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                          continue
                        fi
                        match_database_role "${mb_database_role[$mb_db_counter]}"
                        match_database_type "${mb_database_type[$mb_db_counter]}"

                        if [[ $dbrole_match_count -ge 1 && $dbtype_match_count -ge 1 ]]
                        #if [[ "${mb_database_role[$mb_db_counter]}" = "$check_database_role" ]]
                        then 
	                  DBACTUAL=$OUTPUTDIR/d_actual_${db_name_to_check}.out
			  #remote_database_code && $i = $localnode ]]
	                  if [[ $OFFLINE -eq 0 && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 0 ]] 
	                  then
	                    export ORACLE_SID=${mb_oracle_sids[$mb_db_counter]}
	                    export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}

  	                    OUTFIL=$OUTPUTDIR/d_check_${db_name_to_check}.out
	                    INFIL=${INPUTDIR}/${CHECK_ID}_${db_name_to_check}.sql
			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
  	                      NEW_OUTFIL=$TMP_OUTPUT/d_check_${db_name_to_check}.out
	                      NEW_INFIL=${TMP_OUTPUT}/${CHECK_ID}_${db_name_to_check}.sql
			    fi

                            if [ "${mb_database_type[$mb_db_counter]}" = "PDB" ]; then echo "alter session set container=$db_name_to_check;">$INFIL;fi
	                    echo "$COM">>$INFIL
	
	                    #$READ -p "ORACLE_HOME=$ORACLE_HOME and ORACLE_SID=$ORACLE_SID infile is $INFIL and query is $COM"
                            #if its PDB then will connect to database using user name and password
                            if [ "${mb_database_type[$mb_db_counter]}" = "PDB" ]
                            then 
                              #IS_SYSDBA=0
                              #it will set this string but should never use because ${mb_checksysdba[$mb_db_counter]} will always be 1
                              dbConnectString="${RAT_PDB_USER}/${mb_db_sys_password[$mb_db_counter]}@"${mb_db_connect_string[$mb_db_counter]}" as sysdba"  
                            else
                              DBUSR=${mb_sysdba_user[$mb_db_counter]}
                              DBPWD=${mb_sysdba_pswd[$mb_db_counter]}
                              dbConnectString="$DBUSR/$DBPWD as sysdba"  
                            fi
                            #$READ -p "running for $db_name_to_check" 

		            if [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 0 ]]
		            then	
		              get_current_epoch 
		              echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $db_name_to_check] Execution Start Time: $epoch_time" >> $CHK_TIMINGS
		            fi

		            if [[ -n "${mb_checksysdba[$mb_db_counter]}" && ${mb_checksysdba[$mb_db_counter]} -eq 0 ]]
		            then
		              if [ ${mb_running_host[$mb_db_counter]} = $localnode ]
		              then
				if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
				  get_dbOwner
			
				  cp $INFIL $NEW_INFIL
				  chown $dbOwner:$dbGroup $NEW_INFIL
		                  
		                  su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s \"$dbConnectString\" as sysdba >/dev/null 2>&1 <<EOF
		                  set head off
		                  set lines 80
		                  set feedback off
                                  set timing off
		                  set serveroutput on
		                  spool $NEW_OUTFIL append
		                  @@$NEW_INFIL
		                  spool off
		                  exit
EOF
"
		                  returncode=`echo $?`
				  move_files "$NEW_OUTFIL" "$OUTFIL" append
		   		  rm -f $NEW_INFIL
	  		  	  cd $OLD_DIR
	    			  unset OLD_DIR
				else
		                  $ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
		                  set head off
		                  set lines 80
		                  set feedback off
                                  set timing off  
		                  set serveroutput on
		                  spool $OUTFIL append
		                  @@$INFIL
		                  spool off
		                  exit
EOF
		                  returncode=`echo $?`
				fi
		              else #remote_database_code
				if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
				  TMP_SPOOLFIL=$TMP_OUTPUT/sqltorun.out
				  cp $INFIL $NEW_INFIL
		                  get_cygpath "NEW_INFIL"
		                  $SCOPY $NEW_INFIL ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.sql
		                  restore_cygpath "NEW_INFIL"
				  $SSHELL ${mb_running_host[$mb_db_counter]} "chown $dbOwner:$dbGroup $TMP_OUTPUT/sqltorun.sql"
                                  $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
                                  export ORACLE_HOME=$ORACLE_HOME;
                                  export ORACLE_SID=$ORACLE_SID;
				  cd "$dbhome_dir";
		                  su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
		                  set head off
		                  set lines 80
		                  set feedback off
                                  set timing off
		                  set serveroutput on
		                  spool $TMP_SPOOLFIL 
		                  @@$TMP_OUTPUT/sqltorun.sql"
		                  spool off
		                  exit
EOF
"
EOF2
		                  returncode=`echo $?`
				  rm -f $NEW_INFIL
				  cd $OLD_DIR
				  unset OLD_DIR
				else
				  TMP_SPOOLFIL=$RTEMPDIR/sqltorun.out
		                  get_cygpath "INFIL"
		                  $SCOPY $INFIL ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.sql
		                  restore_cygpath "INFIL"
                                  $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
                                  export ORACLE_HOME=$ORACLE_HOME;
                                  export ORACLE_SID=$ORACLE_SID;
		                  $ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
		                  set head off
		                  set lines 80
		                  set feedback off
                                  set timing off
		                  set serveroutput on
		                  spool $TMP_SPOOLFIL 
		                  @@$RTEMPDIR/sqltorun.sql
		                  spool off
		                  exit
EOF
EOF2
		                  returncode=`echo $?`
				fi
				get_cygpath "TMP_SPOOLFIL"
		                get_cygpath "RTEMPDIR"
		                #$SCOPY ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.out $RTEMPDIR
		                $SCOPY ${mb_running_host[$mb_db_counter]}:$TMP_SPOOLFIL $RTEMPDIR
				restore_cygpath "TMP_SPOOLFIL"
		                restore_cygpath "RTEMPDIR"
                                cat $RTEMPDIR/sqltorun.out >> $OUTFIL
		                #echo "Output from sql collection $INFIL"; cat $RTEMPDIR/sqltorun.out
		              fi
		              move_failed_to_skipped "$returncode" "" "$i:$db_name_to_check" "1"
		            else
		              if [ ${mb_running_host[$mb_db_counter]} = $localnode ]
		              then
				if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
				  get_dbOwner
			
				  cp $INFIL $NEW_INFIL
				  chown $dbOwner:$dbGroup $NEW_INFIL
		                  #$READ -p "before asm collection"
		                  su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		                  set head off
		                  set lines 80
		                  set feedback off
                                  set timing off
		                  set serveroutput on
		                  spool $NEW_OUTFIL append
		                  @@$NEW_INFIL
		                  spool off
		                  exit
EOF
"
		                  returncode=`echo $?`
				  move_files "$NEW_OUTFIL" "$OUTFIL" append
		   		  rm -f $NEW_INFIL
	  		  	  cd $OLD_DIR
	    			  unset OLD_DIR
				else
		                  #$READ -p "before asm collection"
		                  $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		                  set head off
		                  set lines 80
		                  set feedback off
                                  set timing off
		                  set serveroutput on
		                  spool $OUTFIL append
		                  @@$INFIL
		                  spool off
		                  exit
EOF
		                  returncode=`echo $?`
				fi
		              else #remote_database_code
				if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
				  get_dbOwner

				  TMP_SPOOLFIL=$TMP_OUTPUT/sqltorun.out
				  cp $INFIL $NEW_INFIL
				  get_cygpath "NEW_INFIL"
		                  $SCOPY $NEW_INFIL ${mb_running_host[$mb_db_counter]}:$TMP_OUTPUT/sqltorun.sql
				  restore_cygpath "NEW_INFIL"
				  $SSHELL ${mb_running_host[$mb_db_counter]} "chown $dbOwner:$dbGroup $TMP_OUTPUT/sqltorun.sql"
                                  $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
                                  export ORACLE_HOME=$ORACLE_HOME;
                                  export ORACLE_SID=$ORACLE_SID;
				  cd "$dbhome_dir";
		                  su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		                  set head off
		                  set lines 80
		                  set feedback off
                                  set timing off
		                  set serveroutput on
		                  spool $TMP_SPOOLFIL
		                  @@$TMP_OUTPUT/sqltorun.sql
		                  spool off
		                  exit
EOF
"
EOF2
		                  returncode=`echo $?`
				  rm -f $NEW_INFIL
	  		  	  cd $OLD_DIR
	    			  unset OLD_DIR
				else 
				  TMP_SPOOLFIL=$RTEMPDIR/sqltorun.out
				  get_cygpath "INFIL"
		                  $SCOPY $INFIL ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.sql
                                  restore_cygpath "INFIL"
                                  $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
                                  export ORACLE_HOME=$ORACLE_HOME;
                                  export ORACLE_SID=$ORACLE_SID;
		                  $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		                  set head off
		                  set lines 80
		                  set feedback off
                                  set timing off
		                  set serveroutput on
		                  spool $TMP_SPOOLFIL
		                  @@$RTEMPDIR/sqltorun.sql
		                  spool off
		                  exit
EOF
EOF2
		                  returncode=`echo $?`
				fi
		                #$SCOPY ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.out $RTEMPDIR
				get_cygpath "TMP_SPOOLFIL"
				get_cygpath "RTEMPDIR"
		                $SCOPY ${mb_running_host[$mb_db_counter]}:$TMP_SPOOLFIL $RTEMPDIR
				restore_cygpath "TMP_SPOOLFIL"
				restore_cygpath "RTEMPDIR"
                                cat $RTEMPDIR/sqltorun.out >> $OUTFIL
		                #echo "Output from sql collection $INFIL"; cat $RTEMPDIR/sqltorun.out
		              fi
		              move_failed_to_skipped "$returncode" "" "$i:$db_name_to_check" "1"
		              #$READ -p "check asm collection $ORACLE_SID and $ORACLE_HOME $OUTFIL and infile=$INFIL"
		            fi

		     	    if [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 0 ]]
		            then	
		              get_current_epoch 
	           	      echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $db_name_to_check] Execution End Time: $epoch_time" >> $CHK_TIMINGS
			    fi
		          else
                            if [[ `uname -s` = "HP-UX" ]] ; then
                              PARAM_PATH_GRP=$(echo "$PARAM_PATH"| sed s'/\$/\\\$/g')
		              VAL=`grep -w $PARAM_PATH_GRP $OUTPUTDIR/d_check_${db_name_to_check}.out|cut -d= -f2`
		              VAL=`echo $VAL|sed 's/^ *\(.*\) *$/\1/'`
		            else
		              VAL=`grep -w $PARAM_PATH $OUTPUTDIR/d_check_${db_name_to_check}.out|cut -d= -f2`
		              VAL=`echo $VAL|sed 's/^ *\(.*\) *$/\1/'`
		            fi
		          fi 
                          #$READ -p "stop here for db_create_online_log_dest_1_and_log_file_name_convert"

		          if [[ -n "$COM_REPORT" && $OFFLINE -eq 0 && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 0 ]]
		          then
		            export ORACLE_SID=${mb_oracle_sids[$mb_db_counter]}
		            export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}

		            INFIL_REPORT=${INPUTDIR}/${CHECK_ID}_${db_name_to_check}_report.sql
			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			      NEW_INFIL_REPORT=$TMP_OUTPUT/${CHECK_ID}_${db_name_to_check}_report.sql
			    fi
                            if [ "${mb_database_type[$mb_db_counter]}" = "PDB" ]; then echo "alter session set container=$db_name_to_check;">$INFIL_REPORT;fi
		            echo "$COM_REPORT">>$INFIL_REPORT

		            SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${db_name_to_check}_report.out
			    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
		              NEW_ROOT_SOURCEFIL_REPORT=${TMP_OUTPUT}/${CHECK_ID}_${db_name_to_check}_report.out
			    fi 

		            if [ $OFFLINE -eq 0 ]
		            then
		              SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${db_name_to_check}_report.out
		            else
		              SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${db_name_to_check}_report.out
		            fi
		            echo -e "TO REVIEW COLLECTED DATA FOR $(echo $db_name_to_check|tr "[a-z]" "[A-Z]") FOR $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$SOURCEFIL_REPORT
		            #$READ -p "ORACLE_HOME=$ORACLE_HOME and ORACLE_SID=$ORACLE_SID infile is $INFIL and query is $COM"

			    #if [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 0 ]]
			    #then	
			    #  get_current_epoch 
			    #  echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $db_name_to_check] Execution Start Time: $epoch_time" >> $CHK_TIMINGS
			    #fi

		            if [[ -n "${mb_checksysdba[$mb_db_counter]}" && ${mb_checksysdba[$mb_db_counter]} -eq 0 ]]
		            then
		              if [ ${mb_running_host[$mb_db_counter]} = $localnode ]
		              then
				if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
				  get_dbOwner

				  cp $INFIL_REPORT $NEW_INFIL_REPORT
				  chown $dbOwner:$dbGroup $NEW_INFIL_REPORT

		                  su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s \"$dbConnectString\" as sysdba >/dev/null 2>&1 <<EOF
		                  set head off
		                  set lines 80
		                  set feedback off
                                  set timing off
		                  set serveroutput on
		                  spool $NEW_ROOT_SOURCEFIL_REPORT append
		                  @@$NEW_INFIL_REPORT
		                  spool off
		                  exit
EOF
"
		                  returncode=`echo $?`
				  move_files "$NEW_ROOT_SOURCEFIL_REPORT" "$SOURCEFIL_REPORT" "append"
		   		  rm -f $NEW_INFIL_REPORT
	  		  	  cd $OLD_DIR
	    			  unset OLD_DIR
				else
		                  $ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
		                  set head off
		                  set lines 80
		                  set feedback off
                                  set timing off
		                  set serveroutput on
		                  spool $SOURCEFIL_REPORT append
		                  @@$INFIL_REPORT
		                  spool off
		                  exit
EOF
		                  returncode=`echo $?`
				fi
		              else #remote_database_code
				if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
				  get_dbOwner

				  TMP_SPOOLFIL=$TMP_OUTPUT/sqltorun.out
				  cp $INFIL_REPORT $NEW_INFIL_REPORT
				  get_cygpath "NEW_INFIL_REPORT"
				  get_cygpath "TMP_OUTPUT"
		                  $SCOPY $NEW_INFIL_REPORT ${mb_running_host[$mb_db_counter]}:$TMP_OUTPUT/sqltorun.sql
				  restore_cygpath "NEW_INFIL_REPORT"
				  restore_cygpath "TMP_OUTPUT"
				  $SSHELL ${mb_running_host[$mb_db_counter]} "chown $dbOwner:$dbGroup $TMP_OUTPUT/sqltorun.sql"
                                  $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
                                  export ORACLE_HOME=$ORACLE_HOME;
                                  export ORACLE_SID=$ORACLE_SID;
				  cd "$dbhome_dir";
		                  su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s \"$dbConnectString\" as sysdba >/dev/null 2>&1 <<EOF
		                  set head off
		                  set lines 80
		                  set feedback off
                                  set timing off
		                  set serveroutput on
		                  spool $TMP_SPOOLFIL
		                  @@$TMP_OUTPUT/sqltorun.sql
		                  spool off
		                  exit
EOF
"
EOF2
		                  returncode=`echo $?`
		   		  rm -f $NEW_INFIL_REPORT
	  		  	  cd $OLD_DIR
	    			  unset OLD_DIR
				else
				  TMP_SPOOLFIL=$RTEMPDIR/sqltorun.out

		                  get_cygpath "INFIL_REPORT"
		                  get_cygpath "RTEMPDIR"
		                  $SCOPY $INFIL_REPORT ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.sql
		                  restore_cygpath "INFIL_REPORT"
		                  restore_cygpath "RTEMPDIR"
                                  $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
                                  export ORACLE_HOME=$ORACLE_HOME;
                                  export ORACLE_SID=$ORACLE_SID;
		                  $ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
		                  set head off
		                  set lines 80
		                  set feedback off
                                  set timing off 
		                  set serveroutput on
		                  spool $RTEMPDIR/sqltorun.out
		                  @@$RTEMPDIR/sqltorun.sql
		                  spool off
		                  exit
EOF
EOF2
		                  returncode=`echo $?`
				fi
		                #$SCOPY ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.out $RTEMPDIR
		                get_cygpath "TMP_SPOOLFIL"
		                get_cygpath "RTEMPDIR"
		                $SCOPY ${mb_running_host[$mb_db_counter]}:$TMP_SPOOLFIL $RTEMPDIR
		                restore_cygpath "TMP_SPOOLFIL"
		                restore_cygpath "RTEMPDIR"
                                cat $RTEMPDIR/sqltorun.out >> $SOURCEFIL_REPORT
		              fi
		              #move_failed_to_skipped "$returncode" "" "$i:$db_name_to_check"
		              #move_failed_to_skipped "$returncode" "" "$i:$db_name_to_check" "2"
		            else
		              #$READ -p "before asm collection"
		              if [ ${mb_running_host[$mb_db_counter]} = $localnode ]
		              then
				if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
				  get_dbOwner

				  cp $INFIL_REPORT $NEW_INFIL_REPORT
				  chown $dbOwner:$dbGroup $NEW_INFIL_REPORT

		                  su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		                  set head off
		                  set lines 80
		                  set feedback off
                                  set timing off
		                  set serveroutput on
		                  spool $NEW_ROOT_SOURCEFIL_REPORT append
		                  @@$NEW_INFIL_REPORT
		                  spool off
		                  exit
EOF
"
		                  returncode=`echo $?`
				  move_files "$NEW_ROOT_SOURCEFIL_REPORT" "$SOURCEFIL_REPORT" "append"
		   		  rm -f $NEW_INFIL_REPORT
	  		  	  cd $OLD_DIR
	    			  unset OLD_DIR
				else
		                  $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		                  set head off
		                  set lines 80
		                  set feedback off
                                  set timing off
		                  set serveroutput on
		                  spool $SOURCEFIL_REPORT append
		                  @@$INFIL_REPORT
		                  spool off
		                  exit
EOF
		                  returncode=`echo $?`
				fi
		              else #remote_database_code
				if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
				  get_dbOwner

				  TMP_SPOOLFIL=$TMP_OUTPUT/sqltorun.out
				  cp $INFIL_REPORT $NEW_INFIL_REPORT
				  get_cygpath "NEW_INFIL_REPORT"
				  get_cygpath "TMP_OUTPUT"
		                  $SCOPY $NEW_INFIL_REPORT ${mb_running_host[$mb_db_counter]}:$TMP_OUTPUT/sqltorun.sql
				  restore_cygpath "NEW_INFIL_REPORT"
				  restore_cygpath "TMP_OUTPUT"
				  $SSHELL ${mb_running_host[$mb_db_counter]} "chown $dbOwner:$dbGroup $TMP_OUTPUT/sqltorun.sql"
                                  $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
                                  export ORACLE_HOME=$ORACLE_HOME;
                                  export ORACLE_SID=$ORACLE_SID;
				  cd "$dbhome_dir";
		                  su $dbOwner -c "$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		                  set head off
		                  set lines 80
		                  set feedback off
                                  set timing off
		                  set serveroutput on
		                  spool $TMP_SPOOLFIL
		                  @@$TMP_OUTPUT/sqltorun.sql
		                  spool off
		                  exit
EOF
"
EOF2
		                  returncode=`echo $?`
		   		  rm -f $NEW_INFIL_REPORT
	  		  	  cd $OLD_DIR
	    			  unset OLD_DIR
				else
				  TMP_SPOOLFIL=$RTEMPDIR/sqltorun.out

				  get_cygpath "INFIL_REPORT"
				  get_cygpath "RTEMPDIR"
		                  $SCOPY $INFIL_REPORT ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.sql
				  restore_cygpath "INFIL_REPORT"
				  restore_cygpath "RTEMPDIR"
                                  $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
                                  export ORACLE_HOME=$ORACLE_HOME;
                                  export ORACLE_SID=$ORACLE_SID;
		                  $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		                  set head off
		                  set lines 80
		                  set feedback off
                                  set timing off
		                  set serveroutput on
		                  spool $RTEMPDIR/sqltorun.out
		                  @@$RTEMPDIR/sqltorun.sql
		                  spool off
		                  exit
EOF
EOF2
		                  returncode=`echo $?`
				fi
		                #$SCOPY ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.out $RTEMPDIR
		                get_cygpath "TMP_SPOOLFIL"
		                get_cygpath "RTEMPDIR"
		                $SCOPY ${mb_running_host[$mb_db_counter]}:$TMP_SPOOLFIL $RTEMPDIR
		                restore_cygpath "TMP_SPOOLFIL"
		                restore_cygpath "RTEMPDIR"
                                cat $RTEMPDIR/sqltorun.out >> $SOURCEFIL_REPORT
		              fi
		              #move_failed_to_skipped "$returncode" "" "$i:$db_name_to_check"
		              #move_failed_to_skipped "$returncode" "" "$i:$db_name_to_check" "2"
		              #$READ -p "check asm collection $ORACLE_SID and $ORACLE_HOME $OUTFIL and infile=$INFIL"
		            fi

			    #if [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 0 ]]
			    #then	
			    #  get_current_epoch 
			    #  echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: $db_name_to_check] Execution End Time: $epoch_time" >> $CHK_TIMINGS
			    #fi
		          else
		            SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${db_name_to_check}_report.out
		            if [ $OFFLINE -eq 0 ]
		            then
		              SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${db_name_to_check}_report.out
		            else
		              SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${db_name_to_check}_report.out
		            fi
		          fi
                          #Adding grep -v "^select" not to read errored out result like '||sum(sum(read_errs)+sum(write_errs))fromv$asm_diskgroupby1
			  SKIP_CHECK=0
                          if [[ `uname -s` = "HP-UX" ]] ; then
                            PARAM_PATH_GRP=$(echo "$PARAM_PATH"| sed s'/\$/\\\$/g')
		            VAL=`grep -w $PARAM_PATH_GRP $OUTPUTDIR/d_check_${db_name_to_check}.out|grep -v "^select"|cut -d= -f2`
		            VAL=`echo $VAL|sed 's/^ *\(.*\) *$/\1/'`
			    if [[ `grep -wic $PARAM_PATH_GRP $OUTPUTDIR/d_check_${db_name_to_check}.out|grep -v "^select"|cut -d= -f2` -gt 1 ]]; then SKIP_CHECK=1; fi
		          else
		            VAL=`grep -w $PARAM_PATH $OUTPUTDIR/d_check_${db_name_to_check}.out|grep -v "^select"|cut -d= -f2`
		            VAL=`echo $VAL|sed 's/^ *\(.*\) *$/\1/'`
			    if [[ `grep -wic $PARAM_PATH $OUTPUTDIR/d_check_${db_name_to_check}.out|grep -v "^select"|cut -d= -f2` -gt 1 ]]; then SKIP_CHECK=1; fi
		          fi
			  if [[ -n $SKIP_CHECK && $SKIP_CHECK -eq 0 ]]; then
		            call_get_log_result=0
		            #PMSG=$(echo $ORIG_PMSG for ${GREEN}${db_name_to_check}${NORM})
		            #FMSG=$(echo $ORIG_FMSG for ${ORANGE}${db_name_to_check}${NORM})
		            PMSG=$(echo $ORIG_PMSG for ${db_name_to_check})
		            FMSG=$(echo $ORIG_FMSG for ${db_name_to_check})
		            #if [ $mb_db_counter -gt 0 ];then write_report_on_fail=0;fi
		            get_log_result "inloop" "-"
		            mb_db_counter_log=$(expr $mb_db_counter_log + 1)
                            #$READ -p "stop for pass/fail $db_name_to_check"
			  fi
                        else
                          call_get_log_result=0    
                          echo "skipping $COM at $ROW for $db_name_to_check because database role does not(${mb_database_role[$mb_db_counter]}) match to check role ($check_database_role) or database type(${mb_database_type[$mb_db_counter]}) does not match to ${check_database_type}">>$LOGFIL
                        fi
                        mb_db_counter=$(expr $mb_db_counter + 1)
                      done

 		      if [[ $OFFLINE -eq 0 && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 ]]
	              then
		        rm -f "$t_PSQL_METAFIL" >/dev/null 2>&1
		        rm -f "$t_PSQL_INFIL" >/dev/null 2>&1
		        rm -f "$t_PSQL_STAT" >/dev/null 2>&1
	              fi
                      write_report_on_fail=1
                    else
                      call_get_log_result=0
                      echo -e "\n\nskipping $COM at $ROW ($audit_check_name) because either no database was running or user selected None from database select list\n\n">>$LOGFIL
	            fi
                  fi
           	  #$READ -p "COM=$COM param path=$PARAM_PATH at $ROW recommended value=$COMP operator=$OP alert level=$ALVL actual value=$VAL" 
           	  ;;
                SQL_COLLECT)
                  #echo "${stack_asm_up[$stack_counter]}  ${stack_dbinst_up[$stack_counter]} ${stack_db_status[$stack_counter]}"
                  mb_db_counter=0
                  if [ $OFFLINE -eq "0" ] &&  [ ${stack_asm_up[$stack_counter]} -eq 1 -o ${stack_db_status[$mb_db_counter]} -ne 0 -o ${stack_dbinst_up[$stack_counter]} -ne 0 ] 
                  then
                    call_get_log_result=1
                    if [ $op_mode -eq 0 ]
                    then
                      COM=`grep "_"$ROW"-SQL_COLLECT_COMMAND" $REFFIL |sed  -n 's/.*SQL_COLLECT_COMMAND //p'`
                      COLLECTION_NAME=`grep "_"$ROW"-COLLECTION_NAME" $REFFIL |sed  -n 's/.*COLLECTION_NAME //p'`
                    else
                      com_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_START"
                      com_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_END"
                      COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                      com_report_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_START"
                      com_report_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_END"
                      COM_REPORT=$(sed -n /$com_report_begin_pattern/,/$com_report_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                      COLLECTION_NAME=`grep "_"$CHECK_ID"-COLLECTION_NAME" $REFFIL |sed  -n 's/.*COLLECTION_NAME //p'`
                      #COM=`grep "_"$CHECK_ID"-SQL_COLLECT_COMMAND" $REFFIL |sed  -n 's/.*SQL_COLLECT_COMMAND //p'`
                    fi
                    #OUTFILNAME is the name we set up in the app as the file name we want
                    #the data redirected to when doing OS and SQL COLLECTs
                    #we'll search this file for OS and SQL param values
                    #so SQL and OS COLLECT creates OUTFIL in the OUTPUTDIR
                    #SQL and OS PARAM reads the values of the parameters from OUTFIL
                    #OUTFIL will also be archived at the end
                    #FIELDPOS is the position we define in the app to tell the script
                    #which field to look in for the value as the position might vary from
                    #command to command or OS to OS
                    if [ $op_mode -eq 0 ]
	            then
	              OUTFILNAM=`grep _$ROW\-OUTPUT_FILE $REFFIL |awk {'print $2'}`
	            else
	              OUTFILNAM=`grep _$CHECK_ID\-OUTPUT_FILE $REFFIL |awk {'print $2'}`
	            fi

                    #Meta File for DB parallelization
	            if [[ $OFFLINE -eq "0" ]] && [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 ]] && [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]]
	            then 
		      t_PSQL_STAT="${PSQL_STAT}_${CHECK_ID}"
                      t_PSQL_METAFIL="${PSQL_METAFIL}_${CHECK_ID}"
                      echo "CHECKID=$CHECK_ID"                             	    >  $t_PSQL_METAFIL 
                      echo "COMTYPE=$COMTYPE"                              	    >> $t_PSQL_METAFIL  
                      echo "COM_START=$COM"                                         >> $t_PSQL_METAFIL
                      echo "COM_END"                                                >> $t_PSQL_METAFIL
                      echo "COM_REPORT_START=$COM_REPORT"                           >> $t_PSQL_METAFIL
                      echo "COM_REPORT_END"                                         >> $t_PSQL_METAFIL
                      echo "AUDIT_CHECK_NAME=$audit_check_name"            	    >> $t_PSQL_METAFIL 
	              echo "COLLECTION_NAME=$COLLECTION_NAME"                       >> $t_PSQL_METAFIL
	              echo "STACK_ASM_SID=${stack_asm_sid[$stack_counter]}"         >> $t_PSQL_METAFIL
	              echo "STACK_ASM_HOME=${stack_asm_home[$stack_counter]}"       >> $t_PSQL_METAFIL
                      echo "RAT_RUNMODE_INTERNAL=$RAT_RUNMODE_INTERNAL"    	    >> $t_PSQL_METAFIL 
	              echo "OUTFILNAM=$OUTFILNAM"                                   >> $t_PSQL_METAFIL
	
	              #DB information for DB parallelization
	              t_PSQL_INFIL="${PSQL_INFIL}_${CHECK_ID}"
	              t_mb_db_counter=0
	              for db_name_to_check in "${mb_db_names[@]}"
	              do
	                match_database_role "${mb_database_role[$t_mb_db_counter]}"
	                match_database_type "${mb_database_type[$t_mb_db_counter]}"

	                echo "${db_name_to_check},${mb_oracle_sids[$t_mb_db_counter]},${mb_oracle_homes[$t_mb_db_counter]},${mb_database_role[$t_mb_db_counter]},$dbrole_match_count,${mb_database_type[$t_mb_db_counter]},$dbtype_match_count,${mb_sysdba_user[$t_mb_db_counter]},${mb_sysdba_pswd[$t_mb_db_counter]},${RAT_PDB_USER},${mb_db_sys_password[$t_mb_db_counter]},${mb_db_connect_string[$t_mb_db_counter]},${mb_checksysdba[$t_mb_db_counter]},${mb_running_host[$t_mb_db_counter]}" >> $t_PSQL_INFIL
	                t_mb_db_counter=$(expr $t_mb_db_counter + 1)
	              done
	              t_mb_db_counter=0
	            fi

                    if [ "$NEEDS_RUNNING" = "ASM" ]
                    then
                      OUTFIL=$OUTPUTDIR/"a_"$OUTFILNAM".out"
	              INFIL=$INPUTDIR/"d_"$OUTFILNAM"_"$DB".sql"
		      if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			NEW_OUTFIL=$TMP_OUTPUT/"a_"$OUTFILNAM".out"
	                NEW_INFIL=$TMP_OUTPUT/"d_"$OUTFILNAM"_"$DB".sql"
		      fi
                    else
                      mb_db_counter=0
                      mb_db_counter_log=0
	              psql_counter=0
	              for db_name_to_check in "${mb_db_names[@]}"
	              do
	                #DB parallelization
	                if [[ $OFFLINE -eq "0" ]] && [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 ]] && [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]] && [[ $component_match_count -ge 1 ]]
	                then
	                  if [[ $psql_counter -eq 0 ]]
	                  then
	                    parallel_sql
	                  fi
                          psql_counter=$(expr $psql_counter + 1)
	                fi

	                skip_this_version=0
                        set_skip_this_version "-"
                        if [ $skip_this_version -eq 1 ]
                        then
                          mb_db_counter=$(expr $mb_db_counter + 1)
                          echo "Skipping check($CHECK_ID) on version 5 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                          continue
                        fi

	                OUTFIL=$OUTPUTDIR/"d_"$OUTFILNAM"_"$db_name_to_check".out"
	                INFIL=$INPUTDIR/"d_"$OUTFILNAM"_"$db_name_to_check".sql"
		        if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
			  NEW_OUTFIL=$TMP_OUTPUT/"a_"$OUTFILNAM".out"
	                  NEW_INFIL=$TMP_OUTPUT/"d_"$OUTFILNAM"_"$db_name_to_check".sql"
		        fi
                        export ORACLE_SID=${mb_oracle_sids[$mb_db_counter]}
                        export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
                        match_database_role "${mb_database_role[$mb_db_counter]}"
                        match_database_type "${mb_database_type[$mb_db_counter]}"
                        if [[ $dbrole_match_count -ge 1 && $dbtype_match_count -ge 1 ]]
                        then
                          call_get_log_result=0
                          get_log_result "inloop" "-"
	                  mb_db_counter_log=$(expr $mb_db_counter_log + 1)
                        else
                          echo "skipping $COM at $ROW for $db_name_to_check because database role does not(${mb_database_role[$mb_db_counter]}) match to check role ($check_database_role) or database type(${mb_database_type[$mb_db_counter]}) does not match to ${check_database_type}">>$LOGFIL                                   
                        fi
                        mb_db_counter=$(expr $mb_db_counter + 1)
	                #note that since each sql command is run only once, unlike OS commands
	                #and there's no host name to account for, we'll go ahead and append the
	                #.out extension here rather than in log_result()
	                #if [ "$NEEDS_RUNNING" = "ASM" ]
	                #then
	                #    OUTFIL=$OUTPUTDIR/"a_"$OUTFILNAM"_"$DB".out"
	                #else
	                #fi
	                #OUTFIL=$OUTPUTDIR/"d_"$OUTFILNAM".out"

	                #in the case of SQL_COLLECT we need both an OUTFIL (spool file)
	                #and an INFIL (a script file) which will be executed by SQL*Plus
	                #it is named the same but with a .sql extension
	                #and will be stored in INPUTDIR instead of OUTPUTDIR
	              done
	              mb_db_counter=0
	              if [[ $OFFLINE -eq "0" ]] && [[ -n "$RAT_DB_PARALLEL" && $RAT_DB_PARALLEL -eq 1 ]] && [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]]
                      then
                        rm -f "$t_PSQL_METAFIL" >/dev/null 2>&1
                        rm -f "$t_PSQL_INFIL" >/dev/null 2>&1
		        rm -f "$t_PSQL_STAT" >/dev/null 2>&1
                      fi
	            fi
                  fi
                  ;;
                SQL_PARAM)
                  mb_db_counter=0
                  mb_db_counter_log=0
                  if  [[ $component_match_count  -lt 1 ]]
                  then
                    echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
                    call_get_log_result=0
                  elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$PARAM_PATH" $EXCLUDEFIL` -ge 1 ]]
                  then
                    call_get_log_result=0
                    echo "Skipping $PARAM_PATH (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                    generate_exceptions_xml "Skipping $PARAM_PATH because its in exclude file $EXCLUDEFIL"
                  else   
                    call_get_log_result=1
	            if [[ -n "${stack_dbinst_up[$stack_counter]}" && ${stack_dbinst_up[$stack_counter]} -ne 0 ]] || [ ${stack_asm_up[$stack_counter]} -eq 1 ]
	            then
	              COM=`echo "SQL PARAMETER $PARAM_PATH  $OP  $COMP"`
	              if [ $op_mode -eq 0 ]
	              then
	                SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	              else
	                SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	              fi
	              SOURCEFILENAME=$SOURCEFIL
                      if [[ "$SOURCEFILENAME" = "v_parameter_asm" && ${stack_asm_up[$stack_counter]} -eq 1 ]]
	              then
                        SOURCEFIL_REPORT=$OUTPUTDIR/"a_"$SOURCEFIL".out"
                        if [ $OFFLINE -eq 0 ]
                        then
                          SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"a_"$SOURCEFIL".out"
                        else
                          SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"a_"$SOURCEFIL".out"
                        fi
	                SOURCEFIL=$OUTPUTDIR/"a_"$SOURCEFIL".out"
                        if [ -e $SOURCEFIL ]
                        then
	                  if [ $op_mode -eq 0 ]
	                  then
	                    FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`
	                  else
	                    FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`
	                  fi       
	                  inst_name=${stack_asm_sid[$stack_counter]}
	                  case $FIELDPOS in
	                    1) VAL=`grep -wi "${stack_asm_sid[$stack_counter]}.${PARAM_PATH}" $SOURCEFIL |awk {'print $1'}`
	                      ;;
	                    2) VAL=`grep -wi "${stack_asm_sid[$stack_counter]}.${PARAM_PATH}" $SOURCEFIL |awk {'print $2'}`
	                      ;;
	                    3) 
                              # removed + from ASM instnace in hp-ux to avoid rep: ?, *, or + not preceded by valid regular expression
                              if [ `uname -s` = "HP-UX" ]
                              then 
                                inst_name_trimmed=$(echo $inst_name|sed 's/\+//g')
                                VAL=`grep -wi "${inst_name_trimmed}.${PARAM_PATH}" $SOURCEFIL |awk {'print $3'}`
                              else
                                VAL=`grep -wi "${stack_asm_sid[$stack_counter]}.${PARAM_PATH}" $SOURCEFIL |awk {'print $3'}`  
                              fi
	                      ;;
	                    4) VAL=`grep -wi "${stack_asm_sid[$stack_counter]}.${PARAM_PATH}" $SOURCEFIL |awk {'print $4'}`
	                      ;;
	                    5) VAL=`grep -wi "${stack_asm_sid[$stack_counter]}.${PARAM_PATH}" $SOURCEFIL |awk {'print $5'}`
	                      ;;
	                    99) VAL=`grep -wi "${stack_asm_sid[$stack_counter]}.${PARAM_PATH}" $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
	                      ;;
	                  esac          
                        fi
	                #if [ $ISBRANCH -eq 0 ]; then echo "$inst_name|$CHECK_ID|$VAL">>$AACTUAL; fi 
                      else  
                        ORIG_PMSG=$PMSG
                        ORIG_FMSG=$FMSG
	                for db_name_to_check in "${mb_db_names[@]}"
	                do
	                  skip_this_version=0
	                  set_skip_this_version "-"
                          if [ $skip_this_version -eq 1 ]
                          then
                            mb_db_counter=$(expr $mb_db_counter + 1)
                            echo "Skipping check($CHECK_ID) on version 6 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                            continue
                          fi
                          source_file_exists=0
	                  if [ $OFFLINE -eq 0 ]
                          then
                            inst_name=$(grep -w "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_NAME|awk '{print $3}')
                            inst_mode=$(grep -w "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_MODE|awk '{print $3}')
                          else
                            inst_name=$(grep -w "$i.$db_name_to_check" $DUMPDIR/$CHKFIL|grep INSTANCE_NAME|awk '{print $3}')
                            inst_mode=$(grep -w "$i.$db_name_to_check" $DUMPDIR/$CHKFIL|grep INSTANCE_MODE|awk '{print $3}')
                          fi
                          match_database_role "${mb_database_role[$mb_db_counter]}"
                          match_database_type "${mb_database_type[$mb_db_counter]}"  
                          if [[ $dbrole_match_count -ge 1 && $dbtype_match_count -ge 1 ]] 
	                  then
	                    DBACTUAL=$OUTPUTDIR/d_actual_${db_name_to_check}.out
	                    #if [[ "$SOURCEFILENAME" = "v_parameter" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
	                    if [[ "$SOURCEFILENAME" = "v_parameter" && $inst_mode -ne 0 ]]
	                    then
	              	      SOURCEFIL_REPORT=$OUTPUTDIR/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
	              	      if [ $OFFLINE -eq 0 ]
	              	      then
	              	        SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
	              	      else
	              	        SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
	              	      fi
	              	      SOURCEFIL=$OUTPUTDIR/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
                              instance_exists=0
                              if [ -e $SOURCEFIL ] ;then instance_exists=$(grep -wc $inst_name $SOURCEFIL);fi  
	              	      if [[ -e $SOURCEFIL && $instance_exists -gt 0 ]]
	              	      then
	              	        source_file_exists=1
	              	        if [ $op_mode -eq 0 ]
	              	        then
	              	          FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`
	              	        else
	              	          FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`
	              	        fi
	              	        case $FIELDPOS in
	              	          1) VAL=`grep -wi "${inst_name}.${PARAM_PATH}" $SOURCEFIL |awk {'print $1'}`
	              	          ;;
	              	          2) VAL=`grep -wi "${inst_name}.${PARAM_PATH}" $SOURCEFIL |awk {'print $2'}`
	              	          ;;
	              	          3) VAL=`grep -wi "${inst_name}.${PARAM_PATH}" $SOURCEFIL |awk {'print $3'}`
	              	          ;;
	              	          4) VAL=`grep -wi "${inst_name}.${PARAM_PATH}" $SOURCEFIL |awk {'print $4'}`
	              	          ;;
	              	          5) VAL=`grep -wi "${inst_name}.${PARAM_PATH}" $SOURCEFIL |awk {'print $5'}`
	              	          ;;
	              	          99) VAL=`grep -wi "${inst_name}.${PARAM_PATH}" $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
	              	          ;;
	              	        esac
	              	      fi
	                      #elif [[ "$SOURCEFILENAME" = "v_parameter_u" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
	                    elif [[ "$SOURCEFILENAME" = "v_parameter_u" && ${inst_mode} -ne 0 ]]
	                    then
	              	      SOURCEFIL_REPORT=$OUTPUTDIR/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
	              	      if [ $OFFLINE -eq 0 ]
	              	      then
	              	        SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
	              	      else
	              	        SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
	              	      fi
	              	      SOURCEFIL=$OUTPUTDIR/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
	              	      if [ -e $SOURCEFIL ]
	              	      then
	              	        source_file_exists=1
	              	        if [ $op_mode -eq 0 ]
	              	        then
	              	          FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`
	              	        else
	              	          FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`
	              	        fi
	              	        case $FIELDPOS in
	              	          1) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $1'}`
	              	          ;;
	              	          2) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $2'}`
	              	          ;;
	              	          3) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $3'}`
	              	          ;;
	              	          4) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $4'}`
	              	          ;;
	              	          5) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $5'}`
	              	          ;;
	              	          99) VAL=`grep -w $PARAM_PATH $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
	              	          ;;
	              	        esac
	              	      fi  
	                    fi
                            #if [[ $inst_mode -eq 0 || $source_file_exists -eq 0 || $instance_exists -eq 0 ]]; then call_get_log_result=0;fi
	                    #if [[ $inst_mode -ne 0 && $source_file_exists -eq 1 && $instance_exists -gt 0 ]]
                            if [[ $inst_mode -eq 0 || $source_file_exists -eq 0 ]]; then call_get_log_result=0;fi
	                    if [[ $inst_mode -ne 0 && $source_file_exists -eq 1 ]]
	                    then
	              	      #if [ $ISBRANCH -eq 0 ]; then echo "$inst_name|$CHECK_ID|$VAL">>$DBACTUAL; fi 
	              	      call_get_log_result=0
	              	      #PMSG=$(echo $ORIG_PMSG on ${GREEN}${inst_name}${NORM} instance) 
	              	      #FMSG=$(echo $ORIG_FMSG on ${ORANGE}${inst_name}${NORM} instance)
	              	      PMSG=$(echo $ORIG_PMSG on ${inst_name} instance) 
	              	      FMSG=$(echo $ORIG_FMSG on ${inst_name} instance)
	              	      #$READ -p "inst_name=$inst_name"
	              	      if [ $mb_db_counter -gt 0 ];then write_report_on_fail=0;fi
	              	      get_log_result "inloop" "-"
	                      mb_db_counter_log=$(expr $mb_db_counter_log + 1)
                            else
                              echo "skipping $PARAM_PATH at $ROW for $db_name_to_check because inst_mode=$inst_mode and source_file_exists=$source_file_exists \
                                    and instance_exists=$instance_exists">>$LOGFIL
                              if [[ $inst_mode -ne 0 && $source_file_exists -eq 1 && $instance_exists -eq 0 ]]
                              then
                                echo "skipping SQL Parameter $PARAM_PATH checking (checkid:-$CHECK_ID) because $inst_name not found in $SOURCEFIL" >>$SKIPFIL 
                                let G_SKIP_CHECKS=$G_SKIP_CHECKS+1
                                let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1; 
				validate_needs_running;
                              fi
	                    fi
                          else
                            call_get_log_result=0    
                            echo "skipping $PARAM_PATH at $ROW for $db_name_to_check because database role (${mb_database_role[$mb_db_counter]}) does not match to check role ($check_database_role) or database type(${mb_database_type[$mb_db_counter]}) does not match to ${check_database_type}">>$LOGFIL
                          fi
	                  mb_db_counter=$(expr $mb_db_counter + 1)
	                done
                        mb_db_counter=0
                        write_report_on_fail=1
                      fi
	            fi
                  fi
                  ;;
                OS_PARAM)
                  if  [[  $component_match_count  -lt 1 ]]
                  then
                    echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
                    call_get_log_result=0
                  elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$PARAM_PATH" $EXCLUDEFIL` -ge 1 ]]
                  then
                    call_get_log_result=0
                    echo "Skipping $PARAM_PATH (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                    generate_exceptions_xml "Skipping $PARAM_PATH because its in exclude file $EXCLUDEFIL"
                  else   
                    call_get_log_result=1
	            COM=`echo "OS PARAMETER $PARAM_PATH  $OP  $COMP"`
	            if [ $op_mode -eq 0 ]
	            then
	              SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	            else
	              SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	            fi
	            SOURCEFIL_REPORT=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
                    if [ $OFFLINE -eq 0 ]
                    then
	              SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"o_"$SOURCEFIL"_"$i".out"
                    else
	              SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
                    fi
	            SOURCEFIL=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
	            if [ $op_mode -eq 0 ]
	            then
	              FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`
	            else
	              FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`
	            fi 
                  fi
                  ;;
                CROSS_NODE_CHECK)
                #Following code is to store CROSS_NODE_CHECK check_ids. later based on this list, checks will be executed.
	          call_get_log_result=0
                  if [ "$i" = "$localnode" ]
                  then
	            #call_get_log_result=1
	            if [ -z "$noRootScriptNode" ];then noPasswordAvailable=0;fi
	            noPasswordAvailable=$(echo ${noRootScriptNode[*]}|grep -c $i)       
	            if [[ $PARAM = "CRS" &&  ${crs_installed[$stack_counter]} -eq 0 ]] ||  [[ $PARAM = "RDBMS" &&  ${rdbms_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "ASM" &&  ${asm_installed[$stack_counter]} -eq 0 ]] 
	            then
	              call_get_log_result=0
	            elif [[ $NEEDS_RUNNING = "CRS" &&  ${stack_crs_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "RDBMS" &&  ${stack_dbinst_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "ASM" &&  ${stack_asm_up[$stack_counter]} -eq 0 ]] || [[ $NEEDS_RUNNING = "ACFS" &&  ${stack_acfs_up[$stack_counter]} -eq 0  ]]
	            then
	              call_get_log_result=0
	            elif  [[ $component_match_count  -lt 1 ]]
	            then
	              echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
	              call_get_log_result=0
                    elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$audit_check_name" $EXCLUDEFIL` -ge 1 ]]
	            then
	              call_get_log_result=0
	              echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                      generate_exceptions_xml "Skipping $audit_check_name because its in exclude file $EXCLUDEFIL"
	            else    
	              call_get_log_result=0
                      process_cross_node_checks=1
                      cross_node_checkids[$cross_node_checkids_counter]=$CHECK_ID
	              cross_node_checkids_counter=$(expr $cross_node_checkids_counter + 1 ) 
                      echo $CHECK_ID >> $OUTPUTDIR/cross_node_checkids.out
	            fi
                  fi   
                  #$READ -p "stop for cross node check"  
                  ;;  
                CLUSTERWIDE_CHECK|SYSTEMWIDE_CHECK)
                  call_get_log_result=1
                  #$READ -p "PARAM=$PARAM asm_installed=${asm_installed[$stack_counter]} needs_running=$NEEDS_RUNNING asm_up= ${stack_asm_up[$stack_counter]} "
                  #$READ -p "PARAM=$PARAM asm_installed=${asm_installed[$stack_counter]} needs_running=$NEEDS_RUNNING asm_up= ${stack_asm_up[$stack_counter]} "
                  if [ -z "$noRootScriptNode" ];then noPasswordAvailable=0;fi
                  noPasswordAvailable=$(echo ${noRootScriptNode[*]}|grep -c $i)       
                  if [[ $PARAM = "CRS" &&  ${crs_installed[$stack_counter]} -eq 0 ]] ||  [[ $PARAM = "RDBMS" &&  ${rdbms_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "ASM" &&  ${asm_installed[$stack_counter]} -eq 0 ]] 
	          then
	            call_get_log_result=0
	          #elif [[ $NEEDS_RUNNING = "CRS" &&  ${stack_crs_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "RDBMS" &&  ${stack_dbinst_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "ASM" &&  ${stack_asm_up[$stack_counter]} -eq 0 ]] || [[ $NEEDS_RUNNING = "ACFS" &&  ${stack_acfs_up[$stack_counter]} -eq 0  ]]
	          elif [[ $NEEDS_RUNNING = "CRS" &&  ${stack_crs_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "RDBMS" &&  ${stack_dbinst_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "ASM" &&  ${stack_asm_up[$stack_counter]} -eq 0 ]] || [[ $NEEDS_RUNNING = "ACFS" &&  ${stack_acfs_up[$stack_counter]} -eq 0  ]]
	          then
	            call_get_log_result=0
	          elif  [[ $component_match_count  -lt 1 ]]
                  then
                    echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
                    call_get_log_result=0
                  elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$audit_check_name" $EXCLUDEFIL` -ge 1 ]]
                  then
                    call_get_log_result=0
                    echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                    generate_exceptions_xml "Skipping $audit_check_name because its in exclude file $EXCLUDEFIL" 

                    #elif [[ -n "$noPasswordAvailable" && $noPasswordAvailable -ge 1 ]]
                    #then
                    #    call_get_log_result=0
	          else    
	            call_get_log_result=1 
                    if [ $op_mode -eq 0 ]
                    then
                      if [ "$COMTYPE" = "CLUSTERWIDE_CHECK" ]
                      then
	                COM=`grep "_"$ROW"-CLUSTERWIDE_CHECK_COMMAND" $REFFIL |sed  -n 's/.*CLUSTERWIDE_CHECK_COMMAND //p'`
                      else
	                COM=`grep "_"$ROW"-SYSTEMWIDE_CHECK_COMMAND" $REFFIL |sed  -n 's/.*SYSTEMWIDE_CHECK_COMMAND //p'`
                      fi
	              audit_check_name=`grep "_"$ROW"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                      REQUIEE_ROOT=`grep "_"$ROW"-REQUIRES_ROOT" $REFFIL |sed  -n 's/.*REQUIRES_ROOT //p'`
                    else
                      if [ "$COMTYPE" = "CLUSTERWIDE_CHECK" ]
                      then
	                #COM=`grep "_"$CHECK_ID"-CLUSTERWIDE_CHECK_COMMAND" $REFFIL |sed  -n 's/.*CLUSTERWIDE_CHECK_COMMAND //p'`
                        com_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_START"
                        com_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_END"
                        COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d') 
                        com_report_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_START"
                        com_report_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_END"
                        COM_REPORT=$(sed -n /$com_report_begin_pattern/,/$com_report_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                      else
	                #COM=`grep "_"$CHECK_ID"-SYSTEMWIDE_CHECK_COMMAND" $REFFIL |sed  -n 's/.*SYSTEMWIDE_CHECK_COMMAND //p'`
                        com_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_START"
                        com_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_END"
                        COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                        com_report_begin_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_START"
                        com_report_end_pattern="_${CHECK_ID}-${COMTYPE}_COMMAND_REPORT_END"
                        COM_REPORT=$(sed -n /$com_report_begin_pattern/,/$com_report_end_pattern/p $REFFIL|sed '1d'|sed '$d')
                      fi
	              audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                      REQUIEE_ROOT=`grep "_"$CHECK_ID"-REQUIRES_ROOT" $REFFIL |sed  -n 's/.*REQUIRES_ROOT //p'`
                    fi
	            audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'`
                    #$READ -p "rootYesNoint=$rootYesNoint"
                    if [[ $REQUIEE_ROOT -eq 1 && $rootYesNoint -eq 3 ]]
                    then
                      echo "">/dev/null 
	              call_get_log_result=0
                    else
                      #echo "audit_check_name=$audit_check_name executed"
	              if [ $OFFLINE -eq "0" ]
	              then
	                get_current_epoch 
 	                echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution Start Time: $epoch_time" >> $CHK_TIMINGS

	                if [ $i = $localnode ]
	                then
	                  #localcmd=$TMPDIR/localcmd.sh
	                  copy_env_files_to_tmp
	                  nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}.sh/g");

                          CLUSTERCHECK_FIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
	                  echo "#!$bash_scr" >$localcmd
	                  echo "$RAT_DEBUG_FLG" >>$localcmd
	                  echo "$bash_source" >>$localcmd
	                  echo ". $TRGTORCLENV">>$localcmd
	                  echo "$COM 2>>$ERRFIL">>$localcmd

                          if [ $REQUIEE_ROOT -eq 0 ]
                          then
                            echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$CLUSTERCHECK_FIL_REPORT
                          fi
                          if [ -n "$COM_REPORT" ] 
                          then 
                            echo "$COM_REPORT >> $CLUSTERCHECK_FIL_REPORT 2>>$ERRFIL">>$localcmd
                          else
                            echo "$COM >> $CLUSTERCHECK_FIL_REPORT 2>>$ERRFIL">>$localcmd
                          fi

                          echo "echo -e \"\n\n\" >> $CLUSTERCHECK_FIL_REPORT 2>>$ERRFIL">>$localcmd 
			  echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	                  echo "exit 0">>$localcmd
	                  chmod 744 $localcmd
                          if [ $RAT_DEBUG -eq 1 ]
                          then
                            FILVAL=`$localcmd`
                            returncode=`echo $?`
                          else
                            FILVAL=`$localcmd 2>>$ERRFIL`
                            returncode=`echo $?`
                          fi
			  set_alvl
	                  #if [ -e $localcmd ]; then rm $localcmd; fi;
	                  #if [ -e $localcmd ]; then mv $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
			  if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm $localcmd; fi
	                else
                          #localcmd=$TMPDIR/localcmd.sh
	                  copy_env_files_to_tmp
	                  nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}.sh/g");

                          CLUSTERCHECK_FIL_REPORT=${RTEMPDIR}/${CHECK_ID}_${i}_report.out
	                  echo "#!$bash_scr" >$localcmd
	                  echo "$RAT_DEBUG_FLG" >>$localcmd
	                  echo "$bash_source" >>$localcmd
	                  echo ". $TRGTORCLENV">>$localcmd
	                  echo "$COM">>$localcmd
                          if [ $REQUIEE_ROOT -eq 0 ]
                          then    
                            echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$CLUSTERCHECK_FIL_REPORT
                          fi
                          if [ -n "$COM_REPORT" ]
                          then 
                            echo "$COM_REPORT >> $CLUSTERCHECK_FIL_REPORT">>$localcmd
                          else
                            echo "$COM >> $CLUSTERCHECK_FIL_REPORT">>$localcmd      
                          fi
                          echo "echo -e \"\n\n\" >> $CLUSTERCHECK_FIL_REPORT">>$localcmd 
			  echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
	                  echo "exit 0">>$localcmd
	                  chmod 744 $localcmd	

	                  #if [ -e $localcmd ]; then cp $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi	
	             	  if [ -e "$localcmd" ]; then cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; fi
 
                          get_cygpath "localcmd"
                          get_cygpath "RTEMPDIR"
                          get_cygpath "CLUSTERCHECK_FIL_REPORT"
                          $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
	                  $SCOPY $CLUSTERCHECK_FIL_REPORT $i:$RTEMPDIR >/dev/null 2>&1
	                  $SSHELL $i "chmod 744 $RTEMPDIR/localcmd.sh"
                          restore_cygpath "localcmd"
                          restore_cygpath "RTEMPDIR"
                          restore_cygpath "CLUSTERCHECK_FIL_REPORT"
	                  if [ $RAT_DEBUG -eq 1 ]
	                  then
	              	    FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh"`
	              	    returncode=`echo $?`
	                  else
	                    FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
	              	    returncode=`echo $?`
	                  fi
			  set_alvl
                          get_cygpath "CLUSTERCHECK_FIL_REPORT"
                          get_cygpath "OUTPUTDIR"
	                  $SCOPY $i:$CLUSTERCHECK_FIL_REPORT $OUTPUTDIR >/dev/null 2>&1
	                  $SSHELL $i "rm -f $RTEMPDIR/localcmd.sh $CLUSTERCHECK_FIL_REPORT $TRGTORCLENV>/dev/null 2>&1"
                          restore_cygpath "CLUSTERCHECK_FIL_REPORT"
                          restore_cygpath "OUTPUTDIR"
	                fi

	                get_current_epoch 
 	                echo -e "[CHECK:$CHECK_ID][HOST: $i][TAG1: ] Execution End Time: $epoch_time" >> $CHK_TIMINGS

	                move_failed_to_skipped "$returncode" "" "$i:$db_name_to_check"
	                echo "" >>$OSSPOOLFIL
	                #echo " $PARAM_PATH $ROW  $COM == $FILVAL" >>$OSSPOOLFIL
	                printf "%s %s %s %s %s\n" " $PARAM_PATH $ROW == $FILVAL" >>$OSSPOOLFIL
	              fi 
	              VAL=`grep "$PARAM_PATH $ROW " $OSSPOOLFIL|sed  -n 's/.*== //p'`
                      if [ -n "$VAL" ]
                      then  
                        echo $CHECK_ID >> $OUTPUTDIR/crs_checkids.out
	                if [  ! -f $CLUSTERCHECK_FIL ]
	                then
	                  crs_check_id[$clusterware_check_count]=$CHECK_ID
	                  clusterware_check_count=`expr $clusterware_check_count + 1`
	                  if [ $OFFLINE -eq "0" ]; then echo "$i $ROW $COM == $FILVAL" >$CLUSTERCHECK_FIL; fi;
	                else
	                  crs_check_id[$clusterware_check_count]=$CHECK_ID
	                  clusterware_check_count=`expr $clusterware_check_count + 1`
	                  if [ $OFFLINE -eq "0" ]; then echo "$i $ROW $COM == $FILVAL" >>$CLUSTERCHECK_FIL; fi;
	                fi
                      fi 
                      if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -e $CELLIP  && $cell_password_status -ne 3 && "$COMTYPE" = "SYSTEMWIDE_CHECK" && -n "$skip_in_silent" && $skip_in_silent -eq 0 ]]
                      then
                        #cellFilePlaceHolder=$(echo $COM|sed  -n 's/.*cat //p'|awk -F. '{print $1}'|awk -F / '{print $NF}'|sed s'/o_//g')
                        cellFilePlaceHolder=$( echo "$COM"|sed  -n 's/.*cat //p'|$AWK 'BEGIN { FS = "/" } {printf $2}'|$AWK '{print $1}'|$AWK '{sub(/o_/,"");print}'|$AWK '{sub(/.out/,"");print}')
                        #echo "cellFilePlaceHolder=$cellFilePlaceHolder"
                        for cellname in `cat $CELLIP|cut -d= -f2|cut -d\; -f2|sed 's/"//g'`
                        do
                          #if [ -e $CELLDIR/cells.out ]; then cellname_full=$(cat $CELLDIR/cells.out|grep -w "$cellname"|awk '{print $NF}'); fi 
                          if [ -e $CELLDIR/cells.out ]; then cellname_full=$(grep -w "$cellname" $CELLDIR/cells.out|grep -v "^ *#"|awk '{print $NF}'|head -1); fi 
                          cellname=$(echo $cellname|sed 's/\./_/g')  
                          CLUSTERCHECK_FIL_REPORT=$OUTPUTDIR/${CHECK_ID}_report.out
                          if [ -e $CELLDIR/c_cwc_${cellFilePlaceHolder}_${cellname}.out ]; then FILVAL=$(cat $CELLDIR/c_cwc_${cellFilePlaceHolder}_${cellname}.out);fi
	                  if [ $OFFLINE -eq "0" ]; then echo "$cellname $ROW $COM == $FILVAL" >>$CLUSTERCHECK_FIL; fi;
                          if [ -e $CELLDIR/c_cwc_${cellFilePlaceHolder}_${cellname}_report.out ]
                          then 
                            echo -e "TO REVIEW COLLECTED DATA FROM $(echo $cellname_full|tr "[a-z]" "[A-Z]") - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$CLUSTERCHECK_FIL_REPORT
                            cat $CELLDIR/c_cwc_${cellFilePlaceHolder}_${cellname}_report.out >>$CLUSTERCHECK_FIL_REPORT
                            echo -e "\n\n" >> $CLUSTERCHECK_FIL_REPORT
                          fi
                        done
                      fi
                      
                      #making to CLUSTERWIDE_CHECK so log_fail and log_pass can work as before
                      if [ "$COMTYPE" = "SYSTEMWIDE_CHECK" ]; then COMTYPE=CLUSTERWIDE_CHECK;fi
	              #$READ -p "CLUSTERCHECK_FIL=$CLUSTERCHECK_FIL"
    	              #if [[ $ISBRANCH -eq 0  && $OFFLINE -eq 0 ]]; then echo "${CHECK_ID}|${VAL}" >>$OSACTUAL ;fi 
	              #fi
	            fi
                  fi
                  ;;
                OS_PATCH)
                  if  [[ $component_match_count  -lt 1 ]]
                  then
                    echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL  
                    call_get_log_result=0
                  elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$PARAM_PATH" $EXCLUDEFIL` -ge 1 ]] 
                  then
                    call_get_log_result=0
                    echo "Skipping $PARAM_PATH (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                    generate_exceptions_xml "Skipping $PARAM_PATH because its in exclude file $EXCLUDEFIL"
                  else
                    call_get_log_result=1
	            if [ $OFFLINE -eq 0 ]
	            then
	              if [ $op_mode -eq 0 ]
	              then
	                SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	              else
	                SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	              fi 
	              call_get_log_result=1 
                      SOURCEFIL_REPORT=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
                      if [ $OFFLINE -eq 0 ]
                      then
                        SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"o_"$SOURCEFIL"_"$i".out"
                      else
                        SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
                      fi
	              SOURCEFIL=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
	              case `uname -s` in 
	                SunOS)
	                  os_patch_count=0
	                  os_patch_base=0
	                  os_patch_rls=0
	                  os_patch_rls_actual=0 
	                  os_patch_base=$(echo $PARAM_PATH|cut -d- -f1)
	                  os_patch_rls=$(echo $PARAM_PATH|cut -d- -f2)
	                  #os_patch_count=$(grep -c $os_patch_base $SOURCEFIL)
	                  os_patch_count=$(cat $SOURCEFIL|cut -d: -f2|awk '{print $1}'|grep -c $os_patch_base)
	                  #$READ -p "os_patch_count=$os_patch_count"
	                  if [ $os_patch_count -ge 1 ]
	                  then 
	                    if [ $i = $localnode ]
	                    then
	                      os_patch_rls_actual=$(showrev -p |cut -d: -f2|awk '{print $1}'|grep ${os_patch_base}|cut -d- -f2)
	                    else
	                      os_patch_rls_actual=$($SSHELL $i showrev -p |cut -d: -f2|awk '{print $1}'|grep ${os_patch_base}|cut -d- -f2)
	                    fi
	                    #$READ -p "os_patch_rls_actual=$os_patch_rls_actual"
	                    if [ $os_patch_rls_actual -ge $os_patch_rls ]
	                    then
	                      os_patch_status=1
	                    else
	                      os_patch_status=2
	                    fi
	                  else
	                    os_patch_status=0
	                  fi 
	                  echo "${ROW}_${PARAM_PATH}_os_patch_status == $os_patch_status">>$OSSPOOLFIL
	                  ;;
	                AIX|HP-UX)
	                  os_patch_count=0
	                  os_patch_count=$(grep $PARAM_PATH $SOURCEFIL|wc -l)
	                  if [ $os_patch_count -gt 0 ]
	                  then
	                     os_patch_status=1
	                  else
	                     os_patch_status=0
	                  fi     
	                  echo "${ROW}_${PARAM_PATH}_os_patch_status == $os_patch_status">>$OSSPOOLFIL
	                  ;;
	                *)
	                  ;;
	              esac #patch OS case ends here
	              echo "OS PATCH status variable are os_patch_count=$os_patch_count,os_patch_base=$os_patch_base,os_patch_rls=$os_patch_rls and os_patch_rls_actual=$os_patch_rls_actual" os_patch_status=$os_patch_status >>$LOGFIL
	            else # this else is for offline patch 
                      call_get_log_result=1
	              os_patch_status=$(grep "${ROW}_${PARAM_PATH}_os_patch_status" $OSSPOOLFIL|sed  -n 's/.*== //p')
	            fi
	            #if [[ $ISBRANCH -eq 0  && $OFFLINE -eq 0 ]]; then echo "${CHECK_ID}|${os_patch_status}@$os_patch_rls_actual" >>$OSACTUAL; fi
                  fi
                  ;;
                ORACLE_PATCH)
                  if [[ $HOME_PATH = "CRS" &&  ${crs_installed[$stack_counter]} -eq 0 ]] ||  [[ $HOME_PATH = "RDBMS" &&  ${rdbms_installed[$stack_counter]} -eq 0 ]] || [[ $HOME_PATH = "ASM" &&  ${asm_installed[$stack_counter]} -eq 0 ]] 
	          then
	            call_get_log_result=0
	          elif [[ $NEEDS_RUNNING = "CRS" &&  ${stack_crs_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "RDBMS" &&  ${stack_dbinst_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "ASM" &&  ${stack_asm_up[$stack_counter]} -eq 0 ]] || [[ $NEEDS_RUNNING = "ACFS" &&  ${stack_acfs_up[$stack_counter]} -eq 0  ]]
	          then
	            call_get_log_result=0
                  elif [[ $NEEDS_RUNNING = "ACFS" && $db_machine_compute -eq 1 ]] 
                  then
                    call_get_log_result=0
                  elif  [[  $component_match_count  -lt 1 ]]
                  then
                    echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
                    call_get_log_result=0
                  elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$PARAM_PATH" $EXCLUDEFIL` -ge 1 ]]
                  then
                    call_get_log_result=0
                    echo "Skipping $PARAM_PATH (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                    generate_exceptions_xml "Skipping $PARAM_PATH because its in exclude file $EXCLUDEFIL"
	          else    
	            call_get_log_result=1 
                    ORIG_PMSG=$PMSG
                    ORIG_FMSG=$FMSG  
                    if [[ $HOME_PATH = "CRS" || $HOME_PATH = "ASM" ]]
                    then
                      if [ $op_mode -eq 0 ]
	              then
	                SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	              else
	                SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	              fi
                      if [ $OFFLINE -eq 0 ]
	              then
	                SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/o_${SOURCEFIL}_${i}_report.out
	              else
	                SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/o_${SOURCEFIL}_${i}_report.out
	              fi
                      SOURCEFIL_REPORT=$OUTPUTDIR/o_${SOURCEFIL}_${i}_report.out
	              SOURCEFIL=$OUTPUTDIR/o_${SOURCEFIL}_${i}.out
                      if [[ -e $SOURCEFIL && `ls -l $SOURCEFIL|awk '{print $5}'` -gt 1 ]]
                      then
                        PARAM_PATH=$(echo $PARAM_PATH|sed 's/,/ /g')
                        VAL=0
                        for each_oracle_patch in $PARAM_PATH
                        do
                          oracle_patch_count=$(grep -icw $each_oracle_patch $SOURCEFIL)
                          if [ $oracle_patch_count -ge 1 ]; then VAL=$oracle_patch_count;break;fi
                        done 
                        if [ $HOME_PATH = "CRS" ] ;then message4Home=$CRS;elif [ $HOME_PATH = "ASM" ]; then  message4Home=$ASM_HOME;fi
                        PMSG=$(echo $ORIG_PMSG $message4Home)
                        FMSG=$(echo $ORIG_FMSG $message4Home) 
                        if [[ -n $call_get_log_result && $call_get_log_result -eq 1 && -n "$LEVEL" && -f $SOURCEFIL ]]
                        then
                          get_log_result
                          call_get_log_result=0
                        fi 
                      else 
	                echo "skipping Oracle Patch $PARAM_NAME checking (checkid:-$CHECK_ID) because `basename $SOURCEFIL` not found" >>$SKIPFIL
	                generate_exceptions_xml "skipping Oracle Patch $PARAM_NAME checking because `basename $SOURCEFIL` not found"
                        call_get_log_result=0
                        let G_SKIP_CHECKS=$G_SKIP_CHECKS+1
                        let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1; 
			validate_needs_running;
                      fi
                    elif [ $HOME_PATH = "RDBMS" ]
                    then
                      mb_db_counter_log=0
                      for mb_db_homes in ${mb_oracle_homes_distinct[@]}
                      do
                        skip_this_version=0
                        set_skip_this_version "$mb_db_homes"
                        if [ $skip_this_version -eq 1 ]
                        then #dont run
                          mb_db_counter=$(expr $mb_db_counter + 1)
                          echo "Skipping check($CHECK_ID) on version 7 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                          continue
                        fi
                        mb_db_homes_without_slash=$(echo $mb_db_homes|sed 's/\///g')
                        mb_db_homes_without_slash=$(echo $mb_db_homes_without_slash|sed 's/\.//g') 
	                if [ $op_mode -eq 0 ]
	                then
	                  SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	                else
	                  SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	                fi	     
                        if [ $OFFLINE -eq 0 ]
	                then
	                  SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/o_${SOURCEFIL}_${mb_db_homes_without_slash}_${i}_report.out
	                else
	                  SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/o_${SOURCEFIL}_${mb_db_homes_without_slash}_${i}_report.out
	                fi
	                SOURCEFIL_REPORT=$OUTPUTDIR/o_${SOURCEFIL}_${mb_db_homes_without_slash}_${i}_report.out
                        SOURCEFIL=$OUTPUTDIR/o_${SOURCEFIL}_${mb_db_homes_without_slash}_${i}.out
	                if [[ -e $SOURCEFIL && `ls -l $SOURCEFIL|awk '{print $5}'` -gt 1 ]]
	                then
                          PARAM_PATH=$(echo $PARAM_PATH|sed 's/,/ /g')
	                  VAL=0
	                  for each_oracle_patch in $PARAM_PATH
	                  do
	                    oracle_patch_count=$(grep -icw $each_oracle_patch $SOURCEFIL)
	                    if [ $oracle_patch_count -ge 1 ]; then VAL=$oracle_patch_count;break;fi
	                  done
	                  PMSG=$(echo $ORIG_PMSG $mb_db_homes)
	                  FMSG=$(echo $ORIG_FMSG $mb_db_homes) 
                          if [[ -n $call_get_log_result && $call_get_log_result -eq 1 && -n "$LEVEL" && -f $SOURCEFIL ]]
	                  then
	                    get_log_result "inloop" "$mb_db_homes"
	                    mb_db_counter_log=$(expr $mb_db_counter_log + 1)
	                  fi
	                else 
	                  echo "skipping Oracle Patch $PARAM_NAME checking (checkid:-$CHECK_ID) because `basename $SOURCEFIL` not found" >>$SKIPFIL
	                  generate_exceptions_xml "skipping Oracle Patch $PARAM_NAME checking because `basename $SOURCEFIL` not found"
	                  call_get_log_result=0
                          let G_SKIP_CHECKS=$G_SKIP_CHECKS+1
                          let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1; 
			  validate_needs_running;
	                fi   
                      done  
                      call_get_log_result=0
                    fi 
                  fi
                  ;;   
                OS_PACKAGE)
                  #be available via an OS_COLLECT, so we'll check each node's output
                  #OS PAckages are kind of a special case, so doing some trickery here
                  #we first want to check to see if the package is installed
                  #then if it is we want to check to see if the package version is
                  #a known bad version
                  #
                  #we manipulate FMSG,PMSG,OP and COMP to get the desired effect
                  #when get_log_result() is called, those don't come from the data file
                  #as they do for other checks, or if they do we're over-riding them
                  #elif  [[ $components != "NONE" &&  $components != $check_components ]]
                  #elif  [[ $components != "NONE" &&  $component_match_count  -lt 1 ]]
                  if  [[ $component_match_count  -lt 1 ]]
                  then
                    echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
                    call_get_log_result=0
                  elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$PARAM_PATH" $EXCLUDEFIL` -ge 1 ]]
                  then
                    call_get_log_result=0
                    echo "Skipping $PARAM_PATH (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG    
                    generate_exceptions_xml "Skipping $PARAM_PATH because its in exclude file $EXCLUDEFIL" 
                  else
                    call_get_log_result=1
	            if [ $OFFLINE -eq "0" ]
	            then
	              #if running in SILENT mode then we don't want to do any of this
	              #we'll have all we need from the output of the OS command which 
	              #outputs the packages, eg., rpm -qa in linux
	              # HERE we are in NON SILENT mode
	              if [ $op_mode -eq 0 ]
	              then
	                SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	              else
	                SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	              fi
	              #each node could potentially have a different listing of packages
	              #so use the node specific listing to check
	              #RPM STATUS
	              # 0=exact version is installed
	              # 1=higher version of same package is installed
	              # 2=package is installed but version is lower than recommended
	              # 3=package not instaleld
	              #sed 's/|/-/g'
	              SOURCEFIL_REPORT=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
                      if [ $OFFLINE -eq 0 ]
                      then
	                SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"o_"$SOURCEFIL"_"$i".out"
                      else
	                SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
                      fi
	              SOURCEFIL=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
	              call_get_log_result=1 
	              rpm_arch=99
	              case `uname -s` in 
	                Linux)
	                  rpm_match=$(grep -c $PARAM_PATH $SOURCEFIL)
	                  unset rpm_arr1
	                  unset rpm_arr2
	                  unset rpm_name
	                  unset rpm_status
	                  func_rpm_status=0
	                  ir_counter=0
	                  how_many_name_r=1
	                  how_many_no_r=0
	                  if [ $rpm_match -eq 1 ]
	                  then
	                    rpm_status=0
	                  else
                            #if [ -z "$IFS ]
                            #then
                            old_ifs=$IFS
                            #fi
	                    IFS=$'|'
	                    #$READ -p "package name =$PARAM_PATH"
	                    for ir in $PARAM_PATH
	                    do
	               	      rpm_arr1[$ir_counter]=$ir
	               	      if [ -z "$rpm_name" ]
	               	      then
	               	        rpm_name=${rpm_arr1[0]}
	               	      fi
	               	      ir_counter=$(expr $ir_counter + 1)
	                    done
	                    ir_counter=$(expr $ir_counter - 1)
	                    if [ "$i" = "$localnode" ]
	                    then
	               	      actual=$(rpm -q "$rpm_name" --queryformat "%{name}|%{version}|%{release}|%{arch}\n")
	               	      rpm_q_rstatus=$?
	                    else
	               	      #set -xv
	               	      IFS=$old_ifs
	               	      sshrpm="rpm -q $rpm_name --queryformat \"%{name}|%{version}|%{release}|%{arch}\n\""
                              #OLD_SSHELL=$SSHELL
                              #SSHELL="/usr/bin/ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"
	               	      rpm_actual=$($SSHELL $i $sshrpm)
	               	      rpm_q_rstatus=$?
	               	      actual=$(echo $rpm_actual|sed 's/ /|/g')
                              #SSHELL=$OLD_SSHELL 
	               	      #$READ -p "ssh $i $sshrpm and actual is $actual"
	               	      IFS=$'|'
	               	      #set +xv
	                    fi
	                    #$READ -p "RPM name is $rpm_name and actual found on system is $actual rpm_q_rstatus=$rpm_q_rstatus"
	                    if [ $rpm_q_rstatus -ne 0 ]
	                    then
	               	      rpm_status=3
	               	      #echo "rpm $PARAM_PATH is not installed on sysetm"
	                    else
	               	      no_of_rpms=$(echo $actual|wc -l)
	               	      #$READ -p "before 2$actual"
	               	      if [ $no_of_rpms -gt 1 ]
	               	      then
	               	        actual1=$actual
	               	        actual=$(echo $actual|grep ${rpm_arr1[$ir_counter]}|sed 's/ /|/g')
	               	        if [ -z "$actual" ] 
	               	        then
	               	          actual=$(echo $actual1|grep -v "x86_64"|sed 's/ /|/g') 
	               	          #$READ -p " after 2 $actual"
	               	        fi
	               	      fi
                              if [ `echo "$actual"|wc -l` -gt 1 ]; then actual=$(echo "$actual"|head -1);fi
	               	      ar_counter=0
	               	      how_many_name_a=0
	               	      how_many_no_a=0
	               	      element_count=0
	               	      no_of_loops=0 
	               	      for arpm in $actual
	               	      do
	               	        rpm_arr2[$ar_counter]=$arpm
	               	        if [ -z "$rpm_name" ]
	               	        then
	               	          rpm_name=${rpm_arr2[0]}
	               	        fi
	               	        ar_counter=$(expr $ar_counter + 1)
	               	      done
	               	      for array_item in ${rpm_arr1[*]}
	               	      do
	               	        if [ $element_count -eq 1 -o $element_count -eq 2 ] && [ -n "$array_item" ]
	               	        then
	               	          no_of_loops=$(expr $no_of_loops + 1)
	               	        fi
	               	        if [ $element_count -eq 3 ] && [ "${rpm_arr1[3]}" != "${rpm_arr2[3]}" ]
	               	        then
	               	          case "${rpm_arr1[3]}" in
	               	            i386)
	               	              if [[ "${rpm_arr2[3]}" = "i486" ||  "${rpm_arr2[3]}" = "i586" ||  "${rpm_arr2[3]}" = "i686" ||  "${rpm_arr2[3]}" = "i886" ]]
	               	              then
	               	                rpm_arch=1
	               	              fi
	               	              ;;
	               	            i486)
	               	              if [ "${rpm_arr2[3]}" = "i386" ]
	               	              then
	               	                rpm_arch=0
	               	              elif [[ "${rpm_arr2[3]}" = "i586" ||  "${rpm_arr2[3]}" = "i686" ||  "${rpm_arr2[3]}" = "i886" ]]
	               	              then
	               	                rpm_arch=1
	               	              fi
	               	              ;;
	               	            i586)
	               	              if [[ "${rpm_arr2[3]}" = "i386" || "${rpm_arr2[3]}" = "i486"  ]]
	               	              then
	               	                rpm_arch=0
	               	              elif [[ "${rpm_arr2[3]}" = "i686" ||  "${rpm_arr2[3]}" = "i886" ]]
	               	              then
	               	                rpm_arch=1
	               	              fi  
	               	              ;;
	               	            i686)
	               	              if [[ "${rpm_arr2[3]}" = "i386" || "${rpm_arr2[3]}" = "i486" || "${rpm_arr2[3]}" = "i586"  ]]
	               	              then
	               	                rpm_arch=0
	               	              elif [  "${rpm_arr2[3]}" = "i886" ] 
	               	              then
	               	                rpm_arch=1
	               	              fi
	               	              ;;
	               	            i886)
	               	              if [[ "${rpm_arr2[3]}" = "i386" || "${rpm_arr2[3]}" = "i486" || "${rpm_arr2[3]}" = "i586"  || "${rpm_arr2[3]}" = "i686" ]]
	               	              then
	               	                rpm_arch=0 
	               	              fi
	               	              ;; 
	               	            *)
	               	              rpm_status=3
	               	            ;; 
	               	          esac    
	               	          #$READ -p "${rpm_arr1[3]} and ${rpm_arr2[3]} $rpm_status $actual $PARAM_PATH"
	               	        fi
	               	        #$READ -p "element is $array_item"
	               	        element_count=$(expr $element_count + 1)
	               	      done
	               	      element_count=0
	                        #no_of_loops=$(expr $how_many_name_r + 2)
	               	      if [ -z "$rpm_status" ]
	               	      then
	               	        while [ "$how_many_name_r" -le "$no_of_loops" ]
	               	        do
	               	          #echo "to compare ${rpm_arr1[$how_many_name_r]} and ${rpm_arr2[$how_many_name_r]} and func_rpm_status =$func_rpm_status"
	               	          if [ "$func_rpm_status" -eq 0 ]
	               	          then
	               	            compare_rpmversion "${rpm_arr1[$how_many_name_r]}" "${rpm_arr2[$how_many_name_r]}"
	               	            rpm_status=$func_rpm_status
	               	          fi
	               	          how_many_name_r=$(expr $how_many_name_r + 1)
	               	        done
	               	      fi
	                    fi
                            IFS=$old_ifs
	                  fi 
	                  echo "${ROW}_${PARAM_PATH}_rpm_status == $rpm_status">>$OSSPOOLFIL
	                  echo "${ROW}_${PARAM_PATH}_rpm_arch == $rpm_arch">>$OSSPOOLFIL
	                  ;;
	                SunOS)
	                  PARAM_PATH=$(echo $PARAM_PATH|cut -d '|' -f1)
	                  rpm_match=$(grep -c "$PARAM_PATH" $SOURCEFIL)
	                  if [ $rpm_match -eq 1 ]
	                  then
	                    rpm_status=0
	                  else
	                    if [ $i = $localnode ]
	                    then
	                      rpm_match=$(pkginfo -q $PARAM_PATH;echo $?)
	                    else
	                      sshrpm="pkginfo -q $PARAM_PATH;echo \$?"
	                      rpm_match=$($SSHELL $i $sshrpm)
                              #$READ -p "rpm_match=$rpm_match and sshrpm=$sshrpm"
	                    fi
	                    actual=$PARAM_PATH
	                    if [ $rpm_match -eq 0 ]
	                    then
	                      rpm_status=1
	                    else
	                      rpm_status=3
	                    fi
	                  fi
	                  echo "${ROW}_${PARAM_PATH}_rpm_status == $rpm_status">>$OSSPOOLFIL
	                  echo "${ROW}_${PARAM_PATH}_rpm_arch == $rpm_arch">>$OSSPOOLFIL
	                  ;;
	                AIX)
	                  rpm_match=$(grep -c $PARAM_PATH $SOURCEFIL)
	                  unset rpm_arr1
	                  unset rpm_arr2
	                  unset rpm_name
	                  unset rpm_status
	                  func_rpm_status=0
	                  ir_counter=0
	                  how_many_name_r=1
	                  how_many_no_r=0
	                  if [ $rpm_match -eq 1 ]
	                  then
	                    rpm_status=0
	                  else
                            if [ -n "$IFS" ]
                            then
                              old_ifs=$IFS
                            fi
                            IFS=$'|'
	                    #$READ -p "package name =$PARAM_PATH"
	                    for ir in $PARAM_PATH
	                    do
	                      rpm_arr1[$ir_counter]=$ir
	                      if [ -z "$rpm_name" ]
	                      then
	                        rpm_name=${rpm_arr1[0]}
	                      fi
	                      ir_counter=$(expr $ir_counter + 1)
	                    done
	                    ir_counter=$(expr $ir_counter - 1)
	                    if [ "$i" = "$localnode" ]
	                    then
	                      actual=$(lslpp -lcq "$rpm_name" 2> /dev/null|head -1|awk 'BEGIN { FS = ":" };{print $2"|" $3}')
	                    else
	                      IFS=$old_ifs
                              sshrpm="lslpp -lcq $rpm_name 2>/dev/null|head -1"  
                              #OLD_SSHELL=$SSHELL
                              #SSHELL="/usr/bin/ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"
                              actual=$($SSHELL $i $sshrpm|sed 's/ /|/g')
                              actual=$(echo $actual|awk 'BEGIN { FS = ":" };{print $2"|" $3}')
                              #SSHELL=$OLD_SSHELL
	                      IFS=$'|'
	                      #actual=$($SSHELL $i lslpp -lcq "$rpm_name" 2>/dev/null|head -1|awk 'BEGIN { FS = ":" };{print $2"|" $3}')
	                    fi
	                    if [[ -z "$actual" || $actual = "|"  ]]
	                    then
	                      rpm_status=3
	                      #echo "rpm $PARAM_PATH is not installed on sysetm"
	                    else
	                      #$READ -p "actual is $actual"
	                      ar_counter=0
	                      how_many_name_a=0
	                      how_many_no_a=0
	                      element_count=0
	                      no_of_loops=0
	                      for arpm in $actual
	                      do
	                        rpm_arr2[$ar_counter]=$arpm
	                        if [ -z "$rpm_name" ]
	                        then
	                  	  rpm_name=${rpm_arr2[0]}
	                        fi
	                        ar_counter=$(expr $ar_counter + 1)
	                      done
	                      if [ -z "$rpm_status" ]
	                      then
	                        #echo "to compare ${rpm_arr1[1]} and ${rpm_arr2[1]} and func_rpm_status =$func_rpm_status"
	                        if [ "$func_rpm_status" -eq 0 ]
	                        then
	                  	  compare_rpmversion "${rpm_arr1[1]}" "${rpm_arr2[1]}"
	                  	  rpm_status=$func_rpm_status
	                        fi
	                      fi
	                    fi
	                  fi
                          unset IFS
                          IFS=$' \t\n'  
	                  echo "${ROW}_${PARAM_PATH}_rpm_status == $rpm_status">>$OSSPOOLFIL
	                  echo "${ROW}_${PARAM_PATH}_rpm_arch == $rpm_arch">>$OSSPOOLFIL
	                  ;;
	              esac #packages OS case ends here
	              #if [ $ISBRANCH -eq 0 ]; then echo "${CHECK_ID}|${rpm_status}@$actual" >>$OSACTUAL;fi
	            else # package offline else so above is for online and below is for offline 
	              if [ $op_mode -eq 0 ]
	              then
	                SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	              else
	                SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	              fi
	              #each node could potentially have a different listing of packages
	              #so use the node specific listing to check
	              #RPM STATUS
	              # 0=exact version is installed
	              # 1=higher version of same package is installed
	              # 2=package is installed but version is lower than recommended
	              # 3=package not instaleld
	              #sed 's/|/-/g'
	              SOURCEFIL_REPORT=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
                      if [ $OFFLINE -eq 0 ]
                      then
	                SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"o_"$SOURCEFIL"_"$i".out"
                      else
	                SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
                      fi
	              #write the code here to read back from os spool file
	              #$READ -p "PARAM_PATH=$PARAM_PATH"
	              call_get_log_result=1
	              pkgtype=$(echo $PARAM_PATH|cut -d '|' -f2)
	              pkgarch=$(echo $PARAM_PATH|cut -d '|' -f4)
	               
	              if [[ -z "$pkgtype" && "$pkgarch" != "ppc_64" ]]
	              then 
	                PARAM_PATH=$(echo $PARAM_PATH|cut -d '|' -f1)
	              fi
	              rpm_status=$(grep "${ROW}_${PARAM_PATH}_rpm_status" $OSSPOOLFIL|sed  -n 's/.*== //p')
	              rpm_arch=$(grep "${ROW}_${PARAM_PATH}_rpm_arch" $OSSPOOLFIL|sed  -n 's/.*== //p')
	              #$READ -p "RPM status $rpm_status and PARAM_PATH=$PARAM_PATH pkgarch=$pkgarch"
	            fi
                  fi
                  ;;
              esac # this end case is for SQL|SQL_PARAM|SQL_COLLECT|OS_PARAM|OS_PACKAGE|OS_PATCH
              case $COMTYPE in
                OS_PARAM)
                  if  [[ $component_match_count  -lt 1 ]]
                  then 
                    echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL 
                    call_get_log_result=0
                  elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$PARAM_PATH" $EXCLUDEFIL` -ge 1 ]]  
                  then
                    call_get_log_result=0
                    echo "Skipping $PARAM_PATH (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                    generate_exceptions_xml "Skipping $PARAM_PATH because its in exclude file $EXCLUDEFIL"   
                  else
                    call_get_log_result=1
	            case $FIELDPOS in
	              1) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $1'}`
	               ;;
	              2) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $2'}`
	               ;;
	              3) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $3'}`
	               ;;
	              4) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $4'}`
	               ;;
	              5) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $5'}`
	               ;;
	              99) VAL=`grep $PARAM_PATH $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
	               ;;
	            esac
	            #if [[ $ISBRANCH -eq 0  && $OFFLINE -eq 0 ]]; then echo "${CHECK_ID}|${VAL}" >>$OSACTUAL; fi
                  fi
		  #commented below to execute sql out check
         	  ;;
    	      esac
              #-----------------DEBUGGING---------------
	      #       echo "----------------------------------------------"
              #       echo "COMMAND = $COM"
              #       echo "RESULT = $VAL"
              #--------------END DEBUGGING-------------
              #if [ -n "$LEVEL" ]
              #then
              #  get_log_result
	      if [[ -n "$LEVEL" && -n $call_get_log_result && $call_get_log_result -eq 1 ]]; then  get_log_result; fi;
              #fi
              ;;
            OS_OUT_CHECK)
              if [[ $PARAM = "CRS" &&  ${crs_installed[$stack_counter]} -eq 0 ]] ||  [[ $PARAM = "RDBMS" &&  ${rdbms_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "TIMESTEN" &&  ${ttx_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "ASM" &&  ${asm_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "GOLDENGATE_HOME" && $is_goldengate_installed -eq 0 ]] || [[ "$PARAM" = "EMAGENT_HOME" && $is_emagent_installed -ne 1 ]]
              then
                call_get_log_result=0
              elif [[ $NEEDS_RUNNING = "CRS" &&  ${stack_crs_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "RDBMS" &&  ${stack_dbinst_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "ASM" &&  ${stack_asm_up[$stack_counter]} -eq 0 ]] || [[ $NEEDS_RUNNING = "ACFS" &&  ${stack_acfs_up[$stack_counter]} -eq 0  ]] || [[ "$NEEDS_RUNNING" = "EMAGENT" && $is_emagent_installed -ne 1 ]]
              then
                call_get_log_result=0 
              elif [[ $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave" ]]
              then
                call_get_log_result=0    
                echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) because execute_once is true">>$LOGFIL   
              elif [[ $execute_once -eq 1 && "$i" != "$localnode" ]]
              then
                call_get_log_result=0    
                echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) because execute_once is true">>$LOGFIL   
              elif  [[ $component_match_count  -lt 1 ]]
              then
                echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
                call_get_log_result=0
	      elif [ -z "$profiles2run" ] && [ -e $PROFILEONLY ] && [[ `grep -ic $CHECK_ID $PROFILEONLY` -ge 1 ]]
                  then
                     call_get_log_result=0
                     echo "Not running $audit_check_name($CHECK_ID) because no profile is in use">>$LOGFIL

              elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$audit_check_name" $EXCLUDEFIL` -ge 1 ]]
              then
                echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                generate_exceptions_xml "Skipping $audit_check_name because its in exclude file $EXCLUDEFIL"
                call_get_log_result=0
              elif [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH" ]] && [[ $i != $localnode ]]
              then
                call_get_log_result=0
              else
                if [ $OFFLINE -eq 0 ]; then switch_name_file=${RTEMPDIR}/o_ibswitches.out;else switch_name_file=$OUTPUTDIR/o_ibswitches.out;fi
                #$READ -p "before switch os_out_check"
                if [ $op_mode -eq 0 ]
                then
	          audit_check_name=`grep "_"$ROW"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                else
	          audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                fi
	        audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'`
                if [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH" ]] && [[ -e $switch_name_file && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  -n "$ibswitch_password_status" && $ibswitch_password_status -ne 3 ]]
                then
                  #write_switchname_in_report=1
                  if [ $write_switchname_in_report -eq 1 ]
                  then
                    write_switchname_in_report=0
                    echo "============================================================="|tee -a $IBSREPFIL_PASS|tee -a $IBSREPFIL_FAIL|tee -a $IBREPFIL_PASS|tee -a $IBREPFIL_FAIL >/dev/null
                    echo "                    Infiniband switch checks                 "|tee -a $IBSREPFIL_PASS|tee -a $IBSREPFIL_FAIL|tee -a $IBREPFIL_PASS|tee -a $IBREPFIL_FAIL >/dev/null
                    echo "============================================================="|tee -a $IBSREPFIL_PASS|tee -a $IBSREPFIL_FAIL|tee -a $IBREPFIL_PASS|tee -a $IBREPFIL_FAIL >/dev/null
                  fi
                  ORIG_PMSG=$PMSG
                  ORIG_FMSG=$FMSG
                  mb_db_counter=0
                  mb_db_counter_log=0
                  for switchname in `cat $switch_name_file`
                  do
                    if [ -e $OUTPUTDIR/s_getnm2type_${switchname}.out ]
                    then 
                      switch_type=$(cat $OUTPUTDIR/s_getnm2type_${switchname}.out)
                      if [[ "$switch_type" = "36P" || "$switch_type" = "36p" ]]; then switch_type_running=SPINE_SWITCH;else switch_type_running=SWITCH;fi
                    else
		      t_switchname_short=""
		      if [[ `echo "$switchname"|grep -c [A-Za-z]` -gt "0" ]]; then t_switchname_short=$(echo $switchname|cut -d. -f1); fi
		      if [ -e $OUTPUTDIR/s_getnm2type_${t_switchname_short}.out ]; then
                        switch_type=$(cat $OUTPUTDIR/s_getnm2type_${t_switchname_short}.out)
			if [[ "$switch_type" = "36P" || "$switch_type" = "36p" ]]; then switch_type_running=SPINE_SWITCH;else switch_type_running=SWITCH;fi
		      else
                        switch_type_running=SWITCH 
		      fi
                    fi
                    is_ibswitch_ip=$(echo $switchname|grep -c [A-Za-z])
                    if [[ -n $is_ibswitch_ip && $is_ibswitch_ip -eq 0 ]]
                    then
                      switchname_short=$(echo $switchname|sed 's/\./_/g')
                    else
                      switchname_short=$(echo $switchname|cut -d. -f1)            
                      #switchname=$(nslookup $switchname|grep -iw name|awk '{print $NF}'|sed 's/\.$//')
                    fi
                    #Added this branch to execute checks based on the switch type. check is not execute and not put in skipped if switch type does not match needs_running   
                    skip_this_target=0
                    set_skip_this_target $switchname
                    if [[ "$NEEDS_RUNNING" = "$switch_type_running" && $skip_this_target -eq "0" ]]
                    then  
		      call_get_log_result=1
		      COM=`echo "OS OUT CHECK $PARAM_PATH  $OP  $COMP"`
		      if [ $op_mode -eq 0 ]
		      then
		        SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
		      else
		        SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
		      fi
		      if [ -e $OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname_short"_"report".out" ]
		      then
		        SOURCEFIL_REPORT=$OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname_short"_"report".out"
		      else
		        SOURCEFIL_REPORT=$OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname_short".out"
		      fi
		      if [ $OFFLINE -eq 0 ]
		      then
		        if [ -e $OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname_short"_"report".out" ]
		        then
		      	  SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"s_"$SOURCEFIL"_"$switchname_short"_"report".out"
		        else
		      	  SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"s_"$SOURCEFIL"_"$switchname_short".out"
		        fi
		      else
		        if [ -e $OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname_short"_"report".out" ]
		        then
		      	  SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname_short"_"report".out"
		        else
		      	  SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname_short".out"
		        fi
		      fi
		      SOURCEFIL=$OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname_short".out"
		      if [ $op_mode -eq 0 ]
		      then
		        FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
		      else
		        FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
		      fi
		      if [ -f $SOURCEFIL ]
		      then
		        case $FIELDPOS in
		          1) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $1'}`
		           ;;
		          2) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $2'}`
		           ;;
		          3) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $3'}`
		           ;;
		          4) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $4'}`
		           ;;
		          5) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $5'}`
		          ;;
		          99) VAL=`grep $PARAM_PATH $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
		          ;;
		        esac
		      else
		        echo "skipping $audit_check_name (checkid:- $CHECK_ID) on $switchname because `basename $SOURCEFIL` not found" >>$SKIPFIL;
		        generate_exceptions_xml "skipping $(echo $audit_check_name|sed 's/\[DBMV2]//g') on $switchname because `basename $SOURCEFIL` not found" 
                        let G_SKIP_CHECKS=$G_SKIP_CHECKS+1
                        let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1; 
			validate_needs_running;
		        #$READ -p "stop here to check skip file"
		      fi
		      PMSG=$(echo $ORIG_PMSG on infiniband switch ${switchname})
		      FMSG=$(echo $ORIG_FMSG on infiniband switch ${switchname})
		      #PMSG=$(echo "$PMSG for $switchname")
		      #FMSG=$(echo "$FMSG for $switchname")
		      #if [[ $ISBRANCH -eq 0  && $OFFLINE -eq 0 ]]; then echo "${CHECK_ID}|${VAL}" >>$OSACTUAL; fi
		      if [[ -n $call_get_log_result && $call_get_log_result -eq 1 && -n "$LEVEL" && -f $SOURCEFIL ]]
		      then
		        get_log_result "inloop" "switch"
		        mb_db_counter_log=$(expr $mb_db_counter_log + 1)
		      fi
                    else
                      if [[ $skip_this_target -eq "1" ]] ; then
                        echo "skip_this_target=1 for $audit_check_name on $switchname so skipping">>$LOGFIL
                      else
                        echo "NEEDS_RUNNING($NEEDS_RUNNING) does not match to switch_type_running($switch_type_running) for $audit_check_name on $switchname so skipping">>$LOGFIL
                      fi
                    fi
                    mb_db_counter=$(expr $mb_db_counter + 1) # needed for opstat
                  done
                  mb_db_counter=0
                #$READ -p "after switch os_out_check"
                elif [[ $NEEDS_RUNNING = "STORAGE_CELL" && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -e $CELLIP &&  -n "$cell_password_status" && $cell_password_status -ne 3 && $current_exadata_version -lt $check_exadata_version  && "$profiles2run" != "switch" ]]
                then
                  #write_cellname_in_report=1
                  if [ $write_cellname_in_report -eq 1 ]
                  then
                    write_cellname_in_report=0
                    echo "============================================================="|tee -a $CELLSREPFIL_PASS|tee -a $CELLSREPFIL_FAIL|tee -a $CELLREPFIL_PASS|tee -a $CELLREPFIL_FAIL >/dev/null
                    echo "                    Storage server checks                    "|tee -a $CELLSREPFIL_PASS|tee -a $CELLSREPFIL_FAIL|tee -a $CELLREPFIL_PASS|tee -a $CELLREPFIL_FAIL >/dev/null
                    echo "============================================================="|tee -a $CELLSREPFIL_PASS|tee -a $CELLSREPFIL_FAIL|tee -a $CELLREPFIL_PASS|tee -a $CELLREPFIL_FAIL >/dev/null
                  fi
                  #$READ -p "stop to see why its writing"
                  #ORIG_PMSG=$PMSG
                  #ORIG_FMSG=$FMSG
		  call_get_log_result=0
                  cell_count=0
                  cell_count_cwc=0
                  amb_temp_total=0 
                  outcheck_cell_counter=0 
                  amb_temp_cell_count=0
                  unset a_cellname
	          unset a_cellCheckStatus
                  for cellname in `cat $CELLIP|cut -d= -f2|cut -d\; -f2|sed 's/"//g'`
                  do 
                    check_status=0
                    cellname_short=$(echo $cellname|sed 's/\./_/g') 
                    cellipaddr=$cellname
                    #if [ $OFFLINE -eq 0 ]
                    #then
                    #  cellname=$(cat /etc/hosts|grep "$cellname"|awk '{print $NF}'|cut -d'-' -f1)
                    #else
                    #cellname=$(cat $CELLDIR/cells.out|grep -w "$cellname"|awk '{print $NF}')
                    cellname=$(grep -w "$cellname" $CELLDIR/cells.out|awk '{print $NF}')
                    #fi
                    mixed_hardware_execute_check=1
                    if [[ $mixed_hardware -gt 1 && -e $CELLDIR/c_cbc_CellMakeModel_${cellname_short}_report.out ]]
                    then
                      #mixed_hardware_cell_type_v2=$(cat $CELLDIR/c_cbc_CellMakeModel_${cellname_short}_report.out| grep -wci "SUN FIRE X4275")
                      #mixed_hardware_cell_type_x2_2=$(cat $CELLDIR/c_cbc_CellMakeModel_${cellname_short}_report.out| grep -wci "SUN FIRE X4[1-2]70 M2")
                      #mixed_hardware_cell_type_x3_2=$(cat $CELLDIR/c_cbc_CellMakeModel_${cellname_short}_report.out| grep -wci "SUN FIRE X4[1-2]70 M3")
                      #mixed_hardware_cell_type_x4_2=$(cat $CELLDIR/c_cbc_CellMakeModel_${cellname_short}_report.out| grep -ci "SUN SERVER X4-2")
                      mixed_hardware_cell_type_v2=$(grep -wci "SUN FIRE X4275" $CELLDIR/c_cbc_CellMakeModel_${cellname_short}_report.out)
                      mixed_hardware_cell_type_x2_2=$(grep -wci "SUN FIRE X4[1-2]70 M2" $CELLDIR/c_cbc_CellMakeModel_${cellname_short}_report.out)
                      mixed_hardware_cell_type_x3_2=$(grep -wci "SUN FIRE X4[1-2]70 M3" $CELLDIR/c_cbc_CellMakeModel_${cellname_short}_report.out)
                      mixed_hardware_cell_type_x4_2=$(grep -ci "SUN SERVER X4-2" $CELLDIR/c_cbc_CellMakeModel_${cellname_short}_report.out)
                      mixed_hardware_cell_type_x5_2=$(grep -ci "ORACLE SERVER X5-2" $CELLDIR/c_cbc_CellMakeModel_${cellname_short}_report.out)

                      if [[ $mixed_hardware_cell_type_v2 -eq 1 && `echo $check_components|grep -icw EXADATA` -eq 0 ]]
                      then
                        mixed_hardware_execute_check=0
                      fi 
                      if [[ $mixed_hardware_cell_type_x2_2 -eq 1 && `echo $check_components|grep -icw X2-2` -eq 0 ]]
                      then
                        mixed_hardware_execute_check=0
                      fi 
                      if [[ $mixed_hardware_cell_type_x3_2 -eq 1 && `echo $check_components|grep -icw X3-2` -eq 0 ]]
                      then
                        mixed_hardware_execute_check=0
                      fi
                      if [[ $mixed_hardware_cell_type_x4_2 -eq 1 && `echo $check_components|grep -icw X4-2` -eq 0 ]]
                      then
                        mixed_hardware_execute_check=0
                      fi 
                      if [[ $mixed_hardware_cell_type_x5_2 -eq 1 && `echo $check_components|grep -icw X5-2` -eq 0 ]]
                      then
                        mixed_hardware_execute_check=0
                      fi  
 
                    fi 
                    if [ $mixed_hardware_execute_check -eq 1 ]
                    then 
		      COM=`echo "OS OUT CHECK $PARAM_PATH  $OP  $COMP"`
		      if [ $op_mode -eq 0 ]
		      then
		        SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
		      else
		        SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
		      fi
		      cell_outcheck_type=$(echo $SOURCEFIL|cut -d_ -f1)
		      SOURCEFIL_REPORT_CELL=$CELLDIR/"c_"$SOURCEFIL"_"$cellname_short"_report.out"
		      if [[ -n "$cell_outcheck_type" && $cell_outcheck_type = "cbc" ]]
		      then 
		        SOURCEFIL_TRIM=$(echo $SOURCEFIL|sed 's/cbc_//g')
		      elif [[ -n "$cell_outcheck_type" && $cell_outcheck_type = "cwc" ]]
		      then
		        SOURCEFIL_TRIM=$(echo $SOURCEFIL|sed 's/cwc_//g')
		      fi
		      SOURCEFIL_REPORT=$OUTPUTDIR/"c_"$SOURCEFIL_TRIM"_report.out"
		      if [ $OFFLINE -eq 0 ]
		      then
		        SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"c_"$SOURCEFIL_TRIM"_report.out"
		      else
		        SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"c_"$SOURCEFIL_TRIM"_report.out"
		      fi
		      SOURCEFIL=$CELLDIR/"c_"$SOURCEFIL"_"$cellname_short".out"
		      if [[ -e $SOURCEFIL_REPORT_CELL && $OFFLINE -eq 0 && -n "$SOURCEFIL_TRIM" && $ISBRANCH -eq 0 ]]
		      then
		        echo -e "TO REVIEW COLLECTED DATA FROM $(echo $cellname|tr "[a-z]" "[A-Z]") FOR $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >> $SOURCEFIL_REPORT
		        cat $SOURCEFIL_REPORT_CELL >>$SOURCEFIL_REPORT
		        rm -f $SOURCEFIL_REPORT_CELL >/dev/null 2>&1
		        echo -e "\n\n\n" >>$SOURCEFIL_REPORT
		      fi
		      if [ $op_mode -eq 0 ]
		      then
		        FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
		      else
		        FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
		      fi
		      if [[ -f $SOURCEFIL && 1 -eq 2 ]]
		      then
		        case $FIELDPOS in
		          1) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $1'}`
		           ;;
		          2) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $2'}`
		           ;;
		          3) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $3'}`
		           ;;
		          4) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $4'}`
		           ;;
		          5) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $5'}`
		          ;;
		          99) VAL=`grep $PARAM_PATH $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
		          ;;
		        esac
		      fi
                      #added this to avoid skipped checks for unreachable storage cells
                      if [ -e $OUTPUTDIR/${program_name}_skipped_nodes.log ] 
                      then
                        is_it_skipped_cell=$(grep -icw $cellipaddr $OUTPUTDIR/${program_name}_skipped_nodes.log)
                      fi
		      if [ -e $SOURCEFIL ]
		      then
		        VAL=$(cat $SOURCEFIL|head -1|awk '{print $1}')
		        call_get_log_result=1
                      elif [[ -n "$is_it_skipped_cell" &&  $is_it_skipped_cell -ge 1 ]]
                      then 
                        echo "skipping $audit_check_name (checkid:-$CHECK_ID) on $cellipaddr because cell is not available" >>$LOGFIL  
                        VAL=$VAL1
		      else
		        VAL=$VAL1
		        echo "skipping $audit_check_name (checkid:-$CHECK_ID) on $cellname because `basename $SOURCEFIL` not found" >>$SKIPFIL;
		        generate_exceptions_xml "skipping $(echo $audit_check_name|sed 's/\[DBMV2]//g') on $cellname because `basename $SOURCEFIL` not found" 
		        call_get_log_result=0
                        let G_SKIP_CHECKS=$G_SKIP_CHECKS+1
                        let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1; 
			validate_needs_running;
		      fi
		      unset CELL_VAL
		      if [[ -e $SOURCEFIL && "$cell_outcheck_type" = "cwc" ]]
		      then
		        if [ $cell_count_cwc -eq 0 ]
		        then
		          VAL1=$VAL
		          CELL_VAL=1 
		        else
		          VAL2=$VAL
		          if [ $RAT_DEBUG -eq 1 ]
		          then
		      	    if [[ -n "$VAL1" && -n "$VAL2" ]] && [ "$VAL1" = "$VAL2" ]
		      	    then 
		      	      CELL_VAL=1
		      	    else
		      	      CELL_VAL=0
		      	      cell_count=$(expr $cell_count + 1 )
		      	    fi 
		          else
		      	    if [[ -n "$VAL1" && -n "$VAL2" ]] && [ "$VAL1" = "$VAL2" ]  2>>$ERRFIL
		      	    then 
		      	      CELL_VAL=1
		      	    else
		      	      CELL_VAL=0
		      	      cell_count=$(expr $cell_count + 1 )
		      	    fi
		          fi  
		        fi  
		      elif [[ -e $SOURCEFIL && "$cell_outcheck_type" = "cbc"  && "$CHECK_ID" != "A4C28178C200A9CBE040E50A1EC00952" ]]
		      then
		        VAL1=$VAL 
		        if [ $RAT_DEBUG -eq 1 ]
		        then
		          if [ "$VAL1" "$OP" "$COMP" ]
		          then
		      	    CELL_VAL=1 
		          else
		      	    CELL_VAL=0 
		      	    cell_count=$(expr $cell_count + 1 ) 
		          fi
		        else
		          if [ "$VAL1" "$OP" "$COMP" ]  2>>$ERRFIL
		          then
		      	    CELL_VAL=1 
		          else
		      	    CELL_VAL=0 
		      	    cell_count=$(expr $cell_count + 1 ) 
		          fi
		        fi   
		      #elif [[ -e $SOURCEFIL && "$CHECK_ID" = "A4C28178C200A9CBE040E50A1EC00952" && `echo $cellname|egrep -ic '01$|02$|03$'` -gt 0 && $outcheck_cell_counter -lt 4 ]] 
		      #then
                      #  amb_temp_total=$(expr $amb_temp_total + $VAL )
                      #  amb_temp_cell_count=$(expr $amb_temp_cell_count + 1 )
                      #fi
		      elif [[ -e $SOURCEFIL && "$CHECK_ID" = "A4C28178C200A9CBE040E50A1EC00952" ]]
		      then
		        VAL1=$VAL 
		        if [ $RAT_DEBUG -eq 1 ]
		        then
			  if [[ $VAL1 -lt 5 || $VAL1 -gt 32 ]]; 
			  then 
			    CELL_VAL=0; 
			  else 
			    CELL_VAL=1; 
                          fi
		        else
			  if [[ $VAL1 -lt 5 || $VAL1 -gt 32 ]] 2>>$ERRFIL
			  then 
			    CELL_VAL=0; 
			  else 
			    CELL_VAL=1; 
                          fi
		        fi   
			if [[ `echo $cellname|egrep -ic '01$|02$|03$'` -gt 0 && $outcheck_cell_counter -lt 4 ]]; then
			  amb_temp_total=$(expr $amb_temp_total + $VAL )
		          amb_temp_cell_count=$(expr $amb_temp_cell_count + 1 )
			fi
		      fi    
		      #if [[ $ISBRANCH -eq 0  && $OFFLINE -eq 0 ]]; then echo "${CHECK_ID}|${VAL}" >>$OSACTUAL; fi
		      if [ -e $SOURCEFIL ];then a_cellname[$cell_count_cwc]=$cellname;fi
		      if [[ -e $SOURCEFIL && "$cell_outcheck_type" = "cwc" ]]
		      then
		        if [[ $CELL_VAL -eq 1 ]]; then a_cellCheckStatus[$cell_count_cwc]=PASS;else a_cellCheckStatus[$cell_count_cwc]=$ALVL;fi
		      elif [[ -e $SOURCEFIL && "$cell_outcheck_type" = "cbc" ]]
		      then
		        if [[ $CELL_VAL -eq 1 ]]; then a_cellCheckStatus[$cell_count_cwc]=PASS;else a_cellCheckStatus[$cell_count_cwc]=$ALVL;fi
		      fi
		      if [ -e $SOURCEFIL ];then cell_count_cwc=$(expr $cell_count_cwc + 1);fi
		      outcheck_cell_counter=$(expr $outcheck_cell_counter + 1)
		      #$READ -p "stop here to check"
		    else
		      echo "$audit_check_name did not execute on $cellname because $old_components does not match with $CELLDIR/c_cbc_CellMakeModel_${cellname}_report.out">>$LOGFIL
		    fi
		    #$READ -p "stop here to check for cell check"
                  done
                  #if [[ $SOURCEFIL && "$cell_outcheck_type" = "cwc" ]]
                  if [[  "$cell_outcheck_type" = "cwc" ]]
                  then
                    if [[ $cell_count -eq 0 && $CELL_VAL -eq 1 ]]; then VAL=$COMP;elif [[ $cell_count -gt 0 ]];then VAL="0123456789XYZ";fi
                  #elif [[ -e $SOURCEFIL && "$cell_outcheck_type" = "cbc" ]]
                  elif [[ "$cell_outcheck_type" = "cbc"  && "$CHECK_ID" != "A4C28178C200A9CBE040E50A1EC00952" ]]
                  then
                    if [[ $cell_count -eq 0 && $CELL_VAL -eq 1 ]]; then VAL=$VAL1;elif [[ $cell_count -gt 0 ]];then VAL="0123456789XYZ";fi
                  elif [ "$CHECK_ID" = "A4C28178C200A9CBE040E50A1EC00952"  ] 
                  then
                    if [[ -n "$amb_temp_total"  && $amb_temp_total -gt 0 ]]
                    then
                      amb_temp_avg=$(echo "scale=0;$amb_temp_total / $amb_temp_cell_count"|bc)
                      echo "amb_temp_total=$amb_temp_total and amb_temp_avg=$amb_temp_avg amb_temp_cell_count = $amb_temp_cell_count">>$LOGFIL
                      if [[ $amb_temp_avg -lt 5 || $amb_temp_avg -gt 32 ]]; then VAL=1; else VAL=0; fi
                    else
                      echo "skipping $audit_check_name (checkid:-$CHECK_ID) because this cluster does not access the first three storage servers" >>$SKIPFIL
                      generate_exceptions_xml "skipping $(echo $audit_check_name|sed 's/\[DBMV2]//g') because this cluster does not access the first three storage servers" 
                      call_get_log_result=0
                      let G_SKIP_CHECKS=$G_SKIP_CHECKS+1
                      let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1; 
		      validate_needs_running;
                    fi
                  fi
                  #if [ "$CHECK_ID" = "A4C28178C200A9CBE040E50A1EC00952" ]
                  #then
                  #$READ -p "stop here to check again"
                  #fi
		  #if [[ -n $call_get_log_result && $call_get_log_result -eq 1 && -n "$LEVEL" && -f $SOURCEFIL ]]
		  if [[ -n $call_get_log_result && $call_get_log_result -eq 1 && -n "$LEVEL"  ]]
		  then
		    get_log_result
	          fi
                  #$READ -p "after switch os_out_check"
                elif [[ -z "$NEEDS_RUNNING" || $NEEDS_RUNNING = "UNSPECIFIED" || $NEEDS_RUNNING = "CRS" || $NEEDS_RUNNING = "ASM" || $NEEDS_RUNNING = "EMAGENT" ]] && [ $rootYesNoint -ne 3 ] 
                then
		  call_get_log_result=1
		  COM=`echo "OS OUT CHECK $PARAM_PATH  $OP  $COMP"`
		  if [ $op_mode -eq 0 ]
		  then
		    SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
		  else
		    SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
		  fi
                  SOURCEFIL_REPORT=$OUTPUTDIR/"o_"$SOURCEFIL"_report_"$i".out"
                  if [ ! -e $SOURCEFIL_REPORT ]; then SOURCEFIL_REPORT=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i"_report.out";fi
                  if [ $OFFLINE -eq 0 ]
                  then
                    SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"o_"$SOURCEFIL"_report_"$i".out"
                    if [ ! -e $SOURCEFIL_REPORT_NEW ]; then SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"o_"$SOURCEFIL"_"$i"_report.out";fi
                  else
                    SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"o_"$SOURCEFIL"_report_"$i".out"
                    if [ ! -e $SOURCEFIL_REPORT_NEW ]; then SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i"_report.out";fi
                  fi
		  SOURCEFIL=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out" 
		  if [ $op_mode -eq 0 ]
		  then
		    FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
		  else
		    FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
		  fi
		  if [[ -f $SOURCEFIL && `ls -l $SOURCEFIL|awk '{print $5}'` -gt 1 ]]
		  then
		    case $FIELDPOS in
		      1) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $1'}`
		       ;;
		      2) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $2'}`
		       ;;
		      3) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $3'}`
		       ;;
		      4) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $4'}`
		       ;;
		      5) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $5'}`
		      ;;
		      99) VAL=`grep $PARAM_PATH $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
		      ;;
		    esac
                  else
                    #if [[ "$NEEDS_RUNNING" != "SWITCH" || "$NEEDS_RUNNING" != "STORAGE_CELL" ]]
                    #then
                    echo "skipping $audit_check_name(checkid:-$CHECK_ID) because `basename $SOURCEFIL` not found" >>$SKIPFIL
                    generate_exceptions_xml "skipping $(echo $audit_check_name|sed 's/\[DBMV2]//g') because `basename $SOURCEFIL` not found"
                    call_get_log_result=0 
                    let G_SKIP_CHECKS=$G_SKIP_CHECKS+1
                    let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1; 
			validate_needs_running;
                    # fi
		  fi
		  #if [[ $ISBRANCH -eq 0  && $OFFLINE -eq 0 ]]; then echo "${CHECK_ID}|${VAL}" >>$OSACTUAL; fi
		  if [[ -n $call_get_log_result && $call_get_log_result -eq 1 && -n "$LEVEL" && -f $SOURCEFIL ]]
		  then
		    get_log_result
		  fi
                fi
              fi
              if [ -n "$old_components" ]; then components=$old_components;unset old_components;fi
              #if [ $NEEDS_RUNNING = "STORAGE_CELL" ]; then $READ -p "stop";fi   
              ;;
            SQL_OUT_CHECK)
              if  [[ $component_match_count  -lt 1 ]]
              then
                echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
                call_get_log_result=0
              elif [ -e $EXCLUDEFIL ] && [[ `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 || `grep -ic "$audit_check_name" $EXCLUDEFIL` -ge 1 ]]
              then
                call_get_log_result=0
                echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) on $i because its in exclude file $EXCLUDEFIL">>$EXCLUDELOG
                generate_exceptions_xml "Skipping $audit_check_name because its in exclude file $EXCLUDEFIL"  
              else
                mb_db_counter=0
                call_get_log_result=1
                COM=`echo "SQL OUT CHECK $PARAM_PATH  $OP  $COMP"`
                if [ $op_mode -eq 0 ]
                then
                  SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
                else
                  SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
                fi
                #echo "PARAM_PATH=$PARAM_PATH and SOURCEFIL=$SOURCEFIL"
                ORIG_PMSG=$PMSG
                ORIG_FMSG=$FMSG
                for db_name_to_check in "${mb_db_names[@]}"
                do
                  skip_this_version=0
                  set_skip_this_version "-"
                  if [$skip_this_version -eq 1 ]
                  then
                    mb_db_counter=$(expr $mb_db_counter + 1)
                    echo "Skipping check($CHECK_ID) on version 8 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                    continue
                  fi
                  DBACTUAL=$OUTPUTDIR/d_actual_${db_name_to_check}.out
                  PMSG=$(echo $ORIG_PMSG for ${db_name_to_check})
                  FMSG=$(echo $ORIG_FMSG for ${db_name_to_check})
                  if [ $SOURCEFIL = "check" ]
                  then
               	    SOURCEFIL=$OUTPUTDIR/"d_check_${db_name_to_check}.out"
                  else
               	    SOURCEFIL=$OUTPUTDIR/"d_"$SOURCEFIL"_"${db_name_to_check}".out"
                  fi 
                  if [ $op_mode -eq 0 ] 
                  then
               	    FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
                  else
               	    FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
                  fi
                  #NEEDS_RUNNING="RDBMS"
                  if [ -n "$LEVEL" ] && [ ${stack_asm_up[$stack_counter]} -eq 1 -a ${stack_db_status[$mb_db_counter]} -ne 0 ]
                  then
               	    case $FIELDPOS in
               	      1) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $1'}`
               	       ;;
               	      2) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $2'}`
               	       ;;
               	      3) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $3'}`
               	       ;;
               	      4) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $4'}`
               	       ;;
               	      5) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $5'}`
               	       ;;
               	      99) VAL=`grep -w $PARAM_PATH $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
               	       ;;
               	    esac
               	    if [ $ISBRANCH -eq 0 ]
               	    then
               	      echo "$CHECK_ID|$VAL">>$DBACTUAL
               	    fi
               	    #$READ -p "New SOURCEFIL=$SOURCEFIL"
                    if [ $mb_db_counter -gt 0 ];then write_report_on_fail=0;fi
               	    if [[ -n $call_get_log_result && $call_get_log_result -eq 1 ]]; then  get_log_result; fi;
                  fi
                  mb_db_counter=$(expr $mb_db_counter + 1)
                done
                mb_db_counter=0
                write_report_on_fail=1
              fi
              ;;
            *)
              if [ -n "$LEVEL" ]
              then
                echo "INVALID COMMAND TYPE - $COMTYPE"
              fi
     	      ;;
     	  esac # this end case is for rest of the commands which is not included in above all
     	  #echo "grep _$ROW\-$COMTYPE\_COMMAND $REFFIL"# |sed -n 's\/.*$COMTYPE_COMMAND \/\/p'"
 
          get_current_epoch 
          echo -e "[CHECK:$CHECK_ID][HOST: $i][TYPE: $COMTYPE][COLLECTION_NAME: $COLLECTION_NAME][AUDIT_CHECK_NAME: $audit_check_name] Check End Time: $epoch_time" >> $CHK_TIMINGS
          echo -e "" >> $CHK_TIMINGS
     
          #---------------DEBUGGING---------------------    
          
          #     if [ -n "$LEVEL" ]
          #     then
          #       echo ""
          #       echo "ROW = $ROW"
          #       echo "TYPE = $COMTYPE"
          #       echo "PARAM_PATH = $PARAM_PATH"
          #       echo "OPERATOR = $OP"
          #       echo "COMPARE_VALUE = $COMP"
          #       echo "PASS_MSG = $PMSG"
          #       echo "FAIL_MSG = $FMSG"
          #       echo "IS_BRANCH = $ISBRANCH"
          #       echo "LEVEL = $LEVEL"
          #       echo "CURRENT LEVEL = $CUR_LEVEL"
          #       echo "SF = $SF"
          #       echo "CAT = $CAT"
          #       echo "SUBCAT = $SUBCAT"
          #       echo "----------------------------------------------"
          #       echo ""
          #     fi
          #
          #-------------END DEBUGGING--------------------

          # Incase of db related checks, check if run in a loop, the OPSTAT is from last entry in loop
          # To fix that m_opstat array is created
          passed_hosts=$(echo "${m_opstat[$CUR_LEVEL]}" | sed 's/,failedontarget//g' | sed 's/failedontarget//g')
          if [[ -n "$passed_hosts" && $ISBRANCH -eq "1" ]]
          then # Succeeded in atleast one loop
            OPSTAT=1
          fi

          #this code manages traversing down the command hierarchy
          if [[ -z "$COMTYPE"  &&  -z "$LEVEL"  &&  "$L2" -eq 0 ]]
          then
            #this means there were no more "root" commands
            #we've reached the end of the hierarchy
            ROW=
          else
            if [[ $LEVEL -eq 1  &&  $ISBRANCH -eq 0 ]]
            then
              #this is a "root" command and no branching required
              #we've landed on a "non-branching root" command, the simplest case
              #increment the level one counter and re-initailze all the others
              #sets us up to look for the NEXT root command, whether branching or not
              CUR_LEVEL=1
              L1=$(($L1+1))
              L2=0;L3=0;L4=0;L5=0;L6=0;L7=0;L8=0;L9=0;L10=0
            elif [ $ISBRANCH -eq 0 ]
            then
              #the level is implicitly > 1 so we're executing a step at some level
              #we had to have gotten here as the result of a successful branch
              #need to determine if there are aby other commands at this level
              #we shoudl be on CUR_LEVEL.  CUR_LEVEL cannot be = 1
              case $CUR_LEVEL in
                2) L2=$(($L2+1)) ;;
                3) L3=$(($L3+1)) ;;
                4) L4=$(($L4+1)) ;;
                5) L5=$(($L5+1)) ;;
                6) L6=$(($L6+1)) ;;
                7) L7=$(($L7+1)) ;;
                8) L8=$(($L8+1)) ;;
                9) L9=$(($L9+1)) ;;
               10) L10=$(($L10+1)) ;;
                *) echo "ONLY 10 LEVELS OF BRANCHING ARE SUPPORTED [1 - $LEVEL,$CUR_LEVEL]" ;;
              esac
              #echo "L2 = $L2,  ROW = $L1.$L2.$L3.$L4.$L5.$L6.$L7.$L8.$L9.$L10,  CUR_LEVEL = $CUR_LEVEL"
            elif [[ $ISBRANCH -eq 1  &&  $OPSTAT -eq 1 ]]
            then
              #we're executing a branch at some level, need to take into account the
              #result , success or failure of the branch
              
              #-----------------DEBUGGING--------------------
              #       echo "BRANCH SUCCESS - $ROW"
              #----------------END DEBUGGING----------------
               
              #it the branch succeeds then we need to go a level deeper
              # to look for steps and or other branches
              #there should be steps if the data was entered correctly

              case $LEVEL in
                1) L2=$(($L2+1)) CUR_LEVEL=2 ;;
                2) L3=$(($L3+1)) CUR_LEVEL=3 ;;
                3) L4=$(($L4+1)) CUR_LEVEL=4 ;;
                4) L5=$(($L5+1)) CUR_LEVEL=5 ;;
                5) L6=$(($L6+1)) CUR_LEVEL=6 ;;
                6) L7=$(($L7+1)) CUR_LEVEL=7 ;;
                7) L8=$(($L8+1)) CUR_LEVEL=8 ;;
                8) L9=$(($L9+1)) CUR_LEVEL=9 ;;
                9) L10=$(($L10+1)) CUR_LEVEL=10 ;;
                *) echo "ONLY 10 LEVELS OF BRANCHING ARE SUPPORTED [2 - $LEVEL,$CUR_LEVEL]" ;;
              esac
            elif [[ $ISBRANCH -eq 1  &&  $OPSTAT -eq 0 ]]
            then
              #this could be a branch at any level (1-10) that failed
              #in that case we do not want to pursue any steps or branches
              #in its hierarchy.  we need to go back up one level to see
              #if there are any other steps or branches, except if the failing
              #bracn was already at level 1
              #when a branch fails we need to stay at the same level because
              #there could be other branches or steps at the same level as the
              #failed branch so we just need to increment the counter for the
              #current level as with the ISBRANCH=0 case

              #-----------------DEBUGGING--------------------
              #       echo "BRANCH FAILURE - $ROW"
              #----------------END DEBUGGING----------------
          
              case $CUR_LEVEL in
                1) L1=$(($L1+1)) ;;
                2) L2=$(($L2+1)) ;;
                3) L3=$(($L3+1)) ;;
                4) L4=$(($L4+1)) ;;
                5) L5=$(($L5+1)) ;;
                6) L6=$(($L6+1)) ;;
                7) L7=$(($L7+1)) ;;
                8) L8=$(($L8+1)) ;;
                9) L9=$(($L9+1)) ;;
               10) L10=$(($L10+1)) ;;
                *) echo "ONLY 10 LEVELS OF BRANCHING ARE SUPPORTED [3 - $LEVEL,$CUR_LEVEL]" ;;
              esac
            fi
            ROW=$L1.$L2.$L3.$L4.$L5.$L6.$L7.$L8.$L9.$L10
          fi
          #re-initialize LEVEL, the next row processed at top of loop should dictate
          #what level we are on byt parsing it from the data
          LEVEL=
        done
        #the above section is only going to be processed if $TYP = -a or -b
        ;;
    esac
  fi #OFFLINE checking for OS commands ends here
  
  case $TYP in
    -a|-p|-f|-u)
      if [[ $SILENT -eq 0 &&  $upgrade_mode -ne 2 ]] 
      then
        #SCRIPTVER=`grep $DBVERSION $REFFIL |awk {'print $3'}`
        #PATCHVER=`grep $SCRIPTVER $REFFIL |awk {'print $3'}`
        #NON_PCW_NUM=`grep -c RP_COMPARE_VALUE $REFFIL1`
        #if [[ -n "$crsdb_mixed_version" && $crsdb_mixed_version -eq 1 ]]
        #then
        #    PCW_NUM=`grep -c PP_COMPARE_VALUE $REFFIL2`
        #    #$READ -p "it came here and found $PCW_NUM patchs from $REFFIL2"
        #else
        PCW_NUM=`grep -c PP_COMPARE_VALUE $REFFIL1`
        #fi
        if [[ $no_patches -eq 0 && $TYP != "-p" && -n "$db_machine_compute" && $db_machine_compute -eq 0 ]] 
        then
          echo -e "\n\nBest Practice checking completed.Checking recommended patches on ${i}."
          echo -e "---------------------------------------------------------------------------------\n\n"
        fi
      fi
      PATCHRESULT=$OUTPUTDIR/o_patch_result_${i}.out
      pp_crs_pcount=0
      pp_crs_tcount=0
      pp_rdbms_pcount=0
      pp_asm_pcount=0
      rp_rdbms_pcount=0
      rp_rdbms_tcount=0
      rp_asm_pcount=0
      unset rs_crs_applied
      unset rs_rdbms_applied
      unset rs_asm_applied
      if [[ -n "${asm_installed[$stack_counter]}" && ${asm_installed[$stack_counter]} -eq 0 ]]
      then
        unset ASM_HOME
      fi
      ##================================================================================================
      # CHANGED DONE BY GIRI TO QUERY OPATCH RATHER THAN COMPS.XML TO FIND OUT  ABOUT PATCH IF NUMBER OF NODES ARE LESS THAN 5
	   
      #if [ `cat $HOSTLIST |wc -l` -lt 5  ]
      if [[ `cat $HOSTLIST |wc -l` -lt 999 && $OFFLINE -eq 0 && $upgrade_mode -ne 2 ]] 
      then
        echo -e "`date '+%a %b %d %H:%M:%S %Y'` - Recommended patches analysis on ${i}\n">>$RACCHECK_TIMING
        if [ $i = $localnode ]
        then 
          if [[ `echo $components|grep -iwc "NONE"` -ge 1 || `echo $components|grep -icw "CRS"` -ge 1 || `echo $components|grep -cwi "EXADATA"` -ge 1 || `echo $components|grep -icw "X2-2"` -ge 1 || `echo $components|grep -cwi "X2-8"` -ge 1 || `echo $components|grep -icw "ODA"` -ge 1 ]] || [[ `echo $components|grep -cwi "SIDB"` -ge 1 && $oracle_restart -eq "1" ]]
          then
	    echo "Collecting patch inventory on  CRS HOME $CRS"|tee -a $LOGFIL
	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then
	      OLD_OH=$ORACLE_HOME
	      ORACLE_HOME=$CRS
	      get_dbOwner
	      ORACLE_HOME=$OLD_OH
	      su $dbOwner -c "$CRS/OPatch/opatch lsinventory -oh $CRS > $TMP_OUTPUT/o_crs_inventory_${i}.out 2>>$ERRFIL"
	      crs_opatch_status=$(echo $?)
	      mv $TMP_OUTPUT/o_crs_inventory_${i}.out $OUTPUTDIR >/dev/null 2>&1 
	      cd $OLD_DIR
	      unset OLD_DIR
	    else
	      $CRS/OPatch/opatch lsinventory -oh $CRS > $OUTPUTDIR/o_crs_inventory_${i}.out 2>>$ERRFIL
	      crs_opatch_status=$(echo $?)
	    fi
	    #if opatch fails then copy comps.xml as second source of patch info
	    if [ $crs_opatch_status  -ne 0 ]
	    then 
	      echo "Opatch failed with error code $crs_opatch_status on $i for $CRS.\n\n${program_name} will use $CRS/inventory/ContentsXML/comps.xml as alternate source for installed recommended patch analysis">> $LOGFIL
	      cat $CRS/inventory/ContentsXML/comps.xml > $OUTPUTDIR/o_crs_inventory_${i}.out
	    fi
	    if [ $crs_opatch_status  -eq 0 ]
	    then
	      #cat $OUTPUTDIR/o_crs_inventory_${i}.out|grep -w ^Patch|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>$OUTPUTDIR/o_crs_patchlist_${i}.out
	      grep -w ^Patch $OUTPUTDIR/o_crs_inventory_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>$OUTPUTDIR/o_crs_patchlist_${i}.out
              echo "$i|crs|$CRS|${stack_crs_version[$stack_counter]}">$OUTPUTDIR/o_crs_installed_patchlist_${i}.out
              #cat $OUTPUTDIR/o_crs_inventory_${i}.out|grep -w ^Patch|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>>$OUTPUTDIR/o_crs_installed_patchlist_${i}.out
	      grep -w ^Patch $OUTPUTDIR/o_crs_inventory_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>>$OUTPUTDIR/o_crs_installed_patchlist_${i}.out
	    fi
          fi

          if [ -n "$ASM_HOME" ] && [[ `echo $components|grep -cwi "NONE"` -ge 1 || `echo $components|grep -icw "ASM"` -ge 1 || `echo $components|grep -cwi "EXADATA"` -ge 1 || `echo $components|grep -icw "X2-2"` -ge 1 || `echo $components|grep -cwi "X2-8"` -ge 1 || `echo $components|grep -icw "ODA"` -ge 1 ]]
	  then
            echo "Collecting patch inventory on ASM HOME $ASM_HOME"|tee -a $LOGFIL
	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then
	      OLD_OH=$ORACLE_HOME
	      ORACLE_HOME=$ASM_HOME
	      get_dbOwner
	      ORACLE_HOME=$OLD_OH
	      su $dbOwner -c "$ASM_HOME/OPatch/opatch lsinventory -oh $ASM_HOME > $TMP_OUTPUT/o_asm_inventory_${i}.out 2>>$ERRFIL"
              asm_opatch_status=$(echo $?)
	      mv $TMP_OUTPUT/o_asm_inventory_${i}.out $OUTPUTDIR >/dev/null 2>&1 
	      cd $OLD_DIR
	      unset OLD_DIR
	    else
	      $ASM_HOME/OPatch/opatch lsinventory -oh $ASM_HOME > $OUTPUTDIR/o_asm_inventory_${i}.out 2>>$ERRFIL
              asm_opatch_status=$(echo $?)
	    fi
            if [ $asm_opatch_status -ne 0 ]
            then 
              echo "Opatch failed with error code $asm_opatch_status on $i for $ASM_HOME.\n\n${program_name} will use $ASM_HOME/inventory/ContentsXML/comps.xml as alternate source for installed recommended patch analysis">> $LOGFIL
              cat $ASM_HOME/inventory/ContentsXML/comps.xml > $OUTPUTDIR/o_asm_inventory_${i}.out
            fi
            if [ $asm_opatch_status -eq 0 ]
            then
              #cat $OUTPUTDIR/o_asm_inventory_${i}.out|grep ^Patch|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>$OUTPUTDIR/o_asm_patchlist_${i}.out
              grep ^Patch $OUTPUTDIR/o_asm_inventory_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>$OUTPUTDIR/o_asm_patchlist_${i}.out
              echo "$i|asm|$ASM_HOME|$asm_version">$OUTPUTDIR/o_asm_installed_patchlist_${i}.out
              #cat $OUTPUTDIR/o_asm_inventory_${i}.out|grep ^Patch|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>>$OUTPUTDIR/o_asm_installed_patchlist_${i}.out 
              grep ^Patch $OUTPUTDIR/o_asm_inventory_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>>$OUTPUTDIR/o_asm_installed_patchlist_${i}.out 
            fi
	  fi

          if [[ `echo $components|grep -iwc "NONE"` -ge 1 || `echo $components|grep -icw "RDBMS"` -ge 1 || `echo $components|grep -cwi "EXADATA"` -ge 1 || `echo $components|grep -icw "X2-2"` -ge 1 || `echo $components|grep -cwi "X2-8"` -ge 1 || `echo $components|grep -icw "ODA"` -ge 1 || `echo $components|grep -icw "SIDB"` -ge 1 ]] 
          then
	    mb_db_counter=0
            for mb_db_homes in ${mb_oracle_homes_distinct[@]}
            do
              mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
              #$READ -p "mb_db_homes=$mb_db_homes"
              if [ -d $mb_db_homes ] 
              then
                rdbms_home_version=$(grep "$mb_db_homes" $OUTPUTDIR/mb_db_homes_distinct.out|sort -u|cut -d'|' -f2)
                if [[ -n "$upgrade_mode" && $upgrade_mode -eq 3 && $rdbms_home_version -ne $targetversion ]]
                then
                  echo "Skipping $mb_db_homes because running in post upgrade and version is $rdbms_home_version">>$LOGFIL
                else
              	  echo "Collecting patch inventory on ORACLE_HOME $mb_db_homes "|tee -a $LOGFIL
              	  export ORACLE_HOME=$mb_db_homes
		  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then
		    get_dbOwner
		    su $dbOwner -c "$ORACLE_HOME/OPatch/opatch lsinventory -oh $ORACLE_HOME > $TMP_OUTPUT/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out 2>>$ERRFIL"
              	    rdbms_opatch_status=$(echo $?)
		    mv $TMP_OUTPUT/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out $OUTPUTDIR >/dev/null 2>&1
	      	    cd $OLD_DIR
	    	    unset OLD_DIR
		  else
              	    $ORACLE_HOME/OPatch/opatch lsinventory -oh $ORACLE_HOME > $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out 2>>$ERRFIL
              	    rdbms_opatch_status=$(echo $?)
		  fi
              	  if [ $rdbms_opatch_status -ne 0 ]
              	  then 
              	    echo  "Opatch failed with error code $rdbms_opatch_status on $i for $ORACLE_HOME.\n\n${program_name} will use $ORACLE_HOME/inventory/ContentsXML/comps.xml as alternate source for installed recommended patch analysis">> $LOGFIL
              	    cat  $ORACLE_HOME/inventory/ContentsXML/comps.xml > $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out
              	  fi
              	  if [ $rdbms_opatch_status -eq 0 ]
              	  then
              	    #cat $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out|grep ^Patch|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>$OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${i}.out
              	    grep ^Patch $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>$OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${i}.out
                    echo "$i|rdbms|$ORACLE_HOME|$rdbms_home_version">$OUTPUTDIR/o_rdbms_installed_patchlist_${mb_db_homes_fil}_${i}.out
                    #cat $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out|grep ^Patch|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>>$OUTPUTDIR/o_rdbms_installed_patchlist_${mb_db_homes_fil}_${i}.out
                    grep ^Patch $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>>$OUTPUTDIR/o_rdbms_installed_patchlist_${mb_db_homes_fil}_${i}.out
              	  fi
                fi
              fi
              mb_db_counter=$(expr $mb_db_counter + 1)
            done
            mb_db_counter=0
          fi
        else    
          if [[ `echo $components|grep -iwc "NONE"` -ge 1 || `echo $components|grep -icw "CRS"` -ge 1 || `echo $components|grep -cwi "EXADATA"` -ge 1 || `echo $components|grep -icw "X2-2"` -ge 1 || `echo $components|grep -cwi "X2-8"` -ge 1 || `echo $components|grep -icw "ODA"` -ge 1  ]] || [[ `echo $components|grep -cwi "SIDB"` -ge 1 && $oracle_restart -eq "1" ]]  
          then
	    echo "Collecting patch inventory on  CRS HOME $CRS "|tee -a $LOGFIL
	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then
	      OLD_OH=$ORACLE_HOME
	      ORACLE_HOME=$CRS
	      get_dbOwner
	      ORACLE_HOME=$OLD_OH
	      $SSHELL $i "su $dbOwner -c \"$CRS/OPatch/opatch lsinventory -oh $CRS\"" > $TMP_OUTPUT/o_crs_inventory_${i}.out 2>>$ERRFIL
	      crs_opatch_status=$(echo $?)
	      mv $TMP_OUTPUT/o_crs_inventory_${i}.out $OUTPUTDIR >/dev/null 2>&1
	      cd $OLD_DIR
	      unset OLD_DIR
	    else
	      $SSHELL $i $CRS/OPatch/opatch lsinventory -oh $CRS > $OUTPUTDIR/o_crs_inventory_${i}.out 2>>$ERRFIL
	      crs_opatch_status=$(echo $?)
	    fi
	    if [ $crs_opatch_status  -ne 0 ] 
	    then 
	      echo "Opatch failed with error code $crs_opatch_status on $i for $CRS.\n\n${program_name} will use $CRS/inventory/ContentsXML/comps.xml as alternate source for installed recommended patch analysis">>$LOGFIL
	      $SSHELL $i  cat  $CRS/inventory/ContentsXML/comps.xml > $OUTPUTDIR/o_crs_inventory_${i}.out
	    fi
	    if [ $crs_opatch_status  -eq 0 ]
	    then
	      #cat $OUTPUTDIR/o_crs_inventory_${i}.out|grep ^Patch|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>$OUTPUTDIR/o_crs_patchlist_${i}.out
	      grep ^Patch $OUTPUTDIR/o_crs_inventory_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>$OUTPUTDIR/o_crs_patchlist_${i}.out
              echo "$i|crs|$CRS|${stack_crs_version[$stack_counter]}">$OUTPUTDIR/o_crs_installed_patchlist_${i}.out
              #cat $OUTPUTDIR/o_crs_inventory_${i}.out|grep -w ^Patch|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>>$OUTPUTDIR/o_crs_installed_patchlist_${i}.out
              grep -w ^Patch $OUTPUTDIR/o_crs_inventory_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>>$OUTPUTDIR/o_crs_installed_patchlist_${i}.out
	    fi
          fi

          if [ -n "$ASM_HOME" ] && [[ `echo $components|grep -cwi "NONE"` -ge 1  || `echo $components|grep -icw"ASM"` -ge 1 || `echo $components|grep -cwi "EXADATA"` -ge 1 || `echo $components|grep -icw "X2-2"` -ge 1 || `echo $components|grep -cwi "X2-8"` -ge 1 || `echo $components|grep -icw "ODA"` -ge 1 ]]
	  then
            echo "Collecting patch inventory on ASM HOME $ASM_HOME "|tee -a $LOGFIL
	    if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then
	      OLD_OH=$ORACLE_HOME
	      ORACLE_HOME=$ASM_HOME
	      get_dbOwner
	      ORACLE_HOME=$OLD_OH
	      $SSHELL $i "su $dbOwner -c \"$ASM_HOME/OPatch/opatch lsinventory -oh $ASM_HOME\"" > $TMP_OUTPUT/o_asm_inventory_${i}.out 2>>$ERRFIL
              asm_opatch_status=$(echo $?)
	      mv $TMP_OUTPUT/o_asm_inventory_${i}.out $OUTPUTDIR >/dev/null 2>&1
	      cd $OLD_DIR
	      unset OLD_DIR
	    else
	      $SSHELL $i $ASM_HOME/OPatch/opatch lsinventory -oh $ASM_HOME > $OUTPUTDIR/o_asm_inventory_${i}.out 2>>$ERRFIL
              asm_opatch_status=$(echo $?)
	    fi
            if [ $asm_opatch_status -ne 0 ]
            then
              echo "Opatch failed with error code $asm_opatch_status on $i for $ASM_HOME.\n${program_name} will use $ASM_HOME/inventory/ContentsXML/comps.xml as alternate source for installed recommended patch analysis">> $LOGFIL
              $SSHELL $i cat $ASM_HOME/inventory/ContentsXML/comps.xml > $OUTPUTDIR/o_asm_inventory_${i}.out
            fi
            if [ $asm_opatch_status -eq 0 ]
            then
              #cat $OUTPUTDIR/o_asm_inventory_${i}.out|grep ^Patch|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>$OUTPUTDIR/o_asm_patchlist_${i}.out
              grep ^Patch $OUTPUTDIR/o_asm_inventory_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>$OUTPUTDIR/o_asm_patchlist_${i}.out
              echo "$i|asm|$ASM_HOME|$asm_version">$OUTPUTDIR/o_asm_installed_patchlist_${i}.out
              #cat $OUTPUTDIR/o_asm_inventory_${i}.out|grep ^Patch|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>>$OUTPUTDIR/o_asm_installed_patchlist_${i}.out
              grep ^Patch $OUTPUTDIR/o_asm_inventory_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>>$OUTPUTDIR/o_asm_installed_patchlist_${i}.out
            fi
	  fi
          if [[ `echo $components|grep -iwc "NONE"` -ge 1 || `echo $components|grep -icw "RDBMS"` -ge 1 || `echo $components|grep -cwi "EXADATA"` -ge 1 || `echo $components|grep -icw "X2-2"` -ge 1 || `echo $components|grep -cwi "X2-8"` -ge 1 || `echo $components|grep -icw "ODA"` -ge 1 ]]
	  then
	    mb_db_counter=0
	    for mb_db_homes in ${mb_oracle_homes_distinct[@]}
	    do
	      mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
	      validate_remote_oracle_home=$($SSHELL $i ls -l $mb_db_homes >/dev/null 2>&1;echo $?)
	      if [[ -n "$validate_remote_oracle_home" && $validate_remote_oracle_home -eq 0 ]]
	      then
                rdbms_home_version=$(grep "$mb_db_homes" $OUTPUTDIR/mb_db_homes_distinct.out|sort -u|cut -d'|' -f2)
                if [[ -n "$upgrade_mode" && $upgrade_mode -eq 3 && $rdbms_home_version -ne $targetversion ]]
                then
	          echo "Skipping $mb_db_homes because running in post upgrade and version is $rdbms_home_version">>$LOGFIL
		else
		  echo "Collecting patch inventory on ORACLE_HOME $mb_db_homes "|tee -a $LOGFIL
		  export ORACLE_HOME=$mb_db_homes
		  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then
		    get_dbOwner
		    $SSHELL $i "su $dbOwner -c \"$ORACLE_HOME/OPatch/opatch lsinventory -oh $ORACLE_HOME\"" > $TMP_OUTPUT/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out 2>>$ERRFIL
		    rdbms_opatch_status=$(echo $?)
		    mv $TMP_OUTPUT/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out $OUTPUTDIR >/dev/null 2>&1
	      	    cd $OLD_DIR
	    	    unset OLD_DIR
		  else
		    $SSHELL $i $ORACLE_HOME/OPatch/opatch lsinventory -oh $ORACLE_HOME > $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out 2>>$ERRFIL
		    rdbms_opatch_status=$(echo $?)
		  fi
		  if [ $rdbms_opatch_status -ne 0 ]
		  then 
		    echo  "Opatch failed with error code $rdbms_opatch_status on $i for $ORACLE_HOME.\n\n${program_name} will use $ORACLE_HOME/inventory/ContentsXML/comps.xml as alternate source for installed recommended patch analysis">> $LOGFIL
		    $SSHELL $i cat $ORACLE_HOME/inventory/ContentsXML/comps.xml > $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out
		  fi
		  if [ $rdbms_opatch_status -eq 0 ]
		  then
		    #cat $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out|grep ^Patch|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>$OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${i}.out
		    grep ^Patch $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>$OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${i}.out
                    echo "$i|rdbms|$ORACLE_HOME|$rdbms_home_version">$OUTPUTDIR/o_rdbms_installed_patchlist_${mb_db_homes_fil}_${i}.out
                    #cat $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out|grep ^Patch|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>>$OUTPUTDIR/o_rdbms_installed_patchlist_${mb_db_homes_fil}_${i}.out
                    grep ^Patch $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out|awk '{print $2}'|grep -v [a-zA-Z]|sed '/^$/d'|sort>>$OUTPUTDIR/o_rdbms_installed_patchlist_${mb_db_homes_fil}_${i}.out
		  fi
                fi
	      fi
	      mb_db_counter=$(expr $mb_db_counter + 1)
	    done
	    mb_db_counter=0
          fi
        fi
      else
        if [ $SILENT = 1 ]
        then
          cp $CRS_INVENTORY $OUTPUTDIR/o_crs_comps_${i}.xml
          cp $RDBMS_INVENTORY $OUTPUTDIR/o_rdbms_comps_${i}xml
          if [[ -n $ASM  && $g112 -gt 0 ]]
          then
            cp $ASM_INVENTORY $OUTPUTDIR/o_asm_comps_${i}.xml
          fi
        fi
      fi
      ##================================================================================================
      #To format headings for patches on screen,output file and logfile 
      #IF RUNNING IN SILENT MODE, DONT CHECK PATCHES APPLIED OR NOT. JUST DUMP THE PATCH FILES ON OUTPUTDIR	
      #echo "DEBUG SILENT=$SILENT and RUNSWITCH=$RUNSWITCH"

      if [[ $SILENT -eq "0" && $RUNSWITCH != "-b"  &&  $no_patches -eq 0 && $db_machine_compute -eq 0 && $oda_machine -eq 0 ]]
      then  
        fmt_recomended="Patch#"
        fmt_rdbms="RDBMS"
        fmt_crs="CRS"
        fmt_asm="ASM"
        fmt_rdbms_home="RDBMS_HOME"
        fmt_patch_type_header="type"
        fmt_dscrp="Patch-Description"
        fmt_patch_yes="yes"
        fmt_patch_no="no"
        fmt_patch_type_merge="merge"
        fmt_patch_type_oneoff="single"
        fmt_hname=`echo $i`
        fmt_line_header="---------------------------------------------------------------------------------"
        fmt_ppheader_1="Total patches"
	fmt_ppheader_2="Applied on CRS"
	fmt_ppheader_4="Applied on ASM"
        fmt_ppheader_3="Applied on RDBMS"
        fmt_rpheader_1="Total patches"
        fmt_rpheader_2="Applied on RDBMS"
        fmt_rpheader_3="Applied on ASM"
        crs_patch_printed_html=0 # gadiga  track first time print to print heading
        pp_crs_tcount=$PCW_NUM
        if [[ $CREATE_HTML_REPORT -eq 1 && -e ${OUTPUTDIR}/o_crs_inventory_${i}.out ]]
        then
          print_crs_patch_detail_heading_html;
        fi
        set old_patch_type
        if [ -e ${OUTPUTDIR}/o_crs_inventory_${i}.out ]
        then
      	  echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL
      	  pcw_rec_num=$PCW_NUM
      	  RCPATCH=`grep _1-PP_RECOMMEND_VALUE $REFFIL1 |awk {'print $2'}`
      	  if [[ -n $RCPATCH ]] ; then pcw_rec_num=1; fi
      	  echo "$pcw_rec_num Recommended CRS patches for `echo ${stack_crs_version[$stack_counter]}|sed 's/\.//g'` from ${CRS} on $fmt_hname"|tee -a $LOGFIL|tee -a $PREPFIL
      	  echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL
      	  echo $fmt_recomended $fmt_crs $fmt_asm $fmt_rdbms $fmt_rdbms_home  $fmt_dscrp|awk '{printf "%-9s%-5s%-7s%-6s%-40s%-45s\n",$1,$2,$3,$4,$5,$6}'|tee -a $LOGFIL|tee -a $PREPFIL
      	  echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL
          if [[ $CREATE_HTML_REPORT -eq 1 && $PCW_NUM -eq "0" ]]
          then # For html report.. as we dont enter for loop, tell user that there are no patches
            print_crs_patch_detail_html;
          fi
      	  for ((j=1;j<=$PCW_NUM;j+=1));
      	  do
      	    SUBJ=`grep "_"$j"-PP_COMMAND" $REFFIL1 |sed  -n 's/.*-PP_COMMAND //p'` 
      	    PATCH=`grep _$j-PP_COMPARE_VALUE $REFFIL1 |awk {'print $2'}`
      	    RCPATCH=`grep _$j-PP_RECOMMEND_VALUE $REFFIL1 |awk {'print $2'}`
      	    PATCHTYPE=`grep _$j-PP_PARAM_PATH $REFFIL1 |awk {'print $2'}`
            PATCH2CHK=$PATCH
      	    if [ -n "$RCPATCH" ] ; then 
               PATCH=$RCPATCH; 
	       PATCH_PRINT=$RCPATCH;
	       SUBJ_PRINT=$SUBJ
            fi
      	    #==========================================================================================
      	    check_patch "crs" "$PATCH2CHK"
      	    ###=========================================================================================
      	    if [ -n "$RCPATCH" ] ; then pp_crs_tcount=1; fi
      	    if [ "$APPLIED" -gt "0" ]
      	    then
      	      fmt_crs_applied=$fmt_patch_yes
      	      rs_crs_applied=1
      	      pp_crs_pcount=$(($pp_crs_pcount+1))
      	      if [ -n "$RCPATCH" ] ; then pp_crs_pcount=1; fi
      	      #Added by kumar
      	      if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
      	      then
      	        echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','crs','$CRS','${stack_crs_version[$stack_counter]}','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',1,1,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
      	      fi
      	    else
      	      fmt_crs_applied=$fmt_patch_no
      	      rs_crs_applied=0
      	      if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
      	      then
      	  	echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','crs','$CRS','${stack_crs_version[$stack_counter]}','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',0,1,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
      	      fi
      	    fi
      	    mb_db_counter=0
      	    #$READ -p "${mb_db_versions_all[$mb_db_counter]} and  ${stack_crs_version[$stack_counter]}"
      	    for mb_db_homes in ${mb_oracle_homes_distinct[@]}
      	    do
      	      mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
      	      if [ -f ${OUTPUTDIR}/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out ]
      	      then
      	        rdbms_home_version=$(grep "$mb_db_homes" $OUTPUTDIR/mb_db_homes_distinct.out|sort -u|cut -d'|' -f2)
      	        #$READ -p "rdbms_home_version=$rdbms_home_version"
      	        if [[ -n "${stack_crs_version[$stack_counter]}" && -n "$rdbms_home_version" && ${rdbms_home_version} -eq `echo ${stack_crs_version[$stack_counter]}|sed 's/\.//g'` ]]
      	        then
      	          mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
      	          #==========================================================================================
      	          if [ -n "$RCPATCH" ] ; then 
                    j_k_applied=0
                    for j_k in `grep "PP_RECOMMEND_VALUE $RCPATCH" $REFFIL1 |cut -d"-" -f1 | tr -d "_"`
                    do
                      j_k_PATCH=`grep _$j_k-PP_COMPARE_VALUE $REFFIL1 |awk {'print $2'}`
                      check_patch "rdbms" "$j_k_PATCH"
                      j_k_applied=$(expr $j_k_applied + $APPLIED)
                    done 
                    APPLIED=$j_k_applied
                  else
      	            check_patch "rdbms" "$PATCH2CHK"
                  fi
      	          #==========================================================================================
                  #echo "patch log rdbms_home_version=$rdbms_home_version and mb_db_homes=$mb_db_homes for $i for CRS" 
		  print_rdbms_home_version=${rdbms_home_version};
		  if [[ -n "$print_rdbms_home_version" && `echo "$print_rdbms_home_version"|grep -c "\."` -eq 0 ]]; then
  		    print_rdbms_home_version=$(echo "$print_rdbms_home_version" | sed 's/[0-9]/&./g' | sed 's/\.//' | sed 's/.$//');
		  fi
      	          if [ "$APPLIED" -gt "0" ]
      	          then
      	      	    mb_fmt_rdbms_applied[$mb_db_counter]=$fmt_patch_yes
      	      	    mb_rs_rdbms_applied[$mb_db_counter]=1
      	      	    pp_rdbms_pcount=$(($pp_rdbms_pcount+1))
      	            if [ -n "$RCPATCH" ] ; then pp_rdbms_pcount=1; fi
      	      	    mb_pp_rdbms_pcount[$mb_db_counter]=$pp_rdbms_pcount
      	      	    mb_crs_oh[$mb_db_counter]=$mb_db_homes
      	      	    #Added by kumar
      	      	    if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
      	      	    then
      	      	      echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','rdbms','${mb_db_homes}','${print_rdbms_home_version}','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',1,1,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
      	      	    fi
      	          else
      	            mb_fmt_rdbms_applied[$mb_db_counter]=$fmt_patch_no
      	            mb_rs_rdbms_applied[$mb_db_counter]=0
      	            mb_crs_oh[$mb_db_counter]=$mb_db_homes
      	            if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
      	            then
      	              echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','rdbms','${mb_db_homes}','${print_rdbms_home_version}','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',0,1,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
      	            fi
      	          fi
      	     	fi
      	      fi
      	      mb_db_counter=$(expr $mb_db_counter + 1)
      	    done
      	    rdbms_home_count_for_crs=$mb_db_counter
      	    mb_db_counter=0
      	    if [[ -n "$ASM_HOME" && -e ${OUTPUTDIR}/o_asm_inventory_${i}.out ]]
      	    then
      	      #==========================================================================================
      	      check_patch "asm" "$PATCH2CHK"
      	      ###=========================================================================================

              #asm_version=$(cat $MASTERFIL|grep $i|grep -w VERSION|awk '{print $3}') 
              asm_version=$(grep $i $MASTERFIL|grep -w VERSION|awk '{print $3}') 
              if [ -z "$asm_version" ]; then asm_version=${stack_crs_version[$stack_counter]};fi
      	      if [ "$APPLIED" -gt "0" ]
      	      then
      	        fmt_asm_applied=$fmt_patch_yes
      	        rs_asm_applied=1
      	        pp_asm_pcount=$(($pp_asm_pcount+1))
      	        if [ -n "$RCPATCH" ] ; then pp_asm_pcount=1; fi
      	        #Added by kumar
      	        if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
      	        then
      	  	  echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','asm','$ASM_HOME','$asm_version','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',1,1,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
      	        fi
      	      else
      	         fmt_asm_applied=$fmt_patch_no
      	         rs_asm_applied=0
      	         if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
      	         then
      	  	   echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','asm','$ASM_HOME','$asm_version','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',0,1,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
      	         fi
      	      fi
      	    fi
            ####  #################################################
            if [ "$P_PATCH" != "$PATCH" ] ; then
      	    if [ $PATCHTYPE = "Merge" ] 
      	    then
      	      fmt_patch_type=$fmt_patch_type_merge
      	    else
      	      fmt_patch_type=$fmt_patch_type_oneoff
      	    fi
      	    #if [ $OFFLINE -eq 0 ] 
      	    #then
            if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
                echo $PATCH_PRINT |awk '{printf "%-9s",$1}'
	    else
		echo $PATCH |awk '{printf "%-9s",$1}'
	    fi
            if [[ `uname -s` = "AIX" || `uname -s` = "HP-UX" ]]
            then
	     if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
	      fmt_subj=`echo $SUBJ_PRINT |$AWK 'BEGIN { FS = "\n" };{print substr($1,0,79)}'`
	     else
      	      fmt_subj=`echo $SUBJ |$AWK 'BEGIN { FS = "\n" };{print substr($1,0,79)}'`
	     fi
      	      if [ $fmt_crs_applied = $fmt_patch_yes ]
      	      then
      	        echo -e $GREEN$fmt_crs_applied$NORM|$AWK '{printf "%-5s",$2}'
      	      else
      	        echo -e $RED $fmt_crs_applied $NORM|$AWK '{printf "%-5s",$2}'
      	      fi
      	      if [[ $fmt_asm_applied = $fmt_patch_yes && -n $ASM_HOME ]]
      	      then
      	        echo -e $GREEN $fmt_asm_applied $NORM|$AWK '{printf "%-6s",$2}'
      	      else
      	        echo -e $RED $fmt_asm_applied $NORM|$AWK '{printf "%-6s",$2}'
      	      fi
      	      mb_db_counter=0
      	      for mb_db_homes in ${mb_oracle_homes_distinct[@]}
      	      do
      	        if [ -n "${mb_fmt_rdbms_applied[$mb_db_counter]}" ]
      	        then
      	          fmt_rdbms_applied=${mb_fmt_rdbms_applied[$mb_db_counter]}
      	          mb_crs_rdbms_home=${mb_crs_oh[$mb_db_counter]}
      	          if [ $fmt_rdbms_applied = $fmt_patch_yes ]
      	          then
      	      	    echo -e $GREEN $fmt_rdbms_applied $NORM|$AWK '{printf "%-7s",$2}'
      	          else
      	      	    echo -e $RED $fmt_rdbms_applied $NORM|$AWK '{printf "%-7s",$2}'
      	          fi
      	          echo -e $mb_crs_rdbms_home|$AWK '{printf "%-19s",$1}'
      	        fi
      	        mb_db_counter=$(expr $mb_db_counter + 1)
      	      done  
      	      mb_db_counter=0
            else
             if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
              fmt_subj=`echo $SUBJ_PRINT |$AWK 'BEGIN { FS = "\n" };{print substr($1,0,79)}'`
             else
              fmt_subj=`echo $SUBJ |$AWK 'BEGIN { FS = "\n" };{print substr($1,0,79)}'`
             fi
      	      if [ $fmt_crs_applied = $fmt_patch_yes ]
      	      then
      	        echo -e $GREEN$fmt_crs_applied$NORM|$AWK '{printf "%-20s",$fmt_crs_applied}'
      	      else
      	        echo -e $RED $fmt_crs_applied $NORM|$AWK '{printf "%-20s",$fmt_crs_applied}'
      	      fi
      	      if [[ $fmt_asm_applied = $fmt_patch_yes && -n $ASM_HOME ]]
      	      then
      	        echo -e $GREEN $fmt_asm_applied $NORM|$AWK '{printf "%-20s",$fmt_asm_applied}'
      	      else
      	        echo -e $RED $fmt_asm_applied $NORM|$AWK '{printf "%-20s",$fmt_asm_applied}'
      	      fi
      	      mb_db_counter=0
              #echo  "mb_fmt_rdbms_applied=${mb_fmt_rdbms_applied[@]} and mb_crs_oh=${mb_crs_oh[@]}"
      	      for mb_db_homes in ${mb_oracle_homes_distinct[@]}
      	      do
      	        if [ -n "${mb_fmt_rdbms_applied[$mb_db_counter]}" ]
      	        then
      	      	  #$READ -p "fmt_rdbms_applied=$fmt_rdbms_applied and fmt_patch_yes=$fmt_patch_yes array=${mb_fmt_rdbms_applied[$mb_db_counter]}"
      	      	  fmt_rdbms_applied=${mb_fmt_rdbms_applied[$mb_db_counter]}
      	      	  mb_crs_rdbms_home=${mb_crs_oh[$mb_db_counter]}
      	      	  if [ $fmt_rdbms_applied = $fmt_patch_yes ]
      	      	  then
      	      	    echo -e $GREEN $fmt_rdbms_applied $NORM|$AWK '{printf "%-19s",$fmt_rdbms_applied}'
      	      	  else
      	      	    echo -e $RED $fmt_rdbms_applied $NORM|$AWK '{printf "%-19s",$fmt_rdbms_applied}'
      	      	  fi
      	      	  echo -e $mb_crs_rdbms_home|$AWK '{printf "%-19s",$mb_crs_rdbms_home}'
                  #echo -e "\n"|awk '{printf "%-40s",$1}'
      	          #echo -e $mb_db_homes|awk '{printf "%-40s",$mb_db_homes}'
      	        fi
      	        mb_db_counter=$(expr $mb_db_counter + 1)
      	      done
      	      mb_db_counter=0
              #$READ -p "stop"
            fi #end if of uname -s AIX
      	    #echo $fmt_patch_type|awk '{printf "%-8s",$fmt_patch_type}'
      	    #echo $fmt_patch_type|awk '{printf "%-8s",$1}'
      	    echo $PATCH $fmt_crs_applied $fmt_asm_applied $fmt_rdbms_applied $fmt_patch_type |awk '{printf "%-9s%-5s%-7s%-6s%-8s",$1,$2,$3,$4,$5}'>>$PREPFIL
      	    echo $PATCH $fmt_crs_applied $fmt_asm_applied $fmt_rdbms_applied $fmt_patch_type |awk '{printf "%-9s%-5s%-7s%-6s%-8s",$1,$2,$3,$4,$5}'>>$LOGFIL
      	    #$READ -p "PATCHRESULT=$PATCHRESULT"
      	    echo $PATCH@$rs_crs_applied@$rs_rdbms_applied@$rs_asm_applied >>$PATCHRESULT
      	    #echo $fmt_subj |awk '{printf "%-45s\n",$fmt_subj}'|tee -a $LOGFIL | tee -a $REPFIL

      	    if [[ `uname -s` = "AIX" || `uname -s` = "HP-UX" ]]
      	    then
      	      echo $fmt_subj |$AWK 'BEGIN { FS = "\n" };{printf "%-45s\n",$1}'|tee -a $LOGFIL | tee -a $PREPFIL
      	    else
      	      echo $fmt_subj |$AWK '{printf "%-45s\n",$fmt_subj}'|tee -a $LOGFIL | tee -a $PREPFIL
      	    fi
            fi #if [ "$P_PATCH" != "$PATCH" ] ; then
            P_PATCH=$PATCH

            if [ $CREATE_HTML_REPORT -eq 1 ]
            then
              print_crs_patch_detail_html;
            fi
      	    #else
      	    #echo $PATCH $fmt_crs_applied $fmt_rdbms_applied $fmt_asm_applied $fmt_patch_type |awk '{printf "%-9s%-5s%-7s%-6s%-8s",$1,$2,$3,$4,$5}'|tee -a $FREPFIL
      	    #echo $fmt_subj |awk '{printf "%-45s\n",$fmt_subj}'|tee -a $FREPFIL
            #fi
    	    #########################################################6
          done
        fi
        mb_db_counter=0
        OLD_REFFIL1=$REFFIL1
        P_PATCH=""
        #echo "${mb_oracle_homes_distinct[@]} ${mb_oracle_versions_distinct[@]} all version=${mb_db_version_all[@]}"
        if [[ -n "$single_instance_run" && $single_instance_run -eq "1" ]] ; then patch_prefix="SP"; else patch_prefix="RP"; fi;

        for mb_db_homes in ${mb_oracle_homes_distinct[@]}
        do  
          mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
          rp_rdbms_pcount=0
          rp_asm_pcount=0 
          if [ -f ${OUTPUTDIR}/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out ]
          then           
	    if [ $crsdb_mixed_version -eq 1 ]
	    then
              rdbms_home_version=$(grep "$mb_db_homes" $OUTPUTDIR/mb_db_homes_distinct.out|sort -u|cut -d'|' -f2)
	      if [ $OFFLINE -eq 0 ]
	      then 
	        REFFIL1=$INPUTDIR/rules_${rdbms_home_version}.dat
	        #REFFIL1=$INPUTDIR/rules_${mb_db_versions_all[$mb_db_counter]}.dat
	      else
	        REFFIL1=$DUMPDIR/rules_${rdbms_home_version}.dat
	      fi
	    fi
            #echo "mb_db_homes=$mb_db_homes $DUMPDIR/mb_db_homes_distinct.out crsdb_mixed_version=$crsdb_mixed_version" 
            NON_PCW_NUM=0  
	    if [ -r $REFFIL1 ]; then NON_PCW_NUM=$(grep -c ${patch_prefix}_COMPARE_VALUE $REFFIL1 2>$ERRFIL);fi
	    echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL
	    echo "" |tee -a $LOGFIL |tee -a $PREPFIL
	    echo "" |tee -a $LOGFIL |tee -a $PREPFIL
	    echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL
            non_pcw_rec_num=$NON_PCW_NUM
            RCPATCH=`grep _1-${patch_prefix}_RECOMMEND_VALUE $REFFIL1 |awk {'print $2'}`
            if [[ -n $RCPATCH ]] ; then non_pcw_rec_num=1; fi
	    echo "$non_pcw_rec_num Recommended RDBMS patches for ${rdbms_home_version} from ${mb_oracle_homes_distinct[$mb_db_counter]} on $i"|tee -a $LOGFIL|tee -a $PREPFIL
	    echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL
	    echo $fmt_recomended $fmt_rdbms $fmt_asm $fmt_patch_type_header $fmt_dscrp|awk '{printf "%-9s%-9s%-8s%-20s%-40s\n",$1,$2,$3,$4,$5}'|tee -a $LOGFIL|tee -a $PREPFIL
	    echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL
	    unset rs_crs_applied
	    unset rs_rdbms_applied
	    unset rs_asm_applied
	    napply_rdbms_cnt=0
	    napply_asm_cnt=0
	    napply_molecule=0
	    napply_molecule_cnt=1
	    unset rdbms_napply_missing_list
	    unset asm_napply_missing_list
            printed_rdbms_patch_html=0 # gadiga added to track first time
            rp_rdbms_tcount=${NON_PCW_NUM}
            if [[ $CREATE_HTML_REPORT -eq 1 && $NON_PCW_NUM -eq "0" ]]
            then
              print_rdbms_patch_detailed_html
            fi
	    #$READ -p "File being used $REFFIL1"
	    #$READ -p "File being used is $REFIL1 mb_db_counter=$mb_db_counter"
	    for ((j=1;j<=${NON_PCW_NUM:-0};j+=1)); 
	    do
	      y=1
	      unset isnapply
	      SUBJ=`grep "_"$j"-${patch_prefix}_COMMAND" $REFFIL1 |sed  -n 's/.*-'${patch_prefix}'_COMMAND //p'`
	      PATCH=`grep _$j-${patch_prefix}_COMPARE_VALUE $REFFIL1 |awk {'print $2'}`
	      RCPATCH=`grep _$j-${patch_prefix}_RECOMMEND_VALUE $REFFIL1 |awk {'print $2'}`
	      PATCHTYPE=`grep _$j-${patch_prefix}_PARAM_PATH $REFFIL1 |awk {'print $2'}`
              PATCH2CHK=$PATCH
              if [ -n "$RCPATCH" ] ; then
                 PATCH=$RCPATCH;
              fi
	      #$READ -p "PATCHTYPE=$PATCHTYPE"
	      #PATCHTYPE=`grep _$j-RP_PARAM_PATH $REFFIL1 |sed  -n 's/.*-RP_PARAM_PATH //p'`
	      
	      if [ $PATCHTYPE = "Merge" ]
	      then
	        fmt_patch_type=$fmt_patch_type_merge
	        isnapply=0
	      elif [ `echo $PATCHTYPE|grep -c "N-APPLY("` -ge 1 ]
	      then
	        isnapply=1
	        SUBJ=`grep "_"$j"-${patch_prefix}_COMMAND_SUBJ" $REFFIL1 |sed  -n 's/.*-'${patch_prefix}'_COMMAND_SUBJ//p'`
	        napply_molecule=$(grep -c $PATCHTYPE $REFFIL1)
	        fmt_patch_type=$(echo $PATCHTYPE|cut -d'(' -f1)
	      else
	        isnapply=0
	        fmt_patch_type=$fmt_patch_type_oneoff
	      fi
	      #if [[ $old_patch_type = $PATCHTYPE && $isnapply -eq 1 ]] 
	      #then
	      #  fmt_patch_type="$napply_molecule "
	      #fi  
	      #old_patch_type=$PATCHTYPE
	      #==========================================================================================
              if [ -n "$RCPATCH" ] ; then
                j_k_applied=0
                for j_k in `grep "${patch_prefix}_RECOMMEND_VALUE $RCPATCH" $REFFIL1 |cut -d"-" -f1 | tr -d "_"`
                do
                  j_k_PATCH=`grep _$j_k-${patch_prefix}_COMPARE_VALUE $REFFIL1 |awk {'print $2'}`
                  check_patch "rdbms" "$j_k_PATCH"
                  j_k_applied=$(expr $j_k_applied + $APPLIED)
                done
                APPLIED=$j_k_applied
              else
	        check_patch "rdbms" "$PATCH2CHK"
              fi
	      ###=========================================================================================
              #echo "patch log rdbms_home_version=$rdbms_home_version and mb_db_homes=$mb_db_homes for $i for RDBMS" 
      	      if [ -n "$RCPATCH" ] ; then rp_rdbms_tcount=1; fi
	      print_rdbms_home_version=${rdbms_home_version};
  	      if [[ -n "$print_rdbms_home_version" && `echo "$print_rdbms_home_version"|grep -c "\."` -eq 0 ]]; then
	        print_rdbms_home_version=$(echo "$print_rdbms_home_version" | sed 's/[0-9]/&./g' | sed 's/\.//' | sed 's/.$//');
	      fi
	      if [ "$APPLIED" -gt "0" ]
	      then
	        fmt_rdbms_applied=$fmt_patch_yes
	        rs_rdbms_applied=1
	        rp_rdbms_pcount=$(($rp_rdbms_pcount+1))
      	        if [ -n "$RCPATCH" ] ; then rp_rdbms_pcount=1; fi
	        if [ $isnapply -eq 1 ]
	        then 
	          napply_rdbms_cnt=$(($napply_rdbms_cnt+1))
	          fmt_rdbms_applied_napply=$(echo ${napply_rdbms_cnt}/${napply_molecule})
	        fi
	        #Added by kumar
	        if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
	        then
	          echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','rdbms','${mb_db_homes}','${print_rdbms_home_version}','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',1,1,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
	        fi   
	      else
	        fmt_rdbms_applied=$fmt_patch_no
	        rs_rdbms_applied=0
	        #Added by kumar
	        if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
	        then   
	          echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','rdbms','${mb_db_homes}','${print_rdbms_home_version}','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',0,1,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
	        fi 
	        if [ $isnapply -eq 1 ]
	        then 
	          fmt_rdbms_applied_napply=$(echo ${napply_rdbms_cnt}/${napply_molecule})
	          if [ -z "$rdbms_napply_missing_list" ] 
	          then
	            rdbms_napply_missing_list=${PATCH}
	          else
	            rdbms_napply_missing_list=$(echo ${rdbms_napply_missing_list}","${PATCH})
	          fi
	        fi
	      fi
	      #echo "ASM_HOME=$ASM_HOME" 
	      if [[ -n "$ASM_HOME" && -e ${OUTPUTDIR}/o_asm_inventory_${i}.out ]]
	      then
	        #==========================================================================================
	        check_patch "asm" "$PATCH2CHK" 
	        ###=========================================================================================
                #asm_version=$(cat $MASTERFIL|grep $i|grep -w VERSION|awk '{print $3}')
                asm_version=$(grep $i $MASTERFIL|grep -w VERSION|awk '{print $3}')
                if [ -z "$asm_version" ]; then asm_version=${stack_crs_version[$stack_counter]};fi
	        if [ "$APPLIED" -gt "0" ]
	        then
	          fmt_asm_applied=$fmt_patch_yes
	          rp_asm_pcount=$(($rp_asm_pcount+1))
      	          if [ -n "$RCPATCH" ] ; then rp_asm_pcount=1; fi
	          rs_asm_applied=1
	          if [ $isnapply -eq 1 ]
	          then 
	             napply_asm_cnt=$(($napply_asm_cnt+1))
	             fmt_asm_applied_napply=$(echo ${napply_asm_cnt}/${napply_molecule})
	          fi
	          #Added by kumar
	          if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
	          then   
	             echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','asm','$ASM_HOME','$asm_version','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',1,1,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
	          fi
	        else
	          fmt_asm_applied=$fmt_patch_no
	          rs_asm_applied=0
	          #Added by kumar
	          if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
	          then
	            echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended,upload_collection_name)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','asm','$ASM_HOME','$asm_version','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',0,1,'$upload_collection_name');">>$upload_raccheck_patch_result_fil
	          fi
	          if [ $isnapply -eq 1 ]
	          then 
	            #napply_asm_cnt=$(($napply_rdbms_cnt+1))
	            fmt_asm_applied_napply=$(echo ${napply_asm_cnt}/${napply_molecule})
	            if [ -z "$asm_napply_missing_list" ]
	            then
	              asm_napply_missing_list=${PATCH}
	            else
	              asm_napply_missing_list=$(echo ${asm_napply_missing_list}","${PATCH})
	            fi
	          fi
	        fi
	      fi
	      if [ $isnapply -eq 1 ]
	      then
	        PATCH=$(echo $PATCHTYPE|sed  -n 's/.*(//p'|sed 's/)//g')
	      fi
	      #$READ -p " $napply_molecule and  $napply_molecule_cnt $PATCH nappy=$isnapply rdbms_napply_missing_list=$rdbms_napply_missing_list" 
	      if  [[ $isnapply -eq 1 && $napply_molecule_cnt -lt $napply_molecule ]]
	      then
	        napply_molecule_cnt=$(($napply_molecule_cnt+1))
	      else
                if [ "$P_PATCH" != "$PATCH" ] ; then
	        echo $PATCH |awk '{printf "%-9s",$1}'
	        #$READ -p "napply_rdbms_cnt=$napply_rdbms_cnt and napply_molecule_cnt=$napply_molecule_cnt"
	        if [ $isnapply -eq 1 ] && [[ $napply_rdbms_cnt -gt 0 && $napply_rdbms_cnt -lt $napply_molecule_cnt ]]
	        then
	          fmt_rdbms_applied=$fmt_patch_no
	          fmt_asm_applied=$fmt_patch_no
	          if [[ `uname -s` = "AIX" || `uname -s` = "HP-UX" ]]
	          then
	            fmt_subj=`echo $SUBJ |$AWK 'BEGIN { FS = "\n" };{print substr($1,0,80)}'`
	            if [ $fmt_rdbms_applied = $fmt_patch_yes ]
	            then
	              echo -e $GREEN $fmt_rdbms_applied_napply $NORM|$AWK '{printf "%-9s",$2}'
	            else
	              echo -e $RED $fmt_rdbms_applied_napply $NORM|$AWK '{printf "%-9s",$2}'  
	            fi
	            echo "Missing fixes from n-apply patch $PATCH from RDBMS HOME  are $rdbms_napply_missing_list" > $napply_missing_list
	            if [[ $fmt_asm_applied = $fmt_patch_yes && -n $ASM_HOME ]]
	            then
	              echo -e $GREEN $fmt_asm_applied_napply $NORM|$AWK '{printf "%-8s",$2}'
	            else
	              echo -e $RED $fmt_asm_applied_napply $NORM|$AWK '{printf "%-8s",$2}'
	            fi
	            if [ -n "$ASM_HOME" ]
	            then
	              echo "Missing fixes from n-apply patch $PATCH from ASM HOME are $asm_napply_missing_list" >> $napply_missing_list
	            fi
	          else 
	            fmt_subj=`echo $SUBJ |$AWK '{print substr($SUBJ,0,80)}'`
	            if [ $fmt_rdbms_applied = $fmt_patch_yes ]
	            then
	              echo -e $GREEN $fmt_rdbms_applied_napply $NORM|$AWK '{printf "%-22s",$fmt_rdbms_applied}'
	            else
	              echo -e $RED $fmt_rdbms_applied_napply $NORM|$AWK '{printf "%-22s",$fmt_rdbms_applied}'  
	            fi 
	            echo "Missing fixes from n-apply patch $PATCH from RDBMS HOME  are $rdbms_napply_missing_list" >>  $napply_missing_list
	            if [[ $fmt_asm_applied = $fmt_patch_yes && -n $ASM_HOME ]]
	            then
	              echo -e $GREEN $fmt_asm_applied_napply $NORM|$AWK '{printf "%-22s",$fmt_asm_applied}'
	            else
	              echo -e $RED $fmt_asm_applied_napply $NORM|$AWK '{printf "%-22s",$fmt_asm_applied}'
	            fi
	            if [ -n "$ASM_HOME" ]
	            then
	              echo "Missing fixes from n-apply  patch $PATCH from ASM HOME are $asm_napply_missing_list" >> $napply_missing_list
	            fi
	          fi
	          echo $fmt_patch_type|$AWK '{printf "%-20s",$1}'
	          echo $PATCH $fmt_rdbms_applied_napply $fmt_asm_applied_napply $fmt_patch_type|$AWK '{printf "%-9s%-9s%-8s%-20s",$1,$2,$3,$4}'>>$LOGFIL
	          echo $PATCH $fmt_rdbms_applied_napply $fmt_asm_applied_napply $fmt_patch_type|$AWK '{printf "%-9s%-9s%-8s%-20s",$1,$2,$3,$4}'>>$PREPFIL
                  if [ $CREATE_HTML_REPORT -eq 1 ]
                  then
                    print_rdbms_patch_detailed_html "$PATCH" "$fmt_rdbms_applied_napply" "$fmt_asm_applied_napply" "$fmt_patch_type"
                  fi
	        else
	          if [[ `uname -s` = "AIX" || `uname -s` = "HP-UX" ]]
	          then
	            fmt_subj=`echo $SUBJ |$AWK 'BEGIN { FS = "\n" };{print substr($1,0,60)}'`
	            if [ $fmt_rdbms_applied = $fmt_patch_yes ]
	            then
	              echo -e $GREEN $fmt_rdbms_applied $NORM|$AWK '{printf "%-9s",$2}'
	            else
	              echo -e $RED $fmt_rdbms_applied $NORM|$AWK '{printf "%-9s",$2}'  
	            fi 
	            if [[ $fmt_asm_applied = $fmt_patch_yes && -n $ASM_HOME ]]
	            then
	              echo -e $GREEN $fmt_asm_applied $NORM|$AWK '{printf "%-8s",$2}'
	            else
	              echo -e $RED $fmt_asm_applied $NORM|$AWK '{printf "%-8s",$2}'
	            fi
	          else 
	            fmt_subj=`echo $SUBJ |awk '{print substr($SUBJ,0,80)}'`
	            if [ $fmt_rdbms_applied = $fmt_patch_yes ]
	            then
	              echo -e $GREEN $fmt_rdbms_applied $NORM|$AWK '{printf "%-22s",$fmt_rdbms_applied}'
	            else
	              echo -e $RED $fmt_rdbms_applied $NORM|$AWK '{printf "%-22s",$fmt_rdbms_applied}'  
	            fi 
	            if [[ $fmt_asm_applied = $fmt_patch_yes && -n $ASM_HOME ]]
	            then
	              echo -e $GREEN $fmt_asm_applied $NORM|$AWK '{printf "%-22s",$fmt_asm_applied}'
	            else
	              echo -e $RED $fmt_asm_applied $NORM|$AWK '{printf "%-22s",$fmt_asm_applied}'
	            fi
	          fi
	          echo $fmt_patch_type|$AWK '{printf "%-20s",$1}'
	          echo $PATCH $fmt_rdbms_applied $fmt_asm_applied $fmt_patch_type|$AWK '{printf "%-9s%-9s%-8s%-20s",$1,$2,$3,$4}'>>$LOGFIL
	          echo $PATCH $fmt_rdbms_applied $fmt_asm_applied $fmt_patch_type|awk '{printf "%-9s%-9s%-8s%-20s",$1,$2,$3,$4}'>>$PREPFIL
                  if [ $CREATE_HTML_REPORT -eq 1 ]
                  then
                    print_rdbms_patch_detailed_html "$PATCH" "$fmt_rdbms_applied" "$fmt_asm_applied" "$fmt_patch_type"
                  fi
	        fi
	        #echo $fmt_patch_type|awk '{printf "%-20s",$1}'
	        #echo $PATCH $fmt_rdbms_applied $fmt_asm_applied $fmt_patch_type|awk '{printf "%-9s%-9s%-8s%-20s",$1,$2,$3,$4}'>>$LOGFIL
	        #echo $PATCH $fmt_rdbms_applied $fmt_asm_applied $fmt_patch_type|awk '{printf "%-9s%-9s%-8s%-20s",$1,$2,$3,$4}'>>$REPFIL
	        if [[ `uname -s` = "AIX"  || `uname -s` = "HP-UX" ]]
	        then
	          echo $fmt_subj |$AWK 'BEGIN { FS = "\n" };{printf "%-40s\n",$1}'|tee -a $LOGFIL | tee -a $PREPFIL
	        else
	          echo $fmt_subj |$AWK '{printf "%-40s\n",$fmt_subj}'|tee -a $LOGFIL | tee -a $PREPFIL
	        fi
	        #echo "missing patch list $rdbms_napply_missing_list and $asm_napply_missing_list"
	        napply_molecule_cnt=1
	        napply_rdbms_cnt=0
	        napply_asm_cnt=0
	        unset rdbms_napply_missing_list
	        unset asm_napply_missing_list
	      fi
	      #$READ -p "PATCHRESULT=$PATCHRESULT"
	      echo $PATCH@$rs_crs_applied@$rs_rdbms_applied@$rs_asm_applied>>$PATCHRESULT
              fi #if [ "$P_PATCH" != "$PATCH" ] ; then
              P_PATCH=$PATCH
	    done 
	    mb_non_pcw_num[$mb_db_counter]=$rp_rdbms_tcount
	    mb_rp_rdbms_pcount[$mb_db_counter]=$rp_rdbms_pcount
	    mb_rp_asm_pcount[$mb_db_counter]=$rp_asm_pcount
	    echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
	    if [[ -f $napply_missing_list  ]]
	    then
	      echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
	      cat $napply_missing_list>>$PREPFIL
	      rm $napply_missing_list
	    fi
          fi
          mb_db_counter=$(expr $mb_db_counter + 1)
        done
        REFFIL1=$OLD_REFFIL1
        mb_db_counter=0
     
        P_PATCH=""
        #$READ -p "it should work till here"
        #echo "OFFLINE=$OFFLINE TYP=$TYP RUNSWITCH=$RUNSWITCH single_instance_run=$single_instance_run"
        if [[ $OFFLINE -eq 0 && "$TYP" = "-a" || "$TYP" = "-p"  ]] || [[ $OFFLINE -eq 1 && "$RUNSWITCH" = "-a" || "$RUNSWITCH" = "-p" && $single_instance_run -eq 0 ]]
        then
          if [[ $single_instance_run -eq "0" ]] || [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
            if [[ $single_instance_run -eq "1" && $oracle_restart -eq "1" ]] ; then
               head="ASM"
            else
               head="Clusterware"
            fi 
            echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            echo ""|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            echo ""|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            echo "              $head patches summary report"|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            if [[ `uname -s` = "AIX" || `uname -s` = "HP-UX" ]]
            then
              echo $fmt_ppheader_1|awk 'BEGIN { FS = "\n" } ;{printf "%-15s",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL        
              echo $fmt_ppheader_2|awk 'BEGIN { FS = "\n" } ;{printf "%-15s",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL        
              echo $fmt_ppheader_3|awk 'BEGIN { FS = "\n" } ;{printf "%-17s",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL        
              echo $fmt_ppheader_4|awk 'BEGIN { FS = "\n" } ;{printf "%-15s\n",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL                       
            else
              echo $fmt_ppheader_1|awk '{printf "%-15s",$fmt_ppheader_1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
              echo $fmt_ppheader_2|awk '{printf "%-15s",$fmt_ppheader_2}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
              echo $fmt_ppheader_3|awk '{printf "%-17s",$fmt_ppheader_3}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
              echo $fmt_ppheader_4|awk '{printf "%-15s\n",$fmt_ppheader_4}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            fi
            echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL  
            echo $pp_crs_tcount $pp_crs_pcount $pp_rdbms_pcount $pp_asm_pcount |awk '{printf "%-15s%-15s%-17s%-15s\n",$1,$2,$3,$4}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            if [ $CREATE_HTML_REPORT -eq 1 ]
            then
              print_cluster_patch_summary_html;
            fi
          fi
          echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          echo ""|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          echo ""|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          echo "              RDBMS homes patches summary report"|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          if [[ `uname -s` = "AIX" || `uname -s` = "HP-UX" ]]
          then
            echo $fmt_rpheader_1|awk 'BEGIN { FS = "\n" } ;{printf "%-15s",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            echo $fmt_rpheader_2|awk 'BEGIN { FS = "\n" } ;{printf "%-17s",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            echo $fmt_rpheader_3|awk 'BEGIN { FS = "\n" } ;{printf "%-15s",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            echo ORACLE_HOME    |awk 'BEGIN { FS = "\n" } ;{printf "%-20s\n",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          else
            echo $fmt_rpheader_1|awk '{printf "%-15s",$fmt_rpheader_1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            echo $fmt_rpheader_2|awk '{printf "%-17s",$fmt_rpheader_2}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            echo $fmt_rpheader_3|awk '{printf "%-15s",$fmt_rpheader_3}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
            echo ORACLE_HOME|awk '{printf "%-15s\n",$fmt_rpheader_3}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          fi
          echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          mb_db_counter=0
          mb_db_counter_printed=0 # gadiga Required for html printing
          for mb_db_homes in ${mb_oracle_homes_distinct[@]}
          do 
            mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
            if [ -f ${OUTPUTDIR}/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out ]
            then
              echo ${mb_non_pcw_num[$mb_db_counter]} ${mb_rp_rdbms_pcount[$mb_db_counter]} ${mb_rp_asm_pcount[$mb_db_counter]} $mb_db_homes|awk '{printf " %-15s%-15s%-17s%-20s\n",$1,$2,$3,$4}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
              if [ $CREATE_HTML_REPORT -eq 1 ]
              then
                print_rdbms_patch_summary_html 1;
              fi
            else
              if [ $CREATE_HTML_REPORT -eq 1 ]
              then
                print_rdbms_patch_summary_html 0;
              fi
            fi
            mb_db_counter=$(expr $mb_db_counter + 1)
          done
          mb_db_counter=0
          mb_db_counter_printed=0
          echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          echo ""|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          echo ""|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
          #else
          #echo $fmt_line_header|tee -a $FREPFIL
          #echo ""|tee -a $FREPFIL
          #echo ""|tee -a $FREPFIL
        fi
      fi # THIS IS THE END OF CHECKING THE SILENT MODE
         #the patch checks are only going to be process if $TYP = -a or -p
      ;;
  esac
  #To delete temporary set ORACLE env file after doing all processing
  #for rmFile in `cat $HOSTLIST`
  #do
  #  
  #  if [ -f /tmp/root_"$rmFile".sh ]
  #  then
  #    rm /tmp/root_"$rmFile".sh
  #  fi
  #  ls -l /tmp/root_"$rmFile".sh
  #  $READ -p " rm -f /tmp/root_"$rmFile".sh" 
  #done

  if [ $i = $localnode ]
  then
    #rm $TRGTORCLENV 2>/dev/null
    rm ${RTEMPDIR}/o_*${i}.out 2>/dev/null
    #rm /tmp/raccheck_env.out 2>/dev/null
  elif [ $OFFLINE -eq 0 ] 
  then
    #$SSHELL $i "rm $TRGTORCLENV" 2>/dev/null
    $SSHELL $i "rm ${RTEMPDIR}/o_*${i}.out" 2>/dev/null
    #$SSHELL $i "rm /tmp/raccheck_env.out" 2>/dev/null
  fi
  rm $TMPDIR/root_"$i".sh >/dev/null 2>&1
  
  #loop to delete all os collect files created for os checks
  for collect_file_name in "${collect_files[@]}"
  do
    if [ -f $collect_file_name ]; then rm $collect_file_name; fi;
  done
  os_check_needs_collect_file=0 
  
  #this counter is used to track which instance and crs is being worked upon.0 for 1st node and 1 for second node and so forth
  stack_counter=`expr $stack_counter + 1`
  echo
  #echo "Finished run on node $i.. parallel=$RAT_COMPUTE_PARALLEL runmode=$RAT_RUNMODE_INTERNAL";
  #-----------------------------------------------
  #if [[ -n "$RAT_COMPUTE_PARALLEL" && $RAT_COMPUTE_PARALLEL -eq "1" && $RAT_RUNMODE_INTERNAL = "master" ]] ; then
  #  wait_for_compute_completion
  #  echo "waited for completeion";
  #fi
  #OFFLINE=1
done
#HOST LOOP Ends
get_current_epoch "1"
end_time=$epoch_time

echo "End Time:$end_time" >> $LOGFIL

let chk_dur=$end_time-$start_time
let dh=$chk_dur/3600
let dm=($chk_dur-3600*$dh)/60
let ds=($chk_dur-3600*$dh)-60*$dm
dsec=$(echo "$ds" | awk '{printf("%d\n",$1 + 0.5)}')

if [ $dh -gt 0 ]; then
  checks_duration="$dh Hours, $dm mins, $dsec seconds";
else
  if [ $dm -gt 0 ]; then
    checks_duration="$dm mins, $dsec seconds";
  else
    checks_duration="$dsec seconds";
  fi
fi

if [ -e $MASTERFIL ]; then echo "CHECKS_DURATION = $checks_duration" >> $MASTERFIL; fi

#printf "Total runtime: %02d:%02d:%02.4f\n" $dh $dm $ds
#echo "Total runtime: $dd $dh $dm $ds"

if [ -n "$MERGEFILES" ]
then
  rm -rf $HOSTLIST
  mv $HOSTLIST.new $HOSTLIST
fi

if [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]]
then
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then
    mv "$ERRFIL" $RTEMPDIR/${program_name}_${FDS}/ >/dev/null 2>&1  
  fi
  diff $MASTERFIL.saved $MASTERFIL > $MASTERFIL.diff
  OFFLINE=1
  killtree $watchdog_pid 9 >/dev/null 2>&1
  exit 0;
fi

if [[ $OFFLINE -eq 0 && -n "$RAT_COMPUTE_RUNMODE" && $RAT_COMPUTE_RUNMODE = "parallel" && $RAT_RUNMODE_INTERNAL = "master" ]] ; then
  mv $HOSTLIST.org $HOSTLIST
  wait_for_compute_completion
  OFFLINE=0
fi

#following code is to check that same patches are installed on each node for every oracle home

#To delete 0 byte files 
if [ $is_windows -eq "0" ] ; then
  find $OUTPUTDIR -size -1c  -exec rm -r {} \; #TEMPCHANGE
fi
IFS=$'\n'

insertStatementsForInstalledPatches 'rdbms' $ORACLE_HOME ${stack_dbinst_version[$stack_counter]}
insertStatementsForInstalledPatches 'crs' $CRS ${stack_crs_version[$stack_counter]}
insertStatementsForInstalledPatches 'asm' $ASM_HOME 

if [ -z $MERGEFILES ]; then uploadInstalledPatches; fi

#have to set IFS back to default to get patch loop working. otherwise it was treating both hostname as sinle line
if [ `cat $HOSTLIST|wc -l` -gt 1 ]
then
  patch_counter=0
  for h_patch in `cat $HOSTLIST`
  do
    if [ $patch_counter -eq 0 ]
    then
      if [ -f $OUTPUTDIR/o_crs_patchlist_${h_patch}.out ]; then source_crs=$OUTPUTDIR/o_crs_patchlist_${h_patch}.out;fi;
    else
      if [ -f $OUTPUTDIR/o_crs_patchlist_${h_patch}.out ]  
      then
        diff $source_crs $OUTPUTDIR/o_crs_patchlist_${h_patch}.out >/dev/null 2>&1
        if [ $? -eq 0 ]; then crs_patch_diff=1;else crs_patch_diff=0;break;fi
      fi
    fi
    patch_counter=$(expr $patch_counter + 1)
  done
  if [[ -f $OUTPUTDIR/o_crs_patchlist_${h_patch}.out && $crs_patch_diff -eq 1 ]] 
  then
    CRS_PATCH_MSG="${GREEN} PASS =>$NORM    CRS home has same number of patches installed across the cluster."
    crs_patch_check_status=1
  elif [  -f $OUTPUTDIR/o_crs_patchlist_${h_patch}.out ]
  then
    CRS_PATCH_MSG="${RED} FAIL =>$NORM    CRS home does not have same number of patches installed across the cluster."
    crs_patch_check_status=0
  fi

  mb_db_counter=0
  for mb_db_homes in ${mb_oracle_homes_distinct[@]}
  do
    mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
    patch_counter=0
    for h_patch in `cat $HOSTLIST`
    do
      #$READ -p "file to read=$OUTPUTDIR/o_rdbms_patchlist_${h_patch}_${mb_db_homes_fil}.out hostname=$h_patch"
      if [ $patch_counter -eq 0 ]
      then
        if [ -f $OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${h_patch}.out ]; then source_rdbms=$OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${h_patch}.out;fi;
      else
        #$READ -p "$source_rdbms $OUTPUTDIR/o_rdbms_patchlist_${h_patch}.out"
        if [ -f $OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${h_patch}.out ]  
        then
  	  #$READ -p "$source_rdbms $OUTPUTDIR/o_rdbms_patchlist_${h_patch}_${mb_db_homes_fil}.out"
          diff $source_rdbms $OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${h_patch}.out >/dev/null 2>&1
          if [ $? -eq 0 ]; then mb_rdbms_patch_diff[$mb_db_counter]=1;else mb_rdbms_patch_diff[$mb_db_counter]=0;break;fi
        fi
      fi
      #$READ -p "rdbms_patch_diff=${mb_rdbms_patch_diff[$mb_db_counter]} patch_counter=$patch_counter"
      patch_counter=$(expr $patch_counter + 1)
    done 
    mb_db_counter=$(expr $mb_db_counter + 1)
  done

  mb_db_counter=0
  for mb_db_homes in ${mb_oracle_homes_distinct[@]}
  do
    mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
    if [[ -f $OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${h_patch}.out && ${mb_rdbms_patch_diff[$mb_db_counter]} -eq 1 ]] 
    then
      MB_RDBMS_PATCH_MSG[$mb_db_counter]="${GREEN} PASS =>$NORM    RDBMS home ${mb_db_homes} has same number of patches installed across the cluster."
      mb_rdbms_patch_check_status[$mb_db_counter]=1
    elif [  -f $OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${h_patch}.out ]
    then
      MB_RDBMS_PATCH_MSG[$mb_db_counter]="${RED} FAIL =>$NORM    RDBMS home ${mb_db_homes} does not have same number of patches installed across the cluster."
      mb_rdbms_patch_check_status[$mb_db_counter]=0
    fi
    mb_db_counter=$(expr $mb_db_counter + 1)
  done
  mb_db_counter=0

  patch_counter=0
  for h_patch in `cat $HOSTLIST`
  do
    if [ $patch_counter -eq 0 ]
    then
      if [ -f $OUTPUTDIR/o_asm_patchlist_${h_patch}.out ]; then source_asm=$OUTPUTDIR/o_asm_patchlist_${h_patch}.out;fi;
    else
      if [ -f $OUTPUTDIR/o_asm_patchlist_${h_patch}.out ]  
      then
        diff $source_asm $OUTPUTDIR/o_asm_patchlist_${h_patch}.out >/dev/null 2>&1
        if [ $? -eq 0 ]; then asm_patch_diff=1;else asm_patch_diff=0;break;fi
      fi
    fi
    patch_counter=$(expr $patch_counter + 1)
  done

  patch_counter=0
  if [[ -f $OUTPUTDIR/o_asm_patchlist_${h_patch}.out && $asm_patch_diff -eq 1 ]] 
  then
    ASM_PATCH_MSG="${GREEN} PASS =>$NORM    ASM home has same number of patches installed across the cluster."
    asm_patch_check_status=1
  elif [  -f $OUTPUTDIR/o_asm_patchlist_${h_patch}.out ]
  then
    ASM_PATCH_MSG="${RED} FAIL =>$NORM    ASM home does not have same number of patches installed across the cluster."
    asm_patch_check_status=0
  fi
fi
#following code is to check clustewide checks
#echo "stack_counter=$stack_counter clusterware_check_count=$clusterware_check_count clusterware_check_count_old=$clusterware_check_count_old"

#$READ -p "stack_counter=$stack_counter ${cls_check_host_list[*]} ${cls_check_host_list[0]} and ${cls_check_host_list[1]}"
#To set clusterware_check_count value from a compute node if last node was a control VM.
if [[ $clusterware_check_count -ne $clusterware_check_count_old && $clusterware_check_count_old -gt 0 ]]; then clusterware_check_count=$clusterware_check_count_old;fi
#$READ -p "clusterware_check_count=$clusterware_check_count clusterware_check_count_old=$clusterware_check_count_old"
if [[ -z "$MERGEFILES" ]]
then
  if [[ $SILENT -eq 0 && $clusterware_check_count -ge 1 ]]
  then
    echo -e "\n"|tee -a $LOGFIL|tee -a $CWCREPFIL_PASS|tee -a $SCWCREPFIL_PASS|tee -a $CWCREPFIL_FAIL| tee -a $SCWCREPFIL_FAIL
    echo $fmt_line_header|tee -a $LOGFIL|tee -a $CWCREPFIL_PASS|tee -a $SCWCREPFIL_PASS|tee -a $CWCREPFIL_FAIL| tee -a $SCWCREPFIL_FAIL
    echo "                      CLUSTERWIDE CHECKS"|tee -a $CWCREPFIL_PASS|tee -a $SCWCREPFIL_PASS|tee -a $CWCREPFIL_FAIL| tee -a $SCWCREPFIL_FAIL
    echo $fmt_line_header|tee -a $LOGFIL|tee -a $CWCREPFIL_PASS|tee -a $SCWCREPFIL_PASS|tee -a $CWCREPFIL_FAIL| tee -a $SCWCREPFIL_FAIL
  fi
fi
crs_stack_counter=$clusterware_check_count
C_ACTUAL=${OUTPUTDIR}/c_actual.out
crs_check_file_counter=0
COMTYPE="CLUSTERWIDE_CHECK"
if [ -f $C_ACTUAL ]; then rm $C_ACTUAL; fi;
#$READ -p "crs_stack_counter=$crs_stack_counter and array =${crs_check_id[*]} SILENT=$SILENT"

while [[ $crs_stack_counter -gt 0 && $SILENT -eq 0 ]]
do 
   if [ -n "$MERGEFILES" ]
   then
     CLUSTERCHECK_FIL=$WRKDIR/.MERGED_COLLECTIONS/${crs_check_id[$crs_check_file_counter]}.out
     cls_no_of_nodes=$(cat $WRKDIR/.MERGED_COLLECTIONS/${crs_check_id[$crs_check_file_counter]}.out|wc -l|sed 's/ //g')
   else
     CLUSTERCHECK_FIL=${OUTPUTDIR}/${crs_check_id[$crs_check_file_counter]}.out
     cls_no_of_nodes=$(cat ${OUTPUTDIR}/${crs_check_id[$crs_check_file_counter]}.out|wc -l|sed 's/ //g')
   fi
   #HOSTLIST=${OUTPUTDIR}/o_host_list.out
   #$READ -p " ls -l $CLUSTERCHECK_FIL"
   COMTYPE=$(grep "_"${crs_check_id[$crs_check_file_counter]}"-TYPE" $REFFIL |awk {'print $2'})
   crs_check_counter=0
   unset cls_check_val1
   unset cls_check_val2
   unset no_of_cells
   unset cell_stack_counter
   crs_val_set=0
   #following branch is to handle system wide check where we need to include storage server also to compare some value across nodes
   if [ "$COMTYPE" = "CLUSTERWIDE_CHECK" ]
   then
     if [ -n "$MERGEFILES" ]
     then
       stack_counter=$(cat $WRKDIR/.MERGED_COLLECTIONS/o_host_list.out.merge|wc -l|sed 's/ //g');  
       tmp_stack_counter=0
       for compute_name in `cat $WRKDIR/.MERGED_COLLECTIONS/o_host_list.out.merge`
       do
         cls_check_host_list[$tmp_stack_counter]=$compute_name
         tmp_stack_counter=$(expr $tmp_stack_counter + 1 )
       done
     fi
     crs_host_counter=$stack_counter
   else 
     if [[ -n "$skip_in_silent" && $skip_in_silent -eq "0" ]]
     then
        #if [ -e $CELLIP ] ;then no_of_cells=$(cat $CELLIP|grep "cell="|grep -v ^#|wc -l|tr -d ' '); else no_of_cells=0; fi
        if [ -e $CELLIP ] ;then no_of_cells=$(grep "cell=" $CELLIP|grep -v ^#|wc -l|tr -d ' '); else no_of_cells=0; fi
        if [ -e $CELLDIR/cells.out ] ;then crs_host_counter=$(expr $stack_counter + $no_of_cells );else crs_host_counter=$stack_counter;fi
        cell_stack_counter=$stack_counter
        for cls_cell_host in $(if [ -e $CELLDIR/cells.out ] ;then cat $CELLDIR/cells.out|awk '{print $3}';fi) 
        do
          cls_check_host_list[$cell_stack_counter]=$cls_cell_host
          cell_stack_counter=$(expr $cell_stack_counter + 1 )
        done
     else # No cells in -s or -S
       no_of_cells=0
     fi
   fi
   SOURCEFIL_REPORT=${OUTPUTDIR}/${crs_check_id[$crs_check_file_counter]}_report.out
   if [ $OFFLINE -eq 0 ]
   then
     SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${crs_check_id[$crs_check_file_counter]}_report.out 
   else
     SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${crs_check_id[$crs_check_file_counter]}_report.out 
   fi
   while [ $crs_host_counter -gt 0 ] 
   do
     if [ -n "$MERGEFILES" ]
     then   
       CLUSTERCHECK_FIL_REPORT=$WRKDIR/.MERGED_COLLECTIONS/${crs_check_id[$crs_check_file_counter]}_"${cls_check_host_list[$crs_check_counter]}"_report.out   
     else
       CLUSTERCHECK_FIL_REPORT=${OUTPUTDIR}/${crs_check_id[$crs_check_file_counter]}_"${cls_check_host_list[$crs_check_counter]}"_report.out   
     fi
     #$READ -p "hostname=${cls_check_host_list[$crs_check_counter]}"
     ROW=$(cat $CLUSTERCHECK_FIL|head -1|awk '{print $2}')
     #$READ -p "crs_check_counter=$crs_check_counter and crs_host_counter=$crs_host_counter"
     cls_host_exists=$(grep -ic "${cls_check_host_list[$crs_check_counter]}" $CLUSTERCHECK_FIL)

     if [ -n "$MERGEFILES" ]; then
       if [[ -z "$cls_host_exists" || $cls_host_exists -eq 0 ]]; then
         for xdir in $dirarr
	 do
	   xdir=$(echo $xdir|sed 's/\.zip//g');
	   unset t_CLUSTERCHECK_FIL_REPORT
	   unset t_CLUSTERCHECK_FIL
	   t_CLUSTERCHECK_FIL_REPORT=${xdir}/outfiles/${crs_check_id[$crs_check_file_counter]}_"${cls_check_host_list[$crs_check_counter]}"_report.out
	   t_CLUSTERCHECK_FIL=${xdir}/outfiles/${crs_check_id[$crs_check_file_counter]}.out

	   if [[ -e $t_CLUSTERCHECK_FIL ]]; then cls_host_exists=$(grep -ic "${cls_check_host_list[$crs_check_counter]}" $t_CLUSTERCHECK_FIL); fi
	   if [[ -n "$cls_host_exists" && $cls_host_exists -ge 1 ]]; then
	     CLUSTERCHECK_FIL_REPORT=$t_CLUSTERCHECK_FIL 
	     CLUSTERCHECK_FIL=$t_CLUSTERCHECK_FIL
	     break;
	   fi
	 done	  
       fi
     fi

     if [[ -n "$cls_host_exists" && $cls_host_exists -ge 1 && -n "$cls_no_of_nodes" && $cls_no_of_nodes -gt 1 ]]
     then
       if [ -z "$cls_check_val1" ]
       then
         cls_check_val1=$(grep "${cls_check_host_list[$crs_check_counter]} $ROW" $CLUSTERCHECK_FIL|sed  -n 's/.*== //p')
       else
         cls_check_val2=$(grep "${cls_check_host_list[$crs_check_counter]} $ROW" $CLUSTERCHECK_FIL|sed  -n 's/.*== //p')
         # this is the fix to overcome the issue of having empty value for some nodes
         if [ -z "$cls_check_val2" ]; then cls_check_val2=$cls_check_val1;fi
         if [[ -n "$crs_val_set"  && $crs_val_set -eq 0 ]]
         then
	   if [ $RAT_DEBUG -eq 1 ]
	   then
	     if [[ -n "${cls_check_val1}" && -n "${cls_check_val2}" ]] && [ "${cls_check_val1}" = "${cls_check_val2}" ] 2>>$ERRFIL
	     then
	       CRS_VAL=1
	     else
	       CRS_VAL=0
	       crs_val_set=1   
	       #break
	     fi 
	   else
	     if [[ -n "${cls_check_val1}" && -n "${cls_check_val2}" ]] && [ "${cls_check_val1}" = "${cls_check_val2}" ]
	     then
	       CRS_VAL=1
	     else
	       CRS_VAL=0
	       crs_val_set=1   
	       #break
	     fi
	   fi 
         fi
         #$READ -p "${cls_check_host_list[$crs_check_counter]} $ROW"
       fi
     fi
     if [ -e $CLUSTERCHECK_FIL_REPORT ]; then cat $CLUSTERCHECK_FIL_REPORT >>$SOURCEFIL_REPORT;fi     

     if [ -n "$MERGEFILES" ]; then
       if [ ! -e $CLUSTERCHECK_FIL_REPORT ]; then
	 for xdir in $dirarr
	 do
	   xdir=$(echo $xdir|sed 's/\.zip//g');
	   unset t_CLUSTERCHECK_FIL_REPORT
	   t_CLUSTERCHECK_FIL_REPORT=${xdir}/outfiles/${crs_check_id[$crs_check_file_counter]}_"${cls_check_host_list[$crs_check_counter]}"_report.out

	   if [ -e $t_CLUSTERCHECK_FIL_REPORT ]; then 
	     if [[ `grep -icw "${cls_check_host_list[$crs_check_counter]}" $SOURCEFIL_REPORT` -eq 0 ]]; then cat $t_CLUSTERCHECK_FIL_REPORT >>$SOURCEFIL_REPORT; break; fi
	   fi
	 done
       fi 
     fi

     crs_check_counter=$(expr $crs_check_counter + 1 )
     crs_host_counter=$(expr $crs_host_counter - 1 )
     #$READ -p "crs_check_counter=$crs_check_counter and crs_host_counter=$crs_host_counter $cls_host_exists for ${crs_check_id[$crs_check_file_counter]}"
   done
   #if [[ -f $C_ACTUAL && `cat $C_ACTUAL|wc -l` -ge 1 ]]
   #then
   #else
   #  echo "${crs_check_id[$crs_check_file_counter]}|$CRS_VAL" > $C_ACTUAL
   #fi
   if [ $op_mode -eq 0 ]
   then 
     PMSG=`grep "_"$ROW"-PASS_MSG" $REFFIL1 |sed  -n 's/.*PASS_MSG //p'`
     FMSG=`grep "_"$ROW"-FAIL_MSG" $REFFIL1 |sed  -n 's/.*FAIL_MSG //p'`
     SF=`grep "_"$ROW"-SF" $REFFIL |sed  -n 's/.*-SF //p'`
     CAT=`grep "_"$ROW"-CAT" $REFFIL1 |sed  -n 's/.*-CAT //p'`
     SUBCAT=`grep "_"$ROW"-SUBCAT" $REFFIL1 |sed  -n 's/.*-SUBCAT //p'`
     ALVL=`grep _$ROW\-ALERT_LEVEL $REFFIL1 |awk {'print $2'}`
     audit_check_name=`grep "_"$ROW"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
     NEEDS_RUNNING=`grep "_"$ROW"-NEEDS_RUNNING" $REFFIL |sed  -n 's/.*NEEDS_RUNNING //p'` 
     TARGET_TYPE=`grep "_"$ROW"-TARGET_TYPE" $REFFIL |sed  -n 's/.*TARGET_TYPE //p'` 
     ISBRANCH=`grep _$ROW\-IS_BRANCH $REFFIL |awk {'print $2'} `
     OP=`grep _$ROW\-OPERATOR $REFFIL |sed  -n 's/.*OPERATOR //p'`
     if [[ -z "$OP" && -e $REFFIL1 ]];then OP=`grep _$ROW\-OPERATOR $REFFIL1 |sed  -n 's/.*OPERATOR //p'`;fi 
   else
     PMSG=`grep "_"${crs_check_id[$crs_check_file_counter]}"-PASS_MSG" $REFFIL1 |sed  -n 's/.*PASS_MSG //p'`
     FMSG=`grep "_"${crs_check_id[$crs_check_file_counter]}"-FAIL_MSG" $REFFIL1 |sed  -n 's/.*FAIL_MSG //p'`
     SF=`grep "_"${crs_check_id[$crs_check_file_counter]}"-SF" $REFFIL |sed  -n 's/.*-SF //p'`
     check_components=`grep "_"${crs_check_id[$crs_check_file_counter]}"-COMPONENTS" $REFFIL |sed  -n 's/.*COMPONENTS //p'| sed 's/^ *\(.*\) *$/\1/'`
     CAT=`grep "_"${crs_check_id[$crs_check_file_counter]}"-CAT" $REFFIL1 |sed  -n 's/.*-CAT //p'`
     SUBCAT=`grep "_"${crs_check_id[$crs_check_file_counter]}"-SUBCAT" $REFFIL1 |sed  -n 's/.*-SUBCAT //p'`
     ALVL=`grep _${crs_check_id[$crs_check_file_counter]}\-ALERT_LEVEL $REFFIL1 |awk {'print $2'}`
     audit_check_name=`grep "_"${crs_check_id[$crs_check_file_counter]}"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
     NEEDS_RUNNING=`grep "_"${crs_check_id[$crs_check_file_counter]}"-NEEDS_RUNNING" $REFFIL|sed  -n 's/.*NEEDS_RUNNING //p'`  
     TARGET_TYPE=`grep "_"${crs_check_id[$crs_check_file_counter]}"-TARGET_TYPE" $REFFIL|sed  -n 's/.*TARGET_TYPE //p'`  
     ISBRANCH=`grep _"${crs_check_id[$crs_check_file_counter]}-IS_BRANCH" $REFFIL |awk {'print $2'}`
     OP=`grep _"${crs_check_id[$crs_check_file_counter]}-OPERATOR" $REFFIL |sed  -n 's/.*OPERATOR //p'`
     if [[ -z "$OP" && -e $REFFIL1 ]];then OP=`grep _"${crs_check_id[$crs_check_file_counter]}-OPERATOR" $REFFIL1 |sed  -n 's/.*OPERATOR //p'`;fi
   fi
   ALVL_CHECK=$ALVL
   audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'`
   if [ "$COMTYPE" = "SYSTEMWIDE_CHECK" ]; then COMTYPE=CLUSTERWIDE_CHECK;fi
   if [[ -n "$cls_no_of_nodes" && $cls_no_of_nodes -gt 1 ]]
   then
     if [[ $ALVL = "INFO" && $CRS_VAL -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
     if [ $write_info_actual_files -eq 1 ]; then echo "${crs_check_id[$crs_check_file_counter]}|$CRS_VAL" >> $C_ACTUAL;fi 
   fi
   #following code is create report file if clusterwide check fails
   if [[ -n "$CRS_VAL" && $OFFLINE -eq 0 ]] || [[ -n "$MERGEFILES" ]]
   then
     if [[ -n "$MERGEFILES" ]]
     then
       if [[ `grep -ic ${crs_check_id[$crs_check_file_counter]} $WRKDIR/.MERGED_COLLECTIONS/slave_results.out.merge` -gt 0 ]]
       then
         if [[ -n "$cls_no_of_nodes" && $cls_no_of_nodes -gt 1 ]]; then  get_log_result;fi
         crs_stack_counter=`expr $crs_stack_counter - 1`
         crs_check_file_counter=`expr $crs_check_file_counter + 1`
         continue;
       fi
     fi
     #while read cwc_line_report
     #do 
     #   unset cwc_line_report_output
     #   cwc_line_report_output=$(echo $cwc_line_report|awk '{print $1}')
     ##  cwc_line_report_output=$(echo $cwc_line_report_output = $(echo $cwc_line_report|sed  -n 's/.*== //p')) 
     #   echo $cwc_line_report_output>>$SOURCEFIL_REPORT
     #done<$CLUSTERCHECK_FIL
   fi
   #$READ -p "audit_check_name=$audit_check_name $CLUSTERCHECK_FIL_REPORT SOURCEFIL_REPORT=$SOURCEFIL_REPORT"
   #add if condition for get_log_result to not to  execute if no of nodes are not greater than 1 in clusterwide check
   if [[ -n "$cls_no_of_nodes" && $cls_no_of_nodes -gt 1 ]]; then  get_log_result;fi 
   crs_stack_counter=`expr $crs_stack_counter - 1`
   crs_check_file_counter=`expr $crs_check_file_counter + 1`
done
crs_stack_counter=0
#reassiging i back to localnode to process cross node checks other wise it goes to remote node in copy_env_file function
i=$localnode

#Following code is to process CROSS_NODE_CHECKS
#counter has been increased after adding last item in arrary. -1 to bring it back to last item
cross_node_checkids_counter=$(expr $cross_node_checkids_counter - 1 )

unset COL_COMTYPE
while [[ $process_cross_node_checks -eq 1 && $cross_node_checkids_counter -ge 0 ]]
do
  COMTYPE=CLUSTERWIDE_CHECK 
  COL_COMTYPE=CROSS_NODE_CHECK
  CHECK_ID=${cross_node_checkids[$cross_node_checkids_counter]}
  crs_check_id[$crs_check_file_counter]=$CHECK_ID 
  PARAM_PATH=`grep _$CHECK_ID\-PARAM_PATH $REFFIL |awk {'print $2'}`
  HOME_PATH=`grep _$CHECK_ID\-HOME_PATH $REFFIL |awk {'print $2'}`
  ISBRANCH=`grep _$CHECK_ID\-IS_BRANCH $REFFIL |awk {'print $2'} `
  PARAM=`grep "_"$CHECK_ID"-PARAM_PATH" $REFFIL |sed  -n 's/.*PARAM_PATH //p'`
  NEEDS_RUNNING=`grep "_"$CHECK_ID"-NEEDS_RUNNING" $REFFIL |sed  -n 's/.*NEEDS_RUNNING //p'| sed 's/^ *\(.*\) *$/\1/'`
  TARGET_TYPE=`grep "_"$CHECK_ID"-TARGET_TYPE" $REFFIL |sed  -n 's/.*TARGET_TYPE //p'| sed 's/^ *\(.*\) *$/\1/'`
  execute_once=`grep "_"$CHECK_ID"-EXECUTE_ONCE" $REFFIL |sed  -n 's/.*EXECUTE_ONCE //p'| sed 's/^ *\(.*\) *$/\1/'`
  check_exadata_version=$(grep "_"$CHECK_ID"-EXADATA_VERSION" $REFFIL |sed  -n 's/.*EXADATA_VERSION //p'| sed 's/^ *\(.*\) *$/\1/')
  check_database_role=$(grep "_"$CHECK_ID"-DATABASE_ROLE" $REFFIL |sed  -n 's/.*DATABASE_ROLE //p'| sed 's/^ *\(.*\) *$/\1/')
  check_database_type=$(grep "_"$CHECK_ID"-DATABASE_TYPE" $REFFIL |sed  -n 's/.*DATABASE_TYPE //p'| sed 's/^ *\(.*\) *$/\1/')
  check_database_mode=$(grep "_"$CHECK_ID"-DATABASE_MODE" $REFFIL |sed  -n 's/.*DATABASE_MODE //p'| sed 's/^ *\(.*\) *$/\1/')
  SF=`grep "_"$CHECK_ID"-SF" $REFFIL |sed  -n 's/.*-SF //p'`
  check_components=`grep "_"$CHECK_ID"-COMPONENTS" $REFFIL |sed  -n 's/.*COMPONENTS //p'| sed 's/^ *\(.*\) *$/\1/'`
  OP=`grep _$CHECK_ID\-OPERATOR $REFFIL |sed  -n 's/.*OPERATOR //p'`
  if [[ -z "$OP" && -e $REFFIL1 ]];then OP=`grep _$CHECK_ID\-OPERATOR $REFFIL1 |sed  -n 's/.*OPERATOR //p'`;fi
  COMP=`grep "_"$CHECK_ID"-COMPARE_VALUE" $REFFIL |sed  -n 's/.*COMPARE_VALUE //p'`
  com_begin_pattern="_${CHECK_ID}-${COL_COMTYPE}_COMMAND_START"
  com_end_pattern="_${CHECK_ID}-${COL_COMTYPE}_COMMAND_END"
  COM=$(sed -n /$com_begin_pattern/,/$com_end_pattern/p $REFFIL|sed '1d'|sed '$d')
  com_report_begin_pattern="_${CHECK_ID}-${COL_COMTYPE}_COMMAND_REPORT_START"
  com_report_end_pattern="_${CHECK_ID}-${COL_COMTYPE}_COMMAND_REPORT_END"
  COM_REPORT=$(sed -n /$com_report_begin_pattern/,/$com_report_end_pattern/p $REFFIL|sed '1d'|sed '$d')
  #COM=`grep "_"$CHECK_ID"-CROSS_NODE_CHECK_COMMAND" $REFFIL |sed  -n 's/.*CROSS_NODE_CHECK_COMMAND //p'`
  #COM_REPORT=`grep "_"$CHECK_ID"-CROSS_NODE_CHECK_COMMAND_REPORT" $REFFIL |sed  -n 's/.*CROSS_NODE_CHECK_COMMAND_REPORT //p'`
  audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
  if [[ -z "$COMP" && -e $REFFIL1 ]];then  COMP=`grep "_"$CHECK_ID"-COMPARE_VALUE" $REFFIL1 |sed  -n 's/.*COMPARE_VALUE //p'`;fi
  if [ $SILENT -eq "0" ]
  then
    ALVL=`grep _$CHECK_ID\-ALERT_LEVEL $REFFIL1 |awk {'print $2'}`
    PMSG=`grep "_"$CHECK_ID"-PASS_MSG" $REFFIL1 |sed  -n 's/.*PASS_MSG //p'`
    FMSG=`grep "_"$CHECK_ID"-FAIL_MSG" $REFFIL1 |sed  -n 's/.*FAIL_MSG //p'`
    CAT=`grep "_"$CHECK_ID"-CAT" $REFFIL1 |sed  -n 's/.*-CAT //p'`
    SUBCAT=`grep "_"$CHECK_ID"-SUBCAT" $REFFIL1 |sed  -n 's/.*-SUBCAT //p'`
    ALVL_CHECK=$ALVL
  fi
  
  if [ $OFFLINE -eq 0 ]; then echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i}\n">>$CHECKS_TIMING;fi
  #localcmd=$TMPDIR/localcmd.sh
  copy_env_files_to_tmp
  nlocalcmd=$(basename "$localcmd"|sed "s/\.sh/_${CHECK_ID}_${i}.sh/g");

  echo "#!$bash_scr" >$localcmd
  echo "$RAT_DEBUG_FLG" >>$localcmd
  echo "$bash_source" >>$localcmd
  if [ $OFFLINE -eq 1 ] 
  then 
    echo "export OUTPUTDIR=${OUTPUTDIR}">>$TRGTORCLENV
    echo "export TMPDIR=$TMPDIR">>$TRGTORCLENV
  fi
  echo ". $TRGTORCLENV">>$localcmd;
  if [ -n "$COM_REPORT" ] && [[ $OFFLINE -eq 0 ]]
  then
    echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
  fi
  OUTFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
  echo "$COM 2>>$ERRFIL">>$localcmd
  #if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out 2>>$ERRFIL">>$localcmd;fi
  if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTFIL_REPORT} 2>>$ERRFIL">>$localcmd;fi
  echo "if [ -n \"\$ALVL\" ]; then echo \"ALVL=\$ALVL\" > ${localcmdval}; fi">>$localcmd
  echo "exit 0">>$localcmd
  chmod 744 $localcmd
  FILVAL=`$localcmd 2>>$ERRFIL`
  returncode=`echo $?`
  set_alvl
  #if [ -e $localcmd ]; then rm $localcmd; fi; 
  #if [ -e $localcmd ]; then mv $localcmd ${OUTPUTDIR}/$nlocalcmd >/dev/null 2>&1; fi
  if [ -e "$localcmd" ]; then 
    if [ -e "$ORCLENVFIL" ]; then
      cat $ORCLENVFIL > ${OUTPUTDIR}/$nlocalcmd; echo "" >> ${OUTPUTDIR}/$nlocalcmd; cat $localcmd >> ${OUTPUTDIR}/$nlocalcmd; rm $localcmd; 
    fi
  fi

  move_failed_to_skipped "$returncode"
  #echo "" >>$OSSPOOLFIL
  #printf "%s %s %s %s %s\n" " $PARAM_PATH $CHECK_ID $COM == $FILVAL" >>$OSSPOOLFIL
  #VAL=`grep "$PARAM_PATH $ROW " $OSSPOOLFIL|sed  -n 's/.*== //p'`
  VAL=$FILVAL
  if [ -n "$COM_REPORT" ]
  then
    SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
    if [ $OFFLINE -eq 0 ]
    then
      SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
    else
      SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
    fi
  fi  
  cross_node_get_log_result_call=1
  get_log_result
  if [ $OFFLINE -eq 0 ]; then echo -e "end time -  `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i}\n">>$CHECKS_TIMING;fi
  cross_node_checkids_counter=$(expr $cross_node_checkids_counter - 1 )
  crs_check_file_counter=$(expr $crs_check_file_counter + 1) 
done
unset COL_COMTYPE
crs_check_file_counter=0
#$READ -p "stop after corss node processing"
###CROSS_NODE_CHECK processing ends here

if [ $SILENT -eq 0 ]
then
  if [[ -n "$CRS_PATCH_MSG" && -n "$crs_patch_check_status" ]] && [[ "$TYP" != "-p" ]] && [[ $print_pass_on_screen -eq 1 || $crs_patch_check_status -eq 0 ]];then echo -e "$CRS_PATCH_MSG";fi; 
  mb_db_counter=0
  for mb_db_homes in ${mb_oracle_homes_distinct[@]}
  do 
    if [[ -n "${MB_RDBMS_PATCH_MSG[$mb_db_counter]}" && -n "${mb_rdbms_patch_check_status[$mb_db_counter]}" ]] && [[ "$TYP" != "-p" ]] && [[ $print_pass_on_screen -eq 1 || ${mb_rdbms_patch_check_status[$mb_db_counter]} -eq 0 ]]; then echo -e "${MB_RDBMS_PATCH_MSG[$mb_db_counter]}";fi;
    mb_db_counter=$(expr $mb_db_counter + 1)
  done
  mb_db_counter=0
  if [[ -n "$ASM_PATCH_MSG" && -n "$asm_patch_check_status" ]] && [[ "$TYP" != "-p" ]] && [[ $print_pass_on_screen -eq 1 || $asm_patch_check_status -eq 0 ]]; then echo -e "$ASM_PATCH_MSG";fi; 
  if [ -n "$crs_patch_check_status" ] && [[ "$TYP" != "-p" ]]
  then
    if [ $crs_patch_check_status -eq 1 ]
    then
      echo "Check:- PASS => CRS home has same number of patches installed across the cluster">>$CWCREPFIL_PASS   
      echo "Check:- PASS => CRS home has same number of patches installed across the cluster">>$SCWCREPFIL_PASS
      echo "Check:- PASS => CRS home has same number of patches installed across the cluster">>$MISCCWCHECK
      if [[ $CREATE_HTML_REPORT -eq 1 ]]
      then # gadiga - for html reporting
        write_cwc_status_html "PASS" "CRS home has same number of patches installed across the cluster";
      fi
    else 
      echo "Check:- FAIL => CRS home does not have same number of patches installed across the cluster">>$CWCREPFIL_FAIL
      echo "Check:- FAIL => CRS home does not  have same number of patches installed across the cluster">>$SCWCREPFIL_FAIL
      echo "Check:- FAIL => CRS home does not have same number of patches installed across the cluster">>$MISCCWCHECK
      if [[ $CREATE_HTML_REPORT -eq 1 ]]
      then # gadiga - for html reporting
        write_cwc_status_html "FAIL" "CRS home does not have same number of patches installed across the cluster"
      fi
    fi
  fi
  if [[ "$TYP" != "-p" ]]
  then
    mb_db_counter=0
    for mb_db_homes in ${mb_oracle_homes_distinct[@]}
    do
      if [ -n "${mb_rdbms_patch_check_status[$mb_db_counter]}" ]
      then
        if [ ${mb_rdbms_patch_check_status[$mb_db_counter]} -eq 1 ]
        then
    	    echo "Check:- PASS => RDBMS home ${mb_db_homes} has same number of patches installed across the cluster">>$CWCREPFIL_PASS
    	    echo "Check:- PASS => RDBMS home ${mb_db_homes} has same number of patches installed across the cluster">>$SCWCREPFIL_PASS
    	    echo "Check:- PASS => RDBMS home ${mb_db_homes} has same number of patches installed across the cluster">>$MISCCWCHECK
          if [[ $CREATE_HTML_REPORT -eq 1 ]]
          then # gadiga - for html reporting
            write_cwc_status_html "PASS" "RDBMS home ${mb_db_homes} has same number of patches installed across the cluster"
          fi
        else
    	    echo "Check:- FAIL => RDBMS home ${mb_db_homes} does not have same number of patches installed across the cluster">>$CWCREPFIL_FAIL 
    	    echo "Check:- FAIL => RDBMS home ${mb_db_homes} does not have same number of patches installed across the cluster">>$SCWCREPFIL_FAIL 
    	    echo "Check:- FAIL => RDBMS home ${mb_db_homes} does not have same number of patches installed across the cluster">>$MISCCWCHECK 
          if [[ $CREATE_HTML_REPORT -eq 1 ]]
          then # gadiga - for html reporting
            write_cwc_status_html "FAIL" "RDBMS home ${mb_db_homes} does not have same number of patches installed across the cluster"
          fi
        fi
      fi
      mb_db_counter=$(expr $mb_db_counter + 1)
    done
    mb_db_counter=0
  fi
  if [ -n "$asm_patch_check_status" ] && [[ "$TYP" != "-p" ]]
  then
    if [ $asm_patch_check_status -eq 1 ]
    then
      echo "Check:- PASS => ASM home has same number of patches installed across the cluster">>$CWCREPFIL_PASS
      echo "Check:- PASS => ASM home has same number of patches installed across the cluster">>$SCWCREPFIL_PASS
      echo "Check:- PASS => ASM home has same number of patches installed across the cluster">>$MISCCWCHECK
      if [[ $CREATE_HTML_REPORT -eq 1 ]]
      then # gadiga - for html reporting
        write_cwc_status_html "PASS" "ASM home has same number of patches installed across the cluster"
      fi
    else 
      echo "Check:- FAIL => ASM home does not have same number of patches installed across the cluster">>$CWCREPFIL_FAIL
      echo "Check:- FAIL => ASM home does not have same number of patches installed across the cluster">>$SCWCREPFIL_FAIL
      echo "Check:- FAIL => ASM home does not have same number of patches installed across the cluster">>$MISCCWCHECK
      if [[ $CREATE_HTML_REPORT -eq 1 ]]
      then # gadiga - for html reporting
        write_cwc_status_html "FAIL" "ASM home does not have same number of patches installed across the cluster"
      fi
    fi
  fi
  #MISCCWCHECK=$OUTPUTDIR/o_misc_clusterwide_checks.out
  if [ -z "$platform" ]; then platform=$(uname -s);fi;
  CWSQLPARAM=$OUTPUTDIR/${program_name}_cw_sqlparam.out
  CWOSPARAM=$OUTPUTDIR/${program_name}_cw_osparam.out
  CWOSPKG=$OUTPUTDIR/${program_name}_cw_ospkg.out
  CWOSPATCH=$OUTPUTDIR/${program_name}_cw_ospatch.out
  echo $fmt_line_header|tee -a $LOGFIL|tee -a $CWCREPFIL_PASS|tee -a $SCWCREPFIL_PASS|tee -a $CWCREPFIL_FAIL| tee -a $SCWCREPFIL_FAIL
fi
####

if [ -z $ent_naming ]; then ent_naming=$localnode; else ent_naming=$DB; fi;
#----------------------------------------------------------------------
#Added by kumar
if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
then
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
    upload_outfil=$TMP_OUTPUT/upload_${program_name}_result.lst
    upload_patch_outfil=$TMP_OUTPUT/upload_${program_name}_patch_result.lst
    old_upload_outfil=$OUTPUTDIR/upload_${program_name}_result.lst
    old_upload_patch_outfil=$OUTPUTDIR/upload_${program_name}_patch_result.lst

    upload_raccheck_result_fil=$TMP_OUTPUT/upload_${program_name}_result.sql
    upload_raccheck_patch_result_fil=$TMP_OUTPUT/upload_${program_name}_patch_result.sql
    old_upload_raccheck_result_fil=$OUTPUTDIR/upload_${program_name}_result.sql
    old_upload_raccheck_patch_result_fil=$OUTPUTDIR/upload_${program_name}_patch_result.sql

    move_files "$old_upload_raccheck_result_fil" "$upload_raccheck_result_fil"
    move_files "$old_upload_raccheck_patch_result_fil" "$upload_raccheck_patch_result_fil" 
  else
    upload_outfil=$OUTPUTDIR/upload_${program_name}_result.lst
    upload_patch_outfil=$OUTPUTDIR/upload_${program_name}_patch_result.lst
  fi

  if [ "$TYP" != "-p" ]
  then   
    insert_data_into_table "$RAT_UPLOAD_TABLE" "$upload_raccheck_result_fil" "$upload_outfil"
    if [ $data_upload_status -eq 2 ] 
    then
      echo -e $RED"${program_name} was not able to make successfull connection to database to upload result.\nPlease run ${OUTPUTDIR_NEW}/upload/upload_${program_name}_result.sql script manually to upload result to database\n$NORM"|tee -a $LOGFIL    
    elif [ $data_upload_status -eq 3 ]
    then
      echo -e $RED"$upload_error insert statement have failed from ${OUTPUTDIR_NEW}/upload/upload_${program_name}_result.sql Please see the $OUTPUTDIR_NEW/log/upload_${program_name}_result.lst and fix those errors manually\n$NORM"|tee -a $LOGFIL
    fi 
  fi
  if [[ -n "$data_upload_status" && $data_upload_status -ne 2 ]]
  then
    if [[ "$TYP" = "-a" || "$TYP" = "-s" || "$TYP" = "-S" || "$TYP" = "-p" || "$TYP" = "-u" ]]
    then  
      insert_data_into_table "$RAT_PATCH_UPLOAD_TABLE" "$upload_raccheck_patch_result_fil" "$upload_patch_outfil"
      if [ $data_upload_status -eq 2 ] 
      then         
        echo -e $RED"${program_name} was not able to make successfull connection to database to upload result.\nPlease run ${OUTPUTDIR_NEW}/upload/upload_${program_name}_patch_result.sql script manually to upload result to database\n$NORM"|tee -a $LOGFIL    
      elif [ $data_upload_status -eq 3 ]
      then
        echo -e $RED"$upload_error insert statement have failed from ${OUTPUTDIR_NEW}/upload/upload_${program_name}_patch_result.sql Please see the $OUTPUTDIR_NEW/log/upload_${program_name}_patch_result.lst and fix those errors manually\n$NORM"|tee -a $LOGFIL
      fi 
    fi
  fi
  echo -e ${GREEN}"${upload_pass_msg} $upload_pass_msg2"${NORM}
fi
#----------------------------------------------------------------------

##to delete ssh configuration
if [[ $OFFLINE -eq 0 && 1 -eq 2 ]]
then 
  arr=`expr $arr - 1`
  while [[ -n $arr && $arr -ge 0 ]]
  do
    if [ $i = $localnode ]
    then
      rm -rf ~/.ssh 2>/dev/null
    else
      ssh ${hnameArr[$arr]} rm -rf ~/.ssh 
    fi
    arr=`expr $arr - 1`
  done
fi

for i in `cat $HOSTLIST`
do
  if [ $i = $localnode ]
  then
    rm $TRGTORCLENV 2>/dev/null
    rm $TMPDIR/raccheck_env.out 2>/dev/null
  elif [ $OFFLINE -eq 0 ]
  then
    $SSHELL $i "rm $TRGTORCLENV" 2>/dev/null
    $SSHELL $i "rm $TMPDIR/raccheck_env.out" 2>/dev/null
  fi
done

if [ $is_windows -eq "1" ] ; then
  OUTPUTDIR_NEW=$OUTPUTDIR #TEMPCHANGE
fi
#To copy EXCLUDEFIL to OUTPUTDIR
if [ -e $EXCLUDEFIL ]; then cp $EXCLUDEFIL $OUTPUTDIR;fi;
if [ -e $WRKDIR/cgrep ]; then rm $WRKDIR/cgrep >/dev/null 2>&1;fi;
if [[ $OFFLINE -eq 0 && -n "$OUTPUTDIR_NEW" ]]
then
  if [ $is_windows -eq "0" ] ; then
    mv $OUTPUTDIR $OUTPUTDIR_NEW 2>>$ERRFIL #TEMPCHANGE
  fi
  OUTPUTDIR=$OUTPUTDIR_NEW
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]] ; then
    ERRFIL=$TMP_OUTPUT/${program_name}_error.log
    OLD_ERRFIL=$OUTPUTDIR/${program_name}_error.log
  else
    ERRFIL=$OUTPUTDIR/${program_name}_error.log
  fi
  LOGFIL=$OUTPUTDIR/${program_name}.log
  SKIPFIL=$OUTPUTDIR/${program_name}_skipped_checks.log
  REPFIL=$OUTPUTDIR/${program_name}.rep
  XMLREPFIL=$OUTPUTDIR/${program_name}_results.xml
  XMLSKIPFIL=$OUTPUTDIR/${program_name}_exceptions.xml
  XMLRECFIL=$OUTPUTDIR/${program_name}_recommendations.xml
  CHK_TIMINGS=$OUTPUTDIR/${program_name}_epoch_checks_timings.out
  SREPFIL=$OUTPUTDIR/${program_name}_summary.rep
  REPFIL_PASS=$OUTPUTDIR/${program_name}_pass.rep
  REPFIL_FAIL=$OUTPUTDIR/${program_name}_fail.rep
  SREPFIL_PASS=$OUTPUTDIR/${program_name}_summary_pass.rep
  SREPFIL_FAIL=$OUTPUTDIR/${program_name}_summary_fail.rep
  PREPFIL=$OUTPUTDIR/${program_name}_patches.rep
  PSREPFIL=$OUTPUTDIR/${program_name}_patches_summary.rep
  CWCREPFIL=$OUTPUTDIR/${program_name}_cwc.rep
  SCWCREPFIL=$OUTPUTDIR/${program_name}_cwc_summary.rep
  CWCREPFIL_PASS=$OUTPUTDIR/${program_name}_cwc_pass.rep
  SCWCREPFIL_PASS=$OUTPUTDIR/${program_name}_cwc_summary_pass.rep
  CWCREPFIL_FAIL=$OUTPUTDIR/${program_name}_cwc_fail.rep
  SCWCREPFIL_FAIL=$OUTPUTDIR/${program_name}_cwc_summary_fail.rep
  CELLSREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_summary_pass.rep
  CELLSREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells_summary_fail.rep
  CELLREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_pass.rep
  CELLREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells__fail.rep
  IBSREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_summary_pass.rep
  IBSREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib_summary_fail.rep
  IBREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_pass.rep
  IBREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib__fail.rep
  COLLECT_TIMING=$OUTPUTDIR/${program_name}_collection_timings.out
  CHECKS_TIMING=$OUTPUTDIR/${program_name}_checks_timings.out
  RACCHECK_TIMING=$OUTPUTDIR/${program_name}_timings.out
  HOSTLIST=$OUTPUTDIR/o_host_list.out
  MISCCWCHECK=$OUTPUTDIR/clusterwide_patch_compare.out 
  MASTERFIL=$OUTPUTDIR/raccheck_env.out
  CELLDIR="$OUTPUTDIR/.CELLDIR"
  EXCLUDELOG=$OUTPUTDIR/excluded_check_ids.log
  OGGHOMESVERSIONFIL=$OUTPUTDIR/ogg_homes_version.out
fi

if [ $SILENT -ne 1 ]
then
  if [[ -e $SKIPFIL && `cat $SKIPFIL|wc -l` -gt 4 ]]
  then
    echo -e "$fmt_line_header\n">>$SREPFIL
    echo -e "Some checks were skipped. Please review $SKIPFIL for more detail\n">>$SREPFIL
    echo -e "$fmt_line_header\n\n">>$SREPFIL
    echo -e "$fmt_line_header\n">>$REPFIL
    echo -e "Some checks were skipped. Please review $SKIPFIL for more detail\n">>$REPFIL
    echo -e "$fmt_line_header\n\n">>$REPFIL
  fi 
  if [ -f $SCWCREPFIL_FAIL  ]
  then 
    if [ `cat $SCWCREPFIL_FAIL|wc -l` -gt 6 ]; then cat $SCWCREPFIL_FAIL >>$SREPFIL; fi;
  fi
  if [ -f $SREPFIL_FAIL ]
  then
    if [ `cat $SREPFIL_FAIL|wc -l` -gt 6 ]; then  cat $SREPFIL_FAIL >>$SREPFIL; fi;
  fi
  if [ -f $CELLSREPFIL_FAIL ]; then  cat $CELLSREPFIL_FAIL >>$SREPFIL;fi   
  if [ -f $IBSREPFIL_FAIL ]; then  cat $IBSREPFIL_FAIL >>$SREPFIL;fi   
  if [ -f $SCWCREPFIL_PASS ] 
  then 
    if [ `cat $SCWCREPFIL_PASS|wc -l` -gt 6 ]; then cat $SCWCREPFIL_PASS >>$SREPFIL ;fi;
  fi
  if [ -f $SREPFIL_PASS ] 
  then 
    if [ `cat $SREPFIL_PASS|wc -l` -gt 6 ]; then cat $SREPFIL_PASS >>$SREPFIL ;fi;
  fi
  if [ -f $CELLSREPFIL_PASS ]; then  cat $CELLSREPFIL_PASS >>$SREPFIL;fi   
  if [ -f $IBSREPFIL_PASS ]; then  cat $IBSREPFIL_PASS >>$SREPFIL;fi   
  if [ -f $PSREPFIL ];     then cat $PSREPFIL >>$SREPFIL;fi;
  if [ -f $CWCREPFIL_FAIL ]
  then 
    if [ `cat $CWCREPFIL_FAIL|wc -l` -gt 6 ]; then cat $CWCREPFIL_FAIL>>$REPFIL; fi;
  fi
  if [ -f $REPFIL_FAIL ] 
  then 
    if [ `cat $REPFIL_FAIL|wc -l` -gt 6 ]; then cat $REPFIL_FAIL >>$REPFIL; fi;
  fi
  if [ -f $CELLREPFIL_FAIL ]; then  cat $CELLREPFIL_FAIL >>$REPFIL;fi   
  if [ -f $IBREPFIL_FAIL ]; then  cat $IBREPFIL_FAIL >>$REPFIL;fi   
  if [ -f $CWCREPFIL_PASS ]
  then 
    if [ `cat $CWCREPFIL_PASS|wc -l` -gt 6 ]; then cat $CWCREPFIL_PASS >>$REPFIL; fi;
  fi
  if [ -f $REPFIL_PASS ]
  then
    if [ `cat $REPFIL_PASS|wc -l` -gt 6 ]; then cat $REPFIL_PASS >>$REPFIL; fi;
  fi
  if [ -f $CELLREPFIL_PASS ]; then  cat $CELLREPFIL_PASS >>$REPFIL;fi   
  if [ -f $IBREPFIL_PASS ]; then  cat $IBREPFIL_PASS >>$REPFIL;fi   
  if [ -f $PREPFIL ];     then cat $PREPFIL >>$REPFIL;fi;
  echo "Detailed report is $REPFIL">>$SREPFIL
  if [ $OFFLINE -eq 0 ]
  then
    echo "Log file is at $LOGFIL">>$REPFIL
  fi
  #SREPFIL=$OUTPUTDIR/raccheck_summary.rep 
  #REPFIL=$OUTPUTDIR/raccheck.rep 
  #echo  "Summary report  - $SREPFIL"
  #echo  "Detailed report  - $REPFIL"
fi

#call function to generate exadata version report
if [[ $OFFLINE -eq 0 &&  -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] || [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]] || [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]] || [[ -n "$is_bda_machine" && $is_bda_machine -eq 1 ]]
then
  generate_exadata_report
fi



# gadiga
# Create rachcehck.html file
if [[ $CREATE_HTML_REPORT -eq 1 ]]
then
  top_consumers
  create_raccheck_html
fi

########
if [ $SILENT -eq "1" ]
then
  if [ -f $REPFIL ]; then rm $REPFIL;fi;
  if [ -f $SREPFIL ]; then rm $SREPFIL; fi;
  if [ -f $SCWCREPFIL_FAIL  ]; then rm $SCWCREPFIL_FAIL; fi;
  if [ -f $SREPFIL_FAIL ]; then rm $SREPFIL_FAIL; fi;
  if [ -f $SCWCREPFIL_PASS ]; then rm $SCWCREPFIL_PASS; fi;
  if [ -f $SREPFIL_PASS ]; then rm $SREPFIL_PASS; fi;
  if [ -f $CWCREPFIL_FAIL ]; then rm $CWCREPFIL_FAIL; fi;
  if [ -f $REPFIL_FAIL ]; then rm $REPFIL_FAIL; fi;
  if [ -f $CWCREPFIL_PASS ]; then rm $CWCREPFIL_PASS; fi;
  if [ -f $REPFIL_PASS ]; then rm $REPFIL_PASS; fi;
  if [ -f $CELLSREPFIL_PASS ]; then rm $CELLSREPFIL_PASS;fi
  if [ -f $CELLSREPFIL_FAIL ]; then rm $CELLSREPFIL_FAIL;fi
  if [ -f $CELLREPFIL_PASS ]; then rm $CELLREPFIL_PASS;fi
  if [ -f $CELLREPFIL_FAIL ]; then rm $CELLREPFIL_FAIL;fi
  if [ -f $IBSREPFIL_PASS ]; then rm $IBSREPFIL_PASS;fi
  if [ -f $IBSREPFIL_FAIL ]; then rm $IBSREPFIL_FAIL;fi
  if [ -f $IBREPFIL_PASS ]; then rm $IBREPFIL_PASS;fi
  if [ -f $IBREPFIL_FAIL ]; then rm $IBREPFIL_FAIL;fi
else
  #To delete control-M from report file
  if [ $OFFLINE -eq 0 ]
  then
    ##CONTROLM    sed  's///g' $REPFIL >$INPUTDIR/${program_name}.rep 
    cat $REPFIL|tr -d '\r' >$INPUTDIR/${program_name}.rep
    cp $INPUTDIR/${program_name}.rep $REPFIL
    rm $INPUTDIR/${program_name}.rep
    #echo  "Summary report  - $SREPFIL"
    #echo  "Detailed report (txt) - $REPFIL"
    if [ -e "${HTML_REPFILE}" ]
    then 
      echo "Detailed report (html) - ${HTML_REPFILE}"
    fi 
    #if [ -e $OUTPUTDIR/${program_name}_versions.html ]; then echo  "Exadata version report  - $OUTPUTDIR/${program_name}_versions.html";fi  
  else
    ##CONTROLM    sed  's///g' $REPFIL >$TMPDIR/${program_name}.rep 
    cat $REPFIL |tr -d '\r' >$TMPDIR/${program_name}.rep
    cp $TMPDIR/${program_name}.rep $REPFIL
    rm $TMPDIR/${program_name}.rep
    if [ -e $DUMPDIR/collections.dat  ]; then rm $DUMPDIR/collections.dat; fi;
    if [ -e $DUMPDIR/collections_new.dat  ]; then rm $DUMPDIR/collections_new.dat; fi;
    if [ -e $DUMPDIR/rules.dat  ]; then rm $DUMPDIR/rules.dat; fi;
    if [ -e $DUMPDIR/rules_new.dat  ]; then rm $DUMPDIR/rules_new.dat; fi;
    #echo  "Summary report  - $DUMPDIR/${program_name}_summary.rep"
    #echo  "Detailed report (txt) - $DUMPDIR/${program_name}.rep"
    if [ -e "${HTML_REPFILE}" ]
    then 
      if [ -n "$MERGEFILES" ]
      then
        rm -rf $DUMPDIR/*.html.out.tailed >/dev/null 2>&1
        if [ -e "$WRKDIR/.MERGED_COLLECTIONS/check_env.out.merge" ]; then mv $WRKDIR/.MERGED_COLLECTIONS/check_env.out.merge $DUMPDIR/.check_env.out.merge; fi
        if [ -e "$WRKDIR/.MERGED_COLLECTIONS/slave_results.out.merge" ]; then mv $WRKDIR/.MERGED_COLLECTIONS/slave_results.out.merge $DUMPDIR/slave_results.out; fi
        if [ -e "$WRKDIR/.MERGED_COLLECTIONS/cell_ib_count.out.merge" ]; then mv $WRKDIR/.MERGED_COLLECTIONS/cell_ib_count.out.merge $DUMPDIR/.cell_ib_count.out.merge; fi
	if [ -e "$WRKDIR/.MERGED_COLLECTIONS/mb_db_tmp.out.merge" ]; then mv $WRKDIR/.MERGED_COLLECTIONS/mb_db_tmp.out.merge $DUMPDIR/.mb_db_tmp.out.merge; fi

        d_index=0
        for xdir in $dirarr
        do
          xdir=`basename $xdir`;
          xdir=$(echo $xdir|sed 's/\.zip//g');

          if [ $d_index -ne 0 ];
          then
     	    rm -rf $WRKDIR/.MERGED_COLLECTIONS/$xdir	
          else
     	    replace_name=$xdir
          fi
          d_index=$(expr $d_index + 1);
        done
        HTML_REPFILE=$(echo "$HTML_REPFILE"|sed "s|\.MERGED_COLLECTIONS/||g");
        HTML_REPFILE=$(echo "$HTML_REPFILE"|sed "s/${replace_name}/${replace_name}_merge/g");
      fi
      echo "Detailed report (html) - ${HTML_REPFILE}"
    fi 
    #if [ -e $DUMPDIR/${program_name}_versions.html ]; then echo  "Exadata version report  - $DUMPDIR/${program_name}_versions.html";fi  
  fi
  if [ -e $OUTPUTDIR/${program_name}.html ]
  then
    echo "Note: Use links (text mode browser) or your favorite browser to view the html report."
  fi
fi
#to change the name of raccheck_env.out to check_env.out
if [ $OFFLINE -eq 0 ]; then mv $MASTERFIL $OUTPUTDIR/check_env.out;elif [ $OFFLINE -eq 1 ]; then mv $DUMPDIR/raccheck_env.out $DUMPDIR/check_env.out;fi
if [ -e ${RTEMPDIR}/o_ibswitches.out ]; then cp ${RTEMPDIR}/o_ibswitches.out $OUTPUTDIR >/dev/null 2>&1; fi;

#This is where em plugin xml ends
echo "</Checks>" >> $XMLRECFIL
echo "</${xml_prefix1}Results>" >> $XMLREPFIL
echo "</${xml_prefix2}Exclusions>" >> $XMLSKIPFIL
#

#provide ip addresses instead of switch and cell names in result xml file 
if [[ $OFFLINE -eq 0 ]]; then
  if [ -e $XMLREPFIL ]; then 
    if [ -e $CELLDIR/cells.out ]; then
      for cellname in `cat $CELLDIR/cells.out|cut -d= -f2|cut -d\; -f2|sed 's/"//g'|sed 's/ //g'`
      do
        is_cell_ip=$(echo $cellname|grep -c [A-Za-z])
        if [[ -n $is_cell_ip && $is_cell_ip -ne 0 ]]; then
          cellname_ip=`cat $CELLDIR/cells.out|grep "$cellname"|cut -d= -f1|cut -d\; -f2|sed 's/"//g'|sed 's/ //g'`
  
          is_cell_ip=$(echo $cellname_ip|grep -c [A-Za-z])
          if [[ -n $is_cell_ip && $is_cell_ip -eq 0 ]]; then
      	  sed "s/ColumnValue Name=\"NodeName\" value=\"$cellname\" status=\"\(.*\)\"/\<ColumnValue Name=\"NodeName\" value=\"$cellname\" IPAddress=\"$cellname_ip\" status=\"\1\"/g" $XMLREPFIL > $XMLREPFIL.new	
            mv $XMLREPFIL.new $XMLREPFIL
          fi
        fi
      done
    fi
    if [ -e ${RTEMPDIR}/o_ibswitches.out ]; then 
      for switchname in `cat ${RTEMPDIR}/o_ibswitches.out`
      do
        is_ibswitch_ip=$(echo $switchname|grep -c [A-Za-z])
        if [[ -n $is_ibswitch_ip && $is_ibswitch_ip -ne 0 ]]; then
          switchname_ip=$(echo "$switch_line"|grep -vwi gw|grep -vw localhost|grep -vi leaf|$AWK 'BEGIN { FS = "QDR " };{print $2}'|$AWK '{print $2}'|sed 's/"$//g')
  
          is_ibswitch_ip=$(echo $switchname_ip|grep -c [A-Za-z])
          if [[ -n $is_ibswitch_ip && $is_ibswitch_ip -eq 0 ]]; then
          sed "s/ColumnValue Name=\"NodeName\" value=\"$switchname\"\/>/ColumnValue Name=\"NodeName\" value=\"$switchname\"\/\>\<ColumnValue Name=\"IPAddress\" value=\"$switchname_ip\"\/>/g" $XMLREPFIL > $XMLREPFIL.new	
            mv $XMLREPFIL.new $XMLREPFIL
          fi
        fi
      done
    fi
  fi
fi

#call function to write xml file to remote nodes for CC12
if [[ $OFFLINE -eq 0 ]] && [[ $db_machine_compute -eq 1 || $is_exalogic_machine -eq 1 || $is_exalytics_machine -eq  1 || $is_bda_machine -eq 1  ]]
then 
  copy_em_xml_files_to_remote_nodes
fi
#$READ -p "stop here for copy_em_xml_files_to_remote_nodes"

perl_exe=$(which perl|tr -d '\r');
if [ -n "$perl_exe" ] ; then
  # Create ${program_name}_browse_<FDS>.html
  $perl_exe $SCRIPTPATH/.cgrep/raw_data_browser.pl $OUTPUTDIR  >/dev/null 2>>$ERRFIL
fi

#Moved this finished before reorg
if [ $OFFLINE -eq 0 ]
then
  echo -e "`date '+%a %b %d %H:%M:%S %Y'` - ${program_name} execution finished\n">>$RACCHECK_TIMING
  echo $fmt_timing_lines >>$RACCHECK_TIMING
fi

update_location_file

if [ -z "$RAT_KEEP_TEXT_REPORT" ]; then
  rm -f $OUTPUTDIR/*.rep >/dev/null 2>&1;
fi

reorg_output_dir

#To delete dat files in offline from output directory
if [[ $OFFLINE -eq 1 && `find $OUTPUTDIR -name '*.dat' -type f|wc -l` -gt 0 ]];then rm -f $OUTPUTDIR/*.dat >/dev/null 2>&1;fi

if [ $OFFLINE -eq 0 ]
then
  if [[ -n "$RAT_ROOT_RUN" && $RAT_ROOT_RUN -eq 1 ]]; then
    umask ${oumask}
    chmod -R 755 $OUTPUTDIR 2>>$ERRFIL
    chmod -R 755 $INPUTDIR  2>>$ERRFIL
  fi

  if [[ ! -n "$RAT_KEEP_PASSWORD_IN_DEBUG" && -f "$RAT_DEBUG_FILENAME_INTERNAL" ]] ; then
    if [[ -n "$RAT_KEEP_ORIG_DEBUG_FILE" && $RAT_KEEP_ORIG_DEBUG_FILE -eq "1" ]] ; then
      cp $RAT_DEBUG_FILENAME_INTERNAL $RAT_DEBUG_FILENAME_INTERNAL.orig
    fi
    remove_passwords_in_debug;
  fi

  if [ -e "$RAT_DEBUG_FILENAME_INTERNAL" ]; then cp $RAT_DEBUG_FILENAME_INTERNAL $OUTPUTDIR/log >/dev/null 2>&1; fi

  cd $OUTPUTDIR
  LOGFIL=$OUTPUTDIR/log/${program_name}.log
  #$READ -p "OUTPUTDIR=$OUTPUTDIR"
  cd ..
  which zip >/dev/null 2>&1
  if [ `echo $?` -eq 0 ]
  then
    #zip -q "$UPLOADFIL".zip raccheck_$FDS/* 2>>$ERRFIL
    OUTPUTDIR_ZIP=$(basename $OUTPUTDIR)
    CELLDIR_ZIP=$(basename $CELLDIR)
    zip -qr "$UPLOADFIL".zip $OUTPUTDIR_ZIP/* $OUTPUTDIR_ZIP/$CELLDIR_ZIP/* 2>>$ERRFIL
    upload_zip_file "${UPLOADFIL}.zip"
    if [ $zip_data_upload_status -eq  1 ]
    then
      echo -e "required environment variables are not set to upload zip file to database">>$LOGFIL  
    elif [ $zip_data_upload_status -eq 2 ]
    then
      echo -e $RED"${program_name} was not able to make successfull connection to database to upload "${UPLOADFIL}.zip".\nPlease run ${LDRCTLFIL_NEW} script manually to upload "${UPLOADFIL}.zip" to database\n$NORM"|tee -a $LOGFIL
    elif [ $zip_data_upload_status -eq 3 ]
    then
      echo -e "$zip_upload_message"|tee -a $LOGFIL   
    else
      echo -e "$zip_upload_message"|tee -a $LOGFIL   
    fi
    echo ""
    echo ""
    #Adding changed files to zip
    zip -qr "$UPLOADFIL".zip $OUTPUTDIR_ZIP/*  2>>$ERRFIL
    echo "UPLOAD(if required) - "$UPLOADFIL".zip"
  else
    OUTPUTDIR_ZIP=$(basename $OUTPUTDIR)
    tar -czf "$UPLOADFIL".tar.gz $OUTPUTDIR_ZIP/* 2>>$ERRFIL
    #if [ -f $"$UPLOADFIL".tar.gz ]; then rm "$UPLOADFIL".tar.gz >/dev/null;gzip -q "$UPLOADFIL".tar >/dev/null 2&>1; fi;

    if [ ! -f "${UPLOADFIL}.tar.gz" ]; then tar -cvf "$UPLOADFIL".tar $OUTPUTDIR_ZIP/* >/dev/null; gzip -q "$UPLOADFIL".tar >/dev/null 2>&1; fi;

    upload_zip_file "${UPLOADFIL}.tar.gz" 
    if [ $zip_data_upload_status -eq  1 ]
    then
      echo -e "required environment variables are not set to upload zip file to database">>$LOGFIL
    elif [ $zip_data_upload_status -eq 2 ]
    then
      echo -e $RED"${program_name} was not able to make successfull connection to database to upload "${UPLOADFIL}.tar.gz".\nPlease run ${LDRCTLFIL} script manually to upload "${UPLOADFIL}.zip" to database\n$NORM"|tee -a $LOGFIL
    elif [ $zip_data_upload_status -eq 3 ]
    then
      echo -e "$zip_upload_message"|tee -a $LOGFIL   
    else
      echo -e "$zip_upload_message"|tee -a $LOGFIL   
    fi
    tar -czf "$UPLOADFIL".tar.gz $OUTPUTDIR_ZIP/* 2>>$ERRFIL

    if [ ! -f "${UPLOADFIL}.tar.gz" ]; then tar -cvf "$UPLOADFIL".tar $OUTPUTDIR_ZIP/* >/dev/null; gzip -q "$UPLOADFIL".tar >/dev/null 2>&1; fi;

    echo ""
    echo ""
    echo "UPLOAD(if required) - "$UPLOADFIL".tar.gz"
  fi
else
  if [ -n "$MERGEFILES" ]
  then
    MERGEDIR=$WRKDIR/${replace_name}_merge
    UPLOADFIL=$WRKDIR/${replace_name}_merge

    if [ -e $WRKDIR/.MERGED_COLLECTIONS/o_host_list.out.merge ]; then mv $WRKDIR/.MERGED_COLLECTIONS/o_host_list.out.merge $DUMPDIR/outfiles/o_host_list.out; fi
    if [ -d "$MERGEDIR" ]; then 
      rm -rf $MERGEDIR 2>>$ERRFIL;
      rm -rf ${MERGEDIR}.zip 2>>$ERRFIL; 
    fi;

    mv $OUTPUTDIR $MERGEDIR
    mv -f $WRKDIR/.MERGED_COLLECTIONS/*.out $MERGEDIR/outfiles/ >/dev/null 2>&1 
    cd $MERGEDIR
    for renamefile in `find . -name "*${replace_name}*"`
    do
      merge_file=$(echo $renamefile|sed "s/${replace_name}/${replace_name}_merge/g");
      mv $renamefile $merge_file 

      sed "s|${replace_name}\.zip<|${replace_name}_merge\.zip<|g" $merge_file >$merge_file.new
      rm -f $merge_file
      mv $merge_file.new $merge_file
    done  

    browse_pattern=$(echo "$replace_name"|sed "s/${program_name}/${program_name}_browse/g");
    for renamefile in `find . -name "*${browse_pattern}*"`
    do
      browse_file=$(echo $renamefile|sed "s/${browse_pattern}/${browse_pattern}_merge/g");
      mv $renamefile $browse_file
    done  

    OUTPUTDIR=$(echo "$OUTPUTDIR"|sed "s|\.MERGED_COLLECTIONS||g"); 	      
    OUTPUTDIR=$(echo "$OUTPUTDIR"|sed "s|${replace_name}|${replace_name}_merge|g"); 	      

    ERRFIL=$(echo $ERRFIL|sed "s|\.MERGED_COLLECTIONS||g");
    ERRFIL=$(echo $ERRFIL|sed "s|${replace_name}|${replace_name}_merge|g");

    if [[ -d $WRKDIR/.MERGED_COLLECTIONS/ ]];
    then
      rm -rf $WRKDIR/.MERGED_COLLECTIONS >/dev/null 2>&1
    fi
  fi

  cd $OUTPUTDIR
  cd ..
  if [ -e "${program_name}_${outfilefds1}_collect_${outfilefds2}_${outfilefds3}.zip" ]; then rm ${program_name}_${outfilefds1}_collect_${outfilefds2}_${outfilefds3}.zip 2>>$ERRFIL; fi
  if [ -e "${program_name}_${outfilefds1}_collect_${outfilefds3}_${outfilefds3}.tar.gz" ]; then rm ${program_name}_${outfilefds1}_collect_${outfilefds3}_${outfilefds3}.tar.gz 2>>$ERRFIL; fi
  which zip >/dev/null 2>&1
  if [ `echo $?` -eq 0 ]
  then
    CELLDIR_ZIP=$(basename $CELLDIR)
    if [ -n "$MERGEFILES" ]
    then
      DIR_ZIP=$(basename $MERGEDIR)
      zip -qr "$UPLOADFIL".zip $DIR_ZIP/* $DIR_ZIP/$CELLDIR_ZIP/* 2>>$ERRFIL
    else
      zip -qr "$UPLOADFIL".zip ${program_name}_${outfilefds1}_${outfilefds2}_${outfilefds3}/* ${program_name}_${outfilefds1}_${outfilefds2}_${outfilefds3}/$CELLDIR_ZIP/* 2>>$ERRFIL
    fi
    echo ""
    echo ""
    echo "UPLOAD(if required) - "$UPLOADFIL".zip"
  else
    #$READ -p "UPLOADFIL=$UPLOADFIL ${outfilefds1} ${outfilefds2} ${outfilefds3}"
    tar -czf "$UPLOADFIL".tar.gz ${program_name}_${outfilefds1}_${outfilefds2}_${outfilefds3}/* 2>>$ERRFIL
    #if [ -f $"$UPLOADFIL".tar.gz ]; then rm "$UPLOADFIL".tar.gz >/dev/null 2&>1; gzip -q "$UPLOADFIL".tar >/dev/null 2&>1;fi;
    echo ""
    echo ""
    echo "UPLOAD(if required) - "$UPLOADFIL".tar.gz"
  fi     
fi
echo -e "\n"
echo -e "\n"

exit_status;
}

